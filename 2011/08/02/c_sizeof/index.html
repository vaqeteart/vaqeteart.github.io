<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>
    关于sizeof
</title>
<!--javascript-->
<!--script type="text/javascript" src="/script.js"></script-->
<script src="../../../../lib/jquery-1.11.3.min.js"></script>
<script src="../../../../lib/typelighter.js"></script>
<script src="../../../../js/common.js"></script>
<script src="../../../../js/nav.js"></script>

<!--css-->
<!--link rel="stylesheet" href="/style.css" type="text/css" /-->
<link rel="stylesheet" href="../../../../css/partial/head.css">
<link rel="stylesheet" href="../../../../css/partial/header.css">
<link rel="stylesheet" href="../../../../css/partial/archives.css">
<link rel="stylesheet" href="../../../../css/partial/categories.css">
<link rel="stylesheet" href="../../../../css/partial/home-posts.css">
<link rel="stylesheet" href="../../../../css/partial/page-nav.css">
<link rel="stylesheet" href="../../../../css/partial/tags.css">
<link rel="stylesheet" href="../../../../css/partial/about.css">
<link rel="stylesheet" href="../../../../css/partial/more.css">
<link rel="stylesheet" href="../../../../css/partial/footer.css">
<link rel="stylesheet" href="../../../../css/post.css">
<link rel="stylesheet" href="../../../../css/orgmode/hexo_orgmode_style.css">
  </head>
  <body>
    <main class="main">
      <table class="container">
    <tbody id="tb_container">
        <tr id="tr_navbar">
            <table class="navbar">
	<tbody>
		<tr>
			<th class="navitm">
				<a href="../../../../index.html">主页</a>
			</th>

			<th class="navitm">
				<a href="../../../../categories">分类</a>
				<div id="category_menus" class="second">
					
					<!--合并内部类和自定义类。
    每个分类的数据结构包括：
    id: 分类唯一id
    title: 分类名
    parent: 父分类id
    children:子分类数组
注：
内部类包含一个固定的分类结type="text/javascript"内部根分类设置为categories, title为分类在主题config.yml中有配置（待定）。
后续文章中设置的分类如果不是内部类都会被称作自定义类，可以通过hexo本身引擎检测出来。
最终内部类和自定义类会合并到完整分类(full_categories)中，这样让所有类能用json等通用方式表示，便于移植。

使用举例：
var category_info = getCategoriesInfo();
<x var symbols={}; x> //定义导出变量
<x- include('category_list', {symbols:symbols}) x> //包含该文件
<x var category_info = symbols.getCategoriesInfo(); x> //获取分类信息：包含分类树，以及分类与文章数映射表。
<x- symbols.list_category(category_info.categories, category_info.categories_count) x> //列出分类索引树

注： '<x' 是EJS模板语言的标记比如x为%。
-->

					
					<ul id="full_categories_tree" class="categories_tree categories_level0" type="none"><li id="categories" class="categories_tree_item"><a href="../../../../categories/" class="item_path"><span id="categories_switch" class="tree_switch">▷</span><span id="categories_title" class="item_title">分类</span><span id="categories_count" class="item_count">(62)</span></a><ul id="categories_tree" class="categories_tree categories_level2" type="none"><li id="note" class="categories_tree_item"><a href="../../../../categories/categories/note" class="item_path"><span id="note_switch" class="tree_switch">▷</span><span id="note_title" class="item_title">记事</span><span id="note_count" class="item_count">(8)</span></a><ul id="note_tree" class="categories_tree categories_level3" type="none"><li id="remind" class="categories_tree_item"><a href="../../../../categories/categories/note/remind" class="item_path"><span id="remind_switch" class="tree_switch">○</span><span id="remind_title" class="item_title">备忘</span><span id="remind_count" class="item_count">(0)</span></a></li><li id="plan" class="categories_tree_item"><a href="../../../../categories/categories/note/plan" class="item_path"><span id="plan_switch" class="tree_switch">○</span><span id="plan_title" class="item_title">计划</span><span id="plan_count" class="item_count">(0)</span></a></li>|</ul></li><li id="study" class="categories_tree_item"><a href="../../../../categories/categories/study" class="item_path"><span id="study_switch" class="tree_switch">▷</span><span id="study_title" class="item_title">学习</span><span id="study_count" class="item_count">(4)</span></a><ul id="study_tree" class="categories_tree categories_level3" type="none"><li id="problem" class="categories_tree_item"><a href="../../../../categories/categories/study/problem" class="item_path"><span id="problem_switch" class="tree_switch">○</span><span id="problem_title" class="item_title">问题</span><span id="problem_count" class="item_count">(0)</span></a></li><li id="git" class="categories_tree_item"><a href="../../../../categories/categories/study/git" class="item_path"><span id="git_switch" class="tree_switch">○</span><span id="git_title" class="item_title">git</span><span id="git_count" class="item_count">(1)</span></a></li><li id="os" class="categories_tree_item"><a href="../../../../categories/categories/study/os" class="item_path"><span id="os_switch" class="tree_switch">○</span><span id="os_title" class="item_title">操作系统</span><span id="os_count" class="item_count">(1)</span></a></li><li id="books" class="categories_tree_item"><a href="../../../../categories/categories/study/books" class="item_path"><span id="books_switch" class="tree_switch">▷</span><span id="books_title" class="item_title">books</span><span id="books_count" class="item_count">(0)</span></a><ul id="books_tree" class="categories_tree categories_level4" type="none"><li id="apue" class="categories_tree_item"><a href="../../../../categories/categories/study/books/apue" class="item_path"><span id="apue_switch" class="tree_switch">○</span><span id="apue_title" class="item_title">APUE</span><span id="apue_count" class="item_count">(0)</span></a></li>|</ul></li><li id="linux" class="categories_tree_item"><a href="../../../../categories/categories/study/linux" class="item_path"><span id="linux_switch" class="tree_switch">▷</span><span id="linux_title" class="item_title">linux</span><span id="linux_count" class="item_count">(6)</span></a><ul id="linux_tree" class="categories_tree categories_level4" type="none"><li id="misc" class="categories_tree_item"><a href="../../../../categories/categories/study/linux/misc" class="item_path"><span id="misc_switch" class="tree_switch">○</span><span id="misc_title" class="item_title">杂乱</span><span id="misc_count" class="item_count">(3)</span></a></li><li id="command" class="categories_tree_item"><a href="../../../../categories/categories/study/linux/command" class="item_path"><span id="command_switch" class="tree_switch">○</span><span id="command_title" class="item_title">命令</span><span id="command_count" class="item_count">(19)</span></a></li>|</ul></li><li id="jekyll" class="categories_tree_item"><a href="../../../../categories/categories/study/jekyll" class="item_path"><span id="jekyll_switch" class="tree_switch">○</span><span id="jekyll_title" class="item_title">jekyll</span><span id="jekyll_count" class="item_count">(0)</span></a></li><li id="kits" class="categories_tree_item"><a href="../../../../categories/categories/study/kits" class="item_path"><span id="kits_switch" class="tree_switch">○</span><span id="kits_title" class="item_title">工具</span><span id="kits_count" class="item_count">(1)</span></a></li><li id="emacs" class="categories_tree_item"><a href="../../../../categories/categories/study/emacs" class="item_path"><span id="emacs_switch" class="tree_switch">○</span><span id="emacs_title" class="item_title">emacs</span><span id="emacs_count" class="item_count">(2)</span></a></li><li id="vim" class="categories_tree_item"><a href="../../../../categories/categories/study/vim" class="item_path"><span id="vim_switch" class="tree_switch">○</span><span id="vim_title" class="item_title">vim</span><span id="vim_count" class="item_count">(0)</span></a></li>|</ul></li><li id="work" class="categories_tree_item"><a href="../../../../categories/categories/work" class="item_path"><span id="work_switch" class="tree_switch">▷</span><span id="work_title" class="item_title">工作</span><span id="work_count" class="item_count">(0)</span></a><ul id="work_tree" class="categories_tree categories_level3" type="none"><li id="progress" class="categories_tree_item"><a href="../../../../categories/categories/work/progress" class="item_path"><span id="progress_switch" class="tree_switch">○</span><span id="progress_title" class="item_title">进度</span><span id="progress_count" class="item_count">(0)</span></a></li>|</ul></li><li id="life" class="categories_tree_item"><a href="../../../../categories/categories/life" class="item_path"><span id="life_switch" class="tree_switch">▷</span><span id="life_title" class="item_title">生活</span><span id="life_count" class="item_count">(0)</span></a><ul id="life_tree" class="categories_tree categories_level3" type="none"><li id="experience" class="categories_tree_item"><a href="../../../../categories/categories/life/experience" class="item_path"><span id="experience_switch" class="tree_switch">○</span><span id="experience_title" class="item_title">经验</span><span id="experience_count" class="item_count">(0)</span></a></li><li id="tips" class="categories_tree_item"><a href="../../../../categories/categories/life/tips" class="item_path"><span id="tips_switch" class="tree_switch">○</span><span id="tips_title" class="item_title">技巧</span><span id="tips_count" class="item_count">(0)</span></a></li>|</ul></li><li id="others" class="categories_tree_item"><a href="../../../../categories/categories/others" class="item_path"><span id="others_switch" class="tree_switch">▷</span><span id="others_title" class="item_title">其它</span><span id="others_count" class="item_count">(4)</span></a><ul id="others_tree" class="categories_tree categories_level3" type="none"><li id="rambles" class="categories_tree_item"><a href="../../../../categories/categories/others/rambles" class="item_path"><span id="rambles_switch" class="tree_switch">○</span><span id="rambles_title" class="item_title">随笔</span><span id="rambles_count" class="item_count">(0)</span></a></li><li id="temp" class="categories_tree_item"><a href="../../../../categories/categories/others/temp" class="item_path"><span id="temp_switch" class="tree_switch">○</span><span id="temp_title" class="item_title">临时</span><span id="temp_count" class="item_count">(0)</span></a></li><li id="test" class="categories_tree_item"><a href="../../../../categories/categories/others/test" class="item_path"><span id="test_switch" class="tree_switch">○</span><span id="test_title" class="item_title">测试</span><span id="test_count" class="item_count">(0)</span></a></li>|</ul></li>|</ul></li></ul>
				</div>
			</th>

			<th class="navblank"></th>

			<th class="navitm">
				<a href="../../../../tags">标签</a>
				<div id="tag_menus" class="second">
					<ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/gtd-next/">gtd_next</a><span class="tag-list-count">1</span></li></ul>
				</div>
			</th>

			<th class="navitm">
				<a href="../../../../archives">归档</a>
			</th>

			<th class="navblank"></th>

			<th class="navitm">
				<a href="../../../../more">更多</a>
			</th>

			<th class="navitm">
				<a href="../../../../about">关于</a>
			</th>

			<th class="navblank" style="width:25%;"></th>

			<th class="navitm" style="margin:0; padding:0;border:none;">
				<form method="get" id="searchform" action="/search.html" style="margin:0;padding:0;height:100%;">
					<span style="color:#00FF00;">Q</span>
					<span style="border-style:solid; border-width:1px; border-color:#00FF00;
		  		border-top:0px; border-left:0px;border-right:0px; 
				margin:0;padding:0;height:100%;">
						<input value="Search by title (canbe regex)..." name="s" class="s" onfocus="if (this.value == 'Search by title (canbe regex)...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search by title (canbe regex)...';}" style="margin:0;padding:0;height:100%;border:none;background: #000000; color:#00A600;" type="text">
					</span>
					<!--input type="submit" value="Q" style="width:20%;"-->
				</form>
			</th>

			<th class="navblank"></th>

			<th class="navblank"></th>

			<a href="#" id="topbtn">⇑</a>

			<a href="#bottom" id="bottombtn">⇓</a>
			<!--⇐⇑⇒⇓-->
		</tr><tr>
	</tr></tbody>
</table>
        </tr>
        <tr>
            <td id="td_page_header" colspan="6" valign="top" align="right" style="width:100%;">
        <header style="text-align: center;">
               <a href="/" title="Menu.Home">
               <h1>QuietHeart's Site</h1>
               </a>
        </header>
</td>    
        </tr>
        <tr>
            <td id="td_posts" colspan="6" valign="top">
                <h1 id="header1" style="text-align: center;">
                    关于sizeof
                </h1>
                <hr id="title_line">
                <article>
                    <div>
                        
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. 功能</a></li>
<li><a href="#orgheadline2">2. 使用语法</a></li>
<li><a href="#orgheadline3">3. 计算方法</a>
<ul>
<li><a href="#orgheadline4">3.1. 基本数据类型大小</a></li>
<li><a href="#orgheadline5">3.2. 指针类型大小</a></li>
<li><a href="#orgheadline6">3.3. 数组类型大小</a></li>
<li><a href="#orgheadline7">3.4. 结构和联合类型大小</a></li>
</ul>
</li>
<li><a href="#orgheadline8">4. 举例</a>
<ul>
<li><a href="#orgheadline9">4.1. 例1：小的在后，填充也少</a></li>
<li><a href="#orgheadline10">4.2. 例2：大的在后，填充也大</a></li>
<li><a href="#orgheadline11">4.3. 例3：设置最大对齐参数，节省空间</a></li>
</ul>
</li>
<li><a href="#orgheadline12">5. 五、其他</a>
<ul>
<li><a href="#orgheadline13">5.1. <code>sizeof</code> 应用在C++中的类和结构的处理情况是相同的</a></li>
<li><a href="#orgheadline14">5.2. 经过实践对于Linux如下代码分别输出的情况</a></li>
</ul>
</li>
<li><a href="#orgheadline15">6. 参考资料</a></li>
</ul>
</div>
</div>

<p>
<code>sizeof</code> 以字节形式给出操作数的存储大小。通过本文我们可以了解 <code>sizeof</code> 的使用和计算方法。
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> 功能</h2>
<div class="outline-text-2" id="text-1">
<p>
<code>sizeof</code> 以字节形式给出操作数的存储大小。
</p>

<p>
<code>sizeof</code> 是C语言的一种单目操作符，如C语言的其他操作符 <code>++</code> 、 <code>--</code> 等，它并不是函数。 
</p>

<p>
<code>sizeof</code> 操作符以字节形式给出了其操作数的存储大小。操作数可以是一个表达式或括在括号内的类型名，操作数的存储大小由操作数的类型决定。
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">2</span> 使用语法</h2>
<div class="outline-text-2" id="text-2">
<p>
<code>sizeof</code> 有如下两种使用方式： 
</p>

<ul class="org-ul">
<li><p>
用于数据类型的 <code>sizeof</code> 使用形式： <code>sizeof（type）</code> 。
</p>

<p>
这里，数据类型必须用括号括住。如 <code>sizeof（int）</code> 。
</p></li>

<li><p>
用于变量的 <code>sizeof</code> 使用形式： <code>sizeof（var_name）</code> 或 <code>sizeof　var_name</code> 。
</p>

<p>
变量名可以不用括号括住。如 <code>sizeof　(var_name)</code>, <code>sizeof　var_name</code> 等都是正确形式。带括号的用法更普遍，大多数程序员采用这种形式。　 
</p></li>
</ul>

<p>
注意： <code>sizeof</code> 操作符不能用于 <b>函数类型</b> 、 <b>不完全类型</b> 或 <b>位字段</b> 。不完全类型指具有未知存储大小的数据类型，如未知存储大小的数组类型、未知内容的结构或联合类型、void类型等。如 <code>sizeof(max)</code> 而此时变量 <code>max</code> 定义为 <code>int　max()</code>,  <code>sizeof(char_v)</code> 而此时 <code>char_v</code> 定义为 <code>char　char_v[MAX]</code> 且 <code>MAX</code> 未知， <code>sizeof(void)</code> 都不是正确形式。
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3"><span class="section-number-2">3</span> 计算方法</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">3.1</span> 基本数据类型大小</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<code>sizeof</code> 操作符的结果类型是 <code>size_t</code> ，它在头文件中 <code>typedef</code> 为 <code>unsigned　int</code> 类型。该类型保证能容纳实现所建立的最大对象的字节大小。
</p>

<p>
对于 <code>int</code> , <code>unsigned int</code>, <code>short int</code>, <code>unsigned short</code>, <code>long int</code>, <code>unsigned long</code>, <code>float</code>, <code>double</code>, <code>long　double</code> 等基本类型的大小，没有明确的规定，但是一般应当记住如下原则：
</p>
<ul class="org-ul">
<li>ANSI C规定 <code>char</code> 类型一定是8位。</li>
<li><code>long</code> 类型的长度和cpu字长一样。</li>
<li><code>int</code> 长度没有规定，但是不比 <code>short</code> 短不比 <code>long</code> 长，并且linux上支持的所有体系中 <code>int</code> 长度目前都是32位。</li>
<li><code>short</code> 和 <code>int</code> 类似，目前linux上长度都是16位。</li>
</ul>

<p>
例如，一般常见的基本类型大小信息如下（32位机Linux平台）：
</p>
<pre class="example">
char为1byte; 
int为4byte; 
unsigned int为4byte； 
short int为2byte； 
unsigned short为2byte； 
long int为4byte； 
unsigned long为4byte； 
float为4byte； 
double为8byte； 
long double为12byte；
</pre>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">3.2</span> 指针类型大小</h3>
<div class="outline-text-3" id="text-3-2">
<p>
当操作数是指针时， <code>sizeof</code> 依赖于编译器。
</p>

<p>
例如Microsoft C/C++7.0中， <code>near</code> 类指针字节数为2， <code>far</code> 、 <code>huge</code> 类指针字节数为4。
</p>

<p>
一般Unix的指针字节数为4。
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6"><span class="section-number-3">3.3</span> 数组类型大小</h3>
<div class="outline-text-3" id="text-3-3">
<p>
当操作数具数组类型时，其结果是数组的总字节数。
</p>

<p>
如果操作数是函数中的数组形参或函数类型的形参， <code>sizeof</code> 给出其指针的大小。
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7"><span class="section-number-3">3.4</span> 结构和联合类型大小</h3>
<div class="outline-text-3" id="text-3-4">
<p>
联合类型操作数的 <code>sizeof</code> 是其最大字节成员的字节数。结构类型操作数的 <code>sizeof</code> 是其对象包括任何填充在内的总字节数。
</p>

<p>
关于结构大小和结构变量存放地址，本文后面例子中将重点进行介绍，确定方法依照编译器所不同，大致规则如下：
</p>
<ul class="org-ul">
<li>成员变量在结构中被声明的顺序和其在内存中的存储顺序一致。第一个结构成员变量相对整个结构的地址偏移为0。</li>
<li>结构成员变量的偏移地址由编译器中设置的"最大对齐参数"，以及该结构变量的类型大小决定。</li>
<li>整个结构的大小由最大结构成员变量类型或编译器中设置的"最大对齐参数"决定。</li>
</ul>

<p>
注：这里的最大对齐方式可以由不同的编译器的特定关键字来设置。默认一般是cpu的字长，例如32位机器为4字节。 
</p>

<p>
结构成员、结构变量的地址偏移和大小计算方法分别如下： 
</p>
<ul class="org-ul">
<li>结构成员变量偏移地址计算：偏移地址为该成员类型和最大对齐字节，两者大小较小者的整数倍。若当前偏移位置不满足条件，那么就填充至满足，再存放存放该结构成员。</li>
<li>结构成员变量尺寸计算：就是该成员对应类型的大小。</li>
<li>结构变量偏移地址计算：偏移地址为该结构中最大成员大小和最大对齐字节大小两者较小者的整数倍。</li>
<li>结构变量尺寸计算：整个结构大小为结构中最大成员变量与最大对齐方式两者较小者的整数倍，如果当前所有成员大小之和小于这个整数倍就会添充直至达到要求。</li>
</ul>

<p>
总之，首先假定好最大字节对齐方式，然后确定每个成员起始地址(该成员类型大小以及最大字节对齐的较小者的倍数)，最后确定结构总大小(最大成员大小和最大字节对齐较小者的倍数)。简而言之，先每个成员，再整体，不满足则填充。 
</p>
</div>
</div>
</div>


<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8"><a id="ID-cb65774e-51f7-4e01-b596-1fbd4f98eb02"></a><span class="section-number-2">4</span> 举例</h2>
<div class="outline-text-2" id="text-4">
<p>
下面是整理的说明VC到底怎么样来存放结构的(可以参见后面参考资料，这里没有对其进行严格的实践)，其它编译器处理方式有所不同，但是大体都一致。 
</p>
</div>
<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">4.1</span> 例1：小的在后，填充也少</h3>
<div class="outline-text-3" id="text-4-1">
<p>
结构定义如下： 
</p>
<div class="org-src-container">

<pre class="src src-C">struct MyStruct 
{ 
    double dda1; 
    char dda; 
    int type 
}；
</pre>
</div>

<p>
地址偏移和大小计算方式如下: 
</p>
<pre class="example">
为上面的结构分配空间的时候，VC根据成员变量出现的顺序和对齐方式：
(1)先为第一个成员dda1分配空间，该成员类型为double，其起始地址跟结构的起始地址相同（偏移量 0 为sizeof(double)的倍数），占用sizeof(double)=8个字节；
(2)接下来为第二个成员dda分配空间，该成员类型为char，其想对于结构的起始地址的偏移量为8(偏移量8为sizeof(char)的倍数)，该成员变量占用 sizeof(char)=1个字节；
(3)接下来为第三个成员type分配空间，该成员类型为int，相对于结构的起始地址的偏移量为9，不是sizeof (int)=4的倍数，为了满足对齐方式对偏移量的约束问题，VC自动填充3个字节（这三个字节没有放什么东西），这时下一个可以分配的地址对于结构的起始地址的偏移量为12，刚好是sizeof(int)=4的倍数，所以把type存放在偏移量为12的地方，该成员变量占用sizeof(int)=4个字节；

这时整个结构的成员变量已经都分配了空间，总的占用的空间大小为：8+1+3+4=16，刚好为结构的字节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，所以没有空缺的字节需要填充。所以整个结构的大小为：sizeof(MyStruct)=8+1+ 3+4=16，其中有3个字节是VC自动填充的，没有放任何有意义的东西。
</pre>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">4.2</span> 例2：大的在后，填充也大</h3>
<div class="outline-text-3" id="text-4-2">
<p>
交换一下上面的MyStruct的成员变量的位置，使它变成下面的情况： 
</p>
<div class="org-src-container">

<pre class="src src-C">struct MyStruct 
{ 
    char dda; 
    double dda1; 
    int type 
}；
</pre>
</div>

<p>
这时候地址偏移和大小计算方式如下: 
</p>
<pre class="example">
为上面的结构分配空间的时候，VC根据成员变量出现的顺序和对齐方式：
(1)先为第一个成员dda分配空间，该成员类型为char，其起始地址跟结构的起始地址相同（偏移量 0 为sizeof(char)的倍数），占用sizeof(char)=1个字节；
(2)接下来为第二个成员dda1分配空间，该成员类型为double，其想对于结构的起始地址的偏移量为1，不是sizeof (double)=7的倍数，为了满足对齐方式对偏移量的约束问题，VC自动填充7个字节（这7个字节没有放什么东西），这时下一个可以分配的地址对于结构的起始地址的偏移量为8，刚好是sizeof(double)=8的倍数，所以把dda1存放在偏移量为8的地方，该成员变量占用sizeof(double)=8个字节；
(3)接下来为第三个成员type分配空间，该成员类型为int，相对于结构的起始地址的偏移量为16，刚好是sizeof(int)=4的倍数，所以把type存放在偏移量为16的地方，该成员变量占用sizeof(int)=4个字节；

这时整个结构的成员变量已经都分配了空间，总的占用的空间大小为：1+7+8+4=20，不满足结构的字节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，所以VC自动填充4个字节。综上，整个结构的大小为：sizeof(MyStruc)为1+7+8+4+4=24。其中总的有7+4=11个字节是VC自动填充的，没有放任何有意义的东西。
</pre>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">4.3</span> 例3：设置最大对齐参数，节省空间</h3>
<div class="outline-text-3" id="text-4-3">
<p>
我们也可屏蔽掉变量默认的对齐方式，自己设定变量的对齐方式。VC中提供了 <code>#pragma pack(n)</code> 来设定变量以n字节对齐方式。
</p>

<p>
这里n字节对齐的意思是说:
(1)结构成员变量存放地址偏移按照两种情况确定：如果n大于等于该成员变量类型所占字节，则其偏移量满足默认对齐方式(即以成员变量类型大小对齐)；否则，偏移量为n的倍数。
(2)结构的总大小也按下面两种情况确定：如果n大于等于最大的成员变量类型所占字节，那么结构的总大小为占用空间最大的成员变量所占用的空间数的倍数；否则，必须为n的倍数。
</p>

<p>
下面举例说明其用法。 
</p>
<div class="org-src-container">

<pre class="src src-C">#pragma pack(push) //保存对齐状态 
#pragma pack(4)//设定为4字节对齐 
struct test 
{ 
    char m1; 
    double m4; 
    int m3; 
}; 
#pragma pack(pop)//恢复对齐状态
</pre>
</div>

<p>
这时候地址偏移和大小计算方式如下: 
</p>
<pre class="example">
以上结构的大小为16，为此分配空间的时候，
(1)首先为m1分配空间，该成员类型为char，同时sizeof(char)为1,小于我们自己设定的4字节，所以起始地址按照sizeof(char)=1对齐，和结构起始地址一样，(偏移为0为sizeof(char)的倍数)，m1占用1个字节;
(2)接着开始为m4分配空间，该成员类型为double,同时sizeof(double)为8，大于我们自己设定的4字节，所以按照我们设置的4字节对齐，这时其偏移量为1，需要补足3个字节，使其偏移量为4，满足为n=4的倍数,m4占用8个字节；
(3)接着为m3分配空间，该成员类型为int，sizeof(int)为4，和设定的4字节一样，所以按照4字节对齐，这时其偏移量为12，正好满足为4的倍数，m3占用4个字节。

这时已经为所有成员变量分配了空间，对于整个结构变量，其中最大类型为double为8字节，大于我们设定的4字节，所以结构总大小采用n=4的倍数，这里目前共分配了16个字节正好是4的倍数，所以结构大小为1+3+8+4=16。同理，如果把上面的#pragma pack(4)改为#pragma pack(16)，那么我们可以得到结构的大小为24。
</pre>
<p>
从上面的例子我们可以看出，调整结构成员变量的位置，或者设置对齐方式，都会影响该结构变量的存储效率。同时设置对齐方式可能会影响速度。 
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-2">
<h2 id="orgheadline12"><span class="section-number-2">5</span> 五、其他</h2>
<div class="outline-text-2" id="text-5">
<p>
主要指出几个额外需要注意的地方。
</p>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">5.1</span> <code>sizeof</code> 应用在C++中的类和结构的处理情况是相同的</h3>
<div class="outline-text-3" id="text-5-1">
<p>
但有两点需要注意：
</p>
<ul class="org-ul">
<li>结构或者类中的静态成员不对结构或者类的大小产生影响，因为静态变量的存储位置与结构或者类的实例地址无关。</li>
<li>没有成员变量的结构或类的大小为1，因为必须保证结构或类的每一个实例在内存中都有唯一的地址。</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">5.2</span> 经过实践对于Linux如下代码分别输出的情况</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li><p>
C语言源文件 <code>main.c</code> 内容如下： 
</p>

<div class="org-src-container">

<pre class="src src-C">#include  
struct mystruct 
{ 
}; 

int main(int argc, char *argv[]) 
{ 
    printf("%d\n",sizeof(struct mystruct)); 
    return 0; 
}
</pre>
</div>

<p>
采用 <code>gcc main.c</code> 编译之后，输出结果显示 <code>0</code> ，即空结构体大小为0。 
</p>

<p>
采用 <code>g++ main.c</code> 编译之后，输出结果显示 <code>1</code> ，即空结构体大小为1。 
</p></li>

<li><p>
C++语言源文件 <code>main.cpp</code> 如下： 
</p>

<div class="org-src-container">

<pre class="src src-c++">#include  
class myclass 
{ 
}; 

struct mystruct 
{ 
}; 

int main(int argc, char *argv[]) 
{ 
    printf("%d,%d\n",sizeof(myclass),sizeof(struct mystruct)); 
    return 0; 
}
</pre>
</div></li>
</ul>

<p>
采用 <code>gcc main.cpp</code> 无法编译。 
</p>

<p>
采用 <code>g++ main.cpp</code> 编译之后，输出结果显示 <code>1,1</code> 即空类和结构体大小均为1。 
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-2">
<h2 id="orgheadline15"><span class="section-number-2">6</span> 参考资料</h2>
<div class="outline-text-2" id="text-6">
<p>
<a href="http://hi.baidu.com/ciw_blue/blog/item/28d74c3f6b134cea54e7239e.html" target="_blank" rel="noopener">http://hi.baidu.com/ciw_blue/blog/item/28d74c3f6b134cea54e7239e.html</a> 
</p>
</div>
</div>

                    </div>
                </article>                        
                
                <!--{% include duoshuo_comment.ext %}-->
            </td>
        </tr>
        <tr>
            <td id="td_page_footer" colspan="6">
    <footer>
        &copy 2015
    </footer>
    <a id="bottom"></a>
</td>
        </tr>
    </tbody>
</table>
    </main>
  </body>
</html>