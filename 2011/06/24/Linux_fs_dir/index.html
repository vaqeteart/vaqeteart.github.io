<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>
    Linux文件系统与目录结构
</title>

<!--css-->
<!--link rel="stylesheet" href="/style.css" type="text/css" /-->
<link rel="stylesheet" href="../../../../css/partial/head.css">
<link rel="stylesheet" href="../../../../css/partial/header.css">
<link rel="stylesheet" href="../../../../css/partial/archives.css">
<link rel="stylesheet" href="../../../../css/partial/categories.css">
<link rel="stylesheet" href="../../../../css/partial/home-posts.css">
<link rel="stylesheet" href="../../../../css/partial/page-nav.css">
<link rel="stylesheet" href="../../../../css/partial/tags.css">
<link rel="stylesheet" href="../../../../css/partial/about.css">
<link rel="stylesheet" href="../../../../css/partial/more.css">
<link rel="stylesheet" href="../../../../css/partial/footer.css">
<link rel="stylesheet" href="../../../../css/post.css">
<link rel="stylesheet" href="../../../../css/orgmode/hexo_orgmode_style.css">


<!--javascript-->
<!--script type="text/javascript" src="/script.js"></script-->
<script src="../../../../lib/jquery-1.11.3.min.js"></script>
<script src="../../../../js/common.js"></script>
<script src="../../../../js/nav.js"></script>

  </head>
  <body>
    <main class="main">
      <table class="container">
    <tbody id="tb_container">
        <tr id="tr_navbar">
            <script src="js/nav.js"></script>
<table class="navbar">
	<tbody>
		<tr>
			<th class="navitm">
				<a href="../../../../index.html">主页</a>
			</th>

			<th class="navitm">
				<a href="../../../../categories">分类</a>
				<div id="category_menus" class="second">
					
					<!--合并内部类和自定义类。
    每个分类的数据结构包括：
    id: 分类唯一id
    title: 分类名
    parent: 父分类id
    children:子分类数组
注：
内部类包含一个固定的分类结type="text/javascript"内部根分类设置为categories, title为分类在主题config.yml中有配置（待定）。
后续文章中设置的分类如果不是内部类都会被称作自定义类，可以通过hexo本身引擎检测出来。
最终内部类和自定义类会合并到完整分类(full_categories)中，这样让所有类能用json等通用方式表示，便于移植。

使用举例：
var category_info = getCategoriesInfo();
<x var symbols={}; x> //定义导出变量
<x- include('category_list', {symbols:symbols}) x> //包含该文件
<x var category_info = symbols.getCategoriesInfo(); x> //获取分类信息：包含分类树，以及分类与文章数映射表。
<x- symbols.list_category(category_info.categories, category_info.categories_count) x> //列出分类索引树

注： '<x' 是EJS模板语言的标记比如x为%。
-->

					
					<ul id="full_categories_tree" class="categories_tree categories_level0" type="none"><li id="categories" class="categories_tree_item"><a href="../../../../categories/" class="item_path"><span id="categories_switch" class="tree_switch">▷</span><span id="categories_title" class="item_title">分类</span><span id="categories_count" class="item_count">(58)</span></a><ul id="categories_tree" class="categories_tree categories_level2" type="none"><li id="note" class="categories_tree_item"><a href="../../../../categories/categories/note" class="item_path"><span id="note_switch" class="tree_switch">▷</span><span id="note_title" class="item_title">记事</span><span id="note_count" class="item_count">(6)</span></a><ul id="note_tree" class="categories_tree categories_level3" type="none"><li id="remind" class="categories_tree_item"><a href="../../../../categories/categories/note/remind" class="item_path"><span id="remind_switch" class="tree_switch">○</span><span id="remind_title" class="item_title">备忘</span><span id="remind_count" class="item_count">(0)</span></a></li><li id="plan" class="categories_tree_item"><a href="../../../../categories/categories/note/plan" class="item_path"><span id="plan_switch" class="tree_switch">○</span><span id="plan_title" class="item_title">计划</span><span id="plan_count" class="item_count">(0)</span></a></li>|</ul></li><li id="study" class="categories_tree_item"><a href="../../../../categories/categories/study" class="item_path"><span id="study_switch" class="tree_switch">▷</span><span id="study_title" class="item_title">学习</span><span id="study_count" class="item_count">(2)</span></a><ul id="study_tree" class="categories_tree categories_level3" type="none"><li id="problem" class="categories_tree_item"><a href="../../../../categories/categories/study/problem" class="item_path"><span id="problem_switch" class="tree_switch">○</span><span id="problem_title" class="item_title">问题</span><span id="problem_count" class="item_count">(0)</span></a></li><li id="git" class="categories_tree_item"><a href="../../../../categories/categories/study/git" class="item_path"><span id="git_switch" class="tree_switch">○</span><span id="git_title" class="item_title">git</span><span id="git_count" class="item_count">(1)</span></a></li><li id="os" class="categories_tree_item"><a href="../../../../categories/categories/study/os" class="item_path"><span id="os_switch" class="tree_switch">○</span><span id="os_title" class="item_title">操作系统</span><span id="os_count" class="item_count">(1)</span></a></li><li id="books" class="categories_tree_item"><a href="../../../../categories/categories/study/books" class="item_path"><span id="books_switch" class="tree_switch">▷</span><span id="books_title" class="item_title">books</span><span id="books_count" class="item_count">(0)</span></a><ul id="books_tree" class="categories_tree categories_level4" type="none"><li id="apue" class="categories_tree_item"><a href="../../../../categories/categories/study/books/apue" class="item_path"><span id="apue_switch" class="tree_switch">○</span><span id="apue_title" class="item_title">APUE</span><span id="apue_count" class="item_count">(0)</span></a></li>|</ul></li><li id="linux" class="categories_tree_item"><a href="../../../../categories/categories/study/linux" class="item_path"><span id="linux_switch" class="tree_switch">▷</span><span id="linux_title" class="item_title">linux</span><span id="linux_count" class="item_count">(3)</span></a><ul id="linux_tree" class="categories_tree categories_level4" type="none"><li id="misc" class="categories_tree_item"><a href="../../../../categories/categories/study/linux/misc" class="item_path"><span id="misc_switch" class="tree_switch">○</span><span id="misc_title" class="item_title">杂乱</span><span id="misc_count" class="item_count">(3)</span></a></li><li id="command" class="categories_tree_item"><a href="../../../../categories/categories/study/linux/command" class="item_path"><span id="command_switch" class="tree_switch">○</span><span id="command_title" class="item_title">命令</span><span id="command_count" class="item_count">(19)</span></a></li>|</ul></li><li id="jekyll" class="categories_tree_item"><a href="../../../../categories/categories/study/jekyll" class="item_path"><span id="jekyll_switch" class="tree_switch">○</span><span id="jekyll_title" class="item_title">jekyll</span><span id="jekyll_count" class="item_count">(0)</span></a></li><li id="kits" class="categories_tree_item"><a href="../../../../categories/categories/study/kits" class="item_path"><span id="kits_switch" class="tree_switch">○</span><span id="kits_title" class="item_title">工具</span><span id="kits_count" class="item_count">(1)</span></a></li><li id="emacs" class="categories_tree_item"><a href="../../../../categories/categories/study/emacs" class="item_path"><span id="emacs_switch" class="tree_switch">○</span><span id="emacs_title" class="item_title">emacs</span><span id="emacs_count" class="item_count">(2)</span></a></li><li id="vim" class="categories_tree_item"><a href="../../../../categories/categories/study/vim" class="item_path"><span id="vim_switch" class="tree_switch">○</span><span id="vim_title" class="item_title">vim</span><span id="vim_count" class="item_count">(0)</span></a></li>|</ul></li><li id="work" class="categories_tree_item"><a href="../../../../categories/categories/work" class="item_path"><span id="work_switch" class="tree_switch">▷</span><span id="work_title" class="item_title">工作</span><span id="work_count" class="item_count">(0)</span></a><ul id="work_tree" class="categories_tree categories_level3" type="none"><li id="progress" class="categories_tree_item"><a href="../../../../categories/categories/work/progress" class="item_path"><span id="progress_switch" class="tree_switch">○</span><span id="progress_title" class="item_title">进度</span><span id="progress_count" class="item_count">(0)</span></a></li>|</ul></li><li id="life" class="categories_tree_item"><a href="../../../../categories/categories/life" class="item_path"><span id="life_switch" class="tree_switch">▷</span><span id="life_title" class="item_title">生活</span><span id="life_count" class="item_count">(0)</span></a><ul id="life_tree" class="categories_tree categories_level3" type="none"><li id="experience" class="categories_tree_item"><a href="../../../../categories/categories/life/experience" class="item_path"><span id="experience_switch" class="tree_switch">○</span><span id="experience_title" class="item_title">经验</span><span id="experience_count" class="item_count">(0)</span></a></li><li id="tips" class="categories_tree_item"><a href="../../../../categories/categories/life/tips" class="item_path"><span id="tips_switch" class="tree_switch">○</span><span id="tips_title" class="item_title">技巧</span><span id="tips_count" class="item_count">(0)</span></a></li>|</ul></li><li id="others" class="categories_tree_item"><a href="../../../../categories/categories/others" class="item_path"><span id="others_switch" class="tree_switch">▷</span><span id="others_title" class="item_title">其它</span><span id="others_count" class="item_count">(4)</span></a><ul id="others_tree" class="categories_tree categories_level3" type="none"><li id="rambles" class="categories_tree_item"><a href="../../../../categories/categories/others/rambles" class="item_path"><span id="rambles_switch" class="tree_switch">○</span><span id="rambles_title" class="item_title">随笔</span><span id="rambles_count" class="item_count">(0)</span></a></li><li id="temp" class="categories_tree_item"><a href="../../../../categories/categories/others/temp" class="item_path"><span id="temp_switch" class="tree_switch">○</span><span id="temp_title" class="item_title">临时</span><span id="temp_count" class="item_count">(0)</span></a></li><li id="test" class="categories_tree_item"><a href="../../../../categories/categories/others/test" class="item_path"><span id="test_switch" class="tree_switch">○</span><span id="test_title" class="item_title">测试</span><span id="test_count" class="item_count">(0)</span></a></li>|</ul></li>|</ul></li></ul>
				</div>
			</th>

			<th class="navblank"></th>

			<th class="navitm">
				<a href="../../../../tags">标签</a>
				<div id="tag_menus" class="second">
					<ul class="tag-list"></ul>
				</div>
			</th>

			<th class="navitm">
				<a href="../../../../archives">归档</a>
			</th>

			<th class="navblank"></th>

			<th class="navitm">
				<a href="../../../../more">更多</a>
			</th>

			<th class="navitm">
				<a href="../../../../about">关于</a>
			</th>

			<th class="navblank" style="width:25%;"></th>

			<th class="navitm" style="margin:0; padding:0;border:none;">
				<form method="get" id="searchform" action="/search.html" style="margin:0;padding:0;height:100%;">
					<span style="color:#00FF00;">Q</span>
					<span style="border-style:solid; border-width:1px; border-color:#00FF00;
		  		border-top:0px; border-left:0px;border-right:0px; 
				margin:0;padding:0;height:100%;">
						<input value="Search by title (canbe regex)..." name="s" class="s" onfocus="if (this.value == 'Search by title (canbe regex)...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search by title (canbe regex)...';}" style="margin:0;padding:0;height:100%;border:none;background: #000000; color:#00A600;" type="text">
					</span>
					<!--input type="submit" value="Q" style="width:20%;"-->
				</form>
			</th>

			<th class="navblank"></th>

			<th class="navblank"></th>

			<a href="#" id="topbtn">⇑</a>

			<a href="#bottom" id="bottombtn">⇓</a>
			<!--⇐⇑⇒⇓-->
		</tr><tr>
	</tr></tbody>
</table>
        </tr>
        <tr>
            <td id="td_page_header" colspan="6" valign="top" align="right" style="width:100%;">
        <header style="text-align: center;">
               <a href="/" title="Menu.Home">
               <h1>QuietHeart's Site</h1>
               </a>
        </header>
</td>    
        </tr>
        <tr>
            <td id="td_posts" colspan="6" valign="top">
                <h1 id="header1" style="text-align: center;">
                    Linux文件系统与目录结构
                </h1>
                <hr id="title_line">
                <article>
                    <div>
                        <div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. <code>Linux</code> 和 <code>Windows</code> 文件系统</a>
<ul>
<li><a href="#orgheadline2">1.1. <code>Windows</code> 上面的文件系统</a>
<ul>
<li><a href="#orgheadline3">1.1.1. 优点</a></li>
<li><a href="#orgheadline4">1.1.2. 缺点</a></li>
</ul>
</li>
<li><a href="#orgheadline5">1.2. <code>Linux</code> 上面的文件系统</a>
<ul>
<li><a href="#orgheadline6">1.2.1. 缺点</a></li>
<li><a href="#orgheadline7">1.2.2. 优点</a></li>
</ul>
</li>
<li><a href="#orgheadline8">1.3. <code>Linux</code> 文件系统在操作系统中的位置</a></li>
</ul>
</li>
<li><a href="#orgheadline9">2. <code>Linux</code> 上面的虚拟文件系统目录组织</a>
<ul>
<li><a href="#orgheadline10">2.1. 常用的重要目录</a></li>
<li><a href="#orgheadline11">2.2. 对文件系统目录的分类标准</a></li>
</ul>
</li>
</ul>
</div>
</div>

<p>
<code>Linux</code> 和 <code>Windows</code> 的文件系统有些不同，在学习使用 <code>Linux</code> 之前，若能够了解这些不同，会有助于后续学习。本文先对 <code>Windows</code> 和 <code>Linux</code> 上面文件系统的一些概念进行区分，然后介绍一些 <code>Linux</code> 文件系统相关的原理，最后较为详细地介绍了 <code>Linux</code> 系统的目录结构。
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> <code>Linux</code> 和 <code>Windows</code> 文件系统</h2>
<div class="outline-text-2" id="text-1">
<p>
下面分别简单介绍一下启动 <code>Windows</code> 和 <code>Linux</code> 之后，它们是怎样看待自己世界的， 着重介绍 <code>Linux</code> 。
</p>
</div>
<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2"><span class="section-number-3">1.1</span> <code>Windows</code> 上面的文件系统</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<code>Windows</code> 系统中一切东西都是存放在硬盘上的。启动系统后，先确定硬盘，再硬盘上的分区和每个分区所对应的文件系统，最后是存放在某个分区特定的文件系统中的文件。 也就是说， <code>Windows</code> 是通过 <b>“某个硬盘-硬盘上的某个分区-分区上的特定文件系统-特定文件系统中的文件”</b> 这样的顺序来访问到一个文件的。
</p>

<p>
具体点说，假设我们的机器上面有一个硬盘，硬盘分为几个区，那么我们启动系统之后就会看到 <code>C</code>, <code>D</code>, <code>E</code>, 等几个分区(也就是我们启动系统后看到的 <code>C</code> 盘， <code>D</code> 盘等)，每个分区可以被格式化为各自不同的文件系统（例如 <code>NTFS</code> 格式， <code>FAT32</code> 格式等，文件系统的基本功能就是为了存放文件的，不同文件系统区别一般在于管理其中存放的文件的功能的强弱)，分区被格式化成指定格式的文件系统之后，就可以存放任何文件和目录了。这里，我们可以把文件大体分为两种： <b>系统文件和用户文件</b> 。一般来说系统文件（例如 <code>Windows</code> 操作系统本身，一些系统程序，程序运行所需的库文件，以及一些系统配置文件等）存放的默认位置在 <code>C</code> 盘，当然也可以在安装时候指定在其他盘；其它用户文件，包含用户后来安装的程序以及一些数据文件等，用户可以把它们随意存放在任意的分区。
</p>

<p>
这样组织有优点，更有缺点。
</p>
</div>

<div id="outline-container-orgheadline3" class="outline-4">
<h4 id="orgheadline3"><span class="section-number-4">1.1.1</span> 优点</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
优点主要是用户存放东西的位置比较自由，系统结构简单便于新用户上手。
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-4">
<h4 id="orgheadline4"><span class="section-number-4">1.1.2</span> 缺点</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
缺点有很多这里只列出几种：
</p>

<ul class="org-ul">
<li><p>
目录组织缺乏标准
</p>

<p>
由于对“系统文件”和“用户文件”存放位置缺乏细致的规定，数据组织的方式显得比较凌乱，并且两种文件之间很容易相互干扰（例如数据文件可能存放在系统区域给系统带来垃圾文件等）。
</p></li>

<li><p>
用户的使用经验对系统的使用效率影响很大
</p>

<p>
一般来说，我们使用 <code>Windows</code> 时候合理使用分区会提升的系统效率。例如根据需要设置合理的系统分区（假设为 <code>C</code> 分区），尽量少往 <code>C</code> 盘存放数据文件，根据具体情况可以将一些 <b>“重要并且常用的”</b> 程序安装在 <code>C</code> 分区，随时保持系统目录的清洁和大小助于提升系统的运行速度，用户安装的一般软件尽量不要安装在 <code>C</code> 盘，安装软件时候指定的位置最好采用默认标准目录名称（例如 <code>X:\Program Files</code> 目录，这里 <code>X</code> 表示盘符而不要自己定义一些奇怪名字的目录，这样便于软件的维护等等。
</p></li>

<li><p>
共享不便
</p>

<p>
<code>Windows</code> 上有经验的用户们会将自己的目录结构组织好，但是每个用户组织自己内容的方式是不一样的，所以他的机器上哪里存放了什么内容，别人很难知道，为共享带来了麻烦。
</p></li>
</ul>

<p>
但是这些在 <code>Linux</code> 系统中，情况就所不同了。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">1.2</span> <code>Linux</code> 上面的文件系统</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在 <code>Linux</code> 系统中正好相反，一切东西都是存放在一个唯一的 <code>虚拟文件系统</code> 中的，这个 <code>虚拟文件系统</code> 是树状的结构以一个根目录开始。启动系统后，先有这个 <code>虚拟文件系统</code> ，再硬盘， 再把某个硬盘的某个分区做为这个 <code>虚拟文件系统</code> 的一部分（用某个子目录表示这个分区），再通过这个 <code>虚拟文件系统</code> 中对应硬盘分区的那个子目录确定硬盘分区中的特定文件系统，最后的文件就存放在这个特定的文件系统中。 也就是说， <code>Linux</code> 系统是通过 <b>“虚拟文件系统-硬盘-硬盘上的分区-分区上的特定文件系统-特定文件系统中的文件”</b> 这样的顺序来访问一个文件的。
</p>

<p>
可能对习惯了使用 <code>Windows</code> 的用户来说，这样的组织点不太适应，这里的 <code>虚拟文件系统</code> ，实质就是一颗目录树，最开始的目录叫做根目录，根目录中又有每一级子目录，或者文件，子目录又有子子目录和文件，其中每个子目录都特定的功能这个功能是约定俗成了的后面会详细说明……和 <code>Windows</code> 中把硬盘分成的 <code>C</code>, <code>D</code>, <code>E</code> 分区的概念不同了， <code>Linux</code> 中最开始根本就没有硬盘的概念，就只有一个纯粹的 <code>虚拟文件系统</code> 。如果想要使用哪个硬盘的某个分区，就把那个分区 <b>“挂载”</b> 到某个子目录之下，这样硬盘中的分区，文件系统，目录等内容就呈现到了那个子目录里面。也就是说，在 <code>Linux</code> 中，我们使用硬盘中的数据，实际是先把硬盘 <b>“挂载”</b> 到某个子目录下，然后通过那个子目录来访问硬盘的。硬盘中原的数据组织结构都反映到了子目录上，成为了整个 <code>虚拟文件系统</code> 根目录下的一颗子树。
</p>

<p>
也许人会问，没这个 <code>虚拟文件系统</code> 就无法使用硬盘，但是最开始没有硬盘，那么这个 <code>虚拟文件系统</code> 以及相应的组织结构是怎么存放起来的呢？这个问题，就像先有鸡还是先有蛋这个问题一样看似简单实则……但是，在 <code>Linux</code> 中，很轻易地跳出了这个思维循环，问题的答案并没在 <code>虚拟文件系</code> 和 <code>硬盘</code> 这两者之间徘徊，而是第三者—— <code>内存</code> ，Linux系统启动起来之后，整个 <code>虚拟文件系统</code> 的组织结构，都是随着每次内核系统的启动自动在内存中建立好了的，根本就不需要硬盘。
</p>

<p>
<code>Linux</code> 这样组织它的目录结构，有缺点当然更多的是优点。
</p>
</div>

<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6"><span class="section-number-4">1.2.1</span> 缺点</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
最开始 <code>虚拟文件系统</code> 中的每个子目录的功能是事先规定好了的，我们需要事先知道那些目录存放哪些文件，然后在相应的位置中创建自己的内容，这也是为什么 <code>Linux</code> 系统入门门槛高的一个原因。（当然最开始的新手，也可以像 <code>Windows</code> 那样随意地创建目录和文件）。
</p>

<p>
实际上最开始的目录也不多，主要就那么几个，花不了多长时间就会明白它们的作用的，而明白这些作用之后带来的好处，远不止付出那么多。 本文后面着重对这些目录进行介绍。
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-4">
<h4 id="orgheadline7"><span class="section-number-4">1.2.2</span> 优点</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
这里只说几个优点：
</p>

<ul class="org-ul">
<li><p>
目录结构反映系统运行机理
</p>

<p>
当我们了解了这些目录的功能之后，我们对整个 <code>Linux</code> 操作系统的运行机理也会有一个大致的了解。
</p></li>

<li><p>
结构清晰避免逻辑混乱
</p>

<p>
这样的目录结构，有助于我们以一种高效的方式组织自己的数据，分类清晰并且不会对系统运行有任何影响，规定了最开始每个目录的功能，并没有限制我们的自由，因为我们知道我们可以在哪里创建自己的子目录并且在子目录中任意创建自己的文件。
</p></li>

<li><p>
组织规范便于共享
</p>

<p>
由于目录具有统一的组织结构，所以 <code>Linux</code> 上面的用户在共享数据的时候，能够很容易地猜测出他所需要的数据大致存放在什么位置，同时也不会影响到私有数据的保密性（怎么存放自己的私有数据，那是用户自己决定的）。
</p></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8"><span class="section-number-3">1.3</span> <code>Linux</code> 文件系统在操作系统中的位置</h3>
<div class="outline-text-3" id="text-1-3">
<p>
在 <code>Linux</code> 系统中，主要两个东西： <code>虚拟文件系统</code> 中的文件和 <code>Linux操作系统内核</code> 本身。逻辑上可以认为前者属于上层，后者在下层，前者基于后者，后者依赖前者而存在。
</p>

<p>
<code>Linux</code> 把除了它本身（ <code>Linux操作系统内核</code> ）以外的一切事物都看作是在 <code>虚拟文件系统</code> 中的文件了。无论是键盘，鼠标，数据，程序，CPU，内存，网卡……无论是硬件、软件、数据还是内存中的东西，我们都可以在 <code>虚拟文件系统</code> 中的相应子目录对他们进行访问和操作，操作统一。而实现这些管理的幕后就是 <code>Linux操作系统内核</code> 本身：启动 <code>Linux</code> 系统的时候，首先电脑把 <code>Linux操作系统内核</code> 加载到内存中，内核本身提供了文件管理，设备管理，内存管理，CPU进程调度管理，网络管理等功能，等内核运行起来之后，就在内存中建立起相应的 <code>虚拟文件系统</code> ，最后就是内核利用它提供的那些功能，来管理 <code>虚拟文件系统</code> 中的硬件软件等各种资源了。
</p>

<p>
<code>Linux</code> 把提供操作系统本身功能（管理计算机软硬件资源）的那些部分划给了 <code>Linux操作系统内核</code> ，使得 <code>Linux操作系统内核</code> 成为一个独立的部分，有它自己的开源代码；其上其它的一切（软件，硬件，数据）都根据其特性有自己的开源代码、或者自由地组织并且存放在那个 <code>虚拟文件系统</code> 中由 <code>Linux操作系统内核</code> 来管理。这样，将系统本身和系统所管理的资源分开，并开放源代码，有助于对系统或者系统所管理的资源进行灵活的定制和扩展，还能按需快速建立起只适合自己使用的操作系统，也利于操作系统本身的发展。实际 <code>Ubuntu</code> ， <code>Fedora</code> ， <code>RedHat</code> 等各种不同的 <code>Linux</code> 操作系统发行版，简单来说就是对其文件系统和内核进行了不同的配置而产生的 <b>“大众化”</b> 的操作系统，相比之下， <code>Windows</code> 就显得非常地零乱复杂，将系统、软件、硬件都混在了一起，其不同版本只能由 <code>Mircro</code> 一家公司发行。
</p>

<p>
另外，我们还要注意个问题，就是在我们的角度上，是使用路径来访问一个文件的。表示文件的路径由 <b>“文件所在的目录+各级目录的分隔符+文件”</b> 三个部分组成，这无论在 <code>Windows</code> 还是 <code>Linux</code> 上面，都是一样的，所不同的是， <code>Windows</code> 下面目录分隔符是 <code>\</code> ， <code>Linux</code> 下面是 <code>/</code> ，也许这也是两者之间为了表示其各自立场不同的一个原因吧？^_^
</p>

<p>
例如：
</p>
<pre class="example">
Window系统上的文件：D:\Program Files\PPStream\PPStream.exe
Linux系统上的文件：/usr/bin/screen
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-2">
<h2 id="orgheadline9"><span class="section-number-2">2</span> <code>Linux</code> 上面的虚拟文件系统目录组织</h2>
<div class="outline-text-2" id="text-2">
<p>
实质上，我们启动系统所看到的 <b>“根目录”</b> ，逻辑上是 <code>Linux</code> 虚拟文件系统的根目录中的一个子目录，我们看不到除了这个 <b>“根目录”</b> 以外的其他的目录，那些目录和操作系统的具体实现相关是被操作系统内核隐藏起来了的，所以这里就介绍我们所能看到的文件系统中的 <b>“根目录”</b> 的各个子目录中的作用吧。
</p>

<p>
在 <code>Linux</code> 文件系统中的每一个子目录都有特定的目的和用途。一般都是根据 <code>FHS</code> 标准定义一个正式的文件系统结构的，这个标准规定了哪些目录应该哪些作用。这里我们先介绍一些日常经常用到的目录，然后给出 <code>FHS</code> 相关的内容。
</p>
</div>

<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">2.1</span> 常用的重要目录</h3>
<div class="outline-text-3" id="text-2-1">
<p>
这里，根据本人的使用经验，给出比较常见重要的一些目录，最开始我们对它们有所了解就可以了。随着对 <code>Linux</code> 使用的经验的加深，我们会了解越来越多的目录。对目录的功能知道得越多，我们对 <code>Linux</code> 系统的工p作原理就理解的越深刻，理解操作系统的工作原理，更助于我们更为规范地使用和理解系统中每个目录存在的意义，直至最后几乎知道系统中的每个文件……
</p>

<ul class="org-ul">
<li><p>
<code>/</code> 根目录
</p>

<p>
包含了几乎所的文件目录。相当于中央系统。进入的最简单方法是：cd /。
</p></li>

<li><p>
<code>/boot</code> 引导程序，内核等存放的目录
</p>

<p>
这个目录，包括了在引导过程中所必需的文件，引导程序的相关文件（例如 <code>grub</code> ， <code>lilo</code> 以及相应的配置文件）以及 <code>Linux</code> 操作系统内核相关文件（例如 <code>vmlinuz</code> 等）一般都存放在这里。在最开始的启动阶段，通过引导程序将内核加载到内存，完成内核的启动（这个时候， <code>虚拟文件系统</code> 还不存在，加载的内核虽然是从硬盘读取的，但是没经过 <code>Linux</code> 的 <code>虚拟文件系统</code> ，这是比较底层的东西来实现的）。然后内核自己创建好 <code>虚拟文件系统</code> ，并且从 <code>虚拟文件系统</code> 的其他子目录中（例如 <code>/sbin</code> 和 <code>/etc</code> ）加载需要在开机启动的其他程序或者服务或者特定的动作（部分可以由用户自己在相应的目录中修改相应的文件来配制）。如果我们的机器中包含多个操作系统，那么可以通过修改这个目录中的某个配置文件（例如 <code>grub.conf</code> ）来调整启动的默认操作系统，系统启动的择菜单，以及启动延迟等参数。
</p></li>

<li><p>
<code>/sbin</code> 超级用户可以使用的命令的存放目录
</p>

<p>
存放大多涉及系统管理的命令（例如引导系统的 <code>init</code> 程序），是超级权限用户 <code>root</code> 的可执行命令存放地，普通用户无权限执行这个目录下的命令（但是有时普通用户也可能会用到）。这个目录和 <code>/usr/sbin</code> , <code>/usr/X11R6/sbin或/usr/local/sbin</code> 等目录是相似的，我们要记住，凡是目录 <code>sbin</code> 中包含的都是 <code>root</code> 权限才能执行的，这样就行了。后面会具体区分。
</p></li>

<li><p>
<code>/bin</code> 普通用户可以使用的命令的存放目录
</p>

<p>
系统所需要的那些命令位于此目录，比如 <code>ls</code> 、 <code>cp</code> 、 <code>mkdir</code> 等命令；类似的目录还 <code>/usr/bin</code> ， <code>/usr/local/bin</code> 等等。这个目录中的文件都是可执行的、普通用户都可以使用的命令。作为基础系统所需要的最基础的命令就是放在这里。
</p></li>

<li><p>
<code>/lib</code> 根目录下的所程序的共享库目录
</p>

<p>
此目录下包含系统引导和在根用户执行命令时候所必需用到的共享库。做个不太好但是比较形象的比喻，点类似于 <code>Windows</code> 上面的 <code>system32</code> 目录。按理说，这里存放的文件应该是 <code>/bin</code> 目录下程序所需要的库文件的存放地，也不排除一些例外的情况。类似的目录还 <code>/usr/lib</code> ， <code>/usr/local/lib</code> 等等。
</p></li>

<li><p>
<code>/dev</code> 设备文件目录
</p>

<p>
在 <code>Linux</code> 中设备都是以文件形式出现，这里的设备可以是硬盘，键盘，鼠标，网卡，终端，等设备，通过访问这些文件可以访问到相应的设备。设备文件可以使用 <code>mknod</code> 命令来创建，具体参见相应的命令；而为了将对这些设备文件的访问转化为对设备的访问，需要向相应的设备提供设备驱动模块（一般将设备驱动编译之后，生成的结果是一个 <code>*.ko</code> 类型的二进制文件），在内核启动之后，再通过 <code>insmod</code> 等命令加载相应的设备驱动之后，我们就可以通过设备文件来访问设备了。一般来说，想要 <code>Linux</code> 系统支持某个设备，只需要三个东西：相应的硬件设备，支持硬件的驱动模块，以及相应的设备文件。
</p></li>

<li><p>
<code>/home</code> 普通用户的家目录（或 <code>$HOME</code> 目录、主目录）
</p>

<p>
在 <code>Linux</code> 机器上，用户主目录通常直接或间接地置在此目录下。其结构通常由本地机的管理员来决定。通常而言，系统的每个用户都有自己的家目录，目录以用户名作为名字存放在 <code>/home</code> 下面（例如 <code>quietheart</code> 用户，其家目录的名字为 <code>/home/quietheart</code> ）。该目录中保存了绝大多数的用户文件(用户自己的配置文件，定制文件，文档，数据等)， <code>root</code> 用户除外（参见后面的 <code>/root</code> 目录）。由于这个目录包含了用户实际的数据，通常系统管理员为这个目录单独挂载一个独立的磁盘分区，这样这个目录的文件系统格式就可能和其他目录不一样了（尽管表面上看，这个目录还是属于根目录的一棵子树上），将系统文件和数据文件分开存放，有利于维护。
</p></li>

<li><p>
<code>/root</code> 用户root的 <code>$HOME</code> 目录
</p>

<p>
系统管理员(就是 <code>root</code> 用户或超级用户)的主目录比较特殊，不存放在 <code>/home</code> 中，而是直接放在 <code>/root</code> 目录下了。
</p></li>

<li><p>
<code>/etc</code> 全局的配置文件存放目录
</p>

<p>
系统和程序一般都可以通过修改相应的配置文件，来进行配置。例如，要配置系统开机的时候启动那些程序，配置某个程序启动的时候显示什么样的风格等等。通常这些配置文件都集中存放在 <code>/etc</code> 目录中，所以想要配置什么东西的话，可以在 <code>/etc</code> 下面寻找我们可能需要修改的文件。一些大型套件，如 <code>X11</code> ，在 <code>/etc</code> 下它们自己的子目录。系统配置文件可以放在这里或在 <code>/usr/etc</code> 。 不过所有程序总是在 <code>/etc</code> 目录下查找所需的配置文件，你也可以将这些文件链接到目录 <code>/usr/etc</code> 。另外，还一个需要注意的常见现象就是，当某个程序在某个用户下运行的时候，可能会在该用户的家目录中生成一个配置文件（一般这个文件最开始就是 <code>/etc</code> 下相应配置文件的拷贝，存放相应于“当前用户”的配置），这样当前用户可以通过配置这个家目录的配置文件，来改变程序的行为，并且这个行为只是该用户特有的。原因就是：一般来说一个程序启动，如果需要读取一些配置文件的话，它会首先读取当前用户家目录的配置文件，如果存在就使用；如果不存在它就到 <code>/etc</code> 下读取全局的配置文件进而启动程序。就是这个配置文件不自动生成，我们手动在自己的家目录中创建一个文件的话，也有许多程序会首先读取到这个家目录的文件并且以它的配置作为启动的选项（例如我们可以在家目录中创建 <code>vim</code> 程序的配置文件 <code>.vimrc</code> ，来配置自己的 <code>vim</code> 程序）。
</p></li>

<li><p>
<code>/usr</code> 这个目录中包含了命令库文件和在通常操作中不会修改的文件
</p>

<p>
这个目录对于系统来说也是一个非常重要的目录，其地位类似Windows上面的 <code>Program Files</code> 目录（请原谅我可能这样做比较不太恰当^_^）。安装程序的时候，默认就是安装在此文件内部某个子文件夹内。输入命令后系统默认执行 <code>/usr/bin</code> 下的程序（当然，前提是这个目录的路径已经被添加到了系统的环境变量中）。此目录通常也会挂载一个独立的磁盘分区，它应保存共享只读类文件，这样它可以被运行 <code>Linux</code> 的不同主机挂载。
</p></li>

<li><p>
<code>/usr/lib</code> 目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置
</p>

<p>
这个目录功能类似 <code>/lib</code> 目录，理说，这里存放的文件应该是 <code>/bin</code> 目录下程序所需要的库文件的存放地，也不排除一些例外的情况。
</p></li>

<li><p>
<code>/usr/bin</code> 一般使用者使用并且不是系统自检等所必需可执行文件的目录
</p>

<p>
此目录相当于根文件系统下的对应目录（ <code>/bin</code> ），非启动系统，非修复系统以及非本地安装的程序一般都放在此目录下。
</p></li>

<li><p>
<code>/usr/sbin</code> 管理员使用的非系统必须的可执行文件存放目录
</p>

<p>
此目录相当于根文件系统下的对应目录（ <code>/sbin</code> ），保存系统管理程序的二进制文件，并且这些文件不是系统启动或文件系统挂载 <code>/usr</code> 目录或修复系统所必需的。
</p></li>

<li><p>
<code>/usr/share</code> 存放共享文件的目录
</p>

<p>
在此目录下不同的子目录中保存了同一个操作系统在不同构架下工作时特定应用程序的共享数据(例如程序文档信息)。使用者可以找到通常放在 <code>/usr/doc</code> 或 <code>/usr/lib</code> 或 <code>/usr/man</code> 目录下的这些类似数据。
</p></li>

<li><p>
<code>/usr/include</code> C程序语言编译使用的头文件
</p>

<p>
<code>Linux</code> 下开发和编译应用程序所需要的头文件一般都存放在这里，通过头文件来使用某些库函数。默认来说这个路径被添加到了环境变量中，这样编译开发程序的时候编译器会自动搜索这个路径，从中找到你的程序中可能包含的头文件。
</p></li>

<li><p>
<code>/usr/local</code> 安装本地程序的一般默认路径
</p>

<p>
当我们下载一个程序源代码，编译并且安装的时候，如果不特别指定安装的程序路径，那么默认会将程序相关的文件安装到这个目录的对应目录下。例如，安装的程序可执行文件被安装（安装实质就是复制）到了 <code>/usr/local/bin</code> 下面，此程序（可执行文件）所需要依赖的库文件被安装到了 <code>/usr/local/lib</code> 目录下，被安装的软件如果是某个开发库（例如 <code>Qt</code> ， <code>Gtk</code> 等）那么相应的头文件可能就被安装到了 <code>/usr/local/include</code> 中等等。也就是说，这个目录存放的内容，一般都是我们后来自己安装的软件的默认路径，如果择了这个默认路径作为软件的安装路径，被安装的软件的所文件都限制在这个目录中，其中的子目录就相应于根目录的子目录。
</p></li>

<li><p>
<code>/proc</code> 特殊文件目录
</p>

<p>
这个目录采用一种特殊的文件系统格式（ <code>proc</code> 格式），内核支持这种格式。其中包含了全部虚拟文件。它们并不保存在磁盘中，也不占据磁盘空间(尽管命令 <code>ls -c</code> 会显示它们的大小)。当您查看它们时，您实际上看到的是内存里的信息，这些文件助于我们了解系统内部信息。例如：
</p>
<pre class="example">
 ├1/ 关于进程1的信息目录。每个进程在/proc 下一个名为其进程号的目录。
 ├cpuinfo 处理器信息，如类型、制造商、型号和性能。
 ├devices 当前运行的核心配置的设备驱动的列表。
 ├dma 显示当前使用的DMA通道。
 ├filesystems 核心配置的文件系统。
 ├interrupts 显示使用的中断，and how many of each there have been.
 ├ioports 当前使用的I/O端口。
 ├kcore 系统物理内存映象。与物理内存大小一样，但实际不占这么多内存；
 ├kmsg 核心输出的消息。也被送到syslog 。
 ├ksyms 核心符号表。
 ├loadavg 系统”平均负载”；3个没意义的指示器指出系统当前的工作量。
 ├meminfo 存储器使用信息，包括物理内存和swap。
 ├modules 当前加载了哪些核心模块。
 ├net 网络协议状态信息。
 ├self 到查看/proc 的程序的进程目录的符号连接。
 ├stat 系统的不同状态
 ├uptime 系统启动的时间长度。
 └version 核心版本。
</pre></li>

<li><p>
<code>/opt</code> 可择的文件目录
</p>

<p>
这个目录表示的是可择的意思，些自定义软件包或者第方工具，就可以安装在这里。比如在 <code>Fedora Core 5.0</code> 中， <code>OpenOffice</code> 就是安装在这里。些我们自己编译的软件包，就可以安装在这个目录中；通过源码包安装的软件，可以把它们的安装路径设置成 <code>/opt</code> 这样来安装。这个目录的作用一点类似 <code>/usr/local</code> 。
</p></li>

<li><p>
<code>/mnt</code> 临时挂载目录
</p>

<p>
这个目录一般是用于存放挂载储存设备的挂载目录的，比如磁盘，光驱，网络文件系统等，当我们需要挂载某个磁盘设备的时候，可以把磁盘设备挂载到这个目录上去，这样我们可以直接通过访问这个目录来访问那个磁盘了。一般来说，我们最好在 <code>/mnt</code> 目录下面多建立几个子目录，挂载的时候挂载到这些子目录上面，因为通常我们可能不仅仅是挂载一个设备吧?
</p></li>

<li><code>/media</code> 挂载的媒体设备目录
挂载的媒体设备目录，一般外部设备挂载到这里，例如 <code>cdrom</code> 等。比如我们插入一个U盘，我们一般会发现， <code>Linux</code> 自动在这个目录下建立一个 <code>disk</code> 目录，然后把U盘挂载到这个 <code>disk</code> 目录上，通过访问这个 <code>disk</code> 来访问U盘。</li>

<li><p>
<code>/var</code> 内容经常变化的目录
</p>

<p>
此目录下文件的大小可能会改变，如缓冲文件，日志文件，缓存文件，等一般都存放在这里。
</p></li>

<li><p>
<code>/tmp</code> 临时文件目录
</p>

<p>
该目录存放系统中的一些临时文件，文件可能会被系统自动清空。的系统直接把 <code>tmpfs</code> 类型的文件系统挂载到这个目录上， <code>tmpfs</code> 文件系统由 <code>Linux</code> 内核支持，在这个文件系统中的数据，实际上是内存中的，由于内存的数据断电易失，当系统重新启动的时候我们就会发现这个目录被清空了。
</p></li>

<li><p>
<code>/lost+found</code> 恢复文件存放的位置
</p>

<p>
当系统崩溃的时候，在系统修复过程中需要恢复的文件，可能就会在这里被找到了，这个目录一般为空。
</p></li>
</ul>

<p>
以上目录，是最常见的重要目录。其中，有些目录初学者容易混淆，这里简单区分一下：
</p>
<ol class="org-ol">
<li><code>/bin</code> , <code>/sbin</code> 与 <code>/usr/bin</code> , <code>/usr/sbin</code>

<ul class="org-ul">
<li><code>/bin</code> 一般存放对于用户和系统来说“必须”的程序（二进制文件）。</li>
<li><code>/sbin</code> 一般存放用于系统管理的“必需”的程序（二进制文件），一般普通用户不会使用，根用户使用。</li>
<li><code>/usr/bin</code> 一般存放的只是对用户和系统来说“不是必需的”程序（二进制文件）。</li>
<li><code>/usr/sbin</code> 一般存放用于系统管理的系统管理的不是必需的程序（二进制文件）。</li>
</ul></li>
<li><code>/lib</code> 与 <code>/usr/lib</code>

<ul class="org-ul">
<li><code>/lib</code> 和 <code>/usr/lib</code> 的区别类似 <code>/bin</code>, <code>/sbin</code> 与 <code>/usr/bin</code>, <code>/usr/sbin</code> 。</li>
<li><code>/lib</code> 一般存放对于用户和系统来说“必须”的库（二进制文件）。</li>
<li><code>/usr/lib</code> 一般存放的只是对用户和系统来说“不是必需的”库（二进制文件）。</li>
</ul></li>
</ol>

<p>
其他还一些目录例如： <code>/home/user/bin</code>, <code>/home/user/opt</code>, <code>/home/user/etc</code>, <code>/usr/local/etc</code> 等等，其作用都是类似于 <code>/etc</code>, <code>/bin</code> 等目录的，可能只是层次概念不同了，使用 <code>Linux</code> 时间长了，会逐渐体会到其中的含义。
</p>

<p>
当然，我们可以无视这些目录，像使用 <code>Windows</code> 那样自由的，不管啥文件，想往哪存就往哪存，还是那句话，使用 <code>Linux</code> 时间长了，会逐渐体会到其中的含义，到时候也许我们想要乱来都不行了呢。^_^
</p>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">2.2</span> 对文件系统目录的分类标准</h3>
<div class="outline-text-3" id="text-2-2">
<p>
在大多数 <code>Linux</code> 系统上面，我们可以使用一个命令： <code>man hier</code> ，通过这个命令的输出，就知道“根目录”中所子目录的作用了。这个命令含义我不多说了，总之这里的 <code>hier</code> 就是对 <code>Linux</code> 文件系统中各级目录的标准功能，是一个大家都约定俗成了的东西。想要了解每个目录更详细的信息，需要仔细参考 <code>man hier</code> 的输出。下面就是一个比较简短的中文描述的对文件系统目录分类的 <code>FHS</code> 标准，也就是对 <code>man hier</code> 的简单翻译。
</p>
<pre class="example">
NAME 名称
hier - 文件系统描述
 DESCRIPTION 描述
一个典型的Linux系统具以下几个目录结构：
/ 根目录，是所目录树开始的地方。
/bin 此目录下包括了单用户方式及系统启动或修复所用到的所执行程序。
/boot 包括了引导程序的静态文件。此目录下包括了在引导过程中所必需的文件。系统装载程序及配制文件在 /sbin 和 /etc 目录中找到。
/dev 对应物理设备的指定文件或驱动程序。参见mknod(1)。
/dos 如果MS-DOS和Linux共存于一台计算机时，这里通常用于存放DOS 文件系统。
/etc 用于存放本地机的配置文件。一些大型套件，如X11，在 /etc 下它们自己的子目录。系统配置文件可以放在这里或在 /usr/etc。 不过所程序总是在 /etc 目录下查找所需的配置文件，你也可以将这些文件链接到目录 /usr/etc.
/etc/skel 当建立一个新用户账号时，此目录下的文件通常被复制到用户的主目录下。
/etc/X11X11 window system所需的配置文件。
/home 在Linux机器上，用户主目录通常直接或间接地置在此目录下。其结构通常由本地机的管理员来决定。
/lib 此目录下包含系统引导和在根用户执行命令所必需用到的共享库。
/mnt 挂载临时文件系统的挂载点。
/proc 这是提供运行过程和核心文件系统 proc 挂载点。这一”伪”文件系统在以下章节中详细叙述 proc(5)。
/sbin 类似于 /bin 此目录保存了系统引导所需的命令，但这些命令一般使用者不能执行。
/tmp 此目录用于保存临时文件，临时文件在日常维护或在系统启动时无需通知便可删除
/usr 此目录通常用于从一个独立的分区上挂载文件。它应保存共享只读类文件，这样它可以被运行Linux的不同主机挂载。
/usr/X11R6 X-Window系统 Version 11 release 6.
/usr/X11R6/bin X-Windows系统使用的二进制文件；通常是在对更传统的 /usr/bin/X11 中文件的符号连接。
/usr/X11R6/lib 保存与X-Windows系统关数据文件。
/usr/X11R6/lib/X11 此目录保存与运行X-Windows系统关其他文件。通常是对来自 /usr/lib/X11 中文件的符号连接。
/usr/X11R6/include/X11 此目录保存包括使用X11窗口系统进行编译程序所需的文件。通常是对来自 /usr/lib/X11 中文件的符号连接。
/usr/bin 这是执行程序的主要目录，其中的绝大多数为一般使用者使用，除了那些启动系统或修复系统或不是本地安装的程序一般都放在此目录下。
/usr/bin/X11
X11执行文件放置的地方；在Linux系统中，它通常是对 /usr/X11R6/bin. 符号连接表
/usr/dict
此目录保存拼写检查器所使用的词汇表文件。
/usr/doc
此目录下应可以找到那些已安装的软件文件。
/usr/etc
此目录可用来那些存放整个网共享的配置文件。然而那可执行命令指向总是使用参照使用 /etc 目录下的文件。 /etc 目录下连接文件应指向 /usr/etc. 目录下适当的文件。
/usr/include
C程序语言编译使用的Include”包括”文件。
/usr/include/X11
C程序语言编译和X-Windows系统使用的 Include”包括”文件。它通常中指向 /usr/X11R6/include/X11. 符号连接表。
/usr/include/asm
申明汇编函数的Include”包括”文件，它通常是指向 /usr/src/linux/include/asm 目录的符号连接
/usr/include/linux
包含系统变更的信息通常是指向 /usr/src/linux/include/linux 目录的符号连接表，来获得操作系统特定信息。(注：使用者应在此自行包含那些保证自己开发的程序正常运行所需的libc 函数库。不管怎样，Linux核心系统不是设计用来执行直接运行用户程序的，它并不知道用户程序需要使用哪个版本的libc库 。如果你随意将 /usr/include/asm 和 /usr/include/linux 指向一个系统核心，系统很可能崩溃。Debian系统不这么做。它使用 libc*-dev运行包中提供的核心系统标识，以保证启动所正确的文件。)
 /usr/include/g++
GNU C++编译程序所使用的Include”包括”文件。
/usr/lib
目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件案。一些复杂的程序可能在此占用整个子目录。
/usr/lib/X11
存放X系统数据文件及系统配置文件的地方。 Linux中通常是指向 /usr/X11R6/lib/X11 目录的符号连接表。
/usr/lib/gcc-lib
GNU C 编译程序所使用的可执行文件案和”包括”文件。 gcc(1).
/usr/lib/groff
GNU groff 文件格式系统所使用的文件。
/usr/lib/uucp
uucp(1) 所使用的文件。
/usr/lib/zoneinfo
关时区信息文件文件。
/usr/local
安装在本地执行程序的地方。
/usr/local/bin
在此地放置本地执行程序的二进制文件。
/usr/local/doc
放置本地文件。
/usr/local/etc
安装在本地程序的配置文件。
/usr/local/lib
安装在本地程序的库文件。
/usr/local/info
安装在本地程序关信息文件。
/usr/local/man
安装在本地程序使用手册。
/usr/local/sbin
安装在本地的系统管理程序。
/usr/local/src
安装在本地程序的原始码。
/usr/man
手册页通常放在此目录，或相关子目录下。
/usr/man//man[1-9]
此目录在指定的地方以原始码形式存放手册页。系统在所的手册页中使用自己独特的语言及代码集，可能会省略 substring 子字符串。
/usr/sbin
此目录保存系统管理程序的二进制码，这些文件不是系统启动或文件系统挂载 /usr 目录或修复系统所必需的。
/usr/share
在此目录下不同的子目录中保存了同一个操作系统在不同构架下工作时特定应用程序的共享数据。使用者可以找到通常放在 /usr/doc 或 /usr/lib 或 /usr/man 目录下的这些数据。
/usr/src
系统不同组成部份的源文件包括参考数据报。不要将你自己与项目关的文件放这里，因为在安装软件外，/usr下的文件属性除通常设为只读。
/usr/src/linux
系统核心资源通常拆包安装于此。这是系统中重要的一环，因为 /usr/include/linux 符号连接表指向此目录。你应当使用其他目录来来编译建立新核心。
/usr/tmp
此目录不再使用了。它应指向目录 /var/tmp。 这个链接只是出于系统兼容的目的，一般不再使用。
/var
此目录下文件的大小可能会改变，如缓冲文件可日志文件。
/var/adm
此目录为 /var/log 甩替代，通常是指向 /var/log 的符号连接表。
/var/backups
此目录用来存放重要系统文件的后备文件
/var/catman/cat[1-9] or /var/cache/man/cat[1-9]
此目录存储根据手册分类预先格式化的参考手册页。(这些参考手册页是相互独立的)
/var/lock
此目录存储锁定文件。依据命名习惯，设备锁定文件是 LCKxxxxx xxxxx与在文件系统中该设备名相同，使用的格式是HDU UUCP锁定文件，例如包含进程标识PID的锁定文件是一个10字节的ASCII格式的数字，后面跟一个换行符。
/var/log
各种日志文件。
/var/preserve
这是 vi(1) 存放正在编辑中的文件，以便以后可以恢复。
/var/run
运行时的变量文件，如存放进程标识和登入使用者信息的文件。 (utmp) 此目录下文件在系统启动时被自动清除。
/var/spool
各种程序产生的缓冲或排除等待的文件
/var/spool/at
at(1) 的作业存缓区
/var/spool/cron
cron(1) 的作业存缓区
/var/spool/lpd
打印缓存文件。
/var/spool/mail
使用者邮箱。
/var/spool/smail
存放 smail(1) 邮件发送程序的缓冲文件。
/var/spool/news
新闻子系统的缓冲目录
/var/spool/uucp
uucp(1) 的缓冲文件
/var/tmp
类似 /tmp, 此目录保存未指定持续时间的临时文件。
</pre>
</div>
</div>
</div>

                    </div>
                </article>                        
                
                <!--{% include duoshuo_comment.ext %}-->
            </td>
        </tr>
        <tr>
            <td id="td_page_footer" colspan="6">
    <footer>
        &copy 2015
    </footer>
    <a id="bottom"></a>
</td>
        </tr>
    </tbody>
</table>
    </main>
  </body>
</html>