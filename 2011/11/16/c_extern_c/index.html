<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>
    关于 =C++= 中的 extern &#34;C&#34;
</title>
<!--javascript-->
<!--script type="text/javascript" src="/script.js"></script-->
<script src="../../../../lib/jquery-1.11.3.min.js"></script>
<script src="../../../../lib/typelighter.js"></script>
<script src="../../../../js/common.js"></script>
<script src="../../../../js/nav.js"></script>

<!--css-->
<!--link rel="stylesheet" href="/style.css" type="text/css" /-->
<link rel="stylesheet" href="../../../../css/partial/head.css">
<link rel="stylesheet" href="../../../../css/partial/header.css">
<link rel="stylesheet" href="../../../../css/partial/archives.css">
<link rel="stylesheet" href="../../../../css/partial/categories.css">
<link rel="stylesheet" href="../../../../css/partial/home-posts.css">
<link rel="stylesheet" href="../../../../css/partial/page-nav.css">
<link rel="stylesheet" href="../../../../css/partial/tags.css">
<link rel="stylesheet" href="../../../../css/partial/about.css">
<link rel="stylesheet" href="../../../../css/partial/more.css">
<link rel="stylesheet" href="../../../../css/partial/footer.css">
<link rel="stylesheet" href="../../../../css/post.css">
<link rel="stylesheet" href="../../../../css/orgmode/hexo_orgmode_style.css">
  </head>
  <body>
    <main class="main">
      <table class="container">
    <tbody id="tb_container">
        <tr id="tr_navbar">
            <table class="navbar">
	<tbody>
		<tr>
			<th class="navitm">
				<a href="../../../../index.html">主页</a>
			</th>

			<th class="navitm">
				<a href="../../../../categories">分类</a>
				<div id="category_menus" class="second">
					
					<!--合并内部类和自定义类。
    每个分类的数据结构包括：
    id: 分类唯一id
    title: 分类名
    parent: 父分类id
    children:子分类数组
注：
内部类包含一个固定的分类结type="text/javascript"内部根分类设置为categories, title为分类在主题config.yml中有配置（待定）。
后续文章中设置的分类如果不是内部类都会被称作自定义类，可以通过hexo本身引擎检测出来。
最终内部类和自定义类会合并到完整分类(full_categories)中，这样让所有类能用json等通用方式表示，便于移植。

使用举例：
var category_info = getCategoriesInfo();
<x var symbols={}; x> //定义导出变量
<x- include('category_list', {symbols:symbols}) x> //包含该文件
<x var category_info = symbols.getCategoriesInfo(); x> //获取分类信息：包含分类树，以及分类与文章数映射表。
<x- symbols.list_category(category_info.categories, category_info.categories_count) x> //列出分类索引树

注： '<x' 是EJS模板语言的标记比如x为%。
-->

					
					<ul id="full_categories_tree" class="categories_tree categories_level0" type="none"><li id="categories" class="categories_tree_item"><a href="../../../../categories/" class="item_path"><span id="categories_switch" class="tree_switch">▷</span><span id="categories_title" class="item_title">分类</span><span id="categories_count" class="item_count">(61)</span></a><ul id="categories_tree" class="categories_tree categories_level2" type="none"><li id="note" class="categories_tree_item"><a href="../../../../categories/categories/note" class="item_path"><span id="note_switch" class="tree_switch">▷</span><span id="note_title" class="item_title">记事</span><span id="note_count" class="item_count">(8)</span></a><ul id="note_tree" class="categories_tree categories_level3" type="none"><li id="remind" class="categories_tree_item"><a href="../../../../categories/categories/note/remind" class="item_path"><span id="remind_switch" class="tree_switch">○</span><span id="remind_title" class="item_title">备忘</span><span id="remind_count" class="item_count">(0)</span></a></li><li id="plan" class="categories_tree_item"><a href="../../../../categories/categories/note/plan" class="item_path"><span id="plan_switch" class="tree_switch">○</span><span id="plan_title" class="item_title">计划</span><span id="plan_count" class="item_count">(0)</span></a></li>|</ul></li><li id="study" class="categories_tree_item"><a href="../../../../categories/categories/study" class="item_path"><span id="study_switch" class="tree_switch">▷</span><span id="study_title" class="item_title">学习</span><span id="study_count" class="item_count">(6)</span></a><ul id="study_tree" class="categories_tree categories_level3" type="none"><li id="problem" class="categories_tree_item"><a href="../../../../categories/categories/study/problem" class="item_path"><span id="problem_switch" class="tree_switch">○</span><span id="problem_title" class="item_title">问题</span><span id="problem_count" class="item_count">(0)</span></a></li><li id="git" class="categories_tree_item"><a href="../../../../categories/categories/study/git" class="item_path"><span id="git_switch" class="tree_switch">○</span><span id="git_title" class="item_title">git</span><span id="git_count" class="item_count">(1)</span></a></li><li id="os" class="categories_tree_item"><a href="../../../../categories/categories/study/os" class="item_path"><span id="os_switch" class="tree_switch">○</span><span id="os_title" class="item_title">操作系统</span><span id="os_count" class="item_count">(1)</span></a></li><li id="books" class="categories_tree_item"><a href="../../../../categories/categories/study/books" class="item_path"><span id="books_switch" class="tree_switch">▷</span><span id="books_title" class="item_title">books</span><span id="books_count" class="item_count">(0)</span></a><ul id="books_tree" class="categories_tree categories_level4" type="none"><li id="apue" class="categories_tree_item"><a href="../../../../categories/categories/study/books/apue" class="item_path"><span id="apue_switch" class="tree_switch">○</span><span id="apue_title" class="item_title">APUE</span><span id="apue_count" class="item_count">(0)</span></a></li>|</ul></li><li id="linux" class="categories_tree_item"><a href="../../../../categories/categories/study/linux" class="item_path"><span id="linux_switch" class="tree_switch">▷</span><span id="linux_title" class="item_title">linux</span><span id="linux_count" class="item_count">(6)</span></a><ul id="linux_tree" class="categories_tree categories_level4" type="none"><li id="misc" class="categories_tree_item"><a href="../../../../categories/categories/study/linux/misc" class="item_path"><span id="misc_switch" class="tree_switch">○</span><span id="misc_title" class="item_title">杂乱</span><span id="misc_count" class="item_count">(3)</span></a></li><li id="command" class="categories_tree_item"><a href="../../../../categories/categories/study/linux/command" class="item_path"><span id="command_switch" class="tree_switch">○</span><span id="command_title" class="item_title">命令</span><span id="command_count" class="item_count">(19)</span></a></li>|</ul></li><li id="jekyll" class="categories_tree_item"><a href="../../../../categories/categories/study/jekyll" class="item_path"><span id="jekyll_switch" class="tree_switch">○</span><span id="jekyll_title" class="item_title">jekyll</span><span id="jekyll_count" class="item_count">(0)</span></a></li><li id="kits" class="categories_tree_item"><a href="../../../../categories/categories/study/kits" class="item_path"><span id="kits_switch" class="tree_switch">○</span><span id="kits_title" class="item_title">工具</span><span id="kits_count" class="item_count">(1)</span></a></li><li id="emacs" class="categories_tree_item"><a href="../../../../categories/categories/study/emacs" class="item_path"><span id="emacs_switch" class="tree_switch">○</span><span id="emacs_title" class="item_title">emacs</span><span id="emacs_count" class="item_count">(2)</span></a></li><li id="vim" class="categories_tree_item"><a href="../../../../categories/categories/study/vim" class="item_path"><span id="vim_switch" class="tree_switch">○</span><span id="vim_title" class="item_title">vim</span><span id="vim_count" class="item_count">(0)</span></a></li>|</ul></li><li id="work" class="categories_tree_item"><a href="../../../../categories/categories/work" class="item_path"><span id="work_switch" class="tree_switch">▷</span><span id="work_title" class="item_title">工作</span><span id="work_count" class="item_count">(0)</span></a><ul id="work_tree" class="categories_tree categories_level3" type="none"><li id="progress" class="categories_tree_item"><a href="../../../../categories/categories/work/progress" class="item_path"><span id="progress_switch" class="tree_switch">○</span><span id="progress_title" class="item_title">进度</span><span id="progress_count" class="item_count">(0)</span></a></li>|</ul></li><li id="life" class="categories_tree_item"><a href="../../../../categories/categories/life" class="item_path"><span id="life_switch" class="tree_switch">▷</span><span id="life_title" class="item_title">生活</span><span id="life_count" class="item_count">(0)</span></a><ul id="life_tree" class="categories_tree categories_level3" type="none"><li id="experience" class="categories_tree_item"><a href="../../../../categories/categories/life/experience" class="item_path"><span id="experience_switch" class="tree_switch">○</span><span id="experience_title" class="item_title">经验</span><span id="experience_count" class="item_count">(0)</span></a></li><li id="tips" class="categories_tree_item"><a href="../../../../categories/categories/life/tips" class="item_path"><span id="tips_switch" class="tree_switch">○</span><span id="tips_title" class="item_title">技巧</span><span id="tips_count" class="item_count">(0)</span></a></li>|</ul></li><li id="others" class="categories_tree_item"><a href="../../../../categories/categories/others" class="item_path"><span id="others_switch" class="tree_switch">▷</span><span id="others_title" class="item_title">其它</span><span id="others_count" class="item_count">(4)</span></a><ul id="others_tree" class="categories_tree categories_level3" type="none"><li id="rambles" class="categories_tree_item"><a href="../../../../categories/categories/others/rambles" class="item_path"><span id="rambles_switch" class="tree_switch">○</span><span id="rambles_title" class="item_title">随笔</span><span id="rambles_count" class="item_count">(0)</span></a></li><li id="temp" class="categories_tree_item"><a href="../../../../categories/categories/others/temp" class="item_path"><span id="temp_switch" class="tree_switch">○</span><span id="temp_title" class="item_title">临时</span><span id="temp_count" class="item_count">(0)</span></a></li><li id="test" class="categories_tree_item"><a href="../../../../categories/categories/others/test" class="item_path"><span id="test_switch" class="tree_switch">○</span><span id="test_title" class="item_title">测试</span><span id="test_count" class="item_count">(0)</span></a></li>|</ul></li>|</ul></li></ul>
				</div>
			</th>

			<th class="navblank"></th>

			<th class="navitm">
				<a href="../../../../tags">标签</a>
				<div id="tag_menus" class="second">
					<ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/gtd-next/">gtd_next</a><span class="tag-list-count">1</span></li></ul>
				</div>
			</th>

			<th class="navitm">
				<a href="../../../../archives">归档</a>
			</th>

			<th class="navblank"></th>

			<th class="navitm">
				<a href="../../../../more">更多</a>
			</th>

			<th class="navitm">
				<a href="../../../../about">关于</a>
			</th>

			<th class="navblank" style="width:25%;"></th>

			<th class="navitm" style="margin:0; padding:0;border:none;">
				<form method="get" id="searchform" action="/search.html" style="margin:0;padding:0;height:100%;">
					<span style="color:#00FF00;">Q</span>
					<span style="border-style:solid; border-width:1px; border-color:#00FF00;
		  		border-top:0px; border-left:0px;border-right:0px; 
				margin:0;padding:0;height:100%;">
						<input value="Search by title (canbe regex)..." name="s" class="s" onfocus="if (this.value == 'Search by title (canbe regex)...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search by title (canbe regex)...';}" style="margin:0;padding:0;height:100%;border:none;background: #000000; color:#00A600;" type="text">
					</span>
					<!--input type="submit" value="Q" style="width:20%;"-->
				</form>
			</th>

			<th class="navblank"></th>

			<th class="navblank"></th>

			<a href="#" id="topbtn">⇑</a>

			<a href="#bottom" id="bottombtn">⇓</a>
			<!--⇐⇑⇒⇓-->
		</tr><tr>
	</tr></tbody>
</table>
        </tr>
        <tr>
            <td id="td_page_header" colspan="6" valign="top" align="right" style="width:100%;">
        <header style="text-align: center;">
               <a href="/" title="Menu.Home">
               <h1>QuietHeart's Site</h1>
               </a>
        </header>
</td>    
        </tr>
        <tr>
            <td id="td_posts" colspan="6" valign="top">
                <h1 id="header1" style="text-align: center;">
                    关于 =C++= 中的 extern &#34;C&#34;
                </h1>
                <hr id="title_line">
                <article>
                    <div>
                        
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. 简介</a></li>
<li><a href="#orgheadline2">2. 问题的引出</a>
<ul>
<li><a href="#orgheadline3">2.1. 某企业曾经给出如下的一道面试题</a></li>
<li><a href="#orgheadline4">2.2. 问题分析</a></li>
</ul>
</li>
<li><a href="#orgheadline5">3. 关于 extern "C"</a>
<ul>
<li><a href="#orgheadline6">3.1. 被 extern "C" 限定的函数或变量是 <code>extern</code> 类型的。</a></li>
<li><a href="#orgheadline7">3.2. 被 extern "C" 修饰的变量和函数是按照 <code>C</code> 语言方式编译和连接的。</a>
<ul>
<li><a href="#orgheadline8">3.2.1. 首先看看 <code>C++</code> 中，在未加 extern "C" 声明时，对类似 <code>C</code> 的函数是怎样编译的。</a></li>
<li><a href="#orgheadline9">3.2.2. 其次，看看在未加 extern "C" 声明时，是如何连接的。</a></li>
<li><a href="#orgheadline10">3.2.3. 再者，看看加 extern "C" 声明后的编译和连接方式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline11">4. 用法举例</a>
<ul>
<li><a href="#orgheadline12">4.1. <code>C++</code> 引用 <code>C</code> 函数的具体例子</a></li>
<li><a href="#orgheadline13">4.2. <code>C</code> 引用 <code>C++</code> 函数的具体例子</a></li>
<li><a href="#orgheadline14">4.3. 对 <code>__BEGIN_DECLS</code>  和  <code>__END_DECLS</code>  的理解</a></li>
</ul>
</li>
<li><a href="#orgheadline15">5. 总结</a>
<ul>
<li><a href="#orgheadline16">5.1. extern "C" 只是 <code>C++</code> 的关键字，不是 <code>C</code> 的</a></li>
<li><a href="#orgheadline17">5.2. 被 extern "C" 修饰的目标一般是对一个全局C或者 <code>C++</code> 函数的声明</a></li>
<li><a href="#orgheadline18">5.3. extern "C" 这个关键字声明的真实目的，就是实现 <code>C++</code> 与C及其它语言的混合编程</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> 简介</h2>
<div class="outline-text-2" id="text-1">
<p>
<code>C++</code> 语言的创建初衷是 "a better C"，但是这并不意味着 <code>C++</code> 中类似 <code>C</code> 语言的全局变量和函数所采用的编译和连接方式与 <code>C</code> 语言完全相同。作为一种欲与 <code>C</code> 兼容的语言， <code>C++</code> 保留了一部分过程式语言的特点（被世人称为"不彻底地面向对象"），因而它可以定义不属于任何类的全局变量和函数。但是， <code>C++</code> 毕竟是一种面向对象的程序设计语言，为了支持函数的重载， <code>C++</code> 对全局函数的处理方式与 <code>C</code> 有明显的不同。
</p>

<p>
本文将介绍 <code>C++</code> 中如何通过 extern "C" 关键字支持 <code>C</code> 语言。 
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">2</span> 问题的引出</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">2.1</span> 某企业曾经给出如下的一道面试题</h3>
<div class="outline-text-3" id="text-2-1">
<p>
为什么标准头文件都有类似以下的结构？
</p>
<div class="org-src-container">

<pre class="src src-C++">//incvxworks.h
#ifndef __INCvxWorksh
#define __INCvxWorksh

#ifdef __cplusplus
extern "C" {
#endif

    /*...*/

#ifdef __cplusplus
}
#endif

#endif /* __INCvxWorksh */
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">2.2</span> 问题分析</h3>
<div class="outline-text-3" id="text-2-2">
<p>
对于上面问题，显然，头文件中的编译宏 <code>#ifndef __INCvxWorksh</code> 、 <code>#define __INCvxWorksh</code> 、 <code>#endif</code> 的作用是防止该头文件被重复引用。
</p>

<p>
那么，
</p>
<div class="org-src-container">

<pre class="src src-C++">#ifdef __cplusplus
extern "C" {
#endif
和
#ifdef __cplusplus
}
#endif
</pre>
</div>
<p>
的作用又是什么呢？我们将在后面对此进行详细说明。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5"><span class="section-number-2">3</span> 关于 extern "C"</h2>
<div class="outline-text-2" id="text-3">
<p>
前面的题目中的 <code>__cplusplus</code> 宏，是用来识别编译器的，也就是说，将当前代码编译的时候，是否将代码作为 <code>C++</code> 进行编译。如果是，则定义了 <code>__cplusplus</code> 宏。更多内容，这里就不详细说明了。
</p>

<p>
而题目中的 extern "C" 包含双重含义，从字面上即可得到：首先，被它修饰的目标是 <code>extern</code> 的；其次，被它修饰的目标是 <code>C</code> 的。
</p>

<p>
具体如下：
</p>
</div>
<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6"><span class="section-number-3">3.1</span> 被 extern "C" 限定的函数或变量是 <code>extern</code> 类型的。</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<code>extern</code> 是 <code>C/C++</code> 语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。
</p>

<p>
注意，语句 <code>extern int a;</code> 仅仅是对变量的声明，其并不是在定义变量 <code>a</code> ，声明变量并未为 <code>a</code> 分配内存空间。定义语句形式为 <code>int a;</code> ，变量 <code>a</code> 在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。
</p>

<p>
在引用全局变量和函数之前，必须要有这个变量或者函数的声明（或者定义）。通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字 <code>extern</code> 声明。例如，如果模块 <code>B</code> 欲引用该模块 <code>A</code> 中定义的全局变量和函数时只需包含模块 <code>A</code> 的头文件即可。这样，模块B中调用模块 <code>A</code> 中的函数时，在编译阶段，模块 <code>B</code> 虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块 <code>A</code> 编译生成的目标代码中找到此函数。
</p>

<p>
与 <code>extern</code> 对应的关键字是 <code>static</code> ，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被 extern "C" 修饰。
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7"><span class="section-number-3">3.2</span> 被 extern "C" 修饰的变量和函数是按照 <code>C</code> 语言方式编译和连接的。</h3>
<div class="outline-text-3" id="text-3-2">
</div><div id="outline-container-orgheadline8" class="outline-4">
<h4 id="orgheadline8"><span class="section-number-4">3.2.1</span> 首先看看 <code>C++</code> 中，在未加 extern "C" 声明时，对类似 <code>C</code> 的函数是怎样编译的。</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
作为一种面向对象的语言， <code>C++</code> 支持函数重载，而过程式语言 <code>C</code> 则不支持。所以，函数被 <code>C++</code> 编译后在符号库中的名字与 <code>C</code> 语言的有所不同。例如，假设某个函数的原型为：
</p>
<div class="org-src-container">

<pre class="src src-C">void foo( int x, int y );
</pre>
</div>

<p>
该函数被 <code>C</code> 编译器编译后在符号库中的名字为 <code>_foo</code> ，而 <code>C++</code> 编译器则会产生像 <code>_foo_int_int</code> 之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为 <code>mangled name</code> ）。 <code>_foo_int_int</code> 这样的名字包含了函数名、函数参数数量及类型信息， <code>C++</code> 就是靠这种机制来实现函数重载的。例如，在 <code>C++</code> 中，函数 <code>void foo( int x, int y )</code> 与 <code>void foo( int x, float y )</code> 编译生成的符号是不相同的，后者为 <code>_foo_int_float</code> 。
</p>

<p>
同样地， <code>C++</code> 中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以 <code>.</code> 来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。
</p>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9"><span class="section-number-4">3.2.2</span> 其次，看看在未加 extern "C" 声明时，是如何连接的。</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
假设在 <code>C++</code> 中，模块 <code>A</code> 的头文件如下：
</p>
<div class="org-src-container">

<pre class="src src-C++">//模块A头文件　moduleA.h
#ifndef MODULE_A_H
#define MODULE_A_H
int foo( int x, int y );
#endif
</pre>
</div>

<p>
在模块 <code>B</code> 中引用该函数：
</p>
<div class="org-src-container">

<pre class="src src-C++">// 模块B实现文件　moduleB.cpp
#include "moduleA.h"
foo(2,3);
</pre>
</div>

<p>
实际上，在连接阶段，连接器会从模块 <code>A</code> 生成的目标文件 <code>moduleA.obj</code> 中寻找 <code>_foo_int_int</code> 这样的符号！
</p>

<p>
对于上面例子，如果 <code>B</code> 模块是 <code>C</code> 程序，而A模块是 <code>C++</code> 库头文件的话，会导致链接错误；同理，如果B模块是 <code>C++</code> 程序，而A模块是C库的头文件也会导致错误。
</p>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-4">
<h4 id="orgheadline10"><span class="section-number-4">3.2.3</span> 再者，看看加 extern "C" 声明后的编译和连接方式</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
加 extern "C" 声明后，模块 <code>A</code> 的头文件变为：
</p>
<div class="org-src-container">

<pre class="src src-C++">// 模块A头文件　moduleA.h
#ifndef MODULE_A_H
#define MODULE_A_H
extern "C" int foo( int x, int y );
#endif
</pre>
</div>
<p>
在模块 <code>B</code> 的实现文件中仍然调用 <code>foo( 2,3 )</code> ，其结果，将会是 <code>C</code> 语言的编译连接方式：模块 <code>A</code> 编译生成 <code>foo</code> 的目标代码时，没有对其名字进行特殊处理，采用了 <code>C</code> 语言的方式；连接器在为模块 <code>B</code> 的目标代码寻找 <code>foo(2,3)</code> 调用时，寻找的是未经修改的符号名 <code>_foo</code> 。
</p>

<p>
如果在模块 <code>A</code> 中函数声明了 <code>foo</code> 为 extern "C" 类型，而模块 <code>B</code> 中包含的是 <code>extern int foo( int x, int y )</code> ，则模块 <code>B</code> 找不到模块 <code>A</code> 中的函数(因为这样的声明没有使用 extern "C" 指明采用C语言的编译链接方式)；反之亦然。
</p>

<p>
所以，综上可知， extern "C" 这个声明的真实目的，就是实现 <code>C++</code> 与 <code>C</code> 及其它语言的混合编程。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-2">
<h2 id="orgheadline11"><span class="section-number-2">4</span> 用法举例</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">4.1</span> <code>C++</code> 引用 <code>C</code> 函数的具体例子</h3>
<div class="outline-text-3" id="text-4-1">
<p>
在 <code>C++</code> 中引用 <code>C</code> 语言中的函数和变量，在包含 <code>C</code> 语言头文件（假设为 <code>cExample.h</code> ）时，需进行下列处理：
</p>
<div class="org-src-container">

<pre class="src src-C++">extern "C"
{
    #include "cExample.h"
}
</pre>
</div>
<p>
因为， <code>C</code> 库的编译当然是用 <code>C</code> 的方式生成的，其库中的函数标号一般也是类似前面所说的 <code>_foo</code> 之类的形式，没有任何参数信息，所以当然在 <code>C++</code> 中，要指定使用 extern "C" ，进行 <code>C</code> 方式的声明（如果不指定，那么 <code>C++</code> 中的默认声明方式当然是 <code>C++</code> 方式的，也就是编译器会产生 <code>_foo_int_int</code> 之类包含参数信息的、 <code>C++</code> 形式的函数标号，这样的函数标号在已经编译好了的、可以直接引用的 <code>C</code> 库中当然没有）。通过头文件对函数进行声明，再包含头文件，就能引用到头文件中声明的函数(因为函数的实现在库中呢，所以只声明，然后链接就能用了)。
</p>

<p>
而在 <code>C</code> 语言中，对其外部函数只能指定为 <code>extern</code> 类型，因为 <code>C</code> 语言中不支持 extern "C" 声明，在 <code>.c</code> 文件中包含了 extern "C" 时，当然会出现编译语法错误。
</p>

<p>
下面是一个具体代码：
</p>
<div class="org-src-container">

<pre class="src src-C">/* c语言头文件：cExample.h */
#ifndef C_EXAMPLE_H
#define C_EXAMPLE_H
extern int add(int x,int y);
#endif
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C">/* c语言实现文件：cExample.c */
#include "cExample.h"
int add( int x, int y )
{
    return x + y;
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C++">// c++实现文件，调用add：cppFile.cpp
extern "C"
{
    #include "cExample.h"
}
int main(int argc, char* argv[])
{
    add(2,3);
    return 0;
}
</pre>
</div>

<p>
可见，如果 <code>C++</code> 调用一个 <code>C</code> 语言编写的 <code>.DLL</code> 时，在包含 <code>.DLL</code> 的头文件或声明接口函数时，应加 <code>extern "C" {　}</code> 。这个时候，其实 extern "C" 是在告诉 <code>C++</code> ，链接 <code>C</code> 库的时候，采用 <code>C</code> 的方式进行链接（即寻找类似 <code>_foo</code> 的没有参数信息的标号，而不是默认的 <code>_foo_int_int</code> 这样包含了参数信息的 <code>C++</code> 标号了）。
</p>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">4.2</span> <code>C</code> 引用 <code>C++</code> 函数的具体例子</h3>
<div class="outline-text-3" id="text-4-2">
<p>
在C中引用 <code>C++</code> 语言中的函数和变量时， <code>C++</code> 的头文件需添加 extern "C" ，但是在 <code>C</code> 语言中不能直接引用声明了 extern "C" 的该头文件(因为C语言不支持 extern "C" 关键字，所以会报编译错误)，应该仅在 <code>C</code> 文件中用 <code>extern</code> 声明 <code>C++</code> 中定义的 extern "C" 函数(就是 <code>C++</code> 中用 extern "C" 声明的函数，在 <code>C</code> 中用 <code>extern</code> 来声明一下，这样 <code>C</code> 就能引用 <code>C++</code> 的函数了，但是 <code>C</code> 中是不用用 extern "C" 的)。
</p>

<p>
下面是一个具体代码：
</p>
<div class="org-src-container">

<pre class="src src-C++">//C++头文件 cppExample.h
#ifndef CPP_EXAMPLE_H
#define CPP_EXAMPLE_H
extern "C" int add( int x, int y );
#endif
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C++">//C++实现文件 cppExample.cpp
#include "cppExample.h"
int add( int x, int y )
{
    return x + y;
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C">/* C实现文件 cFile.c
/* 这样会编译出错：#include "cExample.h" */
extern int add( int x, int y );

int main( int argc, char* argv[] )
{
    add( 2, 3 );   
    return 0;
}
</pre>
</div>

<p>
上面例子， <code>C</code> 实现文件 <code>cFile.c</code> 不能直接用 <code>#include "cExample.h"= 因为 =C</code> 语言不支持 extern "C" 关键字。这个时候，而在 <code>cppExample.h</code> 中使用 extern "C" 修饰的目的是为了让 <code>C++</code> 编译时候能够生成 <code>C</code> 形式的符号(类似 <code>_foo</code> 不含参数的形式)，然后将其添加到对应的 <code>C++</code> 实现库中，以便被 <code>C</code> 程序链接到。
</p>
</div>
</div>


<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">4.3</span> 对 <code>__BEGIN_DECLS</code>  和  <code>__END_DECLS</code>  的理解</h3>
<div class="outline-text-3" id="text-4-3">
<p>
在 <code>C</code> 语言代码中头文件中，经常看到充斥着下面的代码片段：
</p>
<pre class="example">
1. __BEGIN_DECLS
2. .....
3. .....
4. __END_DECLS
</pre>

<p>
其实，这些宏一般都是在标准库头文件中定义好了的，例如我当前机器的 <code>sys/cdefs.h</code> 中大致定义如下：
</p>
<pre class="example">
1. #if defined(__cplusplus)
2.        #define __BEGIN_DECLS extern "C" {
3.        #define __END_DECLS }
4.        #else
5.        #define __BEGIN_DECLS
6.        #define __END_DECLS
7. #endif
</pre>

<p>
这目的当然是扩充 <code>C</code> 语言在编译的时候，按照 <code>C++</code> 编译器进行统一处理，使得 <code>C++</code> 代码能够调用 <code>C</code> 编译生成的中间代码。
由于 <code>C</code> 语言的头文件可能被不同类型的编译器读取，因此写 <code>C</code> 语言的头文件必须慎重。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-2">
<h2 id="orgheadline15"><span class="section-number-2">5</span> 总结</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">5.1</span> extern "C" 只是 <code>C++</code> 的关键字，不是 <code>C</code> 的</h3>
<div class="outline-text-3" id="text-5-1">
<p>
所以，如果在 <code>C</code> 程序中引入了 extern "C" 会导致编译错误。
</p>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17"><span class="section-number-3">5.2</span> 被 extern "C" 修饰的目标一般是对一个全局C或者 <code>C++</code> 函数的声明</h3>
<div class="outline-text-3" id="text-5-2">
<p>
从源码上看 extern "C" 一般对头文件中函数声明进行修饰。 <code>C</code> 和 <code>cpp</code> 中头文件函数声明的形式都是一样的（因为两者语法基本一样），对应声明的实现却可能由于语言特性而不同了( <code>C</code> 库和 <code>C++</code> 库里面当然会不同)。
</p>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-3">
<h3 id="orgheadline18"><span class="section-number-3">5.3</span> extern "C" 这个关键字声明的真实目的，就是实现 <code>C++</code> 与C及其它语言的混合编程</h3>
<div class="outline-text-3" id="text-5-3">
<p>
一旦被 extern "C" 修饰之后，它便以 <code>C</code> 的方式工作（编译阶段：以C的方式编译，链接阶段：寻找C方式编译生成的符号）， <code>C</code> 中引用 <code>C++</code> 库的函数，或 <code>C++</code> 中引用 <code>C</code> 库的函数，都可以通过这个方式(即在C++文件中用extern "C" 声明，实现兼容。
</p>

<p>
以上，是对 extern "C" 这个关键字的理解和总结，如果具体问题想要讨论或者发现有何遗漏之处，可以与我联系。谢谢！
</p>
</div>
</div>
</div>

                    </div>
                </article>                        
                
                <!--{% include duoshuo_comment.ext %}-->
            </td>
        </tr>
        <tr>
            <td id="td_page_footer" colspan="6">
    <footer>
        &copy 2015
    </footer>
    <a id="bottom"></a>
</td>
        </tr>
    </tbody>
</table>
    </main>
  </body>
</html>