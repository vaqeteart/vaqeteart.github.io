<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<title>
    关于C/C++中的预处理
</title>
<!--javascript-->
<!--script type="text/javascript" src="/script.js"></script-->
<script src="../../../../lib/jquery-1.11.3.min.js"></script>
<script src="../../../../lib/typelighter.js"></script>
<script src="../../../../js/common.js"></script>
<script src="../../../../js/nav.js"></script>

<!--css-->
<!--link rel="stylesheet" href="/style.css" type="text/css" /-->
<link rel="stylesheet" href="../../../../css/partial/head.css">
<link rel="stylesheet" href="../../../../css/partial/header.css">
<link rel="stylesheet" href="../../../../css/partial/archives.css">
<link rel="stylesheet" href="../../../../css/partial/categories.css">
<link rel="stylesheet" href="../../../../css/partial/home-posts.css">
<link rel="stylesheet" href="../../../../css/partial/page-nav.css">
<link rel="stylesheet" href="../../../../css/partial/tags.css">
<link rel="stylesheet" href="../../../../css/partial/about.css">
<link rel="stylesheet" href="../../../../css/partial/more.css">
<link rel="stylesheet" href="../../../../css/partial/footer.css">
<link rel="stylesheet" href="../../../../css/post.css">
<link rel="stylesheet" href="../../../../css/orgmode/hexo_orgmode_style.css">
  </head>
  <body>
    <main class="main">
      <table class="container">
    <tbody id="tb_container">
        <tr id="tr_navbar">
            <table class="navbar">
	<tbody>
		<tr>
			<th class="navitm">
				<a href="../../../../index.html">主页</a>
			</th>

			<th class="navitm">
				<a href="../../../../categories">分类</a>
				<div id="category_menus" class="second">
					
					<!--合并内部类和自定义类。
    每个分类的数据结构包括：
    id: 分类唯一id
    title: 分类名
    parent: 父分类id
    children:子分类数组
注：
内部类包含一个固定的分类结type="text/javascript"内部根分类设置为categories, title为分类在主题config.yml中有配置（待定）。
后续文章中设置的分类如果不是内部类都会被称作自定义类，可以通过hexo本身引擎检测出来。
最终内部类和自定义类会合并到完整分类(full_categories)中，这样让所有类能用json等通用方式表示，便于移植。

使用举例：
var category_info = getCategoriesInfo();
<x var symbols={}; x> //定义导出变量
<x- include('category_list', {symbols:symbols}) x> //包含该文件
<x var category_info = symbols.getCategoriesInfo(); x> //获取分类信息：包含分类树，以及分类与文章数映射表。
<x- symbols.list_category(category_info.categories, category_info.categories_count) x> //列出分类索引树

注： '<x' 是EJS模板语言的标记比如x为%。
-->

					
					<ul id="full_categories_tree" class="categories_tree categories_level0" type="none"><li id="categories" class="categories_tree_item"><a href="../../../../categories/" class="item_path"><span id="categories_switch" class="tree_switch">▷</span><span id="categories_title" class="item_title">分类</span><span id="categories_count" class="item_count">(67)</span></a><ul id="categories_tree" class="categories_tree categories_level2" type="none"><li id="note" class="categories_tree_item"><a href="../../../../categories/categories/note" class="item_path"><span id="note_switch" class="tree_switch">▷</span><span id="note_title" class="item_title">记事</span><span id="note_count" class="item_count">(8)</span></a><ul id="note_tree" class="categories_tree categories_level3" type="none"><li id="remind" class="categories_tree_item"><a href="../../../../categories/categories/note/remind" class="item_path"><span id="remind_switch" class="tree_switch">○</span><span id="remind_title" class="item_title">备忘</span><span id="remind_count" class="item_count">(0)</span></a></li><li id="plan" class="categories_tree_item"><a href="../../../../categories/categories/note/plan" class="item_path"><span id="plan_switch" class="tree_switch">○</span><span id="plan_title" class="item_title">计划</span><span id="plan_count" class="item_count">(0)</span></a></li>|</ul></li><li id="study" class="categories_tree_item"><a href="../../../../categories/categories/study" class="item_path"><span id="study_switch" class="tree_switch">▷</span><span id="study_title" class="item_title">学习</span><span id="study_count" class="item_count">(7)</span></a><ul id="study_tree" class="categories_tree categories_level3" type="none"><li id="problem" class="categories_tree_item"><a href="../../../../categories/categories/study/problem" class="item_path"><span id="problem_switch" class="tree_switch">○</span><span id="problem_title" class="item_title">问题</span><span id="problem_count" class="item_count">(0)</span></a></li><li id="git" class="categories_tree_item"><a href="../../../../categories/categories/study/git" class="item_path"><span id="git_switch" class="tree_switch">○</span><span id="git_title" class="item_title">git</span><span id="git_count" class="item_count">(1)</span></a></li><li id="os" class="categories_tree_item"><a href="../../../../categories/categories/study/os" class="item_path"><span id="os_switch" class="tree_switch">○</span><span id="os_title" class="item_title">操作系统</span><span id="os_count" class="item_count">(1)</span></a></li><li id="books" class="categories_tree_item"><a href="../../../../categories/categories/study/books" class="item_path"><span id="books_switch" class="tree_switch">▷</span><span id="books_title" class="item_title">books</span><span id="books_count" class="item_count">(0)</span></a><ul id="books_tree" class="categories_tree categories_level4" type="none"><li id="apue" class="categories_tree_item"><a href="../../../../categories/categories/study/books/apue" class="item_path"><span id="apue_switch" class="tree_switch">○</span><span id="apue_title" class="item_title">APUE</span><span id="apue_count" class="item_count">(0)</span></a></li>|</ul></li><li id="linux" class="categories_tree_item"><a href="../../../../categories/categories/study/linux" class="item_path"><span id="linux_switch" class="tree_switch">▷</span><span id="linux_title" class="item_title">linux</span><span id="linux_count" class="item_count">(6)</span></a><ul id="linux_tree" class="categories_tree categories_level4" type="none"><li id="misc" class="categories_tree_item"><a href="../../../../categories/categories/study/linux/misc" class="item_path"><span id="misc_switch" class="tree_switch">○</span><span id="misc_title" class="item_title">杂乱</span><span id="misc_count" class="item_count">(3)</span></a></li><li id="command" class="categories_tree_item"><a href="../../../../categories/categories/study/linux/command" class="item_path"><span id="command_switch" class="tree_switch">○</span><span id="command_title" class="item_title">命令</span><span id="command_count" class="item_count">(19)</span></a></li>|</ul></li><li id="jekyll" class="categories_tree_item"><a href="../../../../categories/categories/study/jekyll" class="item_path"><span id="jekyll_switch" class="tree_switch">○</span><span id="jekyll_title" class="item_title">jekyll</span><span id="jekyll_count" class="item_count">(0)</span></a></li><li id="kits" class="categories_tree_item"><a href="../../../../categories/categories/study/kits" class="item_path"><span id="kits_switch" class="tree_switch">○</span><span id="kits_title" class="item_title">工具</span><span id="kits_count" class="item_count">(1)</span></a></li><li id="emacs" class="categories_tree_item"><a href="../../../../categories/categories/study/emacs" class="item_path"><span id="emacs_switch" class="tree_switch">○</span><span id="emacs_title" class="item_title">emacs</span><span id="emacs_count" class="item_count">(2)</span></a></li><li id="vim" class="categories_tree_item"><a href="../../../../categories/categories/study/vim" class="item_path"><span id="vim_switch" class="tree_switch">○</span><span id="vim_title" class="item_title">vim</span><span id="vim_count" class="item_count">(0)</span></a></li>|</ul></li><li id="work" class="categories_tree_item"><a href="../../../../categories/categories/work" class="item_path"><span id="work_switch" class="tree_switch">▷</span><span id="work_title" class="item_title">工作</span><span id="work_count" class="item_count">(0)</span></a><ul id="work_tree" class="categories_tree categories_level3" type="none"><li id="progress" class="categories_tree_item"><a href="../../../../categories/categories/work/progress" class="item_path"><span id="progress_switch" class="tree_switch">○</span><span id="progress_title" class="item_title">进度</span><span id="progress_count" class="item_count">(0)</span></a></li>|</ul></li><li id="life" class="categories_tree_item"><a href="../../../../categories/categories/life" class="item_path"><span id="life_switch" class="tree_switch">▷</span><span id="life_title" class="item_title">生活</span><span id="life_count" class="item_count">(0)</span></a><ul id="life_tree" class="categories_tree categories_level3" type="none"><li id="experience" class="categories_tree_item"><a href="../../../../categories/categories/life/experience" class="item_path"><span id="experience_switch" class="tree_switch">○</span><span id="experience_title" class="item_title">经验</span><span id="experience_count" class="item_count">(0)</span></a></li><li id="tips" class="categories_tree_item"><a href="../../../../categories/categories/life/tips" class="item_path"><span id="tips_switch" class="tree_switch">○</span><span id="tips_title" class="item_title">技巧</span><span id="tips_count" class="item_count">(0)</span></a></li>|</ul></li><li id="others" class="categories_tree_item"><a href="../../../../categories/categories/others" class="item_path"><span id="others_switch" class="tree_switch">▷</span><span id="others_title" class="item_title">其它</span><span id="others_count" class="item_count">(4)</span></a><ul id="others_tree" class="categories_tree categories_level3" type="none"><li id="rambles" class="categories_tree_item"><a href="../../../../categories/categories/others/rambles" class="item_path"><span id="rambles_switch" class="tree_switch">○</span><span id="rambles_title" class="item_title">随笔</span><span id="rambles_count" class="item_count">(0)</span></a></li><li id="temp" class="categories_tree_item"><a href="../../../../categories/categories/others/temp" class="item_path"><span id="temp_switch" class="tree_switch">○</span><span id="temp_title" class="item_title">临时</span><span id="temp_count" class="item_count">(0)</span></a></li><li id="test" class="categories_tree_item"><a href="../../../../categories/categories/others/test" class="item_path"><span id="test_switch" class="tree_switch">○</span><span id="test_title" class="item_title">测试</span><span id="test_count" class="item_count">(0)</span></a></li>|</ul></li>|</ul></li></ul>
				</div>
			</th>

			<th class="navblank"></th>

			<th class="navitm">
				<a href="../../../../tags">标签</a>
				<div id="tag_menus" class="second">
					<ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/gtd-next/">gtd_next</a><span class="tag-list-count">1</span></li></ul>
				</div>
			</th>

			<th class="navitm">
				<a href="../../../../archives">归档</a>
			</th>

			<th class="navblank"></th>

			<th class="navitm">
				<a href="../../../../more">更多</a>
			</th>

			<th class="navitm">
				<a href="../../../../about">关于</a>
			</th>

			<th class="navblank" style="width:25%;"></th>

			<th class="navitm" style="margin:0; padding:0;border:none;">
				<form method="get" id="searchform" action="/search.html" style="margin:0;padding:0;height:100%;">
					<span style="color:#00FF00;">Q</span>
					<span style="border-style:solid; border-width:1px; border-color:#00FF00;
		  		border-top:0px; border-left:0px;border-right:0px; 
				margin:0;padding:0;height:100%;">
						<input value="Search by title (canbe regex)..." name="s" class="s" onfocus="if (this.value == 'Search by title (canbe regex)...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search by title (canbe regex)...';}" style="margin:0;padding:0;height:100%;border:none;background: #000000; color:#00A600;" type="text">
					</span>
					<!--input type="submit" value="Q" style="width:20%;"-->
				</form>
			</th>

			<th class="navblank"></th>

			<th class="navblank"></th>

			<a href="#" id="topbtn">⇑</a>

			<a href="#bottom" id="bottombtn">⇓</a>
			<!--⇐⇑⇒⇓-->
		</tr><tr>
	</tr></tbody>
</table>
        </tr>
        <tr>
            <td id="td_page_header" colspan="6" valign="top" align="right" style="width:100%;">
        <header style="text-align: center;">
               <a href="/" title="Menu.Home">
               <h1>QuietHeart's Site</h1>
               </a>
        </header>
</td>    
        </tr>
        <tr>
            <td id="td_posts" colspan="6" valign="top">
                <h1 id="header1" style="text-align: center;">
                    关于C/C++中的预处理
                </h1>
                <hr id="title_line">
                <article>
                    <div>
                        
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. 预处理命令简介</a></li>
<li><a href="#orgheadline2">2. 预处理的文法</a></li>
<li><a href="#orgheadline3">3. 预处理命令详述</a>
<ul>
<li><a href="#orgheadline4">3.1. 1、声明定义</a>
<ul>
<li><a href="#orgheadline5">3.1.1. <code>#define</code></a></li>
<li><a href="#orgheadline6">3.1.2. <code>#undef</code></a></li>
<li><a href="#orgheadline7">3.1.3. <code>#, ##</code></a></li>
</ul>
</li>
<li><a href="#orgheadline8">3.2. 2、条件编译</a>
<ul>
<li><a href="#orgheadline9">3.2.1. <code>#if, #elif, #else, #endif</code></a></li>
<li><a href="#orgheadline10">3.2.2. <code>#ifdef, #ifndef, defined</code></a></li>
</ul>
</li>
<li><a href="#orgheadline11">3.3. 3、文件包含</a>
<ul>
<li><a href="#orgheadline12">3.3.1. <code>#include</code> 指令</a></li>
<li><a href="#orgheadline13">3.3.2. <code>#include_next</code> 指令</a></li>
</ul>
</li>
<li><a href="#orgheadline14">3.4. 4、预定义宏</a></li>
<li><a href="#orgheadline15">3.5. 5、扩展控制</a>
<ul>
<li><a href="#orgheadline16">3.5.1. <code>#line</code></a></li>
<li><a href="#orgheadline17">3.5.2. <code>#pragma, _Pragma</code></a></li>
<li><a href="#orgheadline18">3.5.3. <code>#warning, #error</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline19">4. C语言常用宏定义</a>
<ul>
<li><a href="#orgheadline20">4.1. 01: 防止一个头文件被重复包含</a></li>
<li><a href="#orgheadline21">4.2. 02: 重新定义一些类型,防止由于各种平台和编译器的不同,而产生的类型字节数差异,方便移植。</a></li>
<li><a href="#orgheadline22">4.3. 03: 得到指定地址上的一个字节或字</a></li>
<li><a href="#orgheadline23">4.4. 04: 求最大值和最小值</a></li>
<li><a href="#orgheadline24">4.5. 05: 得到一个field在结构体(struct)中的偏移量</a></li>
<li><a href="#orgheadline25">4.6. 06: 得到一个结构体中field所占用的字节数</a></li>
<li><a href="#orgheadline26">4.7. 07: 按照LSB格式把两个字节转化为一个Word</a></li>
<li><a href="#orgheadline27">4.8. 08: 按照LSB格式把一个Word转化为两个字节</a></li>
<li><a href="#orgheadline28">4.9. 09: 得到一个变量的地址（word宽度）</a></li>
<li><a href="#orgheadline29">4.10. 10: 得到一个字的高位和低位字节</a></li>
<li><a href="#orgheadline30">4.11. 11: 返回一个比X大的最接近的8的倍数</a></li>
<li><a href="#orgheadline31">4.12. 12: 将一个字母转换为大写</a></li>
<li><a href="#orgheadline32">4.13. 13: 判断字符是不是10进值的数字</a></li>
<li><a href="#orgheadline33">4.14. 14: 判断字符是不是16进值的数字</a></li>
<li><a href="#orgheadline34">4.15. 15: 防止溢出的一个方法</a></li>
<li><a href="#orgheadline35">4.16. 16: 返回数组元素的个数</a></li>
<li><a href="#orgheadline36">4.17. 17: 返回一个无符号数n尾的值MOD_BY_POWER_OF_TWO(X,n)=X%(2^n)</a></li>
<li><a href="#orgheadline37">4.18. 18: 对于IO空间映射在存储空间的结构,输入输出处理</a></li>
<li><a href="#orgheadline38">4.19. 19: 使用一些宏跟踪调试</a></li>
<li><a href="#orgheadline39">4.20. 20：宏定义防止错误使用小括号包含。</a></li>
</ul>
</li>
<li><a href="#orgheadline40">5. 其它</a></li>
</ul>
</div>
</div>
<p>
本文主要讲述C/C++中预处理命令相关的内容。主要参考资料在后面给出。
</p>

<p>
我们可以在C源程序中插入传给编译程序的各种指令（宏），这些指令被称为预处理器指令，它们扩充了程序设计的环境。
</p>

<p>
在将一个C源程序转换为可执行程序的过程中, 编译预处理是最初的步骤. 这一步骤是由预处理器(preprocessor)来完成的. 在源程序被编译器处理之前, 预处理器首先对源程序中的"宏(macro)"进行处理.
</p>

<p>
C 初学者可能对预处理器没什么概念, 这是情有可原的: 一般的C编译器都将预处理, 汇编, 编译, 连接过程集成到一起了，编译预处理往往在后台运行。 在有的C编译器中, 这些过程统统由一个单独的程序来完成, 在编译的不同阶段分别实现这些不同的功能，我们可以指定特定的命令选项来执行这些指定功能。有的C编译器则使用独立的程序来完成这些步骤. 可单独调用这些程序来完成特定步骤，比如在 <code>gcc</code> 中, 进行编译预处理的程序被称为 <code>CPP</code> , 它的可执行文件名为 <code>cpp</code> 。
</p>

<p>
编译预处理命令的语法与C语言的语法是完全独立的，比如: 你可以将一个宏扩展为与C语法格格不入的内容, 但该内容与后面的语句结合在一个若能生成合法的C语句, 也是可以正确编译的。
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> 预处理命令简介</h2>
<div class="outline-text-2" id="text-1">
<p>
预处理命令由#(hash字符)开头, 它独占一行, #之前只能是空白符. 以#开头的语句就是预处理命令, 不以#开头的语句为C中的代码行。
</p>

<p>
常用的预处理命令如下:
</p>
<pre class="example">
#define              定义一个预处理宏
#undef             取消宏的定义

#if                      编译预处理中的条件命令, 相当于C语法中的if语句
#ifdef                判断某个宏是否被定义, 若已定义, 执行随后的语句
#ifndef             与#ifdef相反, 判断某个宏是否未被定义
#elif                  若#if, #ifdef, #ifndef或前面的#elif条件不满足, 则执行#elif之后的语句, 相当于C语法中的else-if
#else                与#if, #ifdef, #ifndef对应, 若这些条件不满足, 则执行#else之后的语句, 相当于C语法中的else
#endif              #if, #ifdef, #ifndef这些条件命令的结束标志.
defined          与#if, #elif配合使用, 判断某个宏是否被定义

#include            包含文件命令
#include_next   与#include相似, 但它有着特殊的用途

#line                标志该语句所在的行号
#                      将宏参数替代为以参数值为内容的字符窜常量
##                   将两个相邻的标记(token)连接为一个单独的标记
#pragma       说明编译器信息

#warning       显示编译警告信息
#error          显示编译错误信息
</pre>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">2</span> 预处理的文法</h2>
<div class="outline-text-2" id="text-2">
<p>
预处理并不分析整个源代码文件, 它只是将源代码分割成一些标记(token), 识别语句中哪些是C语句, 哪些是预处理语句。
</p>

<p>
预处理器能够识别C标记, 文件名, 空白符, 文件结尾标志。
</p>

<p>
预处理语句格式: <code>#command name(...) token(s)</code>
</p>

<p>
这里，
</p>
<ul class="org-ul">
<li><p>
<code>command</code> 预处理命令的名称。
</p>

<p>
它之前以 <code>#</code> 开头, #之后紧随预处理命令, 标准C允许 <code>#</code> 两边可以有空白符, 但比较老的编译器可能不允许这样. 若某行中只包含 <code>#</code> (以及空白符), 那么在标准C中该行被理解为空白. 整个预处理语句之后只能有空白符或者注释, 不能有其它内容。
</p></li>

<li><p>
<code>name</code> 代表宏名称，它可带参数。
</p>

<p>
参数可以是可变参数列表(C99).
</p></li>

<li><p>
<code>token(s)</code> 宏体，将替换宏名称的语句。
</p>

<p>
语句中可以利用 <code>\</code> 来换行.
</p></li>
</ul>

<p>
e.g.
</p>
<div class="org-src-container">

<pre class="src src-C"># define ONE 1 /* ONE == 1 */
</pre>
</div>
<p>
等价于:
</p>
<div class="org-src-container">

<pre class="src src-C">#define ONE　１
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C">#define err(flag, msg) if(flag) \
   printf(msg)
</pre>
</div>
<p>
等价于:
</p>
<div class="org-src-container">

<pre class="src src-C">#define err(flag, msg) if(flag) printf(msg)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3"><span class="section-number-2">3</span> 预处理命令详述</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">3.1</span> 1、声明定义</h3>
<div class="outline-text-3" id="text-3-1">
</div><div id="outline-container-orgheadline5" class="outline-4">
<h4 id="orgheadline5"><span class="section-number-4">3.1.1</span> <code>#define</code></h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
<code>#define</code> 命令定义一个宏，定义一个标识符和一个串（也就是字符集），在源程序中发现该标识符时，都用该串替换之。这种标识符称为宏名字，相应的替换称为宏代换。
一般形式如下：
</p>
<div class="org-src-container">

<pre class="src src-C">#define MACRO_NAME(args) tokens(opt)
</pre>
</div>
<p>
这种语句不用分号结尾。宏名字和串之间可以有多个空白符，但串开始后只能以新行终止。之后出现的 <code>MACRO_NAME</code> 将被替代为所定义的标记( <code>tokens</code> ). 宏可带参数, 而后面的标记也是可选的。
</p>
</div>

<div id="outline-container-orgheadline41" class="outline-5">
<h5 id="orgheadline41"><span class="section-number-5">3.1.1.1</span> 对象宏</h5>
<div class="outline-text-5" id="text-3-1-1-1">
<p>
不带参数的宏被称为"对象宏(objectlike macro)"。
</p>

<p>
<code>#define</code> 经常用来定义常量, 此时的宏名称一般为大写的字符串。 这样利于修改这些常量。
e.g.
</p>
<div class="org-src-container">

<pre class="src src-C">#define MAX 100
int a[MAX];
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C">#ifndef __FILE_H__
#define __FILE_H__
#include "file.h"
#endif
</pre>
</div>
<p>
这里， <code>#define __FILE_H__</code> 中的宏就不带任何参数, 也不扩展为任何标记. 这经常用于包含头文件.
</p>

<p>
要调用宏, 只需在代码中指定宏名称, 相应宏将被替代为它被定义的内容。
</p>

<p>
例如：我们使用 <code>LEFT</code> 代表1，用 <code>RIGHT</code> 代表0，我们使用两个 <code>#define</code> 指令：
</p>
<div class="org-src-container">

<pre class="src src-C">#define LEFT 1
#define RIGHT 0
</pre>
</div>
<p>
每当在源程序中遇到 <code>LEFT</code> 或 <code>RIGHT</code> 时，编译程序都用1或0替换。
</p>

<p>
宏代换就是用相关的串替代标识符。因此，如果希望定义一条标准错误信息时，可以如下定义：
</p>
<div class="org-src-container">

<pre class="src src-C">#define ERROR_MS “Standard error on input \n”
</pre>
</div>

<p>
如果一个串长于一行，可在行尾用反斜线”\”续行，如下：
</p>
<div class="org-src-container">

<pre class="src src-C">#define LONG_STRING “This is a very very long \
String that is used as an example”
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline47" class="outline-5">
<h5 id="orgheadline47"><span class="section-number-5">3.1.1.2</span> 函数宏</h5>
<div class="outline-text-5" id="text-3-1-1-2">
<p>
带参数的宏也被称为"函数宏". 利用宏可以提高代码的运行效率: 子程序的调用需要压栈出栈, 这一过程如果过于频繁会耗费掉大量的CPU运算资源. 所以一些代码量小但运行频繁的代码如果采用带参数宏来实现会提高代码的运行效率.
</p>
</div>

<ol class="org-ol"><li><a id="orgheadline45"></a>函数宏的参数是固定的情况<br><div class="outline-text-6" id="text-3-1-1-2-1">
<p>
函数宏的定义采用这样的方式: <code>#define name( args ) tokens</code>
</p>

<p>
其中的 <code>args</code> 和 <code>tokens</code> 都是可选的. 它和对象宏定义上的区别在于对象宏名称之后不带括号.
</p>

<p>
注意： <b>定义时</b> ， <code>name</code> 之后的左括号 <code>(</code> 必须紧跟 <code>name</code> , 之间不能有空格, 否则这就定义了一个对象宏, 它将被替换为以 <code>(</code> 开始的字符串；但在 <b>用函数宏时</b> , <code>name</code> 与 <code>(</code> 之间却可以有空格.
</p>

<p>
例如：
</p>
<div class="org-src-container">

<pre class="src src-C">#define mul(x,y) ((x)*(y))
</pre>
</div>

<p>
注意, 函数宏之后的参数要用括号括起来, 看看这个例子:
</p>
<div class="org-src-container">

<pre class="src src-C">#define mul(x,y) x*y
</pre>
</div>
<p>
<code>mul(1, 2+2);</code> 将被扩展为: <code>1*2 + 2</code>
</p>

<p>
同样, 整个标记串也应该用括号引用起来:
</p>
<div class="org-src-container">

<pre class="src src-C">#define mul(x,y) (x)*(y)
</pre>
</div>
<p>
<code>sizeof mul(1,2.0)</code> 将被扩展为 <code>sizeof 1 * 2.0</code>
</p>

<p>
调用函数宏时候, 传递给它的参数可以是函数的返回值, 也可以是任何有意义的语句:
e.g.
</p>
<div class="org-src-container">

<pre class="src src-C">mul (f(a,b), g(c,d));
</pre>
</div>

<p>
e.g.
</p>
<div class="org-src-container">

<pre class="src src-C">#define insert(stmt) stmt
</pre>
</div>
<p>
这里：
</p>
<ul class="org-ul">
<li>insert ( a=1; b=2;) 相当于在代码中加入 a=1; b=2 .</li>
<li>insert ( a=1, b=2;) 就有问题了: 预处理器会提示出错: 函数宏的参数个数不匹配. 预处理器把","视为参数间的分隔符.</li>
<li>insert ((a=1, b=2;)) 可解决上述问题.</li>
</ul>
</div>

<ol class="org-ol"><li><a id="orgheadline44"></a>在定义和调用函数宏时候, 要注意一些问题<br><ol class="org-ol"><li><a id="orgheadline42"></a>使用 <code>do-while(0)</code> 解决结尾 <code>;</code> 问题<br><div class="outline-text-8" id="text-3-1-1-2-1-1-1">
<p>
我们经常用 <code>{}</code> 来引用函数宏被定义的内容, 这就要注意调用这个函数宏时的 <code>;</code> 问题.
example_3.7:
</p>
<div class="org-src-container">

<pre class="src src-C">#define swap(x,y) { unsigned long _temp=x; x=y; y=_tmp}
</pre>
</div>
<p>
如果这样调用它:  <code>swap(1,2);</code> 将被扩展为:  <code>{ unsigned long _temp=1; 1=2; 2=_tmp};</code>
</p>

<p>
明显后面的;是多余的, 我们应该这样调用:  <code>swap(1,2)</code>
</p>

<p>
虽然这样的调用是正确的, 但它和C语法相悖, 可采用下面的方法来处理被 <code>{}</code> 括起来的内容:
</p>
<div class="org-src-container">

<pre class="src src-C">#define swap(x,y) \
   do { unsigned long _temp=x; x=y; y=_tmp} while (0)
</pre>
</div>
<p>
<code>swap(1,2);</code> 将被替换为: <code>do { unsigned long _temp=1; 1=2; 2=_tmp} while (0);</code>
</p>

<p>
在Linux内核源代码中对这种 <code>do-while(0)</code> 语句有这广泛的应用.
</p>
</div></li>

<li><a id="orgheadline43"></a>无法被 <code>do-while(0)</code> 实现的宏<br><div class="outline-text-8" id="text-3-1-1-2-1-1-2">
<p>
有的函数宏是无法用 <code>do-while(0)</code> 来实现的, 所以在调用时不能带上 <code>;</code>, 最好在调用后添加注释说明。
eg_3.8:
</p>
<div class="org-src-container">

<pre class="src src-C">#define incr(v, low, high) \
   for ((v) = (low),; (v) &lt;= (high); (v)++)
</pre>
</div>
<p>
只能以这样的形式被调用: <code>incr(a, 1, 10) /* increase a form 1 to 10 */</code>
</p>
</div></li></ol></li></ol></li>

<li><a id="orgheadline46"></a>函数宏中的参数包括可变参数列表的情况<br><div class="outline-text-6" id="text-3-1-1-2-2">
<p>
C99标准中新增了可变参数列表的内容。 不光是函数, 函数宏中也可以使用可变参数列表。
</p>
<pre class="example">
#define name(args, ...) tokens
#define name(...) tokens
</pre>
<p>
<code>...</code> 代表可变参数列表, 如果它不是仅有的参数, 那么它只能出现在参数列表的最后. 调用这样的函数宏时, 传递给它的参数个数要不少于参数列表中参数的个数(多余的参数被丢弃)。
</p>

<p>
通过 <code>__VA_ARGS__</code> 来替换函数宏中的可变参数列表. 注意 <code>__VA_ARGS__</code> 只能用于函数宏中参数中包含有 <code>...</code> 的情况.
</p>

<p>
e.g.
</p>
<div class="org-src-container">

<pre class="src src-C">#ifdef DEBUG
#define my_printf(...) fprintf(stderr, __VA_ARGS__)
#else
#define my_printf(...) printf(__VA_ARGS__)
#endif
</pre>
</div>

<p>
<code>tokens</code> 中的 <code>__VA_ARGS__</code> 被替换为函数宏定义中的 <code>...</code> 可变参数列表。
</p>
</div></li></ol>
</div>

<div id="outline-container-orgheadline48" class="outline-5">
<h5 id="orgheadline48"><span class="section-number-5">3.1.1.3</span> 注意在使用#define时候的一些常见错误</h5>
<div class="outline-text-5" id="text-3-1-1-3">
<div class="org-src-container">

<pre class="src src-C">#define MAX = 100
#define MAX 100;
</pre>
</div>
<p>
=, ; 的使用要值得注意，再就是调用函数宏是要注意, 不要多给出 <code>;</code> 。
</p>

<p>
注意: 函数宏对参数类型是不敏感的, 你不必考虑将何种数据类型传递给宏。 那么, 如何构建对参数类型敏感的宏呢? 参考本章的第九部分, 关于 <code>##</code> 的介绍。
</p>
</div>
</div>

<div id="outline-container-orgheadline53" class="outline-5">
<h5 id="orgheadline53"><span class="section-number-5">3.1.1.4</span> 关于定义宏的另外一些问题</h5>
<div class="outline-text-5" id="text-3-1-1-4">
</div><ol class="org-ol"><li><a id="orgheadline49"></a>(1)重复定义宏<br><div class="outline-text-6" id="text-3-1-1-4-1">
<p>
宏可以被多次定义, 前提是这些定义必须是相同的. 这里的"相同"要求 <b>先后定义中空白符出现的位置相同, 但具体的空白符类型或数量可不同</b>, 比如原先的空格可替换为多个其他类型的空白符: 可为tab, 注释&#x2026;
</p>

<p>
e.g.
</p>
<div class="org-src-container">

<pre class="src src-C">#define NULL 0
#define NULL　/* null pointer */     0
</pre>
</div>
<p>
上面的重定义是相同的, 但下面的重定义不同:
</p>
<div class="org-src-container">

<pre class="src src-C">#define fun(x) x+1
#define fun(x) x + 1 
//或: #define fun(y) y+1
</pre>
</div>
<p>
如果多次定义时, 再次定义的宏内容是不同的, <code>gcc</code> 会给出 <code>NAME redefined</code> 警告信息。
</p>

<p>
应该避免重新定义函数宏, 不管是在预处理命令中还是C语句中, 最好对某个对象只有单一的定义. 在 <code>gcc</code> 中, 若宏出现了重定义, <code>gcc</code> 会给出警告。
</p>
</div></li>

<li><a id="orgheadline50"></a>(2) 命令行扩展定义<br><div class="outline-text-6" id="text-3-1-1-4-2">
<p>
在 <code>gcc</code> 中, 可在命令行中指定对象宏的定义:
</p>

<p>
e.g.
</p>
<div class="org-src-container">

<pre class="src src-sh">$gcc -Wall -DMAX=100 -o tmp tmp.c
</pre>
</div>
<p>
相当于在 <code>tmp.c</code> 中添加 <code>#define MAX 100</code> 。
</p>

<p>
那么, 如果原先 <code>tmp.c</code> 中含有MAX宏的定义, 那么再在 <code>gcc</code> 调用命令中使用 <code>-DMAX</code> , 会出现什么情况呢?
</p>
<ul class="org-ul">
<li>若 <code>-DMAX=1</code>, 则正确编译.</li>
<li>若 <code>-DMAX</code> 的值被指定为不为1的值, 那么 <code>gcc</code> 会给出 <code>MAX</code> 宏被重定义的警告, <code>MAX</code> 的值仍为1.</li>
</ul>
<p>
注意: 若在调用 <code>gcc</code> 的命令行中不显示地给出对象宏的值, 那么 <code>gcc</code> 赋予该宏默认值(1), 如:  -DVAL == -DVAL=1
</p>
</div></li>

<li><a id="orgheadline51"></a>(3) 宏定义作用域<br><div class="outline-text-6" id="text-3-1-1-4-3">
<p>
<code>#define</code> 所定义的宏的作用域
宏在定义之后才生效, 若宏定义被 <code>#undef</code> 取消, 则 <code>#undef</code> 之后该宏无效. 并且字符串中的宏不会被识别
</p>

<p>
e.g.
</p>
<div class="org-src-container">

<pre class="src src-C">#define ONE 1
sum = ONE + TWO    /* sum = 1 + TWO */
#define TWO 2
sum = ONE + TWO    /* sum = 1 + 2    */
#undef ONE
sum = ONE + TWO    /* sum = ONE + 2 */
char c[] = "TWO"   /* c[] = "TWO", NOT "2"! */
</pre>
</div>
</div></li>

<li><a id="orgheadline52"></a>(4) 递归嵌套定义<br><div class="outline-text-6" id="text-3-1-1-4-4">
<p>
宏的替换可以是递归的, 所以可以嵌套定义宏。也就是说，定义一个宏名字之后，可以在其他宏定义中使用。
</p>

<p>
e.g.
</p>
<div class="org-src-container">

<pre class="src src-C"># define ONE NUMBER_1
# define NUMBER_1 1
int a = ONE /* a = 1 */
</pre>
</div>

<div class="org-src-container">

<pre class="src src-C">#define ONE 1
#define TWO ONE+ONE
#define THREE ONE+TWO
</pre>
</div>
</div></li></ol>
</div>
</div>
<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6"><span class="section-number-4">3.1.2</span> <code>#undef</code></h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
<code>#undef</code> 用来取消宏定义, 它与 <code>#define</code> 对立，经常用来删除前面定义的宏名字。也就是说，它“不定义”宏。一般形式为：
</p>
<pre class="example">
#undef macro-name
</pre>
<p>
如够被取消的宏实际上没有被 <code>#define</code> 所定义, 针对它的 <code>#undef</code> 并不会产生错误，当一个宏定义被取消后, 可以再度定义它。
</p>
</div>
</div>
<div id="outline-container-orgheadline7" class="outline-4">
<h4 id="orgheadline7"><span class="section-number-4">3.1.3</span> <code>#, ##</code></h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
预处理操作符 <code>#</code> 和 <code>##</code> 主要作用是允许预处理程序对付某些特殊情况，多数程序中并不需要，它们可以在 <code>#define</code> 中使用。
</p>

<p>
由于经常用于对字符串的预处理操作, 所以他们也经常用于 <code>printf, puts</code> 之类的字符串显示函数中。例如：
</p>

<p>
e.g.
</p>
<div class="org-src-container">

<pre class="src src-C">#define TEST(a,b) printf( #a "&lt;" #b "=%d\n", (a)&lt;(b));
</pre>
</div>
</div>

<div id="outline-container-orgheadline54" class="outline-5">
<h5 id="orgheadline54"><span class="section-number-5">3.1.3.1</span> <code>#</code> 命令</h5>
<div class="outline-text-5" id="text-3-1-3-1">
<p>
操作符 <code>#</code> 通常称为字符串化的操作符，它把其后的串变成用双引号包围的串。用于在宏扩展之后将 <code>tokens</code> 转换为以 <code>tokens</code> 为内容的字符串常量。
</p>

<p>
例如：
</p>
<div class="org-src-container">

<pre class="src src-C">#include &lt;stdio.h&gt;
#define mkstr(s) #s
int main(void)
{
 printf(mkstr(I like C));
 Return 0;
}
</pre>
</div>
<p>
预处理程序把以下的语句： <code>printf(mkstr(I like C));</code> 变成 <code>printf(“I like C”);</code>
</p>

<p>
注意: <code>#</code> 只针对紧随其后的 <code>token</code> 有效!
</p>
</div>
</div>

<div id="outline-container-orgheadline55" class="outline-5">
<h5 id="orgheadline55"><span class="section-number-5">3.1.3.2</span> <code>##</code> 命令</h5>
<div class="outline-text-5" id="text-3-1-3-2">
<p>
操作符 <code>##</code> 把两个标记拼在一起，形成一个新标记。用于将它前后的两个 <code>token</code> 组合在一起转换成以这两个 <code>token</code> 为内容的字符串常量。
</p>

<div class="org-src-container">

<pre class="src src-C">#include &lt;stdio.h&gt;
#define concat(a,a) a##b
int main(void)
{
 int xy = 10;
 printf(“%d”,concat(x,y));
 Return 0;
}
</pre>
</div>
<p>
预处理程序把以下语句： <code>printf(“%d”,concat(x,y));</code> 变成 <code>printf(“%d”,xy);</code> 
</p>

<p>
注意： <code>##</code> 前后必须要有 <code>token</code> ！
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8"><span class="section-number-3">3.2</span> 2、条件编译</h3>
<div class="outline-text-3" id="text-3-2">
<p>
若干编译指令允许程序员有选择的编译程序源代码的不同部分，这种过程称为条件编译。
</p>
</div>
<div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9"><span class="section-number-4">3.2.1</span> <code>#if, #elif, #else, #endif</code></h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
<code>#if, #elif, #else, #endif</code> 允许程序员根据常数表达式的结果有条件的包围部分代码。一般的表达形式是：
</p>
<pre class="example">
#if 常量表达式1
   语句...
#elif 常量表达式2
   语句...
#elif 常量表达式3
   语句...
...
#else
   语句...
#endif
</pre>

<p>
它们后面所判断的宏只能是对象宏. 如果 <code>name</code> 为名的宏未定义, 或者该宏是函数宏. 那么在 <code>gcc</code> 中使用 <code>-Wundef</code> 选项会显示宏未定义的警告信息。
</p>
</div>

<div id="outline-container-orgheadline56" class="outline-5">
<h5 id="orgheadline56"><span class="section-number-5">3.2.1.1</span> <code>#if</code></h5>
<div class="outline-text-5" id="text-3-2-1-1">
<p>
表示“如果”， 其一般形式是：
</p>
<pre class="example">
#if constant-expression
 Statement sequence
#endif
</pre>
<p>
如 <code>#if</code> 后的常数表达式为真，则 <code>#if</code> 和 <code>#endif</code> 中间的代码被编译，否则忽略该代码段。 <code>#endif</code> 标记 <code>#if</code> 块的结束。
</p>
</div>
</div>

<div id="outline-container-orgheadline57" class="outline-5">
<h5 id="orgheadline57"><span class="section-number-5">3.2.1.2</span> <code>#elif</code> 指令</h5>
<div class="outline-text-5" id="text-3-2-1-2">
<p>
表示“否则，如果”，为多重编译选择建立一条 <code>if-else-if</code> （如果-否则-如果链）。一般形式如下：
</p>
<pre class="example">
#if expression
 Statement sequence
#elif expression1
 Statement sequence
#elif expression2
 Statement sequence
#elif expression
 Statement sequence
#endif
</pre>
<p>
如果 <code>#if</code> 表达式为真，该代码块被编译，不测试其他 <code>#elif</code> 表达式。否则，序列中的下一块被测试，如果成功则编译之。
</p>
</div>
</div>

<div id="outline-container-orgheadline58" class="outline-5">
<h5 id="orgheadline58"><span class="section-number-5">3.2.1.3</span> <code>#else</code> 指令</h5>
<div class="outline-text-5" id="text-3-2-1-3">
<p>
作用与C语言的 <code>else</code> 相似， <code>#if</code> 指令失败时它可以作为备选指令。例如：
</p>
<div class="org-src-container">

<pre class="src src-C">#include &lt;stdio.h&gt;
#define MAX 100

int main(void)
{
 #if MAX&gt;99
 printf(“Compiled for array greater than 99.\n”);
 #else
 printf(“Complied for small array.\n”);
 #endif
 return 0;
}
</pre>
</div>
<p>
注意， <code>#else</code> 既是标记 <code>#if</code> 块的结束，也标记 <code>#else</code> 块的开始。因为每个 <code>#if</code> 只能写一个 <code>#endif</code> 匹配。
</p>
</div>
</div>

<div id="outline-container-orgheadline59" class="outline-5">
<h5 id="orgheadline59"><span class="section-number-5">3.2.1.4</span> 与代码中的 <code>if/else</code> 类似</h5>
<div class="outline-text-5" id="text-3-2-1-4">
<p>
<code>#if</code> 和 <code>#else</code> 分别相当于C语句中的 <code>if</code> , <code>else</code> 。它们根据常量表达式的值来判别是否执行后面的语句。 <code>#elif</code> 相当于C中的 <code>else-if</code> 。使用这些条件编译命令可以方便地实现对源代码内容的控制。 <code>else</code> 之后不带常量表达式, 但若包含了常量表达式,  <code>gcc</code> 只是给出警告信息。
</p>

<p>
使用它们可以提升代码的可移植性——针对不同的平台使用执行不同的语句. 也经常用于大段代码注释。
</p>

<p>
e.g.
</p>
<div class="org-src-container">

<pre class="src src-C">#if 0
{
   一大段代码;
}
#endif
</pre>
</div>

<p>
常量表达式可以是包含宏, 算术运算, 逻辑运算等等的合法C常量表达式, 如果常量表达式为一个未定义的宏, 那么它的值被视为0，
</p>
<div class="org-src-container">

<pre class="src src-C">#if MACRO_NON_DEFINED == #if 0
</pre>
</div>
<p>
在判断某个宏是否被定义时, 应当避免使用#if, 因为该宏的值可能就是被定义为0。 而应当使用下面介绍的 <code>#ifdef</code> 或 <code>#ifndef</code> 。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-4">
<h4 id="orgheadline10"><span class="section-number-4">3.2.2</span> <code>#ifdef, #ifndef, defined</code></h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
<code>#ifdef, #ifndef, defined</code> 用来测试某个宏是否被定义。
</p>

<p>
与 <code>#if, #elif, #else</code> 不同, <code>#indef, #ifndef, defined</code> 测试的宏可以是对象宏, 也可以是函数宏。
</p>

<p>
在 <code>gcc</code> 中使用 <code>-Wundef</code> 选项不会显示宏未定义的警告信息。
</p>
</div>

<div id="outline-container-orgheadline60" class="outline-5">
<h5 id="orgheadline60"><span class="section-number-5">3.2.2.1</span> <code>#ifdef</code> 指令</h5>
<div class="outline-text-5" id="text-3-2-2-1">
<p>
一般形式如下：
</p>
<pre class="example">
#ifdef macro-name
 Statement sequence
#endif
</pre>
<p>
如果 <code>macro-name</code> 原先已经被一个 <code>#define</code> 语句定义，则编译其中的代码块。
</p>
</div>
</div>

<div id="outline-container-orgheadline61" class="outline-5">
<h5 id="orgheadline61"><span class="section-number-5">3.2.2.2</span> <code>#ifndef</code> 指令</h5>
<div class="outline-text-5" id="text-3-2-2-2">
<p>
一般形式如下：
</p>
<pre class="example">
#ifndef macro-name
 Statement sequence
#endif
</pre>
<p>
如果 <code>macro-name</code> 当前未被 <code>#define</code> 语句定义，则编译其中的代码块。
</p>

<p>
<code>#ifndef</code> 经常用于避免头文件的重复引用，例如：
</p>
<div class="org-src-container">

<pre class="src src-C">#ifndef __FILE_H__
#define __FILE_H__
#include "file.h"
#endif
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline65" class="outline-5">
<h5 id="orgheadline65"><span class="section-number-5">3.2.2.3</span> <code>defined</code> 指令</h5>
<div class="outline-text-5" id="text-3-2-2-3">
<p>
除 <code>#ifdef</code> 之外，还有另外一种确定是否定义宏名字的方法，即可以将 <code>#if</code> 指令与 <code>defined</code> 指令一起使用。 <code>defined</code> 操作符的一般形式如下：
</p>
<pre class="example">
defined macro-name
</pre>
<p>
若 <code>macro-name</code> 当前被定义，则表达式为真返回1，否则为假返回0。
</p>

<p>
<code>defined</code> 与 <code>#if, #elif, #else</code> 结合使用来判断宏是否被定义, 乍一看好像它显得多余, 因为已经有了 <code>#ifdef</code> 和 <code>#ifndef</code> ，其实使用 <code>defined</code> 的一个原因是，它允许被做为 <code>#ifdef</code> 与 <code>#ifndef</code> , <code>#elif</code> 的判断条件(如：由 <code>#elif</code> 语句确定宏名字存在)，因此显得更为灵活。
</p>
</div>

<ol class="org-ol"><li><a id="orgheadline62"></a>与 <code>#ifdef</code> 等价的判断<br><div class="outline-text-6" id="text-3-2-2-3-1">
<p>
例如，确定宏 <code>MY</code> 是否定义，可以使用下列两种预处理命令之一：
</p>
<div class="org-src-container">

<pre class="src src-C">#if defined MY
</pre>
</div>
<p>
或
</p>
<div class="org-src-container">

<pre class="src src-C">#ifdef MY
</pre>
</div>
</div></li>

<li><a id="orgheadline63"></a>与 <code>#ifndef</code> 等价的判断<br><div class="outline-text-6" id="text-3-2-2-3-2">
<p>
也可以在 <code>defined</code> 之前加上感叹号”!”来反转相应的条件。例如，只有在DEBUG未定义的情况下才编译。
</p>
<div class="org-src-container">

<pre class="src src-C">#if !defined DEBUG
 printf(“Final Version!\n”);
#endif
</pre>
</div>
<p>
或
</p>
<div class="org-src-container">

<pre class="src src-C">#ifndef DEBUG
 printf(“Final Version!\n”);
#endif
</pre>
</div>
</div></li>

<li><a id="orgheadline64"></a><code>defined</code> 做为条件语句的判断<br><div class="outline-text-6" id="text-3-2-2-3-3">
<p>
比如在一条判断语句中声明多个判别条件，如：
</p>
<div class="org-src-container">

<pre class="src src-C">#if defined(VAX) &amp;&amp; defined(UNIX) &amp;&amp; !defined(DEBUG)
</pre>
</div>

<p>
注：可以没有括号。
</p>
</div></li></ol>
</div>
<div id="outline-container-orgheadline66" class="outline-5">
<h5 id="orgheadline66"><span class="section-number-5">3.2.2.4</span> 结合 <code>#else</code> / <code>#elif</code> 指令使用</h5>
<div class="outline-text-5" id="text-3-2-2-4">
<p>
<code>#ifdef</code> / <code>#ifndef</code> 可与 <code>#else</code> / <code>#elif</code> 结合使用，如下：
</p>
<div class="org-src-container">

<pre class="src src-C">#inlucde &lt;stdio.h&gt;
#define T 10
int main(void)
{
 #ifdef t
 printf(“Hi T\n”);
 #else
 printf(“Hi anyone\n”);
 #endif
 #ifndef M
 printf(“M Not Defined\n”);
 #endif
 Return 0;
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">3.3</span> 3、文件包含</h3>
<div class="outline-text-3" id="text-3-3">
</div><div id="outline-container-orgheadline12" class="outline-4">
<h4 id="orgheadline12"><span class="section-number-4">3.3.1</span> <code>#include</code> 指令</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
用于文件包含. 含义是要求编译程序读入另一个源文件。在 <code>#include</code> 命令所在的行不能含有除注释和空白符之外的其他任何内容。一般形式：
</p>
<pre class="example">
#include "headfile"
#include &lt;headfile&gt;
#include 预处理标记
</pre>

<p>
前面两种形式大家都很熟悉，被读入文件的名字必须用双引号(<code>“”</code>)或一对尖括号(<code>&lt;&gt;</code>)包围，例如：
</p>
<div class="org-src-container">

<pre class="src src-C">#include “stdio.h”
#include &lt;stdio.h&gt;
</pre>
</div>
<p>
表示都使C编译程序读入并编译头文件以用于I/O系统库函数。
</p>

<p>
在 <code>#include 预处理标记</code> 形式中, 预处理标记会被预处理器进行替换, 替换的结果必须符合前两种形式中的某一种。
</p>

<p>
包含文件中可以包含其他 <code>#include</code> 指令，称为嵌套包含。允许的最大嵌套深度随编译器而变。
</p>

<p>
被包含文件名用双引号或尖括号包围决定了对指定文件的搜索方式。当文件名被尖括号包围时，搜索按编译程序(如 <code>gcc</code>)作者的定义进行，一般用于搜索某些专门放置包含文件的特殊目录。当文件名被双引号包围时，搜索按编译程序实时的规定进行，一般搜索当前目录。如未发现，再按尖括号包围时的办法重新搜索一次。通常，绝大多数程序员使用尖括号包围标准的头文件，双引号用于包围与当前程序相关的文件名。
</p>

<p>
实际上, 真正被添加的头文件并不一定就是 <code>#include</code> 中所指定的文件。 <code>#include "headfile"= 包含的头文件当然是同一个文件, 但 =#include &lt;headfile&gt;</code> 包包含的"系统头文件"可能是另外的文件. 但这不值得被注意. 感兴趣的话可以查看宏扩展后到底引入了哪些系统头文件。
</p>

<p>
关于 <code>#include "headfile"和#include &lt;headfile&gt;</code> 的区别以及如何在 <code>gcc</code> 中包含头文件的详细信息, 具体需要参考GCC相关的文档。
</p>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-4">
<h4 id="orgheadline13"><span class="section-number-4">3.3.2</span> <code>#include_next</code> 指令</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
相对于 <code>#include</code>, 我们对 <code>#include_next</code> 不太熟悉。 <code>#include_next</code> 仅用于特殊的场合. 它被用于头文件中(<code>#include</code> 既可用于头文件中, 又可用于 <code>.c</code> 文件中)来包含其他的头文件. 而且包含头文件的路径比较特殊: 从当前头文件所在目录之后的目录来搜索头文件。
</p>

<p>
比如: 
</p>
<pre class="example">
若头文件的搜索路径依次为 =A,B,C,D,E=, 而 =#include_next= 所在的当前头文件位于 =B= 目录, 
那么 =#include_next= 使得预处理器从 =C,D,E= 目录来搜索 =#include_next= 所指定的头文件。
</pre>

<p>
可参考预处理命令 <code>cpp</code> 的手册进一步了解 <code>#include_next</code> 。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">3.4</span> 4、预定义宏</h3>
<div class="outline-text-3" id="text-3-4">
<p>
标准C中定义了一些对象宏, 这些宏的名称以 <code>__</code> 开头和结尾, 并且都是大写字符. 这些预定义宏可以被 <code>#undef</code>, 也可以被重定义。
</p>

<p>
下面列出一些标准C中常见的预定义对象宏(其中也包含gcc自己定义的一些预定义宏:
</p>
<pre class="example">
__LINE__         当前语句所在的行号, 以10进制整数标注.
__FILE__         当前源文件的文件名, 以字符串常量标注.
__DATE__          程序被编译的日期, 以"Mmm dd yyyy"格式的字符串标注.
__TIME__           程序被编译的时间, 以"hh:mm:ss"格式的字符串标注, 该时间由asctime返回.

__STDC__           如果当前编译器符合ISO标准, 那么该宏的值为1
__STDC_VERSION__   如果当前编译器符合C89, 那么它被定义为199409L, 如果符合C99, 那么被定义为199901L.
                   我用gcc, 如果不指定-std=c99, 其他情况都给出__STDC_VERSION__未定义的错误信息, 咋回事呢?
__STDC_HOSTED__     如果当前系统是"本地系统(hosted)", 那么它被定义为1. 本地系统表示当前系统拥有完整的标准C库.
</pre>

<p>
另外， <code>gcc</code> 定义的预定义宏:
</p>
<pre class="example">
__OPTMIZE__         如果编译过程中使用了优化, 那么该宏被定义为1.
__OPTMIZE_SIZE__   同上, 但仅在优化是针对代码大小而非速度时才被定义为1.
__VERSION__         显示所用gcc的版本号.
</pre>
<p>
具体可参考 <code>GCC the complete reference</code> 。
</p>

<p>
要想看到 <code>gcc</code> 所定义的所有预定义宏, 可以运行: 
</p>
<div class="org-src-container">

<pre class="src src-sh">$cpp -dM /dev/null
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3">3.5</span> 5、扩展控制</h3>
<div class="outline-text-3" id="text-3-5">
</div><div id="outline-container-orgheadline16" class="outline-4">
<h4 id="orgheadline16"><span class="section-number-4">3.5.1</span> <code>#line</code></h4>
<div class="outline-text-4" id="text-3-5-1">
<p>
<code>#line</code> 指令用来修改 <code>__LINE__</code> 和 <code>__FILE__</code> 的内容。前面介绍了， <code>__LINE__和__FILE__</code> 都是编译程序中预定义的标识符。标识符 <code>__LINE__</code> 的内容是当前被编译代码行的行号，=__FILE__= 的内容是当前被编译源文件的文件名。 <code>#line</code> 的一般形式是：
</p>
<pre class="example">
#line number “filename”
</pre>
<p>
其中， <code>number</code> 是正整数并变成 <code>__LINE__</code> 的新值；可选的 <code>filename</code> 是合法文件标识符并变成 <code>__FILE__</code> 的新值。 <code>#line</code> 主要用于调试和特殊应用。
</p>

<p>
常见的使用：
</p>
<div class="org-src-container">

<pre class="src src-C">printf("line: %d, file: %s\n", __LINE__, __FILE__);
#line 100 "haha"
printf("line: %d, file: %s\n", __LINE__, __FILE__);
printf("line: %d, file: %s\n", __LINE__, __FILE__);
</pre>
</div>
<p>
以上代码，输出显示:
</p>
<pre class="example">
line: 34, file: 1.c
line: 100, file: haha
line: 101, file: haha
</pre>

<p>
一个完整的例子， <code>main.cpp</code> 文件内容如下:
</p>
<div class="org-src-container">

<pre class="src src-C"> 1 #include&lt;iostream&gt;
 2 using std::cout;
 3 using std::cin;
 4 using std::endl;
 5 #line 2 "myfile.h"
 6 int main(int argc, char *argv[])
 7 {
 8     cout&lt;&lt;__LINE__&lt;&lt;":"&lt;&lt;__FILE__&lt;&lt;endl;
 9     return 0;
10 }
</pre>
</div>
<p>
上述代码编译运行输出如下：
</p>
<div class="org-src-container">

<pre class="src src-sh">[quietheart@lv-k pre_test]$ ls
main.cpp
[quietheart@lv-k pre_test]$ make main
g++     main.cpp   -o main
[quietheart@lv-k pre_test]$ ls
main  main.cpp
[quietheart@lv-k pre_test]$ ./main 
4:myfile.h
</pre>
</div>
<p>
由上面输出可以看出，
</p>
<ul class="org-ul">
<li><code>__LINE__</code> 的内容变成了相对 <code>#line</code> 宏的内容，即 <code>#line</code> 下面的第一行就是 <code>#line</code> 指定的2;</li>
<li>同时 <code>__FILE__</code> 变成了 <code>#line</code> 指定的 <code>myfile.h</code> 。</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-4">
<h4 id="orgheadline17"><span class="section-number-4">3.5.2</span> <code>#pragma, _Pragma</code></h4>
<div class="outline-text-4" id="text-3-5-2">
<p>
<code>#pragma</code> 编译器用来添加新的预处理功能或者显示一些编译信息. 是编译程序实现时定义的指令，它允许由此向编译程序传入各种指令。
</p>

<p>
例如： 
</p>
<pre class="example">
一个编译程序可能具有支持跟踪程序执行的选项，此时可以用 =#pragma= 语句选择该功能。
</pre>

<p>
编译程序忽略其不支持的 <code>#pragma</code> 选项， <code>#pragma</code> 提高C源程序对编译程序的可移植性。
</p>

<p>
<code>#pragma</code> 的格式是各编译器特定的,  <code>gcc</code> 的如下:
</p>
<pre class="example">
#pragma GCC name token(s)
</pre>

<p>
<code>#pragma</code> 之后有两个部分:  <code>GCC</code> 和特定的 <code>pragma name</code> 。
</p>

<p>
下面分别介绍 <code>gcc</code> 中常用的。
</p>
</div>
<div id="outline-container-orgheadline67" class="outline-5">
<h5 id="orgheadline67"><span class="section-number-5">3.5.2.1</span> (1) <code>#pragma GCC dependency</code></h5>
<div class="outline-text-5" id="text-3-5-2-1">
<p>
<code>dependency</code> 测试当前文件(既该语句所在的程序代码)与指定文件(既 <code>#pragma</code> 语句最后列出的文件)的时间戳。 如果指定文件比当前文件新, 则给出警告信息。
</p>

<p>
e.g. 在 <code>demo.c</code> 中给出这样一句:
</p>
<div class="org-src-container">

<pre class="src src-C">#pragma GCC dependency "temp-file"
</pre>
</div>
<p>
然后在 <code>demo.c</code> 所在的目录新建一个更新的文件: 
</p>
<div class="org-src-container">

<pre class="src src-sh">$touch temp-file
</pre>
</div>
<p>
编译:
</p>
<div class="org-src-container">

<pre class="src src-sh">$gcc demo.c
</pre>
</div>
<p>
会给出这样的警告信息:  <code>warning: current file is older than temp-file</code>
</p>

<p>
如果当前文件比指定的文件新, 则不给出任何警告信息。
</p>

<p>
还可以在在 <code>#pragma</code> 中给添加自定义的警告信息。
</p>

<p>
e.g.
</p>
<div class="org-src-container">

<pre class="src src-C">#pragma GCC dependency "temp-file" "demo.c needs to be updated!"
</pre>
</div>
<p>
可能会有如下警告
</p>
<pre class="example">
1.c:27:38: warning: extra tokens at end of #pragma directive
1.c:27:38: warning: current file is older than temp-file
</pre>
<p>
注意: 后面新增的警告信息要用""引用起来, 否则 <code>gcc</code> 将给出警告信息。
</p>
</div>
</div>

<div id="outline-container-orgheadline68" class="outline-5">
<h5 id="orgheadline68"><span class="section-number-5">3.5.2.2</span> (2) <code>#pragma GCC poison token(s)</code></h5>
<div class="outline-text-5" id="text-3-5-2-2">
<p>
若源代码中出现了 <code>#pragma</code> 中给出的 <code>token(s)</code> , 则编译时显示警告信息. 它一般用于在调用你不想使用的函数时候给出出错信息。
</p>

<p>
e.g.
</p>
<div class="org-src-container">

<pre class="src src-C">#pragma GCC poison scanf
scanf("%d", &amp;a);
</pre>
</div>
<p>
会输出如下：
</p>
<pre class="example">
warning: extra tokens at end of #pragma directive
error: attempt to use poisoned "scanf"
</pre>
<p>
注意, 如果调用了 <code>poison</code> 中给出的标记, 那么编译器会给出的是出错信息. 关于第一条警告, 我还不知道怎么避免, 用""将 <code>token(s)</code> 引用起来也不行.
</p>
</div>
</div>

<div id="outline-container-orgheadline69" class="outline-5">
<h5 id="orgheadline69"><span class="section-number-5">3.5.2.3</span> (3) <code>#pragma GCC system_header</code></h5>
<div class="outline-text-5" id="text-3-5-2-3">
<p>
从 <code>#pragma GCC system_header</code> 直到文件结束之间的代码会被编译器视为系统头文件之中的代码. 系统头文件中的代码往往不能完全遵循C标准, 所以头文件之中的警告信息往往不显示. (除非用 <code>#warning</code> 显式指明)。
</p>

<p>
(这条 <code>#pragma</code> 语句还没发现用什么大的用处)
</p>
</div>
</div>

<div id="outline-container-orgheadline70" class="outline-5">
<h5 id="orgheadline70"><span class="section-number-5">3.5.2.4</span> <code>_Pragma</code> 实现将 <code>#pragma</code> 用于宏扩展</h5>
<div class="outline-text-5" id="text-3-5-2-4">
<p>
由于 <code>#pragma</code> 不能用于宏扩展, 所以gcc还提供了 <code>_Pragma</code> :
</p>

<p>
e.g.
</p>
<div class="org-src-container">

<pre class="src src-C">#define PRAGMA_DEP #pragma GCC dependency "temp-file"
</pre>
</div>
<p>
由于预处理之时进行一次宏扩展, 采用上面的方法会在编译时引发错误, 要将 <code>#pragma</code> 语句定义成一个宏扩展, 应该使用下面的 <code>_Pragma</code> 语句:
</p>
<div class="org-src-container">

<pre class="src src-C">#define PRAGMA_DEP _Pragma("GCC dependency \"temp-file\"")
</pre>
</div>
<p>
注意, <code>()</code> 中包含的""引用之前引该加上\转义字符.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-4">
<h4 id="orgheadline18"><span class="section-number-4">3.5.3</span> <code>#warning, #error</code></h4>
<div class="outline-text-4" id="text-3-5-3">
<p>
<code>#warning, #error</code> 分别用于在编译时显示警告和错误信息, 格式如下:
</p>
<pre class="example">
#warning tokens
#error tokens
</pre>

<p>
注意,  <code>#error</code> 和 <code>#warning</code> 后的 <code>token</code> 要用""引用起来!
</p>

<p>
在 <code>gcc</code> 中, 
</p>
<ul class="org-ul">
<li>如果给出了 <code>warning</code> , 编译继续进行,</li>
<li>但若给出了 <code>error</code> , 则编译停止，</li>
<li>若在命令行中指定了 <code>-Werror</code> ( <code>gcc</code> 手册上意思是将所有 <code>warning</code> 变为 <code>error</code> ), 即使只有警告信息, 也不编译.</li>
</ul>
</div>

<div id="outline-container-orgheadline71" class="outline-5">
<h5 id="orgheadline71"><span class="section-number-5">3.5.3.1</span> <code>#warning</code> 指令</h5>
<div class="outline-text-5" id="text-3-5-3-1">
<p>
e.g.
</p>
<div class="org-src-container">

<pre class="src src-C">#warning "some warning"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline72" class="outline-5">
<h5 id="orgheadline72"><span class="section-number-5">3.5.3.2</span> <code>error</code> 指令</h5>
<div class="outline-text-5" id="text-3-5-3-2">
<p>
<code>#error</code> 指令强制编译程序停止编译，它主要用于程序调试。 <code>#error</code> 指令的一般形式是：
</p>
<pre class="example">
#error error-message
</pre>
<p>
注意，宏串 <code>error-message</code> 不用双引号包围。遇到 <code>#error</code> 指令时，错误信息被显示，可能同时还显示编译程序作者预先定义的其他内容。
</p>

<p>
例如 <code>main.cpp</code> 文件内容如下：
</p>
<div class="org-src-container">

<pre class="src src-C++"> 1 #include&lt;iostream&gt;
 2 using std::cout;
 3 using std::cin;
 4 using std::endl;
 5 #ifdef MMM
 6 #error myerror //如果执行了这个就会阻止编译通过
 7 #endif
 8 int main(int argc, char *argv[])
 9 {
10     cout&lt;&lt;"hello world!"&lt;&lt;endl;
11     return 0;
12 }
</pre>
</div>
<p>
编译过程如下：
</p>
<div class="org-src-container">

<pre class="src src-sh">[quietheart@lv-k pre_test]$ ls
main.cpp
[quietheart@lv-k pre_test]$ make CXXFLAGS+=-DMMM pre_error
g++ -DMMM    pre_error.cpp   -o pre_error
pre_error.cpp:6:2: error: #error myerror
 #error myerror //如果执行了这个就会阻止编译通过
  ^~~~~
&lt;内置&gt;: recipe for target 'pre_error' failed
make: *** [pre_error] Error 1
[quietheart@lv-k pre_test]$ ls
main.cpp
[quietheart@lv-k pre_test]$ make main
g++     main.cpp   -o main
[quietheart@lv-k pre_test]$ ls
main  main.cpp
[quietheart@lv-k pre_test]$ ./main 
hello world!
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline19" class="outline-2">
<h2 id="orgheadline19"><span class="section-number-2">4</span> C语言常用宏定义</h2>
<div class="outline-text-2" id="text-4">
<p>
这里给出C语言中一些常用的宏定义。
</p>
</div>
<div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20"><span class="section-number-3">4.1</span> 01: 防止一个头文件被重复包含</h3>
<div class="outline-text-3" id="text-4-1">
<div class="org-src-container">

<pre class="src src-C">#ifndef COMDEF_H
#define COMDEF_H
//头文件内容
#endif
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21"><span class="section-number-3">4.2</span> 02: 重新定义一些类型,防止由于各种平台和编译器的不同,而产生的类型字节数差异,方便移植。</h3>
<div class="outline-text-3" id="text-4-2">
<div class="org-src-container">

<pre class="src src-C">typedef  unsigned char      boolean;     /* Boolean value type. */
typedef  unsigned long int  uint32;      /* Unsigned 32 bit value */
typedef  unsigned short     uint16;      /* Unsigned 16 bit value */
typedef  unsigned char      uint8;       /* Unsigned 8  bit value */
typedef  signed long int    int32;       /* Signed 32 bit value */
typedef  signed short       int16;       /* Signed 16 bit value */
typedef  signed char        int8;        /* Signed 8  bit value */

//下面的不建议使用
typedef  unsigned char     byte;         /* Unsigned 8  bit value type. */
typedef  unsigned short    word;         /* Unsinged 16 bit value type. */
typedef  unsigned long     dword;        /* Unsigned 32 bit value type. */
typedef  unsigned char     uint1;        /* Unsigned 8  bit value type. */
typedef  unsigned short    uint2;        /* Unsigned 16 bit value type. */
typedef  unsigned long     uint4;        /* Unsigned 32 bit value type. */
typedef  signed char       int1;         /* Signed 8  bit value type. */
typedef  signed short      int2;         /* Signed 16 bit value type. */
typedef  long int          int4;         /* Signed 32 bit value type. */
typedef  signed long       sint31;       /* Signed 32 bit value */
typedef  signed short      sint15;       /* Signed 16 bit value */
typedef  signed char       sint7;        /* Signed 8  bit value */
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline22" class="outline-3">
<h3 id="orgheadline22"><span class="section-number-3">4.3</span> 03: 得到指定地址上的一个字节或字</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">

<pre class="src src-C">#define  MEM_B(x) (*((byte *)(x)))
#define  MEM_W(x) (*((word *)(x)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23"><span class="section-number-3">4.4</span> 04: 求最大值和最小值</h3>
<div class="outline-text-3" id="text-4-4">
<div class="org-src-container">

<pre class="src src-C">#define  MAX(x,y) (((x)&gt;(y)) ? (x) : (y))
#define  MIN(x,y) (((x) &lt; (y)) ? (x) : (y))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline24" class="outline-3">
<h3 id="orgheadline24"><span class="section-number-3">4.5</span> 05: 得到一个field在结构体(struct)中的偏移量</h3>
<div class="outline-text-3" id="text-4-5">
<div class="org-src-container">

<pre class="src src-C">#define FPOS(type,field) ((dword)&amp;((type *)0)-&gt;field)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline25" class="outline-3">
<h3 id="orgheadline25"><span class="section-number-3">4.6</span> 06: 得到一个结构体中field所占用的字节数</h3>
<div class="outline-text-3" id="text-4-6">
<div class="org-src-container">

<pre class="src src-C">#define FSIZ(type,field) sizeof(((type *)0)-&gt;field)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline26" class="outline-3">
<h3 id="orgheadline26"><span class="section-number-3">4.7</span> 07: 按照LSB格式把两个字节转化为一个Word</h3>
<div class="outline-text-3" id="text-4-7">
<div class="org-src-container">

<pre class="src src-C">#define FLIPW(ray) ((((word)(ray)[0]) * 256) + (ray)[1])
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline27" class="outline-3">
<h3 id="orgheadline27"><span class="section-number-3">4.8</span> 08: 按照LSB格式把一个Word转化为两个字节</h3>
<div class="outline-text-3" id="text-4-8">
<div class="org-src-container">

<pre class="src src-C">#define FLOPW(ray,val) (ray)[0] = ((val)/256); (ray)[1] = ((val) &amp; 0xFF)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline28" class="outline-3">
<h3 id="orgheadline28"><span class="section-number-3">4.9</span> 09: 得到一个变量的地址（word宽度）</h3>
<div class="outline-text-3" id="text-4-9">
<div class="org-src-container">

<pre class="src src-C">#define B_PTR(var)  ((byte *) (void *) &amp;(var))
#define W_PTR(var)  ((word *) (void *) &amp;(var))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline29" class="outline-3">
<h3 id="orgheadline29"><span class="section-number-3">4.10</span> 10: 得到一个字的高位和低位字节</h3>
<div class="outline-text-3" id="text-4-10">
<div class="org-src-container">

<pre class="src src-C">#define WORD_LO(xxx)  ((byte) ((word)(xxx) &amp; 255))
#define WORD_HI(xxx)  ((byte) ((word)(xxx) &gt;&gt; 8))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline30" class="outline-3">
<h3 id="orgheadline30"><span class="section-number-3">4.11</span> 11: 返回一个比X大的最接近的8的倍数</h3>
<div class="outline-text-3" id="text-4-11">
<div class="org-src-container">

<pre class="src src-C">#define RND8(x) ((((x) + 7)/8) * 8)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline31" class="outline-3">
<h3 id="orgheadline31"><span class="section-number-3">4.12</span> 12: 将一个字母转换为大写</h3>
<div class="outline-text-3" id="text-4-12">
<div class="org-src-container">

<pre class="src src-C">#define UPCASE(c) (((c)&gt;='a' &amp;&amp; (c) &lt;= 'z') ? ((c) - 0x20) : (c))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline32" class="outline-3">
<h3 id="orgheadline32"><span class="section-number-3">4.13</span> 13: 判断字符是不是10进值的数字</h3>
<div class="outline-text-3" id="text-4-13">
<div class="org-src-container">

<pre class="src src-C">#define  DECCHK(c) ((c)&gt;='0' &amp;&amp; (c)&lt;='9')
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline33" class="outline-3">
<h3 id="orgheadline33"><span class="section-number-3">4.14</span> 14: 判断字符是不是16进值的数字</h3>
<div class="outline-text-3" id="text-4-14">
<div class="org-src-container">

<pre class="src src-C">#define HEXCHK(c) (((c) &gt;= '0' &amp;&amp; (c)&lt;='9') ((c)&gt;='A' &amp;&amp; (c)&lt;= 'F') \
((c)&gt;='a' &amp;&amp; (c)&lt;='f'))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline34" class="outline-3">
<h3 id="orgheadline34"><span class="section-number-3">4.15</span> 15: 防止溢出的一个方法</h3>
<div class="outline-text-3" id="text-4-15">
<div class="org-src-container">

<pre class="src src-C">#define INC_SAT(val) (val=((val)+1&gt;(val)) ? (val)+1 : (val))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline35" class="outline-3">
<h3 id="orgheadline35"><span class="section-number-3">4.16</span> 16: 返回数组元素的个数</h3>
<div class="outline-text-3" id="text-4-16">
<div class="org-src-container">

<pre class="src src-C">#define ARR_SIZE(a)  (sizeof((a))/sizeof((a[0])))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline36" class="outline-3">
<h3 id="orgheadline36"><span class="section-number-3">4.17</span> 17: 返回一个无符号数n尾的值MOD_BY_POWER_OF_TWO(X,n)=X%(2^n)</h3>
<div class="outline-text-3" id="text-4-17">
<div class="org-src-container">

<pre class="src src-C">#define MOD_BY_POWER_OF_TWO( val, mod_by ) ((dword)(val) &amp; (dword)((mod_by)-1))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline37" class="outline-3">
<h3 id="orgheadline37"><span class="section-number-3">4.18</span> 18: 对于IO空间映射在存储空间的结构,输入输出处理</h3>
<div class="outline-text-3" id="text-4-18">
<div class="org-src-container">

<pre class="src src-C">#define inp(port) (*((volatile byte *)(port)))
#define inpw(port) (*((volatile word *)(port)))
#define inpdw(port) (*((volatile dword *)(port)))
#define outp(port,val) (*((volatile byte *)(port))=((byte)(val)))
#define outpw(port, val) (*((volatile word *)(port))=((word)(val)))
#define outpdw(port, val) (*((volatile dword *)(port))=((dword)(val)))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline38" class="outline-3">
<h3 id="orgheadline38"><span class="section-number-3">4.19</span> 19: 使用一些宏跟踪调试</h3>
<div class="outline-text-3" id="text-4-19">
<p>
ANSI标准说明了五个预定义的宏名。它们是：
</p>
<div class="org-src-container">

<pre class="src src-C">__LINE__
__FILE__
__DATE__
__TIME__
__STDC__
</pre>
</div>
<p>
C++中还定义了 <code>__cplusplus</code>
</p>

<p>
如果编译器不是标准的,则可能仅支持以上宏名中的几个,或根本不支持。记住编译程序也许还提供其它预定义的宏名。
</p>
<pre class="example">
__LINE__ 及 __FILE__ 宏指示，#line指令可以改变它的值，简单的讲，编译时，它们包含程序的当前行数和文件名。
__DATE__ 宏指令含有形式为月/日/年的串,表示源文件被翻译到代码时的日期。
__TIME__ 宏指令包含程序编译的时间。时间用字符串表示，其形式为： 分：秒
__STDC__ 宏指令的意义是编译时定义的。一般来讲，如果__STDC__已经定义，编译器将仅接受不包含任何非标准扩展的标准C/C++代码。如果实现是标准的,则宏__STDC__含有十进制常量1。如果它含有任何其它数,则实现是非标准的。
__cplusplus 与标准c++一致的编译器把它定义为一个包含至少6为的数值。与标准c++不一致的编译器将使用具有5位或更少的数值。
</pre>

<p>
可以定义宏,例如:当定义了 <code>_DEBUG</code> ,输出数据信息和所在文件所在行
</p>
<div class="org-src-container">

<pre class="src src-C">#ifdef _DEBUG
#define DEBUGMSG(msg,date) printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_)
#else
#define DEBUGMSG(msg,date)
#endif
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline39" class="outline-3">
<h3 id="orgheadline39"><span class="section-number-3">4.20</span> 20：宏定义防止错误使用小括号包含。</h3>
<div class="outline-text-3" id="text-4-20">
<p>
例如：
有问题的定义： 
</p>
<div class="org-src-container">

<pre class="src src-C">#define DUMP_WRITE(addr,nr) {memcpy(bufp,addr,nr); bufp += nr;}
</pre>
</div>

<p>
应该使用的定义： 
</p>
<div class="org-src-container">

<pre class="src src-C">#difne DO(a,b) do{a+b;a++;}while(0)
</pre>
</div>

<p>
例如：
</p>
<div class="org-src-container">

<pre class="src src-C">if(addr)
    DUMP_WRITE(addr,nr);
else
    do_somethong_else();
</pre>
</div>
<p>
宏展开以后变成这样:
</p>
<div class="org-src-container">

<pre class="src src-C">if(addr)
    {memcpy(bufp,addr,nr); bufp += nr;};
else
    do_something_else();
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline40" class="outline-2">
<h2 id="orgheadline40"><span class="section-number-2">5</span> 其它</h2>
<div class="outline-text-2" id="text-5">
<p>
主要参考：
</p>
<ul class="org-ul">
<li><a href="http://blog.sina.com.cn/s/blog_474b787d0100dyy0.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_474b787d0100dyy0.html</a></li>
<li><a href="http://ahead.yo2.cn/" target="_blank" rel="noopener">http://ahead.yo2.cn/</a></li>
</ul>
</div>
</div>

                    </div>
                </article>                        
                
                <!--{% include duoshuo_comment.ext %}-->
            </td>
        </tr>
        <tr>
            <td id="td_page_footer" colspan="6">
    <footer>
        &copy 2015
    </footer>
    <a id="bottom"></a>
</td>
        </tr>
    </tbody>
</table>
    </main>
  </body>
</html>