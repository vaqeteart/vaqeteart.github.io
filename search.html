<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
<title>搜索结果</title>

<!--theme-->
<link rel="stylesheet" type="text/css"
  href="/assets/css/common_green_black.css" media="screen" />
<script src="/assets/js/jquery-1.11.3.min.js"></script>
<script src="/assets/js/common.js"></script>
<script src="/assets/js/category_list.js"></script>


    <link rel="stylesheet" type="text/css"
      href="/assets/css/search.css" media="screen" />
  </head>

  <body>
        <table class="container">
            <tbody id="tb_container">
	      <tr id="tr_navbar">
		<script src="/assets/js/nav.js"></script>
<th id="th_navbar">
    <table class="navbar"> <tbody> <tr>
	<th class="navitm">
	    <a href='/'>主页</a>
	</th>

	<th class="navblank">
	</th>

	<th class="navitm">
	      <a href=/search.html>分类</a>
	      <div id="category_menus" class="second">
  	      	   

		   <script>
		       var categories = {"id":"categories","path":"/","title":"分类","parent":null,"children":{"note":{"id":"categories_note","path":"/categories/note","title":"记事","parent":"categories","children":{"remind":{"id":"categories_note_remind","path":"/categories/note/remind","title":"备忘","parent":"categories_note","children":null},"plan":{"id":"categories_note_plan","path":"/categories/note/plan","title":"计划","parent":"categories_note","children":null}}},"study":{"id":"categories_study","path":"/categories/study","title":"学习","parent":"categories","children":{"problem":{"id":"categories_study_problem","path":"/categories/study/problem","title":"问题","parent":"categories_study","children":null},"git":{"id":"categories_study_git","path":"/categories/study/git","title":"git","parent":"categories_study","children":null},"os":{"id":"categories_study_os","path":"/categories/study/os","title":"操作系统","parent":"categories_study","children":null},"books":{"id":"categories_study_books","path":"/categories/study/books","title":"books","parent":"categories_study","children":{"apue":{"id":"categories_study_books_apue","path":"/categories/study/books/apue","title":"APUE","parent":"categories_study_books","children":null}}},"linux":{"id":"categories_study_linux","path":"/categories/study/linux","title":"linux","parent":"categories_study","children":{"misc":{"id":"categories_study_linux_misc","path":"/categories/study/linux/misc","title":"杂乱","parent":"categories_study_linux","children":null},"command":{"id":"categories_study_linux_command","path":"/categories/study/linux/command","title":"命令","parent":"categories_study_linux","children":null}}},"jekyll":{"id":"categories_study_jekyll","path":"/categories/study/jekyll","title":"jekyll","parent":"categories_study","children":null},"kits":{"id":"categories_study_kits","path":"/categories/study/kits","title":"工具","parent":"categories_study","children":null},"emacs":{"id":"categories_study_emacs","path":"/categories/study/emacs","title":"emacs","parent":"categories_study","children":null},"vim":{"id":"categories_study_vim","path":"/categories/study/vim","title":"vim","parent":"categories_study","children":null}}},"work":{"id":"categories_work","path":"/categories/work","title":"工作","parent":"categories","children":{"progress":{"id":"categories_work_progress","path":"/categories/work/progress","title":"进度","parent":"categories_work","children":null}}},"life":{"id":"categories_life","path":"/categories/life","title":"生活","parent":"categories","children":{"experience":{"id":"categories_life_experience","path":"/categories/life/experience","title":"经验","parent":"categories_life","children":null},"tips":{"id":"categories_life_tips","path":"/categories/life/tips","title":"技巧","parent":"categories_life","children":null}}},"others":{"id":"categories_others","path":"/categories/others","title":"其它","parent":"categories","children":{"rambles":{"id":"categories_others_rambles","path":"/categories/others/rambles","title":"随笔","parent":"categories_others","children":null},"temp":{"id":"categories_others_temp","path":"/categories/others/temp","title":"临时","parent":"categories_others","children":null},"test":{"id":"categories_others_test","path":"/categories/others/test","title":"测试","parent":"categories_others","children":null}}}}};
		       var categories_count = JSON.parse('{"/categories":0}');

  		       
    		       var post_categories = '/categories/study/linux/misc/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/kits';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/misc';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/os';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/note';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/note';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/emacs';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/emacs';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/life';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/git';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others/rambles';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others/rambles';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			

    			create_category_menu(categories, 0, categories_count);
    			//document.write("hello")
		    </script>
	      </div>
	</th>

        <th class="navitm">
	      <a href='#'>标签</a>
	      <div id="tag_menus" class="second">
	          
		      <a id="gtd_next" href="#"> gtd_next(13)</a>
		  
		      <a id="study" href="#"> study(10)</a>
		  
		      <a id="gtd_done" href="#"> gtd_done(4)</a>
		  
		      <a id="others" href="#"> others(3)</a>
		  
		      <a id="life" href="#"> life(1)</a>
		  
	      </div>
        </th>

	<th class="navblank">
	</th>

	<th class="navitm">
	      <a href=/more.html>更多</a>
        </th>

        <th class="navitm">
	      <a href=/about.html>关于</a>
        </th>

	<th class="navblank" style="width:25%;">
	</th>

	<th class="navitm" style="margin:0; padding:0;border:none;">
	    <form method="get" id="searchform" action="/search.html" style="margin:0;padding:0;height:100%;">
	    	  <span style= "color:#00FF00;">Q</span>
	    	  <span style="border-style:solid; border-width:1px; border-color:#00FF00;
		  		border-top:0px; border-left:0px;border-right:0px; 
				margin:0;padding:0;height:100%;">
				<input value="Search in title..." name="s" class="s" 
		  	 	onfocus="if (this.value == 'Search in title...') {this.value = '';}" 
		  	 	onblur="if (this.value == '') {this.value = 'Search in title...';}"
			 	style="margin:0;padding:0;height:100%;border:none;background: #000000; color:#00A600;" 
			 	type="text">
		  </span>
		  <!--input type="submit" value="Q" style="width:20%;"-->
	    </form>
	</th>

	<th class="navblank">
	</th>

	<th class="navblank">
	</th>

	<a href='#' id="topbtn">⇑</a>

	<a href='#bottom' id="bottombtn">⇓</a>
	<!--⇐⇑⇒⇓-->

  <tr> </tbody> </table>
</th>

	      </tr>
	      <tr>
                  <td id="td_page_header" colspan="6" valign="top" align="right" style="width:100%;">
    <header style="text-align: center;">
	<h1>
	       <a href="/" title="Home Page">
	       QuietHeart's Site
	       </a>
	</h1>
    </header>
</td>



	      </tr>
	      <tr id="tr_page_nav">
		<td colspan="6" valign="bottom">
		  

<!--div id="pagination">
     <div class="pagenavi">
	<span class="page_number">第页/共页</span>
	<a href="/">第一页</a>
	
		<span><<前一页</span>
	
	
	

	
	   <span>后一页>></span>
	
	
	<a href="/page">最后一页</a>
     </div>
</div-->

		</td>
	      </tr>
              <tr id="tr_page_content">
                <td id="td_posts" colspan="6" valign="top">
		  <article>
  <h1 id='header1' style="text-align: center;">搜索结果</h1>
  <hr id='title_line'>
  <div>
    <script>  
	var search = getQuery("s");
	
	   var article = '关于linux中的时间和时区'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 基本概念1.1. 系统时钟和硬件时钟1.2. 硬件时间和系统时间的同步1.3. 时间和时区2. 常用命令3. 配置文件与环境变量4. 库函数5. 应用举例5.1. 在单一进程中修改时区的方法5.2. 时间同步校准6. 其它6.1. 参考这里主要讲述linux中时间和时区相关的原理。包括设置方法、配置、环境变量、以及库函数，及应用举例。1 基本概念1.1 系统时钟和硬件时钟Linux时钟分为系统时钟 （System Clock）和硬件（Real Time Clock，简称RTC）时钟。系统时钟是指当前Linux Kernel中的时钟，而硬件时钟则是主板上由电池供电的时钟，这个硬件时钟可以在BIOS中进行设置。当Linux启动时，硬件时钟会去读取系统时钟的设置，然后系统时钟就会独立于硬件运作。1.2 硬件时间和系统时间的同步重新启动系统，硬件时间会读取系统时间，实现同步，但是在不重新启动的时候，需要用hwclock或clock命令实现同步。1.3 时间和时区UTC：协调世界时，又称世界标准时间，简称UTC，从英文国际时间/法文协调时间”Universal Time/Temps Cordonné”而来。时区：反映与UTC的时差问题，中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与UTC的时差均为+8，也就是UTC+8。各个地区的时间都是UTC结合地区的时区信息得到的。整个地球分为二十四时区，每个时区都有自己的本地时间，他们的关系如下：UTC时间 与 GMT时间我们可以认为格林威治时间就是时间协调时间（GMT = UTC），格林威治时间和UTC时间都用秒数来计算的。UTC时间与本地时间UTC + 时区差 = 本地时间时区差东为正，西为负。UTC与Unix时间戳在计算机中看到的UTC时间都是从（1970年01月01日 0:00:00)开始计算秒数的。所看到的UTC时间那就是从1970年这个时间点起到具体时间共有多少秒。 这个秒数就是Unix时间戳。例如： 本地（北京）在东八区， 东八区时区差记为 +0800，则：本地（北京）时间 = UTC + (+0800)所以，不同地区， 其本地时间各不相同。再如， 对于中国和格林，这两个地区的时区不同，得到的时间也不同。分别如下：CST：中国标准时间（China Standard Time），与UTC时差为8,这个解释可能是针对RedHat Linux。GMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。2 常用命令下面给出的是常见的命令，不同系统可能有不同的命令。有关系统时间的命令: data,ntpupdate有关硬件时钟的命令: hwclock/clock时区相关命令: tzselect3 配置文件与环境变量时区信息一般首先从环境变量中去读，如果没有再从 /etc/TZ 等配置文件中去读。所涉及的配置文件和环境变量可能会根据系统有所不同，一般情况如下：时区的配置文件: etc/localtime (可以是/usr/share/zoneinfo&#x2026;的软链接), /etc/TZ, /etc/sysconfig/clock环境变量： TZ, 使用举例如下:bash中   export TZ="Europe/Moscow"        date -u -s "2011-10-29 21:55:00"cshell中 setenv TZ Europe/Moscow4 库函数这些为有关时间时区的常见系统库函数。time_t time(time_t *t)返回 time_t 类型，值为UTC时间从0时0分0秒算起到现在所经过的秒数。struct tm*gmtime(const time_t*timep)根据传入的 time_t 返回类型为 struct tm 结构，包含时、分、秒、日、周、月、年、日光节约时间标记等信息的时间表示，该时间为GMT时间，未经时区转换。struct tm *localtime(const time_t * timep)根据传入的 time_t 返回类型为 struct tm 结构，包含时、分、秒、日、周、月、年、日光节约时间标记等信息的时间表示，该时间为当地时间，已经时区转换。time_t mktime(struct tm * timeptr)将 struct tm 类型的时间转换为  time_t 类型，值为UTC时间从0时0分0秒算起到现在所经过的秒数。char *ctime(const time_t *timep)将传入的 time_t 类型时间转化为现实世界中的字符串表示形式，例如： Fri, 16 Oct 2015 23:12:18 +0800char * asctime(const struct tm * timeptr)将传入的 struct tm 结构类型时间转化为现实世界中的字符串表示形式，例如： Fri Oct 16 15:15:54 2015int gettimeofday ( struct timeval * tv , struct timezone * tz )返回当前时间信息， struct timeval *tv 存放秒和微秒信息， struct timezone *tz 存放时区信息。int settimeofday ( const struct timeval *tv,const struct timezone *tz)根据传入的时间信息 struct timeval *tv, 和时区信息 struct timezone *tz 设置当前时间。总之，time_t 是用秒数表示时间一般在系统时间戳中使用（一般就是UTC时间）；struct tm 使用结构体表示时间，在程序中使用（不同时区可能会有不同值）；而现实中使用字符串来表示时间，字符串格式可以定制。时区信息一般首先从环境变量中去读，如果没有再从 /etc/TZ 等配置文件中去读。5 应用举例5.1 在单一进程中修改时区的方法setenv("TZ","Europe/Moscow",1);tzset();5.2 时间同步校准假设安装完系统发现时间与现实时间相差8小时。一般是如下原因：安装系统时选择的时区是上海，而系统启动后把bios时间认为是utc时间，再根据上海所处时区，将时间+8小时给我们。这个时候的bios的时间和软件的时间便出现不一致的情况。一个代表 utc 一个代表我们设置的cst（+8时区）。可做如下调整（例如系统为center os 6）：修改配置文件，将默认环境变量更正为上海所在时区，不使用UTC时间$ vi /etc/sysconfig/clock  ZONE="Asia/Shanghai"UTC=false                          ARC=false这个文件影响系统启动后默认的时间相关环境变量值，这里主要是 UTC=false 这个选项，设置硬件时钟不是跟utc一致。将linux的时区设置为 上海$ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime加载配置时间环境变量的文件之前，需要指定好该文件的软链接位置，通过这个可在各个时区配置文件下通用的 /etc/localtime 软链接，可使系统能够找到刚刚设置的时区配置文件，并设置好相应的环境变量。对准时间ntp$ntpdate 192.43.244.18系统启动之后，系统时间通过 ntpdate 工具在网络上获取到。设置硬件时间和软件时间的一致并校准/sbin/hwclock -systohc通过这个命令，将系统时间同步至硬件始终上，这样我们的linux软件和计算机硬件都是cst时间了－－并且是我们设置的上海时区。6 其它6.1 参考man 3 tzset解决嵌入式Linux中的时区问题linux调整系统时间和时区的方法Linux下设置时区（通过shell设置和程序中设置）及程序中设置环境变量linux时区时间问题ntpLinux时间时区详解与常用时间函数linux修改系统时间和linux查看时区、修改时区的方法      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-02-18 四 15:45]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-02-18]<a href="/categories/study/linux/misc/others/linux_time_timezone.html"> 关于linux中的时间和时区  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = '网文收集201602'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 网文列表1.1. &lt;2016-02-16 二 17:34&gt;  pkg-config的用法1.2. &lt;2016-02-17 三 15:00&gt;  Scientific Toolworks Understand for linux 的下载1.3. &lt;2016-03-02 三 20:00&gt;  Git Submodule 使用完整教程2. 其它2.1. maff存档格式2.2. 分类管理这里列出任何时候任何内容下收集的感觉有用的网文。1 网文列表1.1 &lt;2016-02-16 二 17:34&gt;  pkg-config的用法站内链接：pkg-config_usage.html存档：pkg-config_usage.html.maff1.2 &lt;2016-02-17 三 15:00&gt;  Scientific Toolworks Understand for linux 的下载站内链接: scitools_understand_for_linux.html存档: scitools_understand_for_linux.html.maff1.3 &lt;2016-03-02 三 20:00&gt;  Git Submodule 使用完整教程站内链接：Git_Submodule_tutor-HenryYan.html 存档：Git_Submodule_tutor-HenryYan.html.maff 2 其它2.1 maff存档格式为基于zip格式的maff文档，maff类似微软的mht都是将当前网页保存成单一离线文件的格式.firefox下的MAFF Archive Format插件可以实现保存网页为maff，并且能直接查看对应文件格式.另外maff文件格式实质是zip压缩文件,可以将文件解压之后用普通浏览器打开其中的内容(与直接打开maff格式的区别是普通方式打开的网页缺少了源网址来源的信息提示),亦可将解压后的文件夹重新用zip压缩,重命名为xxx.maff用firefox的MAFF Archive Format插件浏览.当前存放外部引用网页的方式,可以采取maff方式保存(这要求我们只有使用firefox浏览网页),为便于随时浏览,可将保存的文件用zip解压. 需要时再用zip压缩\重命名为maff再打开.2.2 分类管理每个月或几个月整理一次，或者追加文章，将原来的文章整理至特定分类。      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-02-11 四 15:35]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-02-16]<a href="/categories/others/net_articles201602.html"> 网文收集201602  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = '模板文件'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 介绍1.1. 子标题11.2. 子标题2：2. 内容13. 内容24. 其它5. WAIT/FORWARD FAQ [0/4]([0%])5.1. NEXT 问题1？5.2. NEXT 问题2？本文主要描述orgmode导出到jekyll文件的文章的常见格式。1 介绍文章可以以二级标题开始,便于将来父级追加,这一点不知道是否必要.1.1 子标题1子标题内容列表项目1。列表项目2。1.2 子标题2：子标题2的内容2 内容1规整好的内容13 内容2规整好的内容24 其它介绍没有明确规整的内容.5 WAIT/FORWARD FAQ [0/4]([0%])描述该文章中遗留的问题,有待将来解决.5.1 NEXT 问题1？State "NEXT"       from              [2016-02-01 一 15:39]5.2 NEXT 问题2？State "NEXT"       from "NEXT"       [2016-02-01 一 15:40]      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-02-11 四 15:35]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-02-11]<a href="/categories/others/template_file.html"> 模板文件  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = '实用工具'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. WAIT/FORWARD FAQ [0/0]([100%])1.1. LATER encfs1.2. MAYBE/FUTURE ccache 增加编译速度1 WAIT/FORWARD FAQ [0/0]([100%])1.1 LATER encfsState "LATER"      from "INBOX"      [2016-02-09 二 10:05]Capture Time:[2016-01-25 一 18:08]加密文件系统，可以对特定的目录和目录中的文件进行加密。实现方式是通过encfs进行。安装sudo apt-get install encfs挂载加密目录encfs ~/crypt_dir ~/normal_dir卸载加密目录fusermount -u ~/normal_dir修改密码encfsctl参考：https://linux.cn/article-2234-1.html1.2 MAYBE/FUTURE ccache 增加编译速度State "MAYBE/FUTURE" from "INBOX"      [2016-02-09 二 10:15]Capture Time:[2016-01-26 二 11:43]      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-02-09 二 10:08]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-02-09]<a href="/categories/study/kits/useful_tools.html"> 实用工具  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Linux杂乱记录'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. Miscellaneous1.1. &#x2014;&#x2014; [2015-10-28 三 11:32]  Cscope 没有文件的错误------1.2. &#x2014;&#x2014; [2016-01-31 日 11:12]  top再H即可list by thread------1.3. &#x2014;&#x2014; [2016-01-31 日 14:42]  Linux进程状态机与ps关联------1 Miscellaneous1.1 &#x2014;&#x2014; [2015-10-28 三 11:32]  Cscope 没有文件的错误------From:/home/miracle/mydata/orgmode/gtd/next.org参考：http://www.21qa.net/questions/2699/2699Error detected while processing ~/.vimrc:cs_read_prompt EOF: No such file or directoryE609: Cscope error: cscope: cannot read trailer offset from file cscope.outc使用cscope查看程序代码遇到一个问题，就是在配置vim中默认打开cscope.out文件出现如上错误，经google后发现的问题是代码所放的文件夹命名中存在了“空格 ”，解决办法就是将文件夹重命名，用‘-’或英文等符号替代空格。1.2 &#x2014;&#x2014; [2016-01-31 日 11:12]  top再H即可list by thread------From:/home/miracle/mydata/orgmode/gtd/_next.org1.3 &#x2014;&#x2014; [2016-01-31 日 14:42]  Linux进程状态机与ps关联------From:/home/miracle/mydata/orgmode/gtd/_next.org参考：http://www.cnblogs.com/zhaoyl/archive/2012/09/04/2671156.html进程是通过fork系列的系统调用（fork、clone、vfork）来创建的，内核（或内核模块）也可以通过kernel_thread函数创建内核进程。这些创建子进程的函数本质上都完成了相同的功能——将调用进程复制一份，得到子进程。（可以通过选项参数来决定各种资源是共享、还是私有。）那么既然调用进程处于TASK_RUNNING状态（否则，它若不是正在运行，又怎么进行调用？），则子进程默认也处于TASK_RUNNING状态。另外，在系统调用clone和内核函数kernel_thread也接受CLONE_STOPPED选项，从而将子进程的初始状态置为 TASK_STOPPED。　　进程创建后，状态可能发生一系列的变化，直到进程退出。而尽管进程状态有好几种，但是进程状态的变迁却只有两个方向——从TASK_RUNNING状态变为非TASK_RUNNING状态、或者从非TASK_RUNNING状态变为TASK_RUNNING状态。总之，TASK_RUNNING是必经之路，不可能两个非RUN状态直接转换。也就是说，如果给一个TASK_INTERRUPTIBLE状态的进程发送SIGKILL信号，这个进程将先被唤醒（进入TASK_RUNNING状态），然后再响应SIGKILL信号而退出（变为TASK_DEAD状态）。并不会从TASK_INTERRUPTIBLE状态直接退出。　　进程从非TASK_RUNNING状态变为TASK_RUNNING状态，是由别的进程（也可能是中断处理程序）执行唤醒操作来实现的。执行唤醒的进程设置被唤醒进程的状态为TASK_RUNNING，然后将其task_struct结构加入到某个CPU的可执行队列中。于是被唤醒的进程将有机会被调度执行。　　而进程从TASK_RUNNING状态变为非TASK_RUNNING状态，则有两种途径：　　1、响应信号而进入TASK_STOPED状态、或TASK_DEAD状态；　　2、执行系统调用主动进入TASK_INTERRUPTIBLE状态（如nanosleep系统调用）、或TASK_DEAD状态（如exit系统调用）；或由于执行系统调用需要的资源得不到满　　　　 足，而进入TASK_INTERRUPTIBLE状态或TASK_UNINTERRUPTIBLE状态（如select系统调用）。　　显然，这两种情况都只能发生在进程正在CPU上执行的情况下。通过ps命令我们能够查看到系统中存在的进程，以及它们的状态：R(TASK_RUNNING)，可执行状态。只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。只要可执行队列不为空，其对应的CPU就不能偷懒，就要执行其中某个进程。一般称此时的CPU“忙碌”。对应的，CPU“空闲”就是指其对应的可执行队列为空，以致于CPU无事可做。有人问，为什么死循环程序会导致CPU占用高呢？因为死循环程序基本上总是处于TASK_RUNNING状态（进程处于可执行队列中）。除非一些非常极端情况（比如系统内存严重紧缺，导致进程的某些需要使用的页面被换出，并且在页面需要换入时又无法分配到内存……），否则这个进程不会睡眠。所以CPU的可执行队列总是不为空（至少有这么个进程存在），CPU也就不会“空闲”。很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。S(TASK_INTERRUPTIBLE)，可中断的睡眠状态。处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。D(TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态。与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么ps命令看到的进程几乎不会出现TASK_UNINTERRUPTIBLE状态，而总是TASK_INTERRUPTIBLE状态。而TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了（参见《linux异步信号handle浅析》）。在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。（比如read系统调用触发了一次磁盘到用户空间的内存的DMA，如果DMA进行过程中，进程由于响应信号而退出了，那么DMA正在访问的内存可能就要被释放了。）这种情况下的TASK_UNINTERRUPTIBLE状态总是非常短暂的，通过ps命令基本上不可能捕捉到。linux系统中也存在容易捕捉的TASK_UNINTERRUPTIBLE状态。执行vfork系统调用后，父进程将进入TASK_UNINTERRUPTIBLE状态，直到子进程调用exit或exec。通过下面的代码就能得到处于TASK_UNINTERRUPTIBLE状态的进程：#include &lt;unistd.h&gt;void main() {if (!vfork()) sleep(100);}编译运行，然后ps一下：kouu@kouu-one:~/test$ ps -ax | grep a\.out4371 pts/0 D+ 0:00 ./a.out4372 pts/0 S+ 0:00 ./a.out4374 pts/1 S+ 0:00 grep a.out然后我们可以试验一下TASK_UNINTERRUPTIBLE状态的威力。不管kill还是kill -9，这个TASK_UNINTERRUPTIBLE状态的父进程依然屹立不倒。T(TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态。向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。（SIGSTOP与SIGKILL信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）向进程发送一个SIGCONT信号，可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态。当进程正在被跟踪时，它处于TASK_TRACED这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于TASK_TRACED状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。对于进程本身来说，TASK_STOPPED和TASK_TRACED状态很类似，都是表示进程暂停下来。而TASK_TRACED状态相当于在TASK_STOPPED之上多了一层保护，处于TASK_TRACED状态的进程不能响应SIGCONT信号而被唤醒。只能等到调试进程通过ptrace系统调用执行PTRACE_CONT、PTRACE_DETACH等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复TASK_RUNNING状态。Z(TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程。进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在shell中，$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。当然，内核也可以将这些信息保存在别的地方，而将task_struct结构释放掉，以节省一些空间。但是使用task_struct结构更为方便，因为在内核中已经建立了从pid到task_struct查找关系，还有进程间的父子关系。释放掉task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。这个信号默认是SIGCHLD，但是在通过clone系统调用创建子进程时，可以设置这个信号。通过下面的代码能够制造一个EXIT_ZOMBIE状态的进程：#include &lt;unistd.h&gt;void main() {if (fork())while(1) sleep(100);}编译运行，然后ps一下：kouu@kouu-one:~/test$ ps -ax | grep a\.out10410 pts/0 S+ 0:00 ./a.out10411 pts/0 Z+ 0:00 [a.out] &lt;defunct&gt;10413 pts/1 S+ 0:00 grep a.out只要父进程不退出，这个僵尸状态的子进程就一直存在。那么如果父进程退出了呢，谁又来给子进程“收尸”？当进程退出的时候，会将它的所有子进程都托管给别的进程（使之成为别的进程的子进程）。托管给谁呢？可能是退出进程所在进程组的下一个进程（如果存在的话），或者是1号进程。所以每个进程、每时每刻都有父进程存在。除非它是1号进程。1号进程，pid为1的进程，又称init进程。linux系统启动后，第一个被创建的用户态进程就是init进程。它有两项使命：1、执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）；2、在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作；init进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于TASK_INTERRUPTIBLE状态，“收尸”过程中则处于TASK_RUNNING状态。X(TASK_DEAD - EXIT_DEAD)，退出状态，进程即将被销毁。而进程在退出过程中也可能不会保留它的task_struct。比如这个进程是多线程程序中被detach过的进程（进程？线程？参见《linux线程浅析》）。或者父进程通过设置SIGCHLD信号的handler为SIG_IGN，显式的忽略了SIGCHLD信号。（这是posix的规定，尽管子进程的退出信号可以被设置为SIGCHLD以外的其他信号。）此时，进程将被置于EXIT_DEAD退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-02-09 二 10:35]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-02-09]<a href="/categories/study/linux/misc/linux_misc_notes.html"> Linux杂乱记录  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Linux命令学习记录'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. Misc1.1. MAYBE/FUTURE enca1.2. LATER shasum1.3. MAYBE/FUTURE ifttt1.4. MAYBE/FUTURE tref可查看windows邮件中的dat文件1.5. MAYBE/FUTURE jfbterm &amp; fbterm1.6. MAYBE/FUTURE complete1.7. update-alternatives1.8. ps1 Misc主要收集各类linux下的命令，内容没有整理，或者正在整理，整理好后会移出去到特定的文档中。1.1 MAYBE/FUTURE encaState "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 16:18]Time:[2015-10-14 三 11:33]编码转换更好的傻瓜型命令行工具enca，它不但能智能的识别文件的编码，而且还支持成批转换。  　　1.安装  　　$sudo apt-get install enca  　　2.查看当前文件编码  　　enca -L zh_CN ip.txt     Simplified Chinese National Standard; GB2312     Surrounded by/intermixed with non-text data  　　3.转换  　　命令格式如下  　　$enca -L 当前语言 -x 目标编码 文件名  　　例如要把当前目录下的所有文件都转成utf-8  　　enca -L zh_CN -x utf-8 *     检查文件的编码　enca -L zh_CN file   　　 将文件编码转换为"UTF-8"编码　 enca -L zh_CN -x UTF-8 file如果不想覆盖原文件可以这样         enca -L zh_CN -x UTF-8 &lt; file1 &gt; file2 参考：http://blog.csdn.net/jnbbwyth/article/details/6991425/1.2 LATER shasumState "LATER"      from "INBOX"      [2015-10-14 三 10:17]Time:[2015-10-13 二 14:21]类似 md5sum的一个命令。1.3 MAYBE/FUTURE iftttState "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 16:18]Capture Time:[2015-10-30 五 14:59]1.4 MAYBE/FUTURE tref可查看windows邮件中的dat文件State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 16:18]State "INBOX"      from              [2015-11-05 四 12:06]1.5 MAYBE/FUTURE jfbterm &amp; fbtermState "MAYBE/FUTURE" from "INBOX"      [2015-12-18 五 13:36]Capture Time:[2015-12-14 一 15:45]可以显示中文的纯字符终端，类似zhcon.参考：http://zhidao.baidu.com/link?url=ImeEdpu_besndXYBaeQohsiyHWognPFRRcBJm4XGcL1CxWYKGA54bwRIPqaPlP_67YBKAgaayDhTN9ZhB9V5Jq可以尝试使用fbterm安装命令：sudo apt-get install fbterm xfonts-wqyctrl+alt+f1进入的纯字符界面后，先运行fbterm。退出fbterm，可以输入exit命令。如果不起作用，先把当前用户加入video组：sudo usermod -g video [用户名]1.6 MAYBE/FUTURE completeState "MAYBE/FUTURE" from "LATER"      [2015-12-18 五 13:40]State "LATER"      from "INBOX"      [2015-12-18 五 13:39]Capture Time:[2015-12-16 三 16:51]参考:http://www.gnu.org/software/global/globaldoc_toc.html$ complete -F funcs global$ global kmem_&lt;TAB&gt;&lt;TAB&gt;kmem_alloc           kmem_alloc_wait      kmem_initkmem_alloc_nofault   kmem_free            kmem_mallockmem_alloc_pageable  kmem_free_wakeup     kmem_suballoc1.7 update-alternatives确定多版本命令之时的默认命令。设置默认java环境输入 sudo update-alternatives --display java 可查看信息默认的jdk信息。如果只有一个java环境如下设置即可$sudo update-alternatives --install /usr/bin/java java  /usr/lib/jvm/jdk1.8.0_65/bin/java 300$sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk1.8.0_65/bin/javac 300若有多个版本，需要修改默认的，则再输入$sudo update-alternatives --config java$sudo update-alternatives --config javac将会提示：要维持当前值[*]请安回车键或者输入选择的编号,输入自己设置的优先级的编号(300)，按回车就可以了，再输入display查看，确定默认版本信息。会更新 /etc/alternatives 中的内容。1.8 ps支持三种类型的选项：Unix风格: 选项可能会被分组，但是必须以 - 开始BSD风格: 选项可能会被分组，不以 - 开始GUN长选项风格: 选项以 =&#x2013;=开始ps -a列出所有与terminal有关的进程，不包含session leader.ps a列出所有与terminal有关的进程ps -A 同 ps -e, 列出所有的进程。ps x列出所有你拥有的进程ps ax列出所有进程没有 -x 。ps -u &lt;userlist&gt; 同 ps --user &lt;userlist&gt;列出 EUID为 =&lt;userlist&gt; 对应的名称或者ID的进程。 &lt;userlist&gt; 可以为空格分割的字符串，或者逗号分割。 ps -p "1 2" -p 3,4.ps u以用户为主显示，结果第一列是用户ID。USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND1032      9392  0.0  0.0  10484  1732 pts/11   S+   11:59   0:00 man psps -U &lt;userlist&gt;列出 RUID为 &lt;userlist&gt; 对应的名称或者ID的进程。 &lt;userlist&gt; 可以为空格分割的字符串，或者逗号分割。 ps -p "1 2" -p 3,4.ps U &lt;userlist&gt; 同 ps --user &lt;userlist&gt;列出 EUID为 &lt;userlist&gt; 对应的名称或者ID的进程。 &lt;userlist&gt; 可以为空格分割的字符串，或者逗号分割。 ps -p "1 2" -p 3,4.      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-02-11 四 17:05]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-02-02]<a href="/categories/study/linux/command/linux_command_tips.html"> Linux命令学习记录  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Linux进程和线程的调度与优先级'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 总述1.1. 概念：1.2. 方法：1.3. 原理：2. 进程优先级概念3. 进程优先级与变动影响因素与原理4. 查看与设置优先级与进程线程信息等的方法5. WAIT/FORWARD FAQ [0/4]([0%])5.1. NEXT 线程优先级是否继承父线程优先级？是否继承父进程优先级？5.2. NEXT chrt 修改进程优先级，那么该进程的子线程优先级是否改变？5.3. NEXT chrt, ps, top, pthread_attr_setschedpolicy(), sched_setscheduler() 中的优先级值和含义有什么关系？5.4. NEXT 考虑将引文中的链接下载到本地本文主要概述Linux下进程与线程的调度算法和优先级相关内容。1 总述为便于快速了解和复习，本节先给出结论性的大致概述，后面再详细介绍相关内容。关于进程优先级和调度策略的大致信息如下。1.1 概念：进程优先级值越小，优先级越大。进程优先级是PRI值不是Nice值，但是Nice值会影响优先级。三类调度策略：RR调度和FIFO调度的进程属于实时进程，以分时调度(OTHER)的进程是非实时进程实时进程优先级高于普通进程，实时进程使用静态优先级调度、非实时进程使用动态优先级调度，非实时进程动态优先级通过nice调整、可能受bonus影响。1.2 方法：命令行/脚本中可以通过 ps, top, chrt 来查看和修改调度和优先级属性。通过 sched_setscheduler() 设置进程调度和优先级属性。通过 pthread_attr_setschedpolicy() 设置线程调度和优先级属性。1.3 原理：一般子进程会继承父进程的调度策略，在Linux  2.6.32之后，可以使用 SCHED_RESET_ON_FORK 按位与参数的方式调用 sched_setscheduler(), 使用之后效果是：如果调用进程使用 SCHED_FIFO 或 SCHED_RR 调度策略，使用 SCHED_RESET_ON_FORK 后fork创建的子进程创建时将会自动重置为 SCHED_OTHER 调度策略；如果调用进程使用负值nice，那么使用  SCHED_RESET_ON_FORK 后fork创建的子进程创建时将会自动将其nice重置为0。 这个标记激活时只有当进程具有 CAP_SYS_NICE 标记时才能被重置，而这个 CAP_SYS_NICE 标记在使用fork()创建子进程后，在子进程中被禁止。2 进程优先级概念进程优先级值越小，优先级越大。linux下的进程调度优先级是从-20到19，一共40个级别，数字越大，表示进程的优先级越低。默认时候，进程的优先级是0。如果不是root权限,则侄只能降调度优先级而不能提高，即使是自己用户的进程，自己把它调高了后，优先级也不能再被调会原来的值了，除非使用root用户来调回去。系统重启后，对进程优先级的调整全部失效，所有进程的调度回到默认的初始级别。参考：Linux进程优先级的调整方法进程优先级是PRI值不是Nice值，但是Nice值会影响优先级PRI也还是比较好理解的，即进程的优先级，或者通俗点说就是程序被CPU执行的先后顺序，此值越小进程的优先级别越高。那NI呢？就是我们所要说的nice值了，其表示进程可被执行的优先级的修正数值。如前面所说，PRI值越小越快被执行，那么加入nice值后，将会使得PRI变为：PRI(new)=PRI(old)+nice。到目前为止，更需要强调一点的是，进程的nice值不是进程的优先级，他们不是一个概念，但是进程nice值会影响到进程的优先级变化。通过调整nice值，更改进程优先级，nice调整范围是 -20~19。参考：linux进程优先级、进程nice值3 进程优先级与变动影响因素与原理调度策略：RR调度和FIFO调度的进程属于实时进程，以分时调度(OTHER)的进程是非实时进程。FIFO（先进先出）和RR（时间片轮转）用于实时进程，OTHER（分时调度）用于非实时进程；实时进程会抢占普通进程;FIFO会导致同优先级实时进程始终占用CPU，RR会保证同优先级实时进程按时间片轮流执行。参考：SCHED_OTHER,SCHED_FIFO,SCHED_RR实时进程优先级高于普通进程，实时进程使用静态优先级调度、非实时进程使用动态优先级调度，非实时进程动态优先级通过nice调整、可能受bonus影响。Linux进程有两种优先级：普通进程优先级（使用SCHED_NORMAL调度策略），以及实时进程优先级（使用SCHED_FIFO或SCHED_RR调度策略）不同调度策略的实时进程只有在相同优先级时才有可比性，任何时候，实时进程的优先级都高于普通进程Linux对实时进程使用静态优先级调度，对普通的进程（非实时进程），根据动态优先级进行调度。实时进程，只有静态优先级(在0~MAX_RT_PRIO-1间，默认MAX_RT_PRIO为100）, 内核不会再根据休眠等因素对其静态优先级做调整； 实时进程0-99号优先级每一个优先级对应一个优先级队列（链表），先执行数值高的对应的链表（0号最低），可由后面所述的 chrt 以及 相应函数修改该优先级；非实时进程静态优先级可通过nice值（-20~19）调整：static_prio=MAX_RT_PRIO + nice + 20。nice只影响非实时进程(静态优先级在100~139之间)，nice越大静态优先级值越大，优先级越低。非实时进程动态优先级根据静态优先级和bonus计算:dynamic_prio = max (100, min (static_prio - bonus + 5, 139))bonus反映进程平均睡眠时间（范围0~10），睡眠时间越多越可能是交互进程，每次轮到它运行时它就越可能不会使用完时间片再释放cpu。参考：Linux进程调度原理 以及 给进程设置实时优先级4 查看与设置优先级与进程线程信息等的方法通过 ps 查看进程信息ps -el 可查看进程优先级和nice值,命令执行结果：NI列显示的每个进程的nice值（主要针对非实时进程），PRI是进程的优先级（如果是实时进程就是静态优先级，如果是非实时进程，就是动态优先级）。参考：Linux进程调度原理通过 top 查看进程信息其中的优先级和ps的pri不一样，ps中一般为0的进程，在top中为20，这个优先级应该对应于前面所说的实时进程优先级，实时进程只使用1-99号优先级队列，序号越大优先级越高，0号留给普通进程使用。chrt -p &lt;pid&gt; 查看进程属性通过 chrt 查看和修改进程调度和优先级属性，它一般也是调用后面的 sched_setscheduler() 实现的。  注意： char -o pri command 设置为SCHED_OTHER调度方式优先级别值只能是0表示比任何实时优先级都低，非实时进程不使用该值决定调度行为，普通进程使用自己的调度策略。参考： man chrt 通过 sched_setscheduler() 设置进程调度和优先级属性效果类似 chrt, 关于priority的注意：这里参数中的pri不是ps的nice也不是priority,而是代码中的sched_priority，用于表示一系列可执行进程列表。实时进程中该值范围为1-99越大表示优先级越高, 非实时只能是0表示始终比实时进程低，并且非实时进程的优先级不由此值确定而是由其内部动态优先级确定。chrt中的pri应该也类似含义，例如： chrt -f -p 10 pid 则ps中pri为-11， chrt -f -p 1 pid 则ps中pri为-2）为0，进程命令为command，其它可以根据选项参数设置。关于prioriti的注意：一般子进程会继承父进程的调度策略，在Linux  2.6.32之后，可以使用 SCHED_RESET_ON_FORK 按位与参数的方式调用 sched_setscheduler(), 使用之后效果是：如果调用进程使用 SCHED_FIFO 或 SCHED_RR 调度策略，使用 SCHED_RESET_ON_FORK 后fork创建的子进程创建时将会自动重置为 SCHED_OTHER 调度策略；如果调用进程使用负值nice，那么使用  SCHED_RESET_ON_FORK 后fork创建的子进程创建时将会自动将其nice重置为0。 这个标记激活时只有当进程具有 CAP_SYS_NICE 标记时才能被重置，而这个 CAP_SYS_NICE 标记在使用fork()创建子进程后，在子进程中被禁止。参考： man sched_setscheduler 和 线程优先级设置通过 pthread_attr_setschedpolicy() 设置线程调度和优先级属性效果类似 sched_setscheduler(), 但是用于线程而非进程。参考： man pthread_attr_setschedpolicy5 WAIT/FORWARD FAQ [0/4]([0%])5.1 NEXT 线程优先级是否继承父线程优先级？是否继承父进程优先级？State "NEXT"       from              [2016-02-01 一 15:39]5.2 NEXT chrt 修改进程优先级，那么该进程的子线程优先级是否改变？State "NEXT"       from "NEXT"       [2016-02-01 一 15:40]5.3 NEXT chrt, ps, top, pthread_attr_setschedpolicy(), sched_setscheduler() 中的优先级值和含义有什么关系？State "NEXT"       from              [2016-02-01 一 15:40]5.4 NEXT 考虑将引文中的链接下载到本地State "NEXT"       from              [2016-02-01 一 15:50]      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-02-01 一 15:35]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-02-01]<a href="/categories/study/os/linux_schedule_priority.html"> Linux进程和线程的调度与优先级  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = '测试orgmode文章导出'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. FAQ [3/8]([37%])1.1. INBOX 如何设置style文件链接使之在所有文件中可以公用？1.2. DONE 如何设置文内引用链接保持在文件路径变化时文件内容不变？1.2.1. 链接引用文件存放地1.2.2. org文件中引用链接到jekyll导出文件链接的转换1.2.3. 转换实现1.3. DONE 如何设置图片链接在文件路径变化时保持不变？1.4. NEXT 如何设置文件中的签名信息？1.5. DONE 如何设置文件中jekyll文章的引用位置？1.6. NEXT 如何为每次更新文章追加设置记录时间戳？1.7. NEXT 如何放置引用文章链接在文章路径改变时的失效情况发生？1.8. NEXT 如何为本地orgmode导出文件设置导出引用链接？1 FAQ [3/8]([37%])1.1 INBOX 如何设置style文件链接使之在所有文件中可以公用？1.2 DONE 如何设置文内引用链接保持在文件路径变化时文件内容不变？State "DONE"       from "WAIT/FORWARD" [2016-01-11 一 17:08]State "WAIT/FORWARD" from "NEXT"       [2016-01-08 五 17:41]  等待整理State "NEXT"       from              [2015-12-17 四 17:42]1.2.1 链接引用文件存放地文章引用的文件，存放在jekyll中data目录的，名为对应文章所在文件扩展名替换为 .files 的目录中。假设引用的是一个图片文件， 引用的文章文件名称是 2015-12-17-testexport.org, 导出到jekyll系统中的名称是 2015-12-17-testexport.html, 那么其文章所有被引用的文件都存放在 data/2015-12-17-testexport.files 。1.2.2 org文件中引用链接到jekyll导出文件链接的转换org文件中的引用链接，在导出到jekyll的html需要进行转换才能正确显示，转换方式如下1.2.2.1 org文章使用链接的方式org文章中引用本地外部文件和普通orgmode语法一样，如下[[file:~/mygitrepo/quietheart/mydoc/prepub/orgmode/data/2015-12-17-testexport.files/2015-12-17-editor_study_line.jpg][image file]]1.2.2.2 导出的html链接导出结果到jekyll对应的html文件后，对应链接变成&lt;a href="file:///home/miracle/mygitrepo/quietheart/mydoc/prepub/orgmode/data/2015-12-17-testexport.files/2015-12-17-editor_study_line.jpg"&gt;image file&lt;/a&gt;1.2.2.3 对导出的html链接进行转换这样的结果在jekyll中是无法直接正确显示链接的，需要在导出为html之后，再对相应html文件中相应的链接处进行处理，处理成jekyll可以显示的方式，这里为：&lt;a href="/data/2015-12-17-testexport.files/2015-12-17-editor_study_line.jpg"&gt;image file&lt;/a&gt;处理成功的效果：image file1.2.3 转换实现这里实现上述转换的方法是定义一个替换链接的函数，把它做为hook添加到 org-publish-after-publishing-hook 中。大致如下：(defun my-update-jekyll-html-link (htmlfile);;replace the local file link to site relative link in jekyll.;;open    (setq htmlbuffer (find-file-existing htmlfile));;search    (goto-char (point-min));;TODO the xxx.files, xxx is better to be replaced by the html file name.    (while (re-search-forward "\\(&lt;a href=.*?\\)\\(file:.*?quietheart/mydoc/prepub/jekyll\\)\\(/data/[0-9]\\{4\\}-[0-1][0-9]-[0-3][0-9]-.*?\.files\\)" nil t)         (replace-match "\\1\\3" nil nil));;save and close    (save-buffer)    (kill-buffer htmlbuffer)))(defun my_after_pub_html_hook (orgfile htmlfile)     (my-update-jekyll-html-link htmlfile))(add-hook 'org-publish-after-publishing-hook 'my_after_pub_html_hook)))1.3 DONE 如何设置图片链接在文件路径变化时保持不变？State "DONE"       from "NEXT"       [2016-01-11 一 17:55]State "NEXT"       from              [2016-01-11 一 17:40]类似文件链接的转换，如何设置文内引用链接保持在文件路径变化时文件内容不变？关键添加如下：;;image reference link convert.;;TODO the xxx.files, xxx is better to be replaced by the html file name.(while (re-search-forward "\\(&lt;img .*?src=.*?\\)\\(file:.*?quietheart/mydoc/prepub/orgmode\\)\\(/data/[0-9]\\{4\\}-[0-1][0-9]-[0-3][0-9]-.*?\.files\\)" nil t) (replace-match "\\1\\3" nil nil))效果：1.4 NEXT 如何设置文件中的签名信息？State "NEXT"       from              [2015-12-17 四 17:42]1.5 DONE 如何设置文件中jekyll文章的引用位置？State "DONE"       from "NEXT"       [2016-01-11 一 17:39]State "NEXT"       from              [2015-12-17 四 17:42]类似上面导出文件链接的转换，如何设置文内引用链接保持在文件路径变化时文件内容不变？关键如下：(while (re-search-forward "\\(&lt;a href=.*?\\)\\(file:.*?quietheart/mydoc/prepub/orgmode\\)\\(/.*?\\)\\(_posts/[0-9]\\{4\\}-[0-1][0-9]-[0-3][0-9]-\\)\\(.*?\.html\\)" nil t) (replace-match "\\1\\3\\5" nil nil))效果gtd method1.6 NEXT 如何为每次更新文章追加设置记录时间戳？State "NEXT"       from              [2015-12-17 四 17:42]1.7 NEXT 如何放置引用文章链接在文章路径改变时的失效情况发生？State "NEXT"       from              [2016-01-11 一 18:00]1.8 NEXT 如何为本地orgmode导出文件设置导出引用链接？State "NEXT"       from              [2016-01-18 一 18:28]这个和发布不同，日常orgmode管理之时，一般都会将相关文章放到一个目录中，引用的文件也属于该目录的子目录。这种情况下，使用 elisp: 链接的方式来自定义链接的引用。imagefile;; custom link function for export.(defun my-link-org-file (file_path)  (setq org-file-prefix org-directory)  (find-file (concat org-file-prefix file_path)))(defun my-link-org-img (imgfile_path)  (setq org-file-prefix org-directory)  (find-file (concat org-file-prefix imgfile_path)))[[elisp:(my-link-org-file%20"data/image/2010-04-02-editor_study_line.jpg")][normalfile]][[elisp:(my-link-org-img%20"data/image/2010-04-02-editor_study_line.jpg")][imagefile]]&lt;a href="(my-link-org-file%20"data/image/2010-04-02-editor_study_line.jpg")"&gt;normalfile&lt;/a&gt;&lt;a href="(my-link-org-img%20"data/image/2010-04-02-editor_study_line.jpg")"&gt;imagefile&lt;/a&gt;      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2015-12-25 五 15:00]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-12-17]<a href="/categories/others/testexport.html"> 测试orgmode文章导出  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Test_orglink'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'hellothe image1 data/2015-12-01-test_orglink.files/2015-12-01-test_image.jpgtest2 2015-12-01-test_image.jpgAuthor: QuietHeart(quiet_heart000@126.com)Update: Emacs 23.3.1 (Org mode 8.3.1)';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-12-01]<a href="/categories/others/test_orglink.html"> Test_orglink  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = '使用orgmode进行GTD管理'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 任务状态2. 划分文件3. 管理方式:3.1. 大致思路：3.2. 回顾3.2.1. 回顾种类3.2.2. 回顾内容：4. 实现方式4.1. 实现基本Orgmode任务管理4.1.1. TODO标题表示任务4.1.2. 按照实现策略进行配置4.1.3. 常用操作4.2. 交叉引用4.3. 设置优先级别4.3.1. 可采用四象限法则，将事情按照重要和紧急两个不同的程度进行划分，分为四个“象限”。4.3.2. 设置优先级4.3.3. 切换优先级4.4. Capture-Refile-Archive4.4.1. 概念4.4.2. 配置4.4.3. 操作4.5. 归档4.5.1. 配置归档位置和归档后附带信息4.5.2. 归档命令4.5.3. 举例4.6. 便于整理周报的记录技巧4.7. orgmode与mobile org整合4.7.1. 配置4.7.2. 原理4.7.3. 同步操作4.7.4. 使用举例4.7.5. 其它5. WAIT/FORWARD FAQ [8/11]([72%])5.1. DONE 如何划分任务状态以及存放的文件？5.2. DONE 如何实现任务管理的基本管理？5.3. DONE 如何设置交叉引用?5.4. DONE 如何设置优先级别?5.5. DONE 如何迅速捕获临时产生的任务，以及将各个任务标题在状态文件中进行转移？5.6. DONE 如何设置归档?5.7. DONE 便于整理周回顾?5.8. DONE 如何将PC与移动端的orgmode整合?5.9. LATER 杂乱问题5.10. NEXT 改善归档与done/cancel策略5.11. NEXT 改善refile的配置方式这里给出采用orgmode进行gtd管理的策略。注：orgmode工作目录说明文件(orgmode/gtd/readme.org)即此文的副本,此文定期更新同步到orgmode工作目录的说明文件。1 任务状态状态含义同一般GTD系统，这里先不做深入介绍。主要设置如下任务状态：INBOX任何未经处理的任务。NEXT正在处理的任务。LATER被暂缓延迟的任务。WAIT/FORWARD等待能够继续处理的条件。MAYBE/FUTURE可能会处理，可能不处理的任务。CANCEL被取消的任务。DONE已完成的任务。2 划分文件主要设置如下目录和文件来存放数据：inbox.org整个体系的输入，产生的任何任务、灵感、想法都会通过快速捕捉命令（例如 C-c c ）默认收集到这里。单个文件，因为进入其中的任务迟早会被清空，不会积累。这里的内容是最原始的、迅速捕捉到的内容，待处理，甚至都没有任务状态关键字。每次回顾后，这里的内容要么被移动到相应位置，要么被直接处理，要么归档。next.org这里内容主要存放当前处理的任务。单个文件，因为进入其中的任务迟早会被清空，不会积累。处理任务之时，集中在next.org中进行处理，处理之时相应的任务可能会被切换成各种状态，每次经过定期回顾处理后，这个文件其它状态的内容被移动到合适的位置，导致仅包含 NEXT 状态的任务。later.org这里的内容存放 LATER 状态的任务。单个文件，因为进入其中的任务迟早会被清空，不会积累。每次回顾之后，可能会有一些新的任务切换成 LATER 状态并进入这个文件；也可能有一些任务被切换至其它状态并移出到对应文件。wait_forward.org这里的内容存放 WAIT/FORWARD 状态的任务。单个文件，因为进入其中的任务迟早会被清空，不会积累。每次回顾之后，可能会有一些新的任务切换成 WAIT/FORWARD 状态并进入其中；也可能有一些任务被切换至其它状态并移出这里到对应目录。maybe_future.org这里的内容存放 MAYBE/FUTURE 状态的任务。建议为目录，因为其中内容可能会积累。每次回顾之后，可能会有一些新的任务被切换成 MAYBE/FUTURE 状态并进入其中；也可能有一些任务被切换至其它状态并移出这里到对应目录。cancel.org这里的内容存放 CANCEL 状态的任务。建议为目录，其中内容可能会积累。每次回顾之后，可能会有一些新的任务切换成 CANCEL 状态并进入其中；也可能有一些任务被切换至其它状态并移出这里到对应目录。done.org这里的内容存放 DONE 状态的任务。建议为目录，其中内容可能会积累。每次回顾之后，可能会有一些新的任务切换成 DONE 状态并进入其中；也可能有一些任务被移至其他回顾目录、归档目录、或者加入特定关联信息等。output将处理好的任务转化为文档的地方。建议为目录，其中内容可能会积累。主要存放将要整理成笔记的内容，整理好的内容存放到这里，在合适的时候（如回顾之时）会被转移至其它笔记系统；另外为了借助orgmode环境方便集中访问和refile，有些草稿性质的文档，也可为之做成一个软链接，将软链接放在这里，源文档仍在其初始目录。_review存放与任务关联的项目。建议为目录，其中内容可能会积累。主要存放之前整理过的、或者不活跃的回顾项目。项目其实是对任务的一种“分类”，每个项目包含多个任务，由gtd系统管理，回顾之时会将相关联的任务组织整理，将其概要信息归结为一条项目，存放在这里。_active存放与任务关联的当前活跃项目。建议为目录，其中内容可能会积累。主要存放当前正在整理或者进行的、或者活跃的回顾项目。项目条目的含义同上，是多个相关联的任务的概要索引，便于日后查找参考等，也使得整个gtd中被处理的任务更为有序。_archive归档已完成任务。建议为目录，其中内容可能会积累。主要将一些任务归档，减少Agenda视图的冗余，以及备份，具体依实际情况待定。3 管理方式:3.1 大致思路：两种划分状态的方式任务的状态既通过其所在的 状态文件名 表示，也通过 TODO关键字标记 表示。两种“划分”得到的状态含义大致相同，并且一一对应。回顾阶段与处理阶段为方便信息检索，以及避免信息重复，采用“分阶段”（处理阶段和回顾阶段）方式管理。虽然我们划分任务状态的采用的文件名和TODO状态标记两种方式，通过如下方式对处理阶段划分，并不会造成混乱。处理阶段在任务处理时进行，将任务切换至合适的TODO关键字标记。回顾阶段在系统回顾时进行，将相关TODO关键字标记的任务转移到对应的状态文件中集中存放。3.2 回顾3.2.1 回顾种类短期回顾比较频繁的，例如“日”回顾，主要用来清理inbox中的内容，以及切换状态。对于inbox状态文件，将其中的任务和内容切换到合适状态并refile；对于其它文件的任务，只需切换其状态即可；为简化频繁的文件操作，操作可在orgmode的agenda view下进行。中期回顾根据项目情况定期的，例如“周”回顾，主要用来梳理当前任务的状态和关系。主要涉及对任务的refile，以及文档生成等。长期回顾便于总结复习整理的，例如“月”、“年”回顾，主要用来梳理任务状态、复习曾经整理的内容、归档等等。3.2.2 回顾内容：3.2.2.1 短期回顾在"短期回顾"中，定期处理inbox中的内容使得收集状态的内容及时被处理。根据情况，可能有如下类型：立即处理一般处理过程仅需1-2分钟，直接处理完，让其归结为done状态。做为任务处理转移到对应的gtd任务状态中开始对其进行gtd管理，如果任务复杂，可考虑为其创建项目（回顾）来管理相关任务。不需要处理直接删除。归档与笔记从gtd输出（例如到out目录），或直接转移到对应的笔记系统。对其他状态任务的处理，只需切换相应任务状态，直接在orgmode中的AgendaView中进行可以避免频繁的文件切换。3.2.2.2 中期回顾在"周"回顾中，梳理各种任务状态中的内容，将相关的内容关联起来，将相应的状态内容移动到对应的文件等等。处理方式类似对于inbox的处理，可能有如下类型：立即处理将已完成的任务梳理，并且从其它文件中移动到"done"，需要添加项目回顾关联的，则添加相应的关联信息。做为任务处理没有完成的任务，视情况将其放置到合适的状态和位置，必要时可能会追加更详细的任务属性（如优先级、截止日期、重复间隔等等）。不需要处理将不需要继续进行的任务，放置到cancel状态中，将其取消。归档与笔记将一些有必要归档的内容归档（减少agenda的负担），以及将特定内容移动到特定的笔记系统（内容管理）。4 实现方式下面给出实现上述管理主要需要注意的几个部分。4.1 实现基本Orgmode任务管理4.1.1 TODO标题表示任务TODO标题是一种包含状态的特殊标题在标题标记后面加上相应状态名，便成为TODO项目。状态默认为TODO和DONE，可以自行配置。* TODO 这是一个TODO项目** TODO 这是TODO的子项目带有统计子项目的TODO项目在一个待办标题中添加子待办标题，然后在待办标题中添加 [%] 或者 [%] 。 每当子标题更新时，父标题上面的相应比例会自动统计变化，如果强制刷新，则在父标题相应的比例标记上输入 C-c C-c 。* TODO 这是一个统计子项的TODO项目 [0/2]** TODO 这是TODO的子项目1** TODO 这是TODO的子项目2当然这样也行：* TODO 这是一个统计子项的TODO项目 [0/2] ([0%])** TODO 这是TODO的子项目1** TODO 这是TODO的子项目24.1.2 按照实现策略进行配置增加TODO状态在配置文件中加入类似如下代码：;;set status for TODO.(setq org-todo-keywords     '((sequence "INBOX" "NEXT" "LATER" "WAIT/FORWARD" "MAYBE/FUTURE" "|" "CANCEL" "DONE")))配置状态颜色通过org-todo-keyword-faces的设置实现，添加内容如下;; color for todo keywords(setq org-todo-keyword-faces '(("INBOX" . (:foreground "blue" :weight bold)) ("NEXT" . org-warning)("LATER" . "yellow")("WAIT/FORWARD" . "blue")("MAYBE/FUTURE" . "purple")("DONE" . "green")("CANCEL" . "grey")))配置状态快捷切换键通过定义状态时将快捷按键放在状态后面，用‘（）’括起来，添加内容如下：;;set status for TODO.(setq org-todo-keywords '((sequence                          "INBOX"                         "NEXT(n)"                         "LATER(l)"                         "WAIT/FORWARD(w)"                         "MAYBE/FUTURE(m)"                         "|" "CANCEL(c)" "DONE(d)"                         )) )配置状态切换的跟踪时间戳当TODO列表切换到结束状态时，会自动为其添加一个结束时候的时间戳（转变为非结束状态时会将其移除）。;;add timestamp when todo change to done.(setq org-log-done 'time)4.1.3 常用操作TODO项目相关操作：M-S-Ret 当前位置插入TODO项目，默认状态和上一条统计TODO状态一样C-S-Ret 当前级别子树后面插入TODO项目C-c C-t 当前所在TODO项目状态切换(不一定要在TODO标题上面)默认状态下，循环切换次序是TODO-&gt;Done-&gt;普通标题（只有*）。S-RIGHT/S-LEFT 当前所处TODO标题上进行状态切换，默认状态下，循环切换次序是：TODO-&gt;DONE-&gt;普通标题C-c , 修改优先级（包括A,B,C三个级别，不一定在TODO标题上面）S-UP/S-DOWN 切换优先级，默认次序是A-&gt;B-&gt;C-&gt;无。C-u C-c C-t 快捷切换状态，输入后会提示你要输入的状态，可以支持Tab补全，可以用快捷按键替代。光标停留在 [%] 或者 [%] 之上，输入 C-c C-c4.2 交叉引用因任务可能会在不同的文件与标题间迁移，所以需要为每一条目采用与文件与位置无关的id，即采用全局唯一id链接的方式实现交叉引用。首先配置全局链接类似如下：;;Settings for global id link.(require 'org-id)(setq org-id-link-to-org-use-id t)为被引用标题创建全局链接id保存链接内容的同时也创建了相应的链接。当然，这需要事先配置好保存链接快捷键(global-set-key "\C-cl" 'org-store-link)输入 C-c l 之后便创建好了相应的全局链接，类似如下：* 子树标题   :PROPERTIES: :ID:       60b13787-86e8-43a3-9a33-73d3eb7e6f58 :END:引用链接像正常插入链接一样，输入 C-c C-l 即可，默认插入最近一次保存的链接。引用的格式举例 [[id:60b13787-86e8-43a3-9a33-73d3eb7e6f58][子树标题]]4.3 设置优先级别4.3.1 可采用四象限法则，将事情按照重要和紧急两个不同的程度进行划分，分为四个“象限”。第一象限重要但不紧急的事。法则重点，这才是最需要做的事。需要制定计划，按时完成。可以让你进入良性循环的做法！第二象限重要并紧急的事。需要优先解决，这也是没有计划的做法，无休止地一直在“瞎忙”。第三象限不重要但紧急的事。会让我们产生“这事很重要”的错觉。实际上就算重要也是对别人而言。我们花很多时间在这个里面打转。自以为是在第一象限，其实不过是在满足 别人的期望与标准。第四象限不紧急也不重要的事。浪费时间，或者完全对自己完全无意义的事。如果有可能，交给别人去做。我们把事项进行一些梳理，就会清楚自己的时间和精力主要应该用在什么地方了。4.3.2 设置优先级通过如下方式：;;set priority(setq org-highest-priority ?A)(setq org-lowest-priority ?D)(setq org-default-priority ?A)(setq org-priority-faces '(                           (?A . org-warning)                           (?B . (:background "DodgerBlue" :foreground "black" :weight bold))                            (?C . (:foreground "SkyBlue" :weight bold))                           (?D . (:foreground "DodgerBlue" :weight bold))                            ))4.3.3 切换优先级在标题上输入 S-&lt;up&gt;/&lt;down&gt; 5w1h分析4.4 Capture-Refile-Archive4.4.1 概念Capture用来迅速收集一些临时产生的想法，尽可能少的打断当前的工作状态。通过指定好快捷方式和相应的Capture目标位置后，在任意时间运行捕获命令会将这些临时的记录存放在一个指定的位置，空闲之时再做进一步整理。Refile以特定的命令，用来将之前Capture的内容直接转移到特定的地方，避免了手动剪切（复制）和粘帖。4.4.2 配置4.4.2.1 Capture的配置不同的管理方式可能会导致不同的配置，但是一般都包含两个方面：首先设置好一个启动Capture的快捷方式，再配置用于存储Capture信息的目的地。这里以gtd管理为例给出一个配置例子：;;Setting for gtd captures;;Directory for capture files.(setq org-directory "~/mydata/orgmode/");;Default capture files.(setq org-default-notes-file (concat org-directory "gtd/inbox.org"));;Capture template(setq org-capture-templates '(			      ("t" "Tasks" entry (file+headline "gtd/inbox.org" "Tasks") "* INBOX %?\nTime:%T\nFrom:%F\n")			      ("p" "Projects" entry (file+headline "gtd/inbox.org" "Projects")  "* %?\nTime:%U\nFrom:%F\n")			      ("i" "Item notes" item (file+headline "gtd/inbox.org" "Items")  "+ %?\n  Time:%U\n  From:%F\n")			      ("m" "Misc notes" plain (file+headline "misc.org" "Notes")  "-----------------------------------------------------\nTime:%U\n %?")			     )) ;;set tags;;where?(h/o/w),what?(c/l/s),when?(gtd|immeiately,wait,action),who?(my gtd,others),why?how?(delete/archieve/schedule)(setq org-tag-alist '(                    (:startgroup . nil)                         ("home" . ?r) ("office" . ?o) ("way" . ?w)                    (:endgroup . nil)                    ("职业" . ?c)                    ("生活" . ?l)                     ("学习" . ?s)                    ))4.4.2.2 Refile的配置主要配置两个方面的内容：Refile的目标（org-refile-targets），以及Refile时选择目标的策略(org-refile-use-outline-path会自动补全文件名以及标题，目标的格式类似文件路径的格式，包含文件和标题)。org-refile-targets对应的可以是路径可以是列表，具体参考其中的文档，需要注意的是：如果是列表该变量中的文件路径需要是全路径；文件中需要有一个标题才能在做 C-c C-w 补全的时候显示出来，空文件不行。如果是一个文件路径如果org-refile-targets是一个文件，则：这个文件可以是一个文件列表，使用这个列表的文件做为refile目标; 每个文件项占一行（不要有""），文件项可以是对于org-directory的相对路径; 这样文件内容变化之后，不用重新载入配置也能在 C-c C-w 中显示出新增的文件; 如果有一项是文件目录，那么不要再次包含该目录下的文件，因为这样会在agenda view中导致重复显示。;;targets for refile(setq org-refile-targets (quote (                                 (nil :maxlevel . 9)                                 (org-agenda-files :maxlevel . 9)                                )                         ));;outline path for refile(setq org-refile-use-outline-path 'full-file-path);;org-outline-path-complete-in-steps(setq org-outline-path-complete-in-steps t);;create new parents while refile(setq org-refile-allow-creating-parent-nodes 'confirm)4.4.3 操作基于以上配置，我们可以操作如下：启动Capture输入 C-c c输入之后会提示选择捕获何种类型的信息，提示信息和选择命令取决于之前设置的配置变量 org-capture-templates 。选择将待捕获的信息存于"Tasks"标题之下输入 t具体如何输入取决之前的配置如何，这里输入之后会打开一个Capture Buffer，用于输入将要被记录的信息，其中按照预先配置好的模板，已经预先插入了一些基本信息（如时间、捕获信息时所处位置等等）。完成Capture输入 C-c C-c输入之后，会将buffer中相应的信息插入到之前配置好的位置（例如某个文件中的某个标题之下），然后回到之前被中断的工作状态。取消Capture输入 C-c C-k取消捕获的动作，回到之前被中断的工作状态。访问存放Capture的文件Buffer输入 C-u C-c c输入之后，会提示和 C-c c 一样的信息，选择相应的捕获类型后，会直接打开相关的文件，具体是何文件，取决于事先设置的信息。访问上次捕获所处的文件Buffer输入 C-u C-u C-c c类似前面，捕获访问的是记录上次捕获的文件Buffer，并自动定位到其中上次捕获的信息之上。以剪切方式Refile输入 C-c C-w输入之后，会提示Refile的目标位置（在org-agenda-files中列出），支持Tab补全，选择好相应的文件之后，可以继续将文件内的标题也类似路径的方式输入（也支持TAB补全），选择好之后，回车会将相应的内容移动到对应的目标位置。注意：移动的内容可以是用Mark方式选择的区域，或者当前光标所在的子树，在执行 C-c C-w 之后有提示。以复制方式Refile输入 C-c M-w输入之后，会提示Refile的目标位置（在org-agenda-files中列出），支持Tab补全，选择好相应的文件之后，可以继续将文件内的标题也类似路径的方式输入（也支持TAB补全），选择好之后，回车会将相应的内容复制到对应的目标位置。注意：复制的内容可以是用Mark方式选择的区域，或者当前光标所在的子树，在执行 C-c C-w 之后有提示。访问Refile的目标对应Buffer输入 C-u C-c C-w输入之后，会提示和 C-c C-w 一样的信息，选择相应的位置后，会直接打开相关的文件。访问上次Refile所处的文件Buffer输入 C-u C-u C-c C-w类似前面，访问的是记录上次Refile的文件Buffer，并自动定位到上次Refile目标的信息之上。4.5 归档具体配置方式可以参见： C-h v org-archive-default-command, C-h v org-archive-location, C-h v org-archive-save-context-info4.5.1 配置归档位置和归档后附带信息将内容根据“年-月-日-包含文件名的标题-被归档的标题”的层次，归档在指定的_archive/session&lt;年月&gt;_archive.org文件中，归档之后，被归档节点属性包含：时间、文件、标签、todo状态、分类、节点在归档前的路径等信息。;;location for archive(setq org-archive-location (concat org-directory "gtd/_archive/" (format-time-string "%Y%m") "_archive.org::datetree/* Archive from %s"));;information added to property when a subtree is moved(setq org-archive-save-context-info '(time file ltags itags todo category olpath))注意，以上归档文件名为类似 session201511_archive.org ，这里的时间应该是启动Emacs会话的时间并非归档操作的时间。4.5.2 归档命令输入 C-c C-x C-s4.5.3 举例如上配置之后，例如*Title1**DONE sub title1 CLOSED: [2015-11-27 五 14:17]- State "DONE"       from              [2015-11-27 五 14:17]***subsub title1****DONE subsubsub title1CLOSED: [2015-11-27 五 14:18]- State "DONE"       from              [2015-11-27 五 14:18]****subsubsub title2****subsubsub title3***subsub title2**sub title2注意以上格式中，标题前面应该和'*' 之间有一个空格。执行 C-c C-x C-s 之后，会在相应路径生成一个201510_archive.org文件，追加了如下内容：*2015**2015-11 十一月***2015-11-27 星期五****Archive from orgmodetest.org*****DONE subsubsub title1CLOSED: [2015-11-27 五 14:18]:PROPERTIES::ARCHIVE_TIME: 2015-11-27 五 14:23:ARCHIVE_FILE: ~/test/emacs/orgmodetest.org:ARCHIVE_TODO: DONE:ARCHIVE_CATEGORY: orgmodetest:ARCHIVE_OLPATH: Title1/sub title1/subsub title1:END:- State "DONE"       from              [2015-11-27 五 14:18]4.6 便于整理周报的记录技巧按照时间列出处理情况为便于整理工作周报，可以将每天的记录工作首先按日期时间在每个TODO项目上创建子标题。每个子标题下记录详细工作日记日志。例如：*[2015-10-30 五 09:43] xxxxxx如果需要在agenda中列出时间，那么使用激活的时间戳即可。标题尽量简单叙述当前的工作情况。写周报的时候只看这个地方就行了。另外，每个TODO任务中如果设置了状态切换的日志，这样可能会和处理进度的子标题有些意义冲突，目前对此不做过多考虑，不会在状态切换日志中记录过多信息，并且状态切换日志仅在wait和cancel中记录。经过以上方式之后，做周报时，大致可以按照每个TODO项的日期时间标题来进行搜集。4.7 orgmode与mobile org整合MobileOrg是Mobile端的一个应用程序，运行在Android（也有IOS的MobileOrg）;Org是PC端Emacs的一个插件应用，对应其Orgmode模式。对其具体操作方式在orgmode的文档中有专门的介绍，并且不断更新，这里讲述相对固定的管理方式方面的内容。描述如何用Org创建可以通过MobileOrg显示的文档格式，以及如何将Mobile端的MobileOrg中修改和捕获的笔记，集成到PC端的“主” Org mode系统中（即Org与MobileOrg的同步），不涉及Agenda相关的操作。4.7.1 配置为了在MobileOrg中能够修改tags和TODO状态，你应该在PC端设置好自定义变量： org-todo-keywords 和 org-tag-alist ，使它们包含所有需要修改的重要的tags和TODO keywords，哪怕每个文件只使用其中的部分内容。MobileOrg也能通过in-buffer settings来为你提供TODO和tags设置，但是它只能读懂这些变量中的那些设置好的TODO状态集合以及tags。假设我们想要使PC上的Org与移动设备上的MobileOrg保持内容同步（底层通过git机制，也可以是云存储、ssh、ftp等机制）。这里给出为实现这个目的，在PC需要做的配置工作(移动端的MobileOrg做为辅助工具，其配置和操作非常简单，在适当的时候会提及)。4.7.1.1 在PC上添加使用MobileOrg的emacs配置主要包括对Emacs中org-mode模块的加载以及与MobileOrg同步的路径。例如:;;Sync with mobileorg(require 'org-mobile);;mobile stage(setq org-mobile-directory "/home/miracle/mygitrepo/pocket/MobileOrg")另外，可以通过 org-mobile-encryption-password 设置加密方面的内容。在后面我们可知，在PC上的orgmode中有特定的命令将相关内容推送到这个目录中。4.7.1.2 在PC上添加同步orgmode和MobileOrg的emacs配置主要包括PC端和MobileOrg端状态与标记的设置，PC上被推送orgmode内容的源文件路径，以及PC上接收MobileOrg修改的缓存路径设置。为被推送文件定义只属于该文件的状态和标记被推送的文件可使用文件选项定义相关的状态和标签（实践发现不用定义文件的状态和标签也行），定义内容最好和PC上的相关状态变量(即 setq org-todo-keywords )一致，或者是其子集。如果使用文件定义状态，那么可以将用于push到MobileOrg的文件中的状态设置选项如下：#+TODO: INBOX(i!) NEXT(n!) LATER(l!) WAIT/FORWARD(w@/!) MAYBE/FUTURE(m!) | CANCEL(c!) DONE(d!)标记的设置类似。设置状态关键字和被推送至MobileOrg的文件列表路径如下;;set status for TODO.(setq org-todo-keywords '((sequence "INBOX(i!)""NEXT(n!)""LATER(l!)""WAIT/FORWARD(w@/!)""MAYBE/FUTURE(m!)""|" "CANCEL(c!)" "DONE(d!)")))   ;;mobile push(setq org-mobile-files (list (concat org-directory "gtd/mobile_org")))设置接收来自MobileOrg内容的“缓存”目标文件路径如下;;mobile pull(setq org-mobile-inbox-for-pull (concat org-directory "gtd/from_mobile.org"))4.7.2 原理4.7.2.1 Mobile端的Mobile Org与PC端的Org同步当我们在MobileOrg中与PC端的Org同步时，需要知道它不仅仅是从PC端获取（mobile端的pull）相应org文件用于浏览，同时也会追加(mobile端的push)被captured的entries，并且指向被标记和修改的entries，这些内容被汇总在同步目录( org-mobile-directory )中的 mobileorg.org 文件里。4.7.2.2 PC端的Org与Mobile端的MobileOrg同步PC端的Pull获取MobileOrg修改内容(PC端的pull)的时候，会将这些信息从 mobileorg.org 先转移到到 org-mobile-inbox-for-pull 对应的文件中，并对指向的被标记的内容进行进一步操作，进而将能够自动处理内容同步到对应的文件中。Pull的过程大致过程如下:Org将会将 mobileorg.org 中的所有entries移动到 org-mobile-inbox-for-pull 所指向的文件（假设为mobileinbox），每个被捕获的entry和编辑事件都会被做为这个mobileinbox中的顶级entry而存在。（进行操作之后， mobileorg.org 将会被清空）当将entries移动到 org-mobile-inbox-for-pull 指向的文件之后，Org将会开始执行在MobileOrg进行的修改。有些修改直接就会被应用了不需要额外的用户交互（例如修改tag、TODO状态、标题、正文文本可以被简单的应用）。而需要额外动作的entries会接收到一个:FLAGGED:的tag，这样它们才会很容易地被找到。当应用修改或者寻找一个entry之时出现了问题，目标entry将会保持在 org-mobile-inbox-for-pull 中，并且被标记一个错误信息，我们需要之后手动解决这些问题，并将对应内容(entry)转移到期望的位置。(不熟悉)Org之后会生成一个包含所有flagged的entries的agenda view，用户可以遍历这些entries来做一些必要的动作。如果在对MobileOrg中的entry进行标记的时候一个note已经存储了，那么这个note会在光标处于对应agenda line的时候在回显区域显示出来。关于 ?在哪个特定的agenda中按下 ? 将会在另外一个windows中显示整个被标记的笔记(flagging note)，也会将它push到kill ring中。所以，你可以在这个entry中使用 ?z C-y C-c C-c 保存哪个标记笔记为普通笔记。连续键入 ? 两次将会体同将 :FLAGGED:标签联通记录的标记笔记（flagging note）（在一个属性中被保存）一起被移走。这样，你可以用此来表示这个 flagged entry的处理已经完成。如果你不能够直接处理所有的flagged entries，你可以通过 C-c a 回到这个agenda view。PC端的Push推送内容到MobileOrg端(PC端的push)的时候，会推送PC上设置的 org-mobile-files 对应的文件，该变量对应的文件路径是相对 org-directory 的路径，默认使用 org-agenda-files ,被退送的目标是 org-mobile-directory 设定的位置。Push的过程大致如下：拷贝 org-mobile-files 中的内容到同步目录 org-mobile-directory 中，文档中提到，如果待推送的文件是一个链接文件，那么链接文件名称需要和源名称一致。创建特定的agendas.org文件，这些文件可以是用户自定义的agenda view，由 org-mobile-agendas 来设定。最后，orgmode会写一个 index.org 文件，这个文件包含所有到其他文件的链接，Mobile首先在Server中读取这个文件，然后把这个文件中列出的所有agendas文件和org文件下载下来，为了加速下载过程，MobileOrg只读取checksums3被改变的文件。4.7.2.3 Org与MobileOrg的同步目录我们需要注意，在前面的讲述中所涉及到的同步，其实暗含了两种同步：Mobile端的MobileOrg与PC端的Org之间的同步（通过设定一个同步目录做为中转）这个前面也讲到，主要是Mobile端的Sync（包含Push/Pull）操作，以及PC端的Push/Pull操作。同步目录在云端与PC/Mobile端的同步前面MobileOrg和Org同步之时，需要经过它们之间的一个共通的“同步目录”。这个目录在Mobile端和PC端的内容和结构需要首先保持一致，才能保证后续MobileOrg和Org之间数据的同步一致。所以，我们在同步PC端的Org与Mobile端的MobileOrg之前，先将PC端和Mobile端的目录通过某种方式进行同步。这里同步目录的方式使用用git进行，PC端和Mobile端之间的同步目录用某个git托管服务器进行管理（例如github、bitbucket、或者自己的服务器），任意端的同步目录中数据发生变化后都要推送到托管服务器中，而任意端要读取最新数据都需要从托管服务器中拉取数据，同步目录中的数据更新之后，再进行后续MobileOrg和Org的数据更新。我们也可使用其它方式管理同步目录，比如云存储（百度云、DropBox等）、或者ftp、webdav、ssh等。另外，Mobile端的git可以使用pocketgit工具。4.7.3 同步操作4.7.3.1 PC端的Org推送（Pull）命令如下：M-x org-mobile-push 推送之后，会在同步目录（即 org-mobile-directory 对应的路径）中建立 org-mobile-files 对应文件列表的路径结构，并拷贝相应文件到其中。4.7.3.2 PC端的Org拉取（Push）命令如下：M-x org-mobile-pull 运行之后，其对应的 org-mobile-files 便包含了和MobileOrg同步的内容。4.7.3.3 Mobile端的MobileOrg同步（Sync）这里使用Android版本的MobileOrg，大致如下：首先设置好同步目录，然后选择软件界面中的"Sync"按钮，即可完成同步（包含Pull和Push）。4.7.4 使用举例PC上配置好相关变量和目录手机上安装好MobileOrg也设置好同步目录将PC和手机上的同步目录用github/bitbucket管理PC上同步目录更新： git/pullPC上记录之前运行： org-mobile-pull 可以看到手机上修改的内容。PC上记录，记录之后运行： org-mobile-pushPC上的git同步目录上传修改： git add/commit/push手机上的git同步目录下载更新： git pull手机上的MobileOrg同步(点击Sync)手机上看到PC修改的内容手机上修改并同步（点击Sync）手机上更新同步目录： git add/commit/push回到步骤4。4.7.5 其它目前发现，该功能列表中的段落，无法识别断行？对复杂的管理不是非常实用，相对而言，mobile org中Capture功能相对实用一些，可以将片段捕捉下来，同步到电脑上(但是同步的过程也比较繁琐)。参考相关文档：MobileOrg4.7.5.1 改进已经将状态文件冠以 _ 前缀，便于在Agenda View中集中浏览，例如: _inbox.org, _next.org &#x2026;。每一步处理中，处理子项的步骤可以按照层次冠以 ---- 前缀， n层子处理步骤冠以n个 =-&#x2014;=前缀。例如：**NEXT test1***----&lt;2015-12-21 一 16:17&gt; xxx1***----&lt;2015-12-21 一 16:17&gt; xxx2****--------&lt;2015-12-21 一 16:17&gt;xxx2.1****--------&lt;2015-12-21 一 16:17&gt;xxx2.2这样显示便于在Agenda中一目了然哪些是子待办事项，以4个为单位因为4个字符比较容易输入。回顾的细化：短期回顾简单处理时，会将特定状态关键字的任务从状态文件间迁移，稍复杂的处理会将任务直接迁移至特定文档中（在该文档中做为属于该文档的任务）；中期处理之时，除了对应状态关键字和状态文件，也对状态关键字的任务必要时迁出状态文件进入特定文档中。5 WAIT/FORWARD FAQ [8/11]([72%])State "WAIT/FORWARD" from "NEXT"       [2015-11-27 五 15:07]  Wait for all done.State "NEXT"       from              [2015-11-27 五 15:07]5.1 DONE 如何划分任务状态以及存放的文件？State "DONE"       from "NEXT"       [2015-10-08 四 10:23]参见: 任务状态 和 划分文件5.2 DONE 如何实现任务管理的基本管理？State "DONE"       from "WAIT/FORWARD" [2015-11-27 五 16:13]State "WAIT/FORWARD" from "LATER"      [2015-11-27 五 16:13]  wait for moreState "LATER"      from "NEXT"       [2015-11-27 五 16:13]State "NEXT"       from "INBOX"      [2015-11-27 五 16:13]参见:实现Orgmode任务管理的基本管理5.3 DONE 如何设置交叉引用?State "DONE"       from "NEXT"       [2015-11-26 四 17:51]参考：交叉引用5.4 DONE 如何设置优先级别?State "DONE"       from              [2015-11-26 四 18:00]参考：设置优先级别5.5 DONE 如何迅速捕获临时产生的任务，以及将各个任务标题在状态文件中进行转移？State "DONE"       from              [2015-11-30 一 10:38]参见：Capture-Refile-Archive5.6 DONE 如何设置归档?State "DONE"       from "NEXT"       [2015-11-27 五 14:54]参见：归档5.7 DONE 便于整理周回顾?State "DONE"       from              [2015-11-27 五 10:35]参见：便于整理周报的记录技巧5.8 DONE 如何将PC与移动端的orgmode整合?State "DONE"       from              [2015-11-27 五 11:02]参见：orgmode与mobile org整合5.9 LATER 杂乱问题State "LATER"      from "NEXT"       [2015-11-27 五 16:13]State "NEXT"       from              [2015-11-27 五 15:29]这里描述一些无法分类是杂乱问题。进入 inbox.org的 INBOX 的任务，在回顾的时候，首先切换其状态，然后再refile到对应的状态文件？目前是对于到状态文件的任务，是先切换，再refile；对应其它特殊文档内部的TODO任务，refile与切换次序随意。每个状态，工作日志记录到有状态切换的日志中，还是也可能根据自己情况记录工作日志？不用都加note，也可每个状态切换都加详细的note。折衷起见，主要处理信息还是列在后面。状态切换的列表中，可以添加每次关键的一些步骤。比如NEXT状态中，又获取到一些新的信息，可以切换状态增加NEXT-&gt;NEXT的时间戳，然后附上一个简短笔记“xxx发生了”。5.10 NEXT 改善归档与done/cancel策略State "NEXT"       from              [2016-02-03 三 09:43]之前都是将done和cancel状态的内容放置目录中，按照月份存放相应状态内容，原因是相应状态的内容是属于不断积累增多的，不可能只放在一个文件中。考虑到归档的功能，其实将done/cancel内容放置在一个文件也可，只需要定期进行归档即可，积累的内容会不断地移动到归档中，而归档又可根据日期来进行划分。而wait/forward中的内容，需要再考虑如何进行，目前暂不设定归档， 设置的方式也仍然采用目录的方式，以便学习时能够知道目录目标的设置方式。5.11 NEXT 改善refile的配置方式State "NEXT"       from              [2016-02-03 三 09:46]将refile目标放置到一个文件中，有时候会出现问题，目前不再使用这个方法。直接将refile的目标配置到配置文件中，这样更为保险。;;set agenda files(setq org-agenda-files (list                         (concat org-directory "gtd/_next.org")                         (concat org-directory "gtd/_later.org")                         (concat org-directory "gtd/_wait_forward.org")                         (concat org-directory "gtd/_maybe_future/")                         (concat org-directory "gtd/_cancel.org")                        (concat org-directory "gtd/_done.org")                         (concat org-directory "gtd/mobile_org/_mobile_inbox.org")                         (concat org-directory "gtd/_active")                         (concat org-directory "gtd/_review")                         (concat org-directory "gtd/output/")                       ))      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2015-11-27 五]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-11-27]<a href="/categories/note/gtd_with_orgmode.html"> 使用orgmode进行GTD管理  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'GTD管理方式'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2015-11-30 一]	  	    		  Update	  	    Table of Contents1. 前言2. 概述2.1. 执行平台2.2. 良好GTD系统应该具备的特性2.3. 主要内容3. 任务和项目3.1. 项目3.2. 任务3.3. 举例说明4. 管理思路4.1. 任务管理4.2. 项目管理5. 执行方式5.1. 任务状态5.1.1. 支持的任务状态5.1.2. 任务状态与生命周期5.2. 项目与回顾5.2.1. 项目状态5.2.2. 项目生命周期6. 建议6.1. 原则6.1.1. 不要将任务状态设置太多6.1.2. 任务不一定全部要处理完毕6.1.3. 任务从“收集”中拿出后，不应该再放回去6.1.4. 进行的任务要先移动至“下一步”状态，再进行处理。6.1.5. 处于“下一步”状态的任务不宜过多6.1.6. 处于“稍后”状态的任务，要么会回到“下一步”，要么会被放置其它状态6.1.7. 大多数GTD管理不需要过于复杂的特性6.1.8. 多操作多整理多回顾有助获得正能量6.1.9. 在特定环境下可借助特定工具扩展GTD来提高效率6.2. 推荐6.2.1. Orgmode6.2.2. DGT GTD6.2.3. 任意一个带有分类功能的便签7. 其他7.1. 使用GTD思想进行内容管理7.1.1. “任务管理”方面7.1.2. “内容管理”方面7.2. 将GTD管理中产生的数据进行内容管理7.2.1. 管理思路7.2.2. 举例7.3. 使用GTD标签管理信息7.3.1. GTD标签7.3.2. 实现方式7.3.3. 扩展7.3.4. 关键7.4. 使用GTD方式管理邮件7.4.1. 实现思路7.4.2. 实现举例7.5. 使用GTD方式管理工作文件7.5.1. 思路7.5.2. 实现举例7.6. 杂乱7.6.1. 任务状态7.6.2. 任务属性7.6.3. 任务性质7.6.4. 优先级划分7.6.5. 劳逸结合7.6.6. 回顾的解释7.6.7. 管理回顾的经验7.6.8. 关于参考7.6.9. 如何处理“项目分类”与“状态分类”实现的冲突7.6.10. 自我管理的演化过程7.6.11. 参考资料7.6.12. FAQ1 前言这篇文章并不是以教程目的存在，其实是在本人实践GTD方式半年多的时间里，总结的文档。其中肯定有不确切或者错误之处，但是理解的方式因人而异，希望此文能够为学习GTD以及想高效组织和管理自身生活的朋友们带来一些提示。文中全部基于文本方式实现并无配图，配图可能会让理解更为直观，但是目前看来更多只能做为点缀，细读本文的读者应该不用借助配图便能获取其中的思想，配图可能会在将来更新之时给出。文本原始格式是Orgmode文本，如果看到网页本版或者其它更多格式的本文，应该都是基于该语法导出的文章。采用git方式进行版本管理，所以可能会在完善更新过程中不断发布新的版本。2 概述GTD是一种思路和方法，它可以渗透在我们生活的方方面面，而不仅仅做为任务管理的手段而存在。这里给出的只是是众多GTD管理方式的一种，是基于个人目前应用与实践情况而采用的GTD管理方式；GTD管理并不依赖特定工具，它可以在个人实践过程中，根据情况逐渐完善与改进；不同场景和环境下可能会借助不同的方式或工具来使用GTD，但是这些方式或者工具等都具有一种共性，这个共性就是GTD的思想。2.1 执行平台本文中叙述的GTD方法是基于一些常见的可分类、可贴标签、具有内部引用链接等功能的笔记进行，如为知笔记；但是讲述的方法会尽量避免依赖外部环境的特性（比如标签和引用的功能不一定在所有的工具中都有，Windows下的记事本就只能支持文本编辑）而强调方法的通用。2.2 良好GTD系统应该具备的特性添加对特定环境的特性依赖能使得在该环境下的GTD管理更有效率，但是对于一个良好的GTD方式，个人认为应该具有如下特性：在现有环境中，应该能够方便地添加适合当前环境的特性依赖以提高GTD系统的效率。更换环境之时，原有的GTD系统应该能方便地迁移到新的环境下继续运行。切换到新环境之后，应该能方便地去掉对原有环境特性的依赖。其实，这几点分别是对GTD系统扩展性、通用型、灵活性方面的要求，具有这些特性，有助于增强其健壮与稳定。任何系统在完善之前，首先要保证它有足够强的生存能力，最简单情况下，可以只凭借分类的文件系统、或纸质笔记、甚至只凭借自身的记忆（如果能够保证不会遗忘的话），实现GTD的管理。^_^2.3 主要内容任务和项目管理思路执行方式建议其他3 任务和项目3.1 项目这里的项目，是一个需要处理的事情、计划、或过程。它是日常生活、工作、学习中，我们所有要处理的、一系列相关的事务的统称，不同的项目代表不同类的事务。项目使得我们日常凌乱的处理事务，有了一个明确的归类。3.2 任务这里的任务不像项目那样笼统，而一定是可以明确执行的一个步骤，它可能属于某个项目。确定的任务可以让我们平时行动之时，目标明确，精力集中，无需被更多琐碎的处理判断归纳分类等而分心。3.3 举例说明例如：“学习英语”，这就不是一个任务，它是包含许多步骤的过程，对应这里所讲述的项目；  而“背诵5个单词”，就是一个具体的任务，它属于“学习英语”这个项目的一个子步骤；  我们每完成“学习英语”中的一个任务，就距离“学习英语”这个项目的目标更近一步了。  我们在真正学习英语的时候，每一个时刻其实都是在集中精力做其中的一个任务，期间不可能还做其它的事情；比如“背诵5个单词”的时候，我们不应该还要分出心来思考：“学习英语需要先背诵一定的单词，然后尝试阅读，学习祈使句语法……”；我们只需要背诵完这5个单词，别的事情是规划的问题，会在完成当前“背诵5个单词”的任务之后，来专门集中决策一下下一步需要做的事情。总之，项目是需要规划的，任务是需要执行的，而规划是确定任务的。在一个项目中，将规划和执行分开，可能会提高完成的效率，而能够高效的完成所有的项目，会提高我们的生活质量。另外，并不是所有的项目都一定要完成，GTD只是让完成的效率尽量高，尽量减少压力，而非一定要将其中的项目完成。4 管理思路这里的GTD系统，实际重点在于管理任务的方式，项目在GTD中主要是用来反映将其中相互关联的任务集中起来便于回顾，对于复杂项目的管理方式，可能需要额外考虑。目前大致采用如下方式管理项目和任务，今后有好的方式会逐渐改善。4.1 任务管理每条任务使用单独一条笔记来表示，所有的任务都有自己的状态，状态通过目录来管理，具体见后面。使用本方式管理任务，目前比较弱势的方面是缺乏时间提和醒方面的内容(也许是为了增强其简洁并且可移植，而导致的缺陷)，无法让任务随时间而迁移状态，无法合适的指明任务的时间属性，以及无法合适的在恰当的时间进行提醒。所以日常经常进行的、并且对时间提醒方面依赖不大的任务可集中在这里进行（例如工作日志）。而需要依赖其他特性(如提醒)的任务内容，可考虑借助工具辅助完成，如DGT GTD、中华万年历、等等。4.2 项目管理每一个项目用一条回顾来表示，而每条回顾用一条笔记来表示，而所有项目类似任务，通过项目的状态目录来管理，具体见后面。使用本方式管理项目，目前比较弱势的方面是暂时还无其它合适的方式管理，因为项目也是随时间动态变化的，随着时间的推移我们会遇到的新的项目和计划，所以用目录或标签来表示项目也不太合适（经常建立新标签或者目录会使得系统越来越复杂），这里暂时用回顾表示一个总体的项目，每个回顾用一条笔记表示，期间的产生的各个行动步骤变成特定状态的GTD任务进行管理。执行任务时的一些关键的步骤会纳入到这个回顾系统中，回顾作为总体索引，也用来表示一个计划，期间会引用到本GTD系统内的任意一个其它的任务或者回顾等，也有助于保持整个GTD系统的有序。5 执行方式5.1 任务状态每种任务同一时间只可处于一种状态，所以可以考虑用目录方式实现任务状态。  5.1.1 支持的任务状态“收集”当遇到一个需要处理的任务之时，我们需要首先迅速把它记录下来，可以只简单给出一个标题以便提示等等，之后在空闲时会对其进行进一步处理。这个最初出现的任务，可以没有经过任何整理，此时它处于“收集”状态。它是任务出现的初始状态，是所有内容流入GTD系统的入口。“下一步”同一时段我们一般只能处理有限的任务，根据实际情况，我们可能会从所有任务中选出一部分进行处理，这些已经开始进行处理的的任务，便存在这里，处于“下一步”状态。它是推动GTD系统运作的动力，使我们更集中精力于应该做的事情上来，而不被其它还没有开始的任务扰乱心神。“稍后”这里的任务也是应该做的，但是由于日程或者其它原因，需要将一些相对不重要的任务暂停，推迟一段时间再做，这时任务便处于“稍后”状态，它在GTD中起到缓冲紧张度的作用。“等待委派”有些任务在自己这里已经没有什么可以做的了，需要等待其它方的处理之后才能继续确认下一步的进行状态，或者转交给其他人处理，这可以将任务转给别人，这样的任务就处于“等待委派”状态，它可减轻GTD系统的负担。“将来也许”类似推迟，不过这里的内容表示没有一个期限的“推迟”，这里的任务相对推迟的任务来说也更显得“不重要”一些，这些“以后用空再做”的任务都放在这里，处于“将来也许”的状态。这个分类可以允许我们大胆的将想做的列出，并且可以不用对列出的事情“负责”，想做就做，不做也不会消失，它能大大减少GTD系统的拥塞程度。“已完成”一个任务完成之后，可能以后也会引用，也可能不会，这些已经处理完毕的任务，便成为“已完成”状态，它是GTD系统的历史。“取消”有些任务开始可能在“下一步”，过后又变成“推迟”了，再过后又“将来也许”，再过后，可能都没有必要执行它了，不删除它们，是因为可能它们将来还会有用，这些任务便处于“取消”的状态，相当于GTD系统的回收站。5.1.2 任务状态与生命周期在上述状态下，我们给出一个描述任务生命周期的例子。a.阅读英文文档时，忽然发现需要背诵一些特定的英语单词，于是向“收集”状态目录中，添加一条“背诵英语单词”，然后继续工作。b.空闲时，对“收集”状态的任务处理，这时发现“背诵英语单词”这条任务比较重要，于是把它纳入到“下一步”，准备之后就进行。c.开始处理任务时，首先看“下一步”是否有任务，发现“背诵英语单词”这条任务， 于是开始进行学习，学习过程中不断的对该任务对应的笔记进行记录总结汇总更新等。d.学习一定时间后单词还没有背完，但是在"下一步"又有其它的任务更为重要需要处理，于是开始处理其它的任务。e.在处理“下一步”状态中的任务时，不断的有其它更多的重要任务需要处理，学习英语单词暂时还不能继续，于是把它从“下一步”移动到“稍后”状态，待处理完手头的任务之后再继续处理此任务。f.处理“下一步”状态的任务时，不断的有新的比背诵英语单词更重要的任务，由于有重要的任务在先，被移动到“稍后”状态。g.待“下一步”的任务处理完成后，再看"稍后"状态的任务，找到其中重要的任务，将它重新迁移到“下一步”中，准备进行处理。h.处理完“下一步”的任务，再次从“稍后”状态的任务中， 选出重点的进行处理，这时发现“背诵英语单词”这条任务优先级很低，可能短期内不会再进行了，于是将它移动到“将来也许”中。i.某日实在清闲，在“将来也许”中随便拿出一个叫做“背诵英语单词”的任务，放到“下一步”之前，发现它没有必要了，于是放到“取消”中，表示这个任务不执行了。j.很久以后，浏览“取消”的任务，发现“背诵英语单词”，感觉最近要做，于是放到“下一步”。k.到“下一步”中，取出一条“背诵英语单词”的任务，开始进行，直至完成后，将其移至“已完成”中。至此，“背诵英语单词”这条任务结束。5.2 项目与回顾项目回顾是对GTD系统中任务的有机组织，每条回顾都包含相关的其它子项目或者计划、以及诸多任务处理状况的汇总。它可以使GTD系统更为有序，也便于将来跟踪相关的任务和情况。  由于项目是一系列相关任务的组合，所以每个项目借助一条回顾来表示；而我们遇到的项目的分类和数目经常随时间变化，所以用每条笔记而非目录表示一个回顾，进而表示一个新的项目。同时，类似于任务的管理，由于状态是所有项目相对通用和固定的属性，所以我们用不同的目录来表示项目状态，存放所有项目，为便于区分，表示项目的目录以“#”作为前缀。5.2.1 项目状态这里用来存放项目回顾的主要状态目录有：  “#活跃”有些任务，如学习计划等可能需要反复执行，或者有些项目正处于活跃处理过程中，从中会不断衍生出新的任务到相应的任务状态。这样的项目便处于"#活跃中"状态，当项目进行到一定程度不再特别活跃的时候，可能会进入“#项目回顾”状态。“#回顾”是对相对不活跃的项目汇总，包含已经完成或者基本明朗的项目。在进行任务时，并不是所有任务都要建立回顾。当发现一些任务需要梳理其关系和追踪的时候，为这些相关的任务建立一个回顾，可起索引汇总的作用，在日后回顾这些复杂的任务之间相关的过程之时也可参考。实际上有些项目，开始是做为任务进入到“收集”状态的，执行一段时间之后，知道了它可以做为一个项目回顾后，便将其放置到相应的项目回顾目录中。从这点上来讲也可看出，其实收集既是项目的初始状态，也是任务的初始状态，是任务进入整个GTD系统的入口。5.2.2 项目生命周期项目的生命周期一般是：收集、活跃、回顾；而需要重复执行的项目，其回顾放在"#活跃"目录中。6 建议6.1 原则建议在实现GTD时，能遵循如下的原则：  6.1.1 不要将任务状态设置太多过多的状态会导致GTD系统的复杂，处理任务时反而会因此分散精力。6.1.2 任务不一定全部要处理完毕GTD不是为了完成任务，而是为了减轻压力，使用GTD还能辅助记忆和梳理，减轻大脑记忆的负担。6.1.3 任务从“收集”中拿出后，不应该再放回去收集箱是暂存新流入和产生的任务，它是GTD内容的主要来源，而非为状态迁移而存在。6.1.4 进行的任务要先移动至“下一步”状态，再进行处理。这样能保证正在进行的任务集中在“下一步”状态，将精力只集中在“下一步”中的任务，而无需分散精力在其它状态中寻找需要处理的任务。6.1.5 处于“下一步”状态的任务不宜过多“下一步”是当前真正正在处理的任务，能够同时处理的任务是有限的，这里的任务不宜逗留过久，迟早会被处理成其它状态。过多的“下一步”任务，会为大脑和心里造成很大压力，同时。6.1.6 处于“稍后”状态的任务，要么会回到“下一步”，要么会被放置其它状态一些相对比较重要但是还来不及处理的任务，不放在“下一步”而是放在“稍后”中，可以起到缓冲压力的作用。这里的内容实质是被推迟的任务，如果不会被推迟很久，迟早会回到“下一步”状态；如果它可能会被推迟很久，那干脆将它放置“将来也许”甚至“取消”中。6.1.7 大多数GTD管理不需要过于复杂的特性执行GTD不应当过度依赖工具，只要可以创建内容（表示任务），并且能将内容归类（表示状态），完全可以手动完成绝大多数GTD管理。6.1.8 多操作多整理多回顾有助获得正能量经常回顾和整理自己的GTD系统，可以保持系统有序，还能给自己反馈正能量。GTD中表示待办任务，处理任务时便有一种做事情，也看到了效果的感觉。有一种说法是，这些“成就”会被大脑做为努力一段时间的“奖赏”，在手动处理GTD的同时会不断地有一种亲身获得“奖赏”的感觉。直观一点说，执行任务之前，会在心里不自觉地讨厌列在表上的任务条目，当完成任务之后，手动管理会亲身体会到将讨厌的那一条任务删除的成就感，尽管每次的成就很少，但是众多这样的反馈不断的激励着大脑，却能给自己带来意想不到的力量。6.1.9 在特定环境下可借助特定工具扩展GTD来提高效率除了基本的GTD功能，对于特定工作环境，一些高级属性借助工具扩展，可能会有助提升效率。如今日待办、或者提醒，场景或任务跟踪等等，在一些工具中有特定的表示和组织方式，设置好相关属性后，任务会自动迁移、或者提醒等等，避免了手动设置。尽管几乎不用进行手动设置了，但是想要保持自己GTD的有序和获取更多的执行动力，还是要经常回顾。可以借助相关的GTD管理工具，这里介绍几个：6.1.9.1 DGT GTD：是安卓系统下非常全面的GTD工具，操作便捷，记录迅速，自定制功能丰富，支持备份，自定义同步等，只是刚开始需要稍微熟悉一下其操作的方式。简单说，两个特点：“丑”（不是很丑）、“好用”（非常好用）。6.1.9.2 Doit.im：支持多平台，云同步，界面简洁便于初学者使用和理解GTD的工作流程，但是有些功能需要收费才能实现。6.1.9.3 Omnifocus：没有亲自用过，根据许多文章中的介绍，可以知道这是一款重量级的华丽版的IOS下的GTD管理工具，入门门槛高，但是功能极其强大。6.1.9.4 2Do：也是一款IOS下好用的GTD管理工具，功能强大，入门相对简单。6.1.9.5 Wunderlist(奇妙清单)：简洁的界面，不过在国内同步功能比较慢。6.1.9.6 toodledoIOS下一个比较流行的GTD工具。6.1.9.7 Orgmode：这个其实是基于文本的标记语言，是Emacs的一款著名的编辑模式插件，但是功能非常强大，目前已经在许多地方支持（如vim、github、IOS、Android应用上等）。它的初衷是项目管理相关的目的，其中就包括能够实现GTD管理的相关内容，但是功能不仅限此，它也可以用来记录笔记，记录的笔记基于大纲模式，有一定的所见即所得功能，但是更强大的是“所想即所得”的特性，是word远不能及的。这个工具/语言不限于平台，只需遵循orgmode语法即可，配合Emacs进行使用会使得效率极高、扩展性几近无限。Orgmode能够完成的功能也会随掌握程度的提升而丰富：如果简单掌握，那么Orgmode属于轻量级标记语言中的一种；但是如果需要更多的功能（如导出发布为各种格式），则需要进一步的学习。关键的是，Orgmode文件是纯文本格式，只需纯文本格式的内容便能实现它的全部功能。6.2 推荐这里算是给本文以及实际中习惯的工具做一个“广告”吧。具体如何理解和接受，还要看各位读者的喜好。结合实际经验，这里给出用于GTD管理的工具或方法选取的建议。如果一个工具或方法它存放数据的形式越原始，越开放，记录越便捷，其适用度越高，也越容易被人接受（我想相对于直观的文本格式内容，哪些数据库格式、或压缩格式、或版本控制数据格式、以及更多其他特定格式的数据文件，更容易让人接收应当是文本格式的内容吧）。毕竟数据是自己的，工具只是外壳；访问数据的便捷可能需要借助特定的工具或方法，但是如果脱离了特定的工具方法，数据仍然不受影响才是多数人关心的。对于GTD管理的工具和方法，做如下推荐：6.2.1 Orgmode它其实已经超出了工具的范围，它实际属于一种语言或者规则、方法，功能比较全面，不仅可以GTD管理，还能做项目管理、内容管理等等。Orgmode可以让我们记录的数据以最原始的方式（直观的文本方式）来展示出来，而访问数据的方式一方面可以通过Emacs的orgmode高效进行，另一方面也可脱离相关工具，只要掌握Orgmode的一些约定语法我们仍可以用最原始的方式（如记事本）访问我们的数据，更能结合使用各种版本控制工具来管理我们的数据等。另外，我们还能将Orgmode的数据导出为当前流行的各种格式（如Html、pdf等），当然，越复杂的功能，就越需要更长时间的学习，如果我们没有足够的时间，Orgmode的简单功能也是够用的。因为期间会涉及到Emacs的使用以及Orgmode的配置等，篇幅关系会有专门的文档对Orgmode进行介绍，这里不详细说了。6.2.2 DGT GTD在安卓系统上，它也将其工具的特性发挥到了极致。几乎支持所有你能想得到的GTD管理信息，也支持数据导出、共享、备份等等，最重要的是，记录非常方便，非常适合记录一些瞬间涌现的灵感等等，当然，为避免日后可能会迁移数据引起的问题，重要的数据还是尽早导出到一种通用的存储方式组织好（例如OrgMode）。6.2.3 任意一个带有分类功能的便签毕竟不是所有人都使用Android系统，如果找不到或者没有或者不想学像DGT GTD那样的工具，可能会有些不方便，即便如此我们仍然可以进行GTD管理。我们各自的系统中一般也都能找到一个类似“便签”、“记事本”的工具，如果没有，一般也都能够找到对应系统的一款相关软件。最后一个方法，也就是：结合本文中介绍的方法以及你当前系统上已有的某个相对便捷的、带有“分类”特性的记事软件，也能实现基础的GTD管理。方法很简单，就是将本文中提到的几个GTD状态做为分类，每一篇的笔记内容做为GTD任务（例如，可以使用比较常用的云笔记、中华万年历、为知笔记、evernote、甚至系统自带便签来进行）。如果以上提到的环境都不具备，也并不代表不能进行GTD的管理了。毕竟GTD只是一种方法，如何使用它，还是要看使用这个方法的人。正如前面已经提到的，每个人都有自己的方法来实现GTD，只有一个纸和一支笔，甚至只有一个好的记忆方式，也一样能实现GTD的管理。因为实现GTD最本质的东西只需两个条件：记录和分类。7 其他本文介绍的只是一个实现GTD的核心思想，但是并不包括全部。还有许多基于此的应用场景、和变通的方法（如邮件管理、内容管理、工作项目等等），本文不做过多介绍，会在日后相应的机会下可能有所介绍。使用GTD后一段时间的感受：好的工具能够提高你的效率，但是世界上没有最好的工具，因为总会有新的思想来创造出更好的工具，摆脱工具控的限制，用知识来充实自己的思想。这里给出几个利用GTD思想进行管理的实例：7.1 使用GTD思想进行内容管理这里所说的内容管理是对知识体系的一种组织形式，是日常存放积累知识的体系，实现完整的内容管理和GTD管理类似，也需要一些特定的方法（比如通过云存储、云笔记、版本控制、文件管理等等）。这里不对内容管理的方面做过多介绍，虽然内容管理与任务管理是两个方面的内容，但是它们之间也并非没有联系，这里着重讲述如何将GTD思想应用到内容管理上。在没有一个比较系统的方式管理我们积累的内容之前，这些内容可能会显得杂乱、无章，虽然也经常会进行定期的清理和组织（比如，对分类系统的重构、重新定义，将某些分类中的内容进行修改、或迁移等等），但是整理的过程比较耗时耗力，并且不同时刻整理之时采用的思路和策略（很多都是临时想到的方法）也可能有所不同，尤其是对于“非专业”的内容管理，每次整理后，之前整理的策略也很快会忘记，新的内容又会导致内容系统逐渐重新归于混乱，甚至整个知识体系的结构都会发生翻天覆地的变化。随着时间的推移，和越来越多的内容“堆积”，很容易让人产生疲劳和沮丧。其实我们可以将这些问题归结为两点：需要不断地完善更新这些内容的组织方式需要一个好的方法来完善更新相应的内容组织方式前者属于知识本身的结构化（成长）问题，它可能会随时间、以及我们每个人知识系统的不断扩充而变化，管理策略可以采用内容管理方面涉及的各类方法和手段；而后者属于任务管理的方面，对应的任务便是对内容的管理。内容管理和任务管理之间没有明确界限，其中又有许多相互交叉的方面，所以我们可以将任务管理和内容管理结合起来（任务管理为辅，内容管理为主）管理我们的内容。随着我们知识内容结构的变化，可能不同阶段会需要不同的方法来管理内容，所以可以考虑选择一种相对固定的、不变的方法或思路进行“任务管理”，管理的任务便是“内容”，而管理的方式采用不同阶段涉及到的“内容管理”相关技术。这样，无论内容结构如何变化如何需要调整，由于更新内容所采用的“任务管理”手段相对固定，便能在已有体系基础上让一切有序的进行了。随着对管理技术的深入实践理解，采用的管理策略也会更趋向合理。这里抛砖引玉，给出目前我采用的一种方式^_^：如果GTD管理体系本身就做为内容管理体系的一部分存于其中，例如为知笔记用来管理内容，GTD与其中内容管理共存，此时可将用于GTD的内容 分类冠以"GTD_xxx"，所有GTD相关操作都在该分类中进行。关键是要将内容管理和GTD管理区分开来，分类的作用也可以是区分功能，不再局限于内容属性（这里是普通分类名称上加上特殊前缀等等，用以该分类用于功能属性）。7.1.1 “任务管理”方面使用GTD方法将“内容管理”做为任务进行管理:收集如果日常生活中，遇见有些内容值得记录至内容系统，那么及时迅速地将这些内容记录在某些固定的位置，先不用做更多处理。 记录的位置可以是事先设置好的一个内容管理默认分类，或者GTD中的收集箱，总之这样的地方根据自身情况只有几个，例如：手机中的便签、笔记中的“默认分类”或者“未分类”目录、收藏网页网址的工具、甚至是手动人为创建的“收集”目录等等，只要能方便、快速地将相关内容进行分享记录（例如通过手机中的“分享”菜单，电脑中的鼠标右键）即可。整理闲暇之时（如公交车上、排队等待等空余场合），到之前“收集”对应的那些地方，将曾经收集到的来不及整理的东西一一整理到对应的合适位置上去。具体整理的策略可能根据内容管理的方式而有所变化，但是既然采用GTD方式进行整理，那么整理过程中也必然会在每个整理的子任务中包含“收集”、“下一步”、“稍后”、“将来也许”、“等待委派”、“取消”、“完成”这些类似的状态，将每个整理任务都走完这样的状态，便能有条不紊地让内容越来越趋于有序。具体方式需要在内容管理中才能解释的更清晰，这里不做过多介绍。7.1.2 “内容管理”方面采用多种方式结合，内容保证集中存放、便于访问、灵活通用、可移植，有一个或者两个主要的知识系统，其它做为分支和辅助。内容管理应该属于和GTD时间管理“并行”的另一方面管理内容，比如“云笔记”（如为知笔记，麦库记事，有道，evernote，onenote，mynoteskeeper等）、“云存储”（如百度云，微云，Megalink等）、“本地存储”（存放一些私有数据资料）、“分布式版本控制”（如git本地存放私有内容，）、“版本控制系统托管服务”（github，bitbucket托管不敏感内容的git库）、“发布系统”（博客、Jekyll建站、Orgmode或Markdown便于分享的内容等）、以及其它（如便签、笔记、记事本、Pocket网页收集）等等。这里不过多介绍。7.2 将GTD管理中产生的数据进行内容管理这里介绍的是基于本文中提到的GTD方法，如何将其中的数据与内容管理系统衔接。7.2.1 管理思路在使用GTD方式处理日常任务时，一些的“已处理”状态中的任务，有些值得记录至自己的知识体系系统中，那么可以尝试一下这个方式：如果该任务没有对应的回顾引用到它那么直接将它从GTD系统中移动（或复制）到知识管理体系当中，根据自己的情况选择移动还是复制。如果该任务有对应的回顾引用到它那么不是将该任务内容简单移动或复制到相应笔记位置，而是将其复制到相应笔记处并添加一些引用信息，这样可以防止破坏原有GTD中回顾项目的链接。另外，最好也在GTD中记录一下复制到了哪里，下次更新之时，可以同时更新跟踪；同时内容记录之处，保留到回顾项目的反向引用链接。操作的时候，最好不要让GTD系统的回顾引用到GTD以外的内容。7.2.2 举例例如GTD中，有一条已经完成的任务（单词任务），该任务有对应的项目回顾（单词任务），并且这条任务已经整理到内容管理系统中的某个位置，则可采用类似如下方式处理（实际只需在相应的“已处理”任务中添加整理至何处的信息）。7.2.2.1 GTD系统项目回顾中对应的条目路径回顾条目路径为： 我的任务/GTD/#回顾/英语学习回顾  内容：回顾条目内容如下:xxxxxxx阅读任务单词任务语法积累任务xxxxxxx注意：列出的任务可以是链接，但是显示的名字要与对应的任务名一致，便于在不支持链接的笔记系统中查找7.2.2.2 GTD系统“已处理”状态中对应的任务：路径：任务条目路径为： 我的任务/GTD/已处理/单词任务内容：任务条目内容如下：已整理至：学习/英语/单词任务英语学习回顾XXXXXX注意：被整理至内容管理系统中的任务，整理之时，也在任务顶部追加“已整理至xxxx位置”之类的字样，最好名字也和实际笔记的名字一致，便于日后查找。7.2.2.3 内容管理系统中对应的内容：路径：笔记路径为： 学习/英语/单词任务内容：笔记内容如下：英语学习回顾XXXXXX注意：在内容管理系统中，保留回顾链接，可以链接至GTD系统中的对应回顾条目。7.3 使用GTD标签管理信息对于有标签功能的系统、软件、工具，其中的信息可以通过这个方式来整理，整理只能使相应的信息趋于有序，而每次的整理不会受上次整理的影响也不会对下次整理产生影响，简而言之，如果想用这个方式整理，那么内容会更有序，如果过段时间不用这个方式了，整理了一部分的内容，也不会因为半途而废而导致信息更混乱。7.3.1 GTD标签首先理解这个概念，GTD标签，可以用来辅助整理信息，如果某条信息没贴GTD标签则表示没有被整理过，也即“收集”状态，贴标签的的表示内容已由GTD标签辅助处理过，状态就是标签对应指示的状态。  采用这个方法，需要信息所处环境支持标签功能，并且将信息所处的环境的标签看做有两类:GTD标签,以及普通标签。普通标签就是平时我们使用的标签;而GTD标签是从普通标签中预留一些特殊标签（如标题前加GTD_），用做该方法的GTD整理。只有普通标签不代表已由GTD法处理过，并且不能同时贴两个同一体系的GTD标签，只有GTD标签表示暂不关注整理的分类。7.3.2 实现方式这种方法的原则是：采用此法整理过的内容，一定存在GTD标签，没有GTD标签的，视为没整理过（即收集状态）。即没贴GTD标签的，就是没整理的，整理好后，若不用借助GTD标签可保持有序，则可以不再贴GTD标签，过段时间又乱了可以重拾GTD标签辅助整理。  GTD标签举例gtd_下一步gtd_稍后gtd_将来也许gtd_取消gtd_已处理当信息已处理后（例如借助GTD整理好分类），可以只有已处理，或者同时有GTD标签和普通标签。这种方式适合无分类的信息管理，或者分类及标签混乱，但是还没应用GTD标签，借助GTD标签来管理内容。（例如pocket）7.3.3 扩展若分类大变，或者再次细化整理，则换一套管理思路，管理方式仍旧采用gtd方式管理.例如丢弃之前的gtd标签，采用新的gtd标签：gtd方式2_下一步gtd方式2_稍后gtd方式2_将来也许gtd方式2_取消gtd方式2_已处理这样扩展之后，就算之前应用过GTD标签，如果想换一条整理思路，那么重新换一套标签就行了，之前的标签忽略即可。建议软件能显示所有未贴标签的内容。建议能修改标签名。建议能批量加标签。标签和分类的区别是先有文章后有标签，但先有分类后有文章7.3.4 关键使用该方式，最好相应的环境能支持如下功能：能显示所有未贴标签的内容。能过滤显示出没贴特定标签的内容（如没贴GTD标签，却贴了普通标签的分类）。能修改标签名。能批量增、删改标签。7.4 使用GTD方式管理邮件如果是采取GTD方式管理自己的工作方式，其中邮件中的内容处理之后，可过滤到GTD系统中。而对邮件，也可采用GTD类似的方式来进行过滤，这样自己的GTD管理系统像是分层的一样，但是不宜过于复杂。7.4.1 实现思路大多数邮件客户端都有标签显示的功能，基于此，我们可以先定下如下规则：未贴标签的邮件，就是杂乱的不重要的邮件，而贴了标签的邮件，是需要关注的。7.4.2 实现举例设置如下类似GTD的系统标签：未读邮件类似GTD中的收集，这个状态在一般邮件客户端中都默认存在，所以并不对应什么标签名称，需要特别注意的是，收集是未读状态的无GTD标签邮件，而非无GTD标签邮件，这样保证收集的邮件不至于堆积。下一步该标签表示还来不及读取，只是通过标题等能确认是重点邮件，读取之后会变成后面的对应分类。类似GTD的“下一步”，需要过后进一步处理的邮件，这个分类的内容在整体中应该不多，处理后去掉标签或迁移到其它标签中，或重要邮件放到合适的位置、或者标签已办事项中。稍后相对下一步，可以稍后延缓处理的邮件。该标签邮件的处理方式类似前面，对应于GTD的“稍后”状态。将来也许不确定是否会用到，看起来像是重点，先堆积到这里。该标签邮件处理方式类似前面，对应于GTD中的“将来也许”状态。等待委派委派给别人处理或等待回复。该标签邮件处理方式类似前面，对应于GTD中的“等待委派”状态。已经处理的相关标签已处理邮件，不用贴上“已处理”标签，将其相应的GTD状态标签去掉即可，一般是已读的、未贴GTD标签的邮件，如果邮件比较重要，则建立一些根据自己情况的分类来重点存放。例如开发注意本项目发布，开发过程中的一些注意事项。该标签邮件处理方式类似前面，对应于GTD中的“将来也许”状态。项目文档项目开发、管理、会议、讨论等中发布的一些文档开发技巧日常开发的一些小技巧、说明等。通用技术一些比较通用的，不仅限于当前项目的技术内容，可以日后进一步学习或者有长远的作用的内容。公司事务一些公司事务信息，如人力资源相关、薪资、一些注意事项说明、出差、报销、福利等。重要信息暂时没有办法分类，但是感觉需要终点关注的邮件，比如阶段性的进展或者计划等。另外，有些系统中可用添加星标的方式标注邮件，这时候，一些临时性有期限的阶段重点可以用星标标注（比如上次release到了哪个版本，这次应该从上次的开始，那么每次release的时候为其添加星标，下次的时候就不会为了一个上次版本号，海量搜索所有邮件了），便于近期跟踪，相对重要信息，这类邮件的生命周期较短。这样处理邮件后，处理好的内容（转移至其它系统如GTD系统中继续也表示邮件处理完了）‍，要么就是添加上合适的标签，要么就是去掉标签表示不用关注。但是如前所述，如果感觉处理后还是很重要，那就加上星标。或者放到一个“重要邮件”的标签中。不同的客户端可能显示标签的方式不同，例如对于outlook，为了便于分类显示邮件，我们可以建立一个基于标签的搜索目录；而对于thunderbird，我们可以直接通过将标签添加到快速访问栏过滤显示；等等。其实添加标签后，标签基本上就可以预示分类了，但是如果标签感觉不是十分牢靠（可能一不小心点一下，就没有标签了）所以一些重要的没有过时的东西，可以按照意愿自建目录，转移到特定目录中。7.5 使用GTD方式管理工作文件有时候我们处理问题不一定全部在某一个GTD系统中进行，期间可能会涉及到访问电脑文件系统的相关操作。对文件系统采用GTD的方式管理，能避免文件系统的内容因文件杂乱导致的混乱。7.5.1 思路类似前面讲述的GTD标签的方式，我们可以创建一些GTD分类，将需要处理的资料流经这些分类最终归并到其他的合适的普通分类中。比如，查看邮件时，发现一个待处理的问题。这封邮件中包含一些附件，比如处理问题时参考的文档、处理时的日志、以及测试报告、测试程序；处理问题之时，又可能会查阅其它地方，将其它相关参考资料整理至本地（比如上网下载一个处理该问题的软件或者数据文件）；甚至会自己写一些文档记录当前处理的内容，比如设计文档、流程图、设计图等等。这些内容如果很多，那么可能会将自己的文件系统搞的乱七八糟。显然目前似乎也很难将这些内容的管理集成到现有的GTD系统中，或者也可以集成，但是需要再为现有的GTD系统添加一些额外的处理方式（这个方式可以因人而异，这里也不做介绍，可能将来会给出一套方案来解决这个问题）。如果我们不愿意花费精力将自己的这个GTD系统弄得很庞大复杂，为简便起见，我们可以给出一个折衷方案，自己习惯的方式，直接将相关的内容在本地文件系统中进行操作，但是操作之时，对文件系统采用GTD的思路划分。7.5.2 实现举例比如，我们给自己的文件系统划分为如下GTD分类目录：$ls -p1_inbox/  3_later/  5_maybe_future/  7_cancel/ 2_next/   4_wait/   6_done/  readme  ...目录内容如下：1_inbox/用于将所有处理问题过程中临时下载、获取的资料集中在这里存放，内容不能堆积要及时整理到其他目录。2_next/在整理文件系统时，将正在进行工作所需的资料汇集至此，不同内容可处于不同子目录中。3_later/在整理文件系统时，需要被推迟的事情所涉及的资料汇集至此，不同内容可处于不同子目录中。4_wait/在整理文件系统时，由于等待而被阻塞的事情汇集至此，不同内容可处于不同子目录中。5_maybe_future/在整理文件时，将不重要的以后可能会用到的资料堆积在这里，不同内容可处于不同子目录中。6_done/在整理文件系统时，已完成工作相关资料暂积于此，这里包含各种完成任务所涉及资料，将来可能进一步整理。7_cancel/在整理文件系统时，将取消的任务涉及的资料都汇集到这里，将来可能会被清理。readme对当前处理的目录结构的进一步说明。其它目录任何自己定义的目录。与以上GTD分类不冲突，GTD分类做为过滤，采用GTD方法，经过前面几个GTD分类的过滤（状态切换后）后，最终整理好的资料可以汇集于其他自己习惯的目录中。7.6 杂乱任何经验知识等叙述到一定程度，总有一些无法具体归类的杂项内容，哪怕是某方面知识体系中的一小部分，也很难一下子把所知以及真正的内容全部完美的表达出来。本文也是如此，所以在这里列出暂时堆积一些无法放置的，可能有待进一步整理也可能不会再整理的内容。7.6.1 任务状态GTD系统不是一成不变的，但是大多数GTD系统，应当具有如下几个类似的状态：收集、下一步、将来也许、已完成。收集箱用于快速存放所有临时想到的任务，有时间再将其进一步整理，细化任务属性，但是其中内容不要堆积。下一步便于集中精力，只存放当前处理的任务，其中内容不要过多。将来也许任务堆积的地方，可能做可能不做又不想遗忘的、没处理的任务，都可以先堆积在这里。已完成已完成的任务，做为备份或归档，可能将来回顾或进一步组织整理。7.6.2 任务属性除了前面的任务状态，根据所处环境、工具与方法的不同，GTD任务还可能具有的属性也有所不同。比较基本的有任务所属的“任务名称”、“项目分类”；有时候根据情况还需要其他扩展的属性如：“场景”、“开始/结束时间”、“是否重复”、“提醒”、“备注”、“优先级”等等。不同属性具有不同用途，实现方式也不同。比如：“项目分类”和“场景”可能用分类目录或者标签的方式来实现，如果采用分类目录，需要注意此时与状态分类并不冲突，因为分类不仅是对内容状态、属性的分类，也是对任务场景的分类。任务的“项目分类”一般在回顾的时候会经常用到；任务的“情景”一般在处于不同场合的时候用到（如@家里、@办公室、@外出等）；这些一般都可根据个人习惯进行设置，只要便于快速过滤到适合该情况下需要关注的任务即可。又如：“开始/结束时间”、“是否重复”、“提醒”……这类时间相关的信息，可能根据软件场合的不同也有不同的实现。比如Orgmode可以用时间戳和SCHEDULE属性等来标记这些信息等等。而有些工具在特定的时候，又可能会根据时间信息，对任务进行自动的处理，比如将任务贴上标签，设置好起始结束日后，过期或者特定时间，自动将任务移动到特定的状态或项目等分类中（有许多GTD管理工具中都有一项”今日待办“之类的分类就类似如此)，或者反复提醒。对于简单的GTD管理，如记事本方式，可能就很难直接实现这类根据时间有所动作的任务管理。7.6.3 任务性质如果对任务，需要时间方面的属性进行辅助管理，这里给出一些经验性的建议：提醒不用什么都设提醒，必须在指定时间做的事情，或重要的事情才值得提醒；提醒的功能可以任找类似闹钟功能的方便软件辅助即可（如中华万年历），不用必须集成到GTD中实现。日程有些任务虽然不需提醒，但是也对时间比较敏感，比如今日待办，明日待办，指定日期代办，将来待办等，虽然有些并不一定是要执行，但是都有一个期限，有些工具在日历中会将其标记出来。待办对时间不敏感的任务。有些任务对时间信息不是很敏感，或无法指定究竟什么时候需要做、需要完成，但是能确定的是它应该被做，这类任务可以称为待办。前面所述的，是对任务性质方面的划分，并不是必须的分类方式，这里真正做了划分的，我们在GTD中看到的各个任务的状态，大多状态的任务都具有以上之一的性质。对任务性质进行这样的划分之后，一些比较让人迷惑的概念应该比较容易澄清了。例如：日历、提醒、备忘、日程、待办……这几个概念经常在叙述的时候出现，如果不对其专门规定和提取，有时候连自己都会对其比较迷惑。经过上面的性质划分之后，我们可以这样理解：“日程”就是有时间安排的任务，它可以在“日历”中被标记出来。“备忘”有些是需要提醒的，有些不用“提醒”只要做为“待办”即可。7.6.4 优先级划分任务都有一个优先级的问题，有一个为任务优先级分类的方式：四象限法则。该方法不具体介绍，大致是将任务按照“紧急度”与“重要度”划分为四个象限：第一象限重要不紧急需要制定计划，按时完成的内容，是最重要的事情，它可以帮助我们进入良性循环。建议占用约65%-80%的精力。第二象限重要且紧急需要优先解决，这也是没有经过适当计划的内容，可能因为之前的安排不合理，导致一些任务从第一象限随着时间的推移被迁移到第二象限，可能导致我们无休止地一直在“瞎忙”。建议占用约20%-25%的精力。第三象限紧急不重要会让我们产生“这事很重要”的错觉的事件，实际上其实事件只是对别人而言很重要。建议占用约15%的精力。第四象限不重要不紧急浪费时间的事情，如果可能，交给别人去做。建议占用&lt;1%的精力。7.6.5 劳逸结合划分任务状态很大一部分也是为了集中我们的精力，将处理任务时精力集中在下一步，回顾时精力集中在任务的划分等等。而真正在处理任务之时，精力不一定能保证一直集中；集中过久又可能会导致之后的处理效率低下。所以可以考虑番茄工作法来改善这样的状况。番茄工作法是一种相对于GTD更微观的时间管理方法。大致如下：将每次做事情，比喻成番茄，休息和番茄交替进行。大致如下原则：一个番茄时间（25分钟）不可分割，不存在半个或一个半番茄时间。一个番茄时间内如果做与任务无关的事情，则该番茄时间作废。永远不要在非工作时间内使用《番茄工作法》。（例如：用3个番茄时间陪儿子下的棋、用5个番茄时间钓鱼，等等。）不要拿自己的番茄数据与他人的番茄数据比较。番茄的数量不可能决定任务最终的成败。必须有一份适合自己的作息时间表。通用的方式是：每个番茄25分钟，休息5分钟，但是也可根据自身情况而定。工作时准备好一个定时器，每次过一个番茄，一定休息，休息完毕，就下一个番茄，每次休息和番茄之间，通过定时器来提醒，防止“越界”。7.6.6 回顾的解释如果某项任务比较复杂，处理完毕后，最好能有一个汇总的文档，整理期间处理的情况，类似索引。便于以后参考引用，以及追加索引处理更新情况，也可能没有用处，这就是一条回顾，也是项目。回顾最初可能是以任务的形式出现的，将任务处理到一定程度后，发现其中可以划分为许多子部分，而最初的“任务”可以用来做为一个回顾索引，来引用到处理任务时涉及的的各个子部分。这个时候，“任务”就变成了“回顾”，将新建立的回顾放在相应的“回顾”分类中（如“活跃的回顾”、“普通的回顾”等），之后的处理全在“回顾”以及其引用的相应的任务中记录和复习，并不是说进入到“回顾”中了，就相应的条目就不能更新了，回顾是对项目的划分，这里存在的是项目而非任务，回顾并非任务的终结状态，它是一系列相关任务的处理情况记录和索引，便于今后理解和参考。7.6.7 管理回顾的经验这里有些，可以借鉴，不是必须的：回顾可能没有结尾，但是一定条理清晰，便于追加编辑，和索引。每条回顾中可能包含多条对任务的索引，索引内容不能太多，更多相关的内容可以在该索引对应的链接内容中体现。每条回顾对应一个项目，不同的回顾代表不同项目，每个项目是对相关任务的汇集。并不是所有的任务都需要回顾和汇总，一些单一简单的任务，其本身处理完放入到已处理中，本身就可当作回顾。回顾中索引引用的任务或者内容，最好和相应的任务或内容对应的笔记的题目一致，以便于在无支持链接的情况下移植。回顾和所引用的任务之间最好能够交叉引用。创建相关任务的时候，首先将回顾的链接附上。等待任务处理到一定程度之时，可以重新命名一个好的标题，然后再将任务链接贴在回顾中。理想情况下，回顾中只包含相关的任务标题链接，有时候实在需要进一步说明，也可在回顾相应的索引链接处中给出一些提示性的内容表征任务的大致情况。如果回顾对应的项目仍需继续，那么就不要将相关的所有任务清除为已处理，以免丢失对任务的跟踪。也就是说，没有完成，或达到一定阶段的项目，要保持其中有一项未完成状态的任务(例如长时间不做了，可以将其设置为推迟、将来也许、甚至不了了之的任务确认后放入取消)。活跃的回顾是指当前进行的项目，随着项目的进行可能会在其中不断衍生出新的任务，例如一些重复性的任务，如“周报”，一般每周都要写，短期内不会终止，所以它可被看作一个活跃的项目。回顾所引用的一般是处于各个状态的任务，不一定只有任务，也可能是其他的回顾，但是一定是GTD系统中的内容。回顾的内容与回顾所引用的内容应该能相互引用，便于参考时的跳转。7.6.8 关于参考参考既不是任务，也不是回顾，但是它又处于GTD系统当中。它主要是在回顾，或者处理时不是中间任务性质的半参考文档性质的内容。例如导致接收任务的邮件片段、期间的交互证据、网址文献等等。按理说应该有相关的时间、地点（可以是email地址）、人物、事件（起因/经过/结果）。在目前看来，参考在本文所述的GTD中可以被去掉，归并到已处理分类中，但是也可根据个人需要与喜好单独列出来一个分类用来管理这些内容。如何处理“回顾”、“任务”、“参考”的关系？任务是可以执行事情的分割单位，其中包含处理该任务是的一些总结性质的东西，是深入处理相关任务时做的杂乱记录。回顾是对一系列相关任务的汇集整理，本事就是一个项目，整理任务处理期间的关系以及处理的大致情况和索引，便于今后跟踪和参考。参考可能是回顾会引用的，或者是任务中会引用到的一些资料，例如导致接收任务的邮件、期间的交互证据，网址文献等等。7.6.9 如何处理“项目分类”与“状态分类”实现的冲突先给出问题，在列出思考实现的过程，最后给出采用当前的方案的原因。正常收集过来的任务直接放在收集箱，进行进一步处理之后放在相应的项目分类中，随着时间的推移再进入到下一步状态，但是该任务仍然属于之前所设置的项目分类。也就是说，任务的项目分类是不变的，状态却可能随着处理改变成其它状态（如下一步）。任务的状态是以目录形式存在，所以对于项目分类的管理方式如果也以目录的方式管理可能就导致目录混乱。考虑到项目分类是随时间动态增长的，而目录分类不宜过多；相对的，标签是文章之后动态创建的，将项目用标签表示可能更灵活好用一些；或者在每一个状态目录中建立子目录表示项目，或者使用标签来实现对任务即可用状态的角度来分类，又可用项目角度来分类……然而，这些方式都会到至笔记的分类复杂，并且并不是所有的工具都支持标签。前面的局限在于，认为分类只能是对同一角度内容的分类，所以将项目和状态同时用分类来表示的时候，会混淆。当前采用的方式将状态和项目全都用分类来表示，但是分类不是在一个角度上进行分类，可以是管理状态的分类，或者管理项目的分类……不同方面，有各自的分类方式，可以用分类名前缀，或者自己的习惯来理解不同的分类方式就行。这样，将“分类”进行分类之后，不同方面的分类可以存在于同一个笔记系统中，就不会引起混乱。它是，对于项目这类变化比较大的（基本是只增不减）内容，采用分类又有些不妥，所以项目干脆用笔记来表示，每个项目分类只是一个笔记，然后将所有项目归结到项目状态中。7.6.10 自我管理的演化过程随着时间的过去，我们从学校进入到职场，从个人变成了组建的家庭，所处理和面对的事务也变得越来越复杂。如果不做合理规划，工作、生活、学习各个方面会变得越来越糟糕。希望能有一个高效的生活方式的我们，可能会经历如下的管理过程阶段，希望能给大家一个参考。7.6.10.1 记事本阶段(笔记本子，或者Windows上的记事本，博客等)将平时涉及的一切写到一个记事本中，可以是电子版的，或者纸质的，也有时候为分享和方便记录到博客等网络平台中。在随后的讲述中我们会发现，这些内容渐渐变得越来越复杂分散，简单的记录已不再适应。7.6.10.2 待办清单与文档（任何设备、系统上自带的工具）记事本，可能包含了能够记录的一切，但是其中记录的内容各不相同，而且数据量越来越大，我们真正所需的，其实是在适当的时候将其提取出来，总结起来发现大致有两类事情：一类是平时记录的技巧、经验、资料、文档等等另一类是影响自己行动的计划、待办事项、约会、提醒等等。于是产生了两种方式的记录：待办清单和文档。待办清单其实是行动管理的雏形。罗列了需要处理的事情，需要进行某些事情的时候，浏览一下这个清单，处理完将其划掉，日常的生活在清单不断地增减中度过。文档其实是内容管理的雏形。那些经验、技巧、文档类的内容，被整理至某个笔记系统或目录结构中，为不同的内容建立相应的分类，分门别类存放，需要之时直接到对应地方查阅即可。在任何我们手中的系统和设备中（比如手机的Android和IOS、PC的Window和Linux等等），总有一款待办清单方面的工具，以及笔记记录方面的工具，供我们这时所需。7.6.10.3 丰富的待办清单与文档系统(中华万年历与为知笔记)随着时间迁移，在待办清单和文档，终于有一个像样的名称，内容管理和行动管理。行动管理方面待办清单变得越来越长，往往想确定下一步做什么的时候，需要先浏览一遍长长的清单，然后找到需要的内容，于是产生了对待办清单改善的需要：需要一些新的工具，或者在原来的待办清单上改善和扩展。一是添加提醒，一些事情到特定时间后自动通过闹钟或者其他方式提醒我们去看，手机、电脑上有许多类似的工具；二是划分优先级，那些待办事项中，总有一些是重要的、一些是不重要的、一些是过时的等等，四象限法则就是一个划分优先级的好方法，在我所用过的工具里，中华万年历是这个时候不错的选择，它还附带了一个简单的云笔记功能。内容管理方面总是觉得之前的分类变得越来越复杂，文件系统越来越乱，内容越来越多，并且分散在各处（手机、电脑等），都有不不同的文档系统，而且有时候想要记录的时候，东西不在身边，当有现成的环境之时，却又想不起该记录什么了。这需要对内容管理方式有一个改善，改善分类的方式，让分类简单；增加记录与访问的便携与集中性，比如各类云笔记（麦库、有道、为知、evernote）等等可以随时记录访问，也可根据需要的内容，搜索检索相应的笔记，根据我的经验，为知笔记在这个方面做的非常不错。7.6.10.4 轻重结合(轻量级的系统便签或笔记工具、与为知、中华万年历)在管理内容和行动方面的信息的同时，不断寻求新的更强大的工具，最终会感觉到，自己的手机、电脑、越来越慢，访问所需的等待时间往往超过了我们的忍耐限度，为了临时记录一点东西，我们可能会花费1、2分钟的时间启动我们的系统和软件，启动的时间内，我们往往可能已经能够把相应的事务处理完毕了。这要求我们对所管理的信息有一种便捷的访问方式。各类系统平台上一般都会有那么几款轻量级别的记录工具，记事便签、记事本等等，再添加上分类的功能使之不要过于弱。重量级和轻量级工具同时使用，我们经常访问的信息就存于轻量级别的工具中，空闲之时在重量级工具与轻量级工具之间同步数据。7.6.10.5 需有体系的信息管理组织方式（GTD与Git）便携性意味着功能的减弱，功能强则会减弱便携性。两者综合起来应用，又会涉及到同步和数据移植行的问题。这时候管理信息已经不是工具方面的问题了，而是方法和存储。采用的方式：行动管理方面方法是GTD方法，为所有任务定义好状态。工具则任意款便携、可移植的工具即可。内容管理方面原生文本格式方式增强数据移植性；Git分布式管理增强便携安全与版本控制；用现有大型网站托管资料（如github、bitbucket等等）增强集中与同步性。数据格式、访问、存储与管理方式工具可以尽量简单，方法选择适合自己的方法，而数据的格式也是一个问题。如果做过软件开发的人，可能会觉得，这有点类似软件中的MVC方法问题（M是数据模型、V是数据访问视图、C是数据控制方式）。数据格式-Orgmode为了便于将来环境的切换，数据存储的格式是一个比较重要的内容。文本格式实践发现，最通用的数据格式不是.doc、音视频、图片、pdf、或者各类笔记专有数据格式等等，而是文本，文本格式也便于版本控制管理。标记语言对于文本格式，xml、html就是文本标记语言，latex也是，但是通用性强了、可阅读性也必不可少，这些文本格式对于非专业人员，几乎是天书般的存在。轻量级标记语言各类轻量级的标记语言如markdown、orgmode等等，可以做为数据存储的格式，学习成本也低、而且文本的数据格式也便于直接阅读。Markdown与Orgmode学习成本太低，便意味着功能的有限，反之亦然。markdown的学习成本很低，相对orgmode更流行，但是若用它写复杂的文档，还是有些勉强只能写一些简单的博客性文章；orgmode是这里极力推荐的方式，它可以变得很轻量级，但是如果你多学习，它又能变得非常强大，既能内容管理，又能行动管理，还能导出为其他各种格式远不止于此。访问方式-工具控总结起来，这个阶段，工具不是重点，Emacs、Vim、记事本、任意一款可以编辑的工具都可做为数据访问的方式。如果只考虑工具，又不想自己主动耗费精力思考方法，降低学习成本，这个阶段有两个工具建议可用：行动管理采用dgt gtd，安卓下的工具，可以导出数据，并且便携记录。内容管理仍然采用为知笔记。做为辅助对访问速度要求高时，可以用系统上的任意便签工具做为中转。管理方式-GTD与分布式版本控制方法才是核心，管理方法往往说起来很简单：GTD管理任务，Git分布式管理内容并版本控制，当然肯定也会有其它的方法或者分布式管理。总结总之，如果用最直接的方式来描述一个特定的管理方式，目前而言，我采用的方式是：emacs的扩展性满足了工具控的需要，可以当作任何想到的工具访问数据；markdown和orgmode这类文本标记语言相结合，表示数据，使之符合人阅读的原生文本格式，orgmode还能方便转换为各种其它格式；任意款分布式版本控制工具（比较流行的是git）可以当作云存储与管理内容的方式;gtd方法做为灵魂，做为管理行动的方式（管理数据的组织方式也是诸多行动的一种），其它一切都是浮云。7.6.10.6 其它前面的过程，其实总结起来，可能是这个样子的：杂乱的信息-任务管理/内容管理。当管理达到一定阶段，满足现状的时候，还可能会发生其他的事情，比如，数据、工具、方法都有了，我们要做什么？也许，下一步就是目标管理了吧？因为我也听说过SWOT方法、5w1h方法等等，又或许，还需更好的方式在组织这些。7.6.11 参考资料一些值得参考的一些文章：褪墨・时间管理http://blog.sina.com.cn/s/blog_6495e9c90101evo7.htmlhttp://www.mifengtd.cn/articles/gtd-grab-the-destiny.html7.6.12 FAQ7.6.12.1 NEXT 如何通过orgMobile进行管理？State "NEXT"       from "INBOX"      [2015-12-30 三 09:40]';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-11-03]<a href="/categories/note/GTD_Manage_Method.html"> GTD管理方式  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Emacs Orgmode学习笔记'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 标题与大纲1.1. 语法1.2. 配置1.2.1. 调整大纲缩进显示1.3. 操作2. TODO项目2.1. 语法2.2. 配置2.3. 操作3. 格式3.1. 段落3.2. 字体3.3. 硬换行4. 列表4.1. 语法4.2. 操作5. 表格5.1. 语法5.2. 操作6. 块标记6.1. 语法6.2. 操作7. 链接7.1. 语法7.2. 配置7.3. 操作8. 时间戳8.1. NEXT 语法8.2. 操作9. 标签9.1. 语法9.2. 配置9.3. 操作10. Capture-Refile-Archive10.1. 概念10.2. 配置10.2.1. Capture的配置10.2.2. Refile的配置10.3. 操作11. Agenda11.1. 操作11.1.1. 交互操作11.1.2. 交互命令：12. 导出12.1. 操作13. 其它13.1. 建议13.1.1. 列表与标题13.1.2. 列表与换行13.2. 感想13.3. 注意13.4. orgmode与mobile org整合13.4.1. 配置13.4.2. 原理13.4.3. 同步操作13.4.4. 使用举例13.4.5. 其它13.5. orgmode与jekyll的结合13.5.1. 部署13.5.2. 配置13.5.3. 被导出文件与jekyll的集成13.5.4. 为待发布文章添加兼容jekyll显示的信息13.5.5. 发布命令13.5.6. 其他13.6. Misc collection13.6.1. &#x2014;&#x2014; [2015-12-03 四 14:55]  Agenda view------14. WAIT/FORWARD FAQ [35/111]([31%])14.1. MAYBE/FUTURE 如何隐藏"标题星星"？14.2. LATER 搜索子树相关14.3. DONE 各个级别标题列表如何缩进？14.4. DONE 各个级别列表标题中的内容段落如何缩进？14.5. LATER 如何显示图片14.6. DONE 如何删除标题或者项目以及子树下的内容？14.7. DONE 如何链接文件和位置之类的？14.8. DONE 如何行内转义引用?14.9. DONE 如何设置启动时的自动折叠？14.10. MAYBE/FUTURE 如何预览效果？14.11. DONE 标签的预定义14.12. MAYBE/FUTURE 如何自动对齐ORGMODE文件的格式？14.13. DONE 如何在标题间跳转？14.14. DONE 如何缩进列表段落？14.15. LATER 貌似自动刷新功能还是没有完全实现14.16. DONE 如何增加状态？14.17. DONE 如何定制状态的各种属性？14.18. DONE 如何设置和进行TODO的状态快捷切换？14.19. DONE 如何按状态搜索TODO项目？14.20. LATER 如何实现代码原样引用？14.21. DONE 配置折叠状态编辑的动作14.22. LATER 按照TAG进行搜索14.23. LATER 导出与发布14.24. DONE 如何调整大纲缩进显示14.25. DONE 如何写行内引用的文字，类似markdown中的``。14.26. DONE 如何确保硬换行14.27. DONE 如何保存一个与文件位置无关的链接？ C-c l 相关参数？14.28. DONE 如何简化列表标题等文档复杂度14.29. CANCEL 如何定制插入的时间戳格式？14.30. LATER 如何在Refile的时候新建一个标题？org-refile-allow-creating-parent-nodes?14.31. DONE 恢复到默认的大纲内容模式还不太好用14.32. WAIT/FORWARD 是否可以org-agenda-files只使用一个文件，对应文件中列出所有agenda文件？14.33. WAIT/FORWARD 如何设置问题Open的时间？14.34. WAIT/FORWARD 确认一下agenda的配置文件是否可以配置目录？14.35. LATER 考虑使用F1-n设置自己日常使用的自定义快捷方式，并且保证不要与其它冲突。14.36. LATER 标题如何添加序号？14.37. LATER 如何直接插入一个子标题？14.38. DONE 参考并整理结构编辑的相关操作：14.39. DONE 如何对一个子树进行导出？14.40. MAYBE/FUTURE 注意，断行要用'\\'，要么就空白一行。14.41. WAIT/FORWARD 如何解决输入下划线的时候，自动转换为下标？（想要不转换）14.42. LATER orgmode refile如何创建新的文件和条目，如何定位设置之外的路径14.43. DONE orgmode如何只对一个指定的子标题生成html等导出文件？14.44. DONE 如何在capture模板中将时间戳设置为非活跃时间戳，以减少Agenda的显示负担？14.45. DONE orgmode如何插入带有时间（而不仅仅是日期）的时间戳？14.46. LATER 整理一下emacs_orgmodeusage的文档格式14.47. MAYBE/FUTURE 如何在活跃与非活跃时间戳之间进行切换？14.48. NEXT 如何打开链接的时候不新开一个窗口？14.49. WAIT/FORWARD orgmode 的BEGIN_SRC总是导出错误，提示输入的语言参数，如何确定有哪些语言参数？14.50. LATER 如果Agenda对应TODO状态发生变化，如何刷新Agenda view?14.51. DONE orgmode有没有离线帮助手册在emacs中直接使用？14.52. LATER 如何自由切换orgmode的活跃和非活跃时间戳？14.53. LATER 如何在orgmode中调整已有列表条目的缩进级别？14.54. MAYBE/FUTURE Orgmode表格格式如何自动添加分割横线？为何导出时没有列分割？14.55. MAYBE/FUTURE Agenda view不折行？14.56. MAYBE/FUTURE 如何格式化块？如删除块？14.57. LATER 如何自动触发状态变化？14.58. DONE orgmode与mobile org整合14.59. MAYBE/FUTURE Orgmode refile如何到特定的标题上而非仅仅追加或者插入？14.60. CANCEL orgmode attachment的内容需要看一下14.61. NEXT 如何在orgmode中打开链接的时候不会自动新开窗口而是使用已有窗口？14.62. LATER orgmode 如何修改时间戳？直接编辑？14.63. MAYBE/FUTURE agenda如何不扫描有些状态，如done、cancel、maybe/future14.64. MAYBE/FUTURE orgmode的块是否可以嵌套？比如quote块内是否可以quote？14.65. LATER orgmode如何在导出子树的时候自动以标题命名？14.66. LATER orgmode如何指定导出的路径和文件名称？14.67. LATER orgmode光标如何定位到下一个链接？14.68. LATER orgmode如何实现任务自动触发定时切换以及refile14.69. WAIT/FORWARD 列表与换行14.70. WAIT/FORWARD orgmode建议14.71. LATER Orgmode中checkbox和header也可以结合使用14.72. LATER 确认一下orgmode中的引用块相关细节，例如begin example和begin quote之间的区别14.73. CANCEL 考虑orgmode中，是否应该每一个状态添加!，将处理信息和状态信息集成。14.74. LATER orgmode 如何递归折叠光标所在节点？14.75. WAIT/FORWARD emacs markdown 导出14.76. DONE orgmode与jekyll的结合14.77. LATER orgmode如何输入成块的原样文字而不解释、缩进之类的？14.78. LATER 为什么orgmode定义好的refile如果是单个文件，那么这个文件内容会自动变化？14.79. LATER Jekyll与orgmode结合的问题14.80. NEXT 如何为orgmode导出添加作者信息？14.81. LATER emacs如何导出的时候不缓存上次修改差异而直接强制导出？14.82. DONE 是否应该为取消的项目在切换到取消之前添加备注，类似wait/forward，指明为什么取消？14.83. MAYBE/FUTURE orgmode多文件文档14.84. LATER orgmode中导出时的include关键字所基于的路径能否配置？14.85. LATER 如何在orgmode中时间戳中选择特定的时间插入？需要知道相关的指令和按键，而非手动修改。14.86. NEXT orgmode导出utf8问题14.87. CANCEL orgmode sub task and summary.14.88. DONE 切换和设置优先级14.89. WAIT/FORWARD archive14.89.1. 配置14.89.2. 操作14.89.3. 举例14.90. NEXT orgmode中为何example块中的标题还遵从orgmode的格式？14.91. NEXT orgmode导出为utf8报告错误14.92. LATER orgmode在引用块中缩进的标题问题14.93. MAYBE/FUTURE orgmode导出markdown有太多的引用标记，如何尽可能原样展示而非很多的'style'类似的东西？14.94. LATER orgmode 番茄钟、时间记录14.95. MAYBE/FUTURE orgmode为什么refile 目标会跟踪软链接到其他目录中？14.96. LATER 属性14.96.1. 操作14.97. WAIT/FORWARD ormode项目管理14.98. DONE orgmode考虑是否应该将状态文件以'_' 做为前缀，便于angenda中一目了然不和其他文件混淆？14.99. NEXT orgmode应用聚合有哪些场景？ [2/7]14.100. LATER orgmode记时功能可以提高集中力14.101. NEXT Orgmode如何官方发问？14.101.1. 订阅邮件列表14.101.2. 参考14.102. MAYBE/FUTURE Ascii art14.103. MAYBE/FUTURE artist mode in emacs14.104. MAYBE/FUTURE Emacs中的plantuml配置如何与ascii art格式图形结合？14.105. LATER orgmode画图14.106. LATER pdflatex for orgmode14.107. NEXT mobileorg的加密功能，可以防止隐私的泄漏；orgmode的加密功能既能管理工作又能防止工作隐私泄漏。14.108. WAIT/FORWARD orgmode中图片链接导出之时如何不是文字链接而直接图片？14.109. LATER orgmode表格导出之后，文本或者html没有竖线只有横线14.110. NEXT orgmode导出文章pdf问题14.111. LATER orgmode中搜索相关命令的整理15. 参考资料：这里是学习Emacs Orgmode过程记录的笔记，可供日后查阅以及参考。1 标题与大纲1.1 语法一级标题用"* "，二级标题用"** "，以此类推，最多10级，注意'*'后面的空格。1.2 配置配置默认启动的折叠方式如果对全局起作用，需要设置org-startup-folded变量，设置值可参见 C-h v org-startup-folded ，在emacs启动配置中添加如下类似值：;;set initial folded state.(setq org-startup-folded 'content)如果仅对一个文件起作用，则为文件添加如下类似元数据：#+STARTUP: overview#+STARTUP: content#+STARTUP: showall#+STARTUP: showeverything配置折叠状态下的编辑动作实践发现，在折叠的时候删除或者追加，有些影响可能会在展开的时候才能看见。比如删除一个字符等等，所以不知道的情况下建议不要在折叠的时候删除字符。但是我们可以添加配置来修改这时的行为。配置变量是org-catch-invisible-edits，可以通过查看 C-h v org-catch-invisible-edit 来查看设置的值含义。;;set action when edit invisible content(setq org-catch-invisible-edits 'show-and-error)1.2.1 调整大纲缩进显示默认显示缩进好的大纲内容加入如下配置(setq org-startup-indented t)或者加入如下选项到文件使得只在当前文件生效：#+STARTUP: indent1.3 操作展开、折叠所有章节输入 S+Tab对光标所在章节进行展开、折叠输入 Tab对当前子树标题使用大纲方式显示输入 C-c C-k切换到初始的浏览状态，也就是org-startup-folded设定的状态。输入 C-u C-u TAB显示全部，包括Drawers。输入 C-u C-u C-u TAB跳转至上级标题输入 C-c C-u跳转至上一个/下一个标题（无视级别）输入 C-c C-p/n跳转至上一个/下一个标题（同级别）输入 C-c C-f/b当前标题升级/降级，不包括子树输入 M-LEFT/RIGHT当前标题以及子树升级/降级输入 M-S-LEFT/RIGHT当前标题上移下移??输入 M-UP/DOWN当前子树上移下移??输入 M-S-UP/DOWN在光标处插入当前级别标题输入 M-Ret光标在文本中，则将内容一分为二，换行后插入同级别标题;在空白则在之下插入当前所在级别标题。在当前标题子树后插入同级别标题输入 C-Ret 切换到大纲浏览状态输入 C-c C-j 进入大纲浏览状态之后，状态栏有提示，右侧也会新开一个buffer提示有特殊的大纲浏览状态帮助命令。例如：切换上一条/下一条标题输入 Up/Down直接进入相应标题并退出大纲浏览状态输入 Ret搜索输入 /在某标题上循环切换视图输入 Tab退出大纲浏览视图输入 C-g另外直接输入文字也可进行搜索。切换标题和正文状态输入 C-c *输入之后，会进行标题切换，将文本、区域、或条目转换成相应位置下的子标题，或反之。选择当前Entry输入 M-h输入之后，会高亮显示当前光标所在entry的内容。例如光标在标题上，则高亮标题以及子树内容，持续按 M-h 会继续以同级别下entry为单位，扩展选择范围，这里的entry可以是段落、标题、列表项等等，取决于光标所停留的位置。选择当前光标所处标题以及子树输入 C-c @输入之后，会高亮显示当前光标所在子树的内容，不论光标是否停留在标题上。删除当前所在标题及子树输入 C-c C-x C-w输入之后，无论光标是否在标题上，都会将其所在标题连同子树删除（剪切）。复制当前所在标题及子树输入 C-c C-x M-w输入之后，无论光标是否在标题上，都会将其所在标题连同子树复制。2 TODO项目2.1 语法TODO是一种包含状态的特殊标题在标题标记后面加上相应状态名，便成为TODO项目。状态默认为TODO和DONE，可以自行配置。* TODO 这是一个TODO项目** TODO 这是TODO的子项目带有统计子项目的TODO项目在一个待办标题中添加子待办标题，然后在待办标题中添加 [%] 或者 [%] 。 每当子标题更新时，父标题上面的相应比例会自动统计变化，如果强制刷新，则在父标题相应的比例标记上输入 C-c C-c 。* TODO 这是一个统计子项的TODO项目 [0/2]** TODO 这是TODO的子项目1** TODO 这是TODO的子项目2当然这样也行：* TODO 这是一个统计子项的TODO项目 [0/2] ([0%])** TODO 这是TODO的子项目1** TODO 这是TODO的子项目22.2 配置增加TODO状态在配置文件中加入类似如下代码：;;set status for TODO.(setq org-todo-keywords     '((sequence "INBOX" "NEXT" "LATER" "WAIT/FORWARD" "MAYBE/FUTURE" "|" "CANCEL" "DONE")))配置状态颜色通过org-todo-keyword-faces的设置实现，添加内容如下;; color for todo keywords(setq org-todo-keyword-faces '(("INBOX" . (:foreground "blue" :weight bold)) ("NEXT" . org-warning)("LATER" . "yellow")("WAIT/FORWARD" . "blue")("MAYBE/FUTURE" . "purple")("DONE" . "green")("CANCEL" . "grey")))配置状态快捷切换键通过定义状态时将快捷按键放在状态后面，用‘（）’括起来，添加内容如下：;;set status for TODO.(setq org-todo-keywords '((sequence                          "INBOX"                         "NEXT(n)"                         "LATER(l)"                         "WAIT/FORWARD(w)"                         "MAYBE/FUTURE(m)"                         "|" "CANCEL(c)" "DONE(d)"                         )) )配置状态切换的跟踪时间戳当TODO列表切换到结束状态时，会自动为其添加一个结束时候的时间戳（转变为非结束状态时会将其移除）。;;add timestamp when todo change to done.(setq org-log-done 'time)配置优先级颜色和内容设置如下：;;set priority(setq org-highest-priority ?A)(setq org-lowest-priority ?D)(setq org-default-priority ?A)(setq org-priority-faces '(                           (?A . org-warning)                           (?B . (:background "DodgerBlue" :foreground "black" :weight bold))                            (?C . (:foreground "SkyBlue" :weight bold))                           (?D . (:foreground "DodgerBlue" :weight bold))                            ))2.3 操作TODO项目相关操作：M-S-Ret当前位置插入TODO项目，默认状态和上一条统计TODO状态一样C-S-Ret   当前级别子树后面插入TODO项目C-c C-t 当前所在TODO项目状态切换(不一定要在TODO标题上面)默认状态下，循环切换次序是TODO-&gt;Done-&gt;普通标题（只有*）。S-RIGHT/S-LEFT 当前所处TODO标题上进行状态切换默认状态下，循环切换次序是：TODO-&gt;DONE-&gt;普通标题C-c 修改优先级（包括A,B,C三个级别，不一定在TODO标题上面）S-UP/S-DOWN 切换优先级默认次序是A-&gt;B-&gt;C-&gt;无。C-u C-c C-t 快捷切换状态，输入后会提示你要输入的状态，可以支持Tab补全，可以用快捷按键替代。刷新子项目完成情况统计光标停留在 [%] 或者 [%] 之上，输入 C-c C-c3 格式3.1 段落一个独立段落需要段落之上有一个空行。如果没有空行则上一段的换行符号自动变成空格。如果强制换行而不用空行则在行尾输入 \\ 。3.2 字体字体格式一般会采用特定标记来实现，标记界限周围要和其他字符隔开，不能紧邻其他字符。*粗体*+删除线+_下划线_=等宽= 或 ~等宽~ /斜体/注意，等宽字体可以做为行内代码引用使用。例如： input3.3 硬换行注意，列表内或者其他部分，非段落的硬换行需要将相应行尾插入 \\ ，否则就需要用空行来另起一段落。直接换行会在输出特定格式的时候直接变成一个空白。4 列表4.1 语法Org 能够识别有序列表、无序列表和描述列表。无序列表项以‘-’、‘+’或者‘*‘开头。有序列表项以‘1.’或者‘1)’开头。描述列表用‘::’将项和描述分开。有序列表和无序列表都以缩进表示层级。只要对齐缩进，不管是换行还是分块都认为是处于当前列表项。同一列表中的项的第一行必须缩进相同程度。当下一行的缩进与列表项的的开头的符号或者数字相同或者更小时，这一项就结束了。当所有的项都关上时，或者后面有两个空行时，列表就结束了。例如：+ 列表如何处理缩进  这样处理  - 子列表    子列表缩进    * 子子列表      子子列表缩进内容，一般而言，尽量不用'*'做为列表的项目    子列表内容  列表内容总之，列表项下的内容，如果属于该列表项，那么就将其缩进成大于该列表项首行的标号再输入相应文字。另外，某一列表可以带有checkbox成为任务列表，实际就是在列表项开始加入一对中间有空格的方括号[ ]。任务列表可以有子任务，如果想要显示任务的完成情况计算总进度，只需要在总任务后面添加一对方括号，里面加上%或/ 如[%],[/]。4.2 操作M-RET 插入同级列表项C-RET 当前子树尾部插入同级别列表项M-S-RET 插入有 checkbox的同级列表项C-c C-c 改变 checkbox状态C-c - 更换列表标记，如果当前项不是列表，会被转化成列表。S-LEFT/RIGHT 更换列表标记，类似 C-c - 。M-left/right 改变列表项层级关系，不包括子项M-S-left/right 改变列表项层级关系，包括子项构成的子树M-up/dowm 上下移动列表项=TAB（新的空的列表条目中） 调整缩进级别如果新的条目中还没有文字，TAB 会调整到合适的级别。比如，我们在一个列表下新开一空行，然后TAB，这样之后敲入的内容将在相应的缩进之中（实践发现，如果Tab之前敲入内容了，那么Tab不会缩进）。如果列表项下事先已经有了未缩进的内容（即缩进级别和列表项目标号一样），那么该内容应该不属于相应列表项之内，如果逻辑上让其属于列表项，需要将其缩进。缩进的方法不是直接在相应位置或者行敲 TAB ，有两种方法将这部分内容调整缩进使之属于列表项：在内容前插入一空行，然后空行内敲入 TAB ，然后空行尾 DEL 或 C-k 将空行下的内容自动‘拉上来’实现缩进。2）在相应内容上插入一个 SPC ，然后再键入 =TAB=。注意，以上缩进方式缩进的级别自动和上一行缩进成同样级别。5 表格5.1 语法5.2 操作输入表格需要输入表头如 |Name|Pone|Age 之后，按C-c RET,就可以生成整个表格的结构(也可输入Tab调整)。输入表格分割线输入 |- 之后，按C-c RET,就可以生成整个表格的结构(也可输入Tab调整)。创建表格输入 C-c | ，会提示生成指定行列的表格。在下一行创建表格分割线在当前表格中输入 C-c - 。跳转下一项输入 TAB 可以自动调整表格对齐并且跳转到下一栏，如果是一行末则新开一行并跳入新行第一栏。输入之后，产生类似如下表格：te&#xa0;在单元格内换行输入 M-Ret将区域转换成表格输入 C-c |这里，对一片区域，每行用空格或者TAB分割开，选中该区域后，输入这个命令，便会将相应的内容转换成表格。移动光标到当前所在单元格首部输入 M-a移动光标到当前所在单元格尾部输入 M-e将当前光标所在表格项设置为空输入 C-c &lt;SPC&gt;删除当前光标所在列输入 M-S-&lt;Left&gt;在当前光标所在列左插入一列输入 M-S-&lt;Right&gt;这里注意，如果光标在表格最后一列的右面，运行这个命令就是在表格最右侧追加一列。左/右移动当前光标所在列输入 M-&lt;left&gt;/&lt;right&gt;6 块标记6.1 语法单行的例子内容以": "开头，注意后面的空格。6.2 操作加入"#+BEGIN_SRC和#+END_SRC"配对：行首输入`&lt;s Tab`加入"#+BEGIN_EXAMPLE和#+END_EXAMPLE"配对：行首输入`&lt;e Tab`加入"#+BEGIN_HTML和#+END_HTML"配对：行首输入`&lt;h Tab`输入 M-TAB例如:#+BEGIN_SRC eli#+END_SRC键入 eli 后输入 M-TAB, 即可补全出选项，例如：#+BEGIN_SRC elisp#+END_SRC对代码块进行求职在代码块上输入 C-c C-v C-e7 链接7.1 语法脚注用 [fn:1] 的方式插入脚注，要求脚注定义放在第0列，不能有缩进而在相应的解释部分插入类似如下：[fn:1]本文参考自xxx。其中 [fn:1] 部分是可以点击相互切换的。例如：The Org homepage[fn:1] now looks a lot better than it used to....[fn:1] The link is: http://orgmode.org外部链接链接的格式是：[[链接地址][链接内容]]如：[[http://orgmode.org/orgguide.pdf][grgguid.pdf]][[file:/home/maple/图片/test.jpg][a picture]]如果去掉标签，则能直接显示图片：[[file:/home/maple/图片/test.jpg]]这里，为了便于展示源代码， 我加上了转义，用于对单行例子的引用，如果没有": "转移字符，那么直接会在orgmode显示解析后的结果。7.2 配置保存链接的配置：(global-set-key "\C-cl" 'org-store-link)配置之后，每次输入 C-c l 之后会将当前位置所在的条目链接保存起来，之后输入 C-c C-l 的时候，会提示选择已保存的链接，默认选择最近一次保存的条目链接。启用全局唯一id链接配置如果启用了 org-id.el 以及设置了 org-id-link-to-org-use-id 那么运行 C-c C-l 会保存两个链接：一个是用户可读的链接（包含文件名和标题，当标题的文件和位置变化可能会导致原引用该处的链接不可用）；一个是具有全局唯一id的链接（在相应标题子树被转移到其它位置的时候，这个链接仍然不变）。其实保存链接内容的同时也创建了相应的链接，为创建全局唯一id的链接，运行之后，会导致相应子树标题下追加了如下属性：* 子树标题    :PROPERTIES:  :ID:       60aaa787-86e8-43a3-9a33-73d3eb7e6f58  :END:引用的格式举例 [[id:60aaa787-86e8-43a3-9a33-73d3eb7e6f58][子树标题]]下面给出一个配置的例子：;;Settings for global id link.(require 'org-id)(setq org-id-link-to-org-use-id t)7.3 操作保存链接输入 C-c l这项功能需要事先配置好 org-store-link 按键映射，配置好后这个动作会将当前位置所在条目的链接保存起来，供之后插入链接等使用。插入链接输入: C-c C-l这样会列出已经保存的链接供选择，也会在底部回显区会提示你输入链接网址和描述文字（支持事先保存的链接补全），输入或选择完成后，链接插入完毕。另外，在已有链接上输入该命令，可以在已有链接上进行修改。如果选择了具有全局唯一id的链接形式，不会因相应子树所处的文件等信息的改变而失效。内部链接引用和定义下面是内部链接引用和定义的例子[[inner][内部链接引用]]#&lt;&lt;inner&gt;&gt;记录内部链接地址输入 C-c %跳转到已记录的内部链接地址输入 C-c &amp;不断地输入会不断地跳转到已经记录和定义的内部链接，可以跨buffer。新建脚注输入： C-c C-x f输入之后，如果当前光标已有脚注，那么会在定义和第一个引用之处跳转，否则新建一个脚注。新建的脚注会在文档底部，有一个新开的标题"Footnotes"，新建的脚注编辑好定义之后，再输入 C-c &amp; 可以跳回刚才插入脚注的位置。8 时间戳8.1 NEXT 语法时间戳是一个具有特定格式的日期（可能带有时间和时间段）说明， 时间戳可以出现在树条目的标题和正文的任何地方，它能使条目只在特定的日期才出现在议程列表中。主要有如下一些类型：普通时间戳；可用于事件、约会简单地给一个条目加上时间和日期，指明事件或约会发生的时间：* Meet Peter at the movies &lt;2006-11-01 Wed 19:15&gt;* Discussion on climate change &lt;2006-11-02 Thu 20:00-22:00&gt;具有时间间隔的时间戳：可用于周期重复的内容时间戳可以包含一个时间间隔，表示事件不只在指定的时间发生，还在每隔一个特定的时间如 N 天（d）、周（w）、月（m）或者年（y）之后重复发生。如以下表示从2007-05-15开始每周2发生的会议事件* Pick up Sam at school &lt;2007-05-16 Wed 12:30 +1w&gt;日记样式的 sexp 条目Orgmode 为支持更复杂的时间，支持的Emacs 日历/日记包（calendar/diary package）中的日记条目* The nerd meeting on every 2nd Thursday of the month&lt;%%(diary-float t 4 2)&gt;时间/日期段两个时间戳用‘–’连接起来就定义了一个时间段.** Meeting in Amsterdam&lt;2004-08-23 Mon&gt;--&lt;2004-08-26 Thu&gt;非激活的时间戳在方括号而不是尖括号中的时间戳，是未激活的，只是一个时间戳记录信息，它不会让一个条目显示在议程中。* Gillian comes late for the fifth time [2006-11-01 Wed]时间戳前面可以加一些关键字来协助计划安排。例如表示任务应该完成的日期的截止期限（DEADLINE）,用于指定任务开始日期的日程安排（SCHEDULE）。参考:http://www.cnblogs.com/Open_Source/archive/2011/07/17/2108747.html#sec-8 http://members.optusnet.com.au/~charles57/GTD/org_dates/index.html进行提取8.2 操作插入一个时间戳输入 C-c .输入之后，会进入一个交互模式，默认是当前时间，可以通过 S-LEFT/RIGHT/UP/DOWN 选择一个指定的时间戳，插入之后的时间戳是激活的，会以'&lt;&gt;'括起来，只有日期信息没有时间，可以在日程视图中显示。Calendar Navigation	Shift-RIGHT	Go forward a dayShift-LEFT	Go backward a dayShift-UP	Go to previous weekShift-DOWN	Go to next week&lt;	Scroll calendar back 1 month&gt;	Scroll calendar forward 1 month.	Go to Today插入一个非激活的时间戳输入 C-c !命令类似 C-c . 不过这条命令插入的时间戳是非激活状态的，不会在Agenda中显示。插入一个包含日期和时间的时间戳输入 C-u C-c .输入这个命令也会插入时间戳，与 C-c . 不同的是它插入的时间戳不仅包含日期信息，还包含时间信息。插入一个包含日期和时间的非激活时间戳输入 C-u C-c !命令类似 C-u C-c . 只是插入的时间戳是非激活的。修改插入的时间戳光标停在待修改的项目上(年/月/日/时/分/秒)输入 S-UP / S-DOWN , 如果 S-LEFT / S-RIGHT 则是修改日期。插入设置为SCHEDULE的时间戳输入 C-c C-s会在当前标题下面插入一个带有"SCHEDULE"的时间戳，同样可以通过 S-LEFT/RIGHT/UP/DOWN 选择一个指定的时间。插入设置为DEADLINE的时间戳输入 C-c C-d会在当前标题下面插入一个带有"DEADLINE"的时间戳，同样可以通过 S-LEFT/RIGHT/UP/DOWN 选择一个指定的时间。插入一个非激活的时间戳输入 C-c !输入之后，类似上面，通过 S-LEFT/RIGHT/UP/DOWN 选择日期插入。插入的时间戳不是激活的，会以'[]'括起来，不在日程视图中显示。打开Emacs Clendar输入 C-c &gt;插入Emacs Calendar光标所在的日期到光标所在处输入 C-c &lt; 计算光标所在time range之间的天数输入 C-c C-y记录工作时间在任务开始、结束、中断的时候可以使用Org在相应的任务标题下添加一个时间日志，动态记录时间信息。相关指令如下：C-c C-x C-i	开始当前条目的计时（clock-in）。这会插入一个 CLOCK 关键字和一个时间戳。加上 C-u 前缀，从当前已经计时的任务中选择任务。C-c C-x C-o	停止计时（clock-out）。这会在开始计时的地方插入另一个时间戳。它会直接计算使用时间并插入到时间段的后面如 “=&gt; HH:MM”。C-c C-x C-e	为当前的计时任务更新进度。C-c C-x C-x	取消当前的计时。当你误操作打开一个计时时，或者转而去做其他事情时，这个命令就很有用。C-c C-x C-j	跳转到包含当前正在运行的计时的任务条目。用 C-uf前缀从当前计时的任务中选择。C-c C-x C-r	在当前文件插入一个包含像 Org 表格一样的计时报告的动态块。当光标正处于一个存在的块上时，更新它。C-c C-c	在一个已经存在的计时表格之上时，更新它。 更新动态块。光标需要置于动态块 #+BEGIN 这行。9 标签9.1 语法标签以":"做为开头和结尾，可以连续定义多个。例如：:boss:notes:9.2 配置标签是动态增加的，也可预定义，预定义的方式如下：使用#+TAGS元数据进行标记，仅对当前文件有效：#+TAGS: { 桌面(d) 服务器(s) }  编辑器(e) 浏览器(f) 多媒体(m) 压缩(z)修改.emaxcs配置;;set tags(setq org-tag-alist '(                    (:startgroup . nil)                         ("room" . ?r) ("outside" . ?o)                    (:endgroup . nil)                    ("工作" . ?w)                    ("生活" . ?l)                     ("学习" . ?s)                    ))9.3 操作键入 : 后， M-Tab 自动提供标签的补齐。更方便的做法是在正文部分用 C-c C-q 或直接在标题上用 C-c C-c 创建标签，这种方式可以列出所有预定义的标签以便选取。10 Capture-Refile-Archive10.1 概念Capture用来迅速收集一些临时产生的想法，尽可能少的打断当前的工作状态。通过指定好快捷方式和相应的Capture目标位置后，在任意时间运行捕获命令会将这些临时的记录存放在一个指定的位置，空闲之时再做进一步整理。Refile以特定的命令，用来将之前Capture的内容直接转移到特定的地方，避免了手动剪切（复制）和粘帖。10.2 配置10.2.1 Capture的配置不同的管理方式可能会导致不同的配置，但是一般都包含两个方面：首先设置好一个启动Capture的快捷方式，再配置用于存储Capture信息的目的地。这里以gtd管理为例给出一个配置例子：;;Setting for gtd captures;;Directory for capture files.(setq org-directory "~/mydata/orgmode/");;Default capture files.(setq org-default-notes-file (concat org-directory "gtd/inbox.org"));;Capture template(setq org-capture-templates '(			      ("t" "Tasks" entry (file+headline "gtd/inbox.org" "Tasks") "* INBOX %?\nTime:%T\nFrom:%F\n")			      ("p" "Projects" entry (file+headline "gtd/inbox.org" "Projects")  "* %?\nTime:%U\nFrom:%F\n")			      ("i" "Item notes" item (file+headline "gtd/inbox.org" "Items")  "+ %?\n  Time:%U\n  From:%F\n")			      ("m" "Misc notes" plain (file+headline "misc.org" "Notes")  "-----------------------------------------------------\nTime:%U\n %?")			     )) ;;set tags;;where?(h/o/w),what?(c/l/s),when?(gtd|immeiately,wait,action),who?(my gtd,others),why?how?(delete/archieve/schedule)(setq org-tag-alist '(                    (:startgroup . nil)                         ("home" . ?r) ("office" . ?o) ("way" . ?w)                    (:endgroup . nil)                    ("职业" . ?c)                    ("生活" . ?l)                     ("学习" . ?s)                    ))10.2.2 Refile的配置主要配置两个方面的内容：Refile的目标（org-refile-targets），以及Refile时选择目标的策略(org-refile-use-outline-path会自动补全文件名以及标题，目标的格式类似文件路径的格式，包含文件和标题)。org-refile-targets对应的可以是路径可以是列表，具体参考其中的文档，需要注意的是：如果是列表该变量中的文件路径需要是全路径；文件中需要有一个标题才能在做 C-c C-w 补全的时候显示出来，空文件不行。如果是一个文件路径如果org-refile-targets是一个文件，则：这个文件可以是一个文件列表，使用这个列表的文件做为refile目标; 每个文件项占一行（不要有""），文件项可以是对于org-directory的相对路径; 这样文件内容变化之后，不用重新载入配置也能在 C-c C-w 中显示出新增的文件; 如果有一项是文件目录，那么不要再次包含该目录下的文件，因为这样会在agenda view中导致重复显示。;;targets for refile(setq org-refile-targets (quote (                                 (nil :maxlevel . 9)                                 (org-agenda-files :maxlevel . 9)                                )                         ));;outline path for refile(setq org-refile-use-outline-path 'full-file-path);;org-outline-path-complete-in-steps(setq org-outline-path-complete-in-steps t);;create new parents while refile(setq org-refile-allow-creating-parent-nodes 'confirm)10.3 操作基于以上配置，我们可以操作如下：启动Capture输入 C-c c输入之后会提示选择捕获何种类型的信息，提示信息和选择命令取决于之前设置的配置变量 org-capture-templates 。选择将待捕获的信息存于"Tasks"标题之下输入 t具体如何输入取决之前的配置如何，这里输入之后会打开一个Capture Buffer，用于输入将要被记录的信息，其中按照预先配置好的模板，已经预先插入了一些基本信息（如时间、捕获信息时所处位置等等）。完成Capture输入 C-c C-c输入之后，会将buffer中相应的信息插入到之前配置好的位置（例如某个文件中的某个标题之下），然后回到之前被中断的工作状态。取消Capture输入 C-c C-k取消捕获的动作，回到之前被中断的工作状态。访问存放Capture的文件Buffer输入 C-u C-c c输入之后，会提示和 C-c c 一样的信息，选择相应的捕获类型后，会直接打开相关的文件，具体是何文件，取决于事先设置的信息。访问上次捕获所处的文件Buffer输入 C-u C-u C-c c类似前面，捕获访问的是记录上次捕获的文件Buffer，并自动定位到其中上次捕获的信息之上。以剪切方式Refile输入 C-c C-w输入之后，会提示Refile的目标位置（在org-agenda-files中列出），支持Tab补全，选择好相应的文件之后，可以继续将文件内的标题也类似路径的方式输入（也支持TAB补全），选择好之后，回车会将相应的内容移动到对应的目标位置。注意：移动的内容可以是用Mark方式选择的区域，或者当前光标所在的子树，在执行 C-c C-w 之后有提示。以复制方式Refile输入 C-c M-w输入之后，会提示Refile的目标位置（在org-agenda-files中列出），支持Tab补全，选择好相应的文件之后，可以继续将文件内的标题也类似路径的方式输入（也支持TAB补全），选择好之后，回车会将相应的内容复制到对应的目标位置。注意：复制的内容可以是用Mark方式选择的区域，或者当前光标所在的子树，在执行 C-c C-w 之后有提示。访问Refile的目标对应Buffer输入 C-u C-c C-w输入之后，会提示和 C-c C-w 一样的信息，选择相应的位置后，会直接打开相关的文件。访问上次Refile所处的文件Buffer输入 C-u C-u C-c C-w类似前面，访问的是记录上次Refile的文件Buffer，并自动定位到上次Refile目标的信息之上。11 Agenda11.1 操作调出Agenda显示交互界面输入 C-c a输入之后，根据提示选择想要显示的视图种类。11.1.1 交互操作调出Agenda交互界面之后，可以进行如下交互操作（注意：操作作用范围是相应的agenda文件）。限定Agenda显示内容的范围输入 &lt;输入之后，会切换Agenda视图的搜索范围，依次为“没有限定”、“限定当前buffer”、"限定当前子树"。取消对Agenda view的范围限定输入 &gt;列出所有TODO项目输入 t列出特定状态的TODO项目输入 T输入之后，需要进一步输入需要列出的状态关键字，以完成显示。搜索包含指定字符串的标题输入 s输入之后，再输入待搜索字符串即可列出所有包含该字符串的标题（字符串可能在内容中）搜索TODO项目字符串输入 S同上，不同之处是，搜索的是TODO标题项目，而不是普通标题。搜索字符串输入 /输入之后，再输入待搜索字符串将会列出所有包含该字符串的地方。11.1.2 交互命令：进入Agenda中后，会有如下提示：Global list of TODO items of type: ALLAvailable with `N r': (0)[ALL] (1)INBOX (2)NEXT (3)LATER (4)WAIT/FORWARD (5)MAYBE/FUTURE (6)CANCEL (7)DONE只显示某一项，如只显示NEXT的内容输入 2 r重新刷新当前 Agenda输入 r切换是否显示当前行所在buffer内容输入 &lt;12 导出12.1 操作导出为特定格式输入 C-c C-e 输入之后，会默认将当前Buffer导出为特定格式，期间需要输入交互信息指定导出为html还是pdf；如果需要其它的导出选项，比如将当前子标题导出为特定格式，需要根据交互命令来做（比如C-s是切换导出范围）。13 其它搜索sparse tree输入 C-c / 输入之后，会提示你搜索对应的内容，输入你想搜索的内容后可以看到相关内容以及相关的tree。导出输入 C-c C-e输入之后，进入交互命令，可以选择各种需要导出的格式。13.1 建议13.1.1 列表与标题建议少用列表，多用标题。列表中的段落尽可能少，层次尽可能浅；多用标题也方便定位和缩进(标题过多，会导致目录复杂?)。建议少用断行，多用段落。13.1.2 列表与换行[2015-10-19 一 07:52]想到一个方法解决列表内多段落的问题。换行杜绝硬换行的习惯, 尽量使用空行表示换行。硬换行用“\\”，但是输入不便且有些情况不支持（如MobileOrg），所以想要换行，就新起一段落，那么新行前多一个空行。这是一个新行，也是新段落。一个段落，实际就是一行。逻辑关系有标点表示。列表内换行用描述列表有时为美观，列表第一换行若用一空行则显得与列表项标题相距有点远，并且第一行内容一般也很少，一般都是总体描述性文字。所以，建议第一行是简短描述时用描述列表，第一行在描述的“::”后，之后的段落也用空行。若直接第一行就很长不是描述，那么不用描述列表，并且宁可与列表项标题多空一行，也不用断行符。13.2 感想学习orgmode主要分为如下几个阶段：基本标记语法阶段 可以在简单场合写作简短的评论、文章使用，需要关注的内容可以是：标题、格式、列表、链接、表格、块标记日程管理阶段 对基本标记语法掌握之后，进一步掌握日程管理并利用其中的功能，需要关注的内容可以是：发布阶段 对已有内容整理、组织、发布成公开格式13.3 注意如果Checkbox，则最好一行，如果是多行的Checkbox, 那么导出的效果将会把 + [ ] 放到第一行，其它的全在新行开始。13.4 orgmode与mobile org整合参考相关文档：MobileOrg学习本文之前，需要首先了解Orgmode相关知识，至少应该知道：Orgmode可用于轻量级文档标记、项目管理、以及内容发布。MobileOrg是一个使用Org mode的移动端应用程序。目前支持IOS和Android系统。MobileOrg提供离线浏览(Viewing)和捕获(Capture)在真实计算机上的Org mode系统内容。它允许你为已有的entries记录修改。本文中：MobileOrg是Mobile端的一个应用程序，运行在Android（也有IOS的MobileOrg）;Org是PC端Emacs的一个插件应用，对应其Orgmode模式。文档中描述如何用Org创建可以通过MobileOrg显示的文档格式，以及如何将Mobile端的MobileOrg中修改和捕获的笔记，集成到PC端的“主” Org mode系统中（即Org与MobileOrg的同步），不涉及Agenda相关的操作。13.4.1 配置为了在MobileOrg中能够修改tags和TODO状态，你应该在PC端设置好自定义变量： org-todo-keywords 和 org-tag-alist ，使它们包含所有需要修改的重要的tags和TODO keywords，哪怕每个文件只使用其中的部分内容。MobileOrg也能通过in-buffer settings来为你提供TODO和tags设置，但是它只能读懂这些变量中的那些设置好的TODO状态集合以及tags。假设我们想要使PC上的Org与移动设备上的MobileOrg保持内容同步（底层通过git机制，也可以是云存储、ssh、ftp等机制）。这里给出为实现这个目的，在PC需要做的配置工作(移动端的MobileOrg做为辅助工具，其配置和操作非常简单，在适当的时候会提及)。13.4.1.1 在PC上添加使用MobileOrg的emacs配置主要包括对Emacs中org-mode模块的加载以及与MobileOrg同步的路径。例如:;;Sync with mobileorg(require 'org-mobile);;mobile stage(setq org-mobile-directory "/home/miracle/mygitrepo/pocket/MobileOrg")另外，可以通过 org-mobile-encryption-password 设置加密方面的内容。在后面我们可知，在PC上的orgmode中有特定的命令将相关内容推送到这个目录中。13.4.1.2 在PC上添加同步orgmode和MobileOrg的emacs配置主要包括PC端和MobileOrg端状态与标记的设置，PC上被推送orgmode内容的源文件路径，以及PC上接收MobileOrg修改的缓存路径设置。为被推送文件定义只属于该文件的状态和标记被推送的文件可使用文件选项定义相关的状态和标签（实践发现不用定义文件的状态和标签也行），定义内容最好和PC上的相关状态变量(即 setq org-todo-keywords )一致，或者是其子集。如果使用文件定义状态，那么可以将用于push到MobileOrg的文件中的状态设置选项如下：#+TODO: INBOX(i!) NEXT(n!) LATER(l!) WAIT/FORWARD(w@/!) MAYBE/FUTURE(m!) | CANCEL(c!) DONE(d!)标记的设置类似。设置状态关键字和被推送至MobileOrg的文件列表路径如下;;set status for TODO.(setq org-todo-keywords '((sequence "INBOX(i!)""NEXT(n!)""LATER(l!)""WAIT/FORWARD(w@/!)""MAYBE/FUTURE(m!)""|" "CANCEL(c!)" "DONE(d!)")))   ;;mobile push(setq org-mobile-files (list (concat org-directory "gtd/mobile_org")))设置接收来自MobileOrg内容的“缓存”目标文件路径如下;;mobile pull(setq org-mobile-inbox-for-pull (concat org-directory "gtd/from_mobile.org"))13.4.2 原理13.4.2.1 Mobile端的Mobile Org与PC端的Org同步当我们在MobileOrg中与PC端的Org同步时，需要知道它不仅仅是从PC端获取（mobile端的pull）相应org文件用于浏览，同时也会追加(mobile端的push)被captured的entries(之后captured的内容会消失)，并且指向被标记和修改的entries，这些内容被汇总在同步目录( org-mobile-directory )中的 mobileorg.org 文件里。13.4.2.2 PC端的Org与Mobile端的MobileOrg同步PC端的Pull获取MobileOrg修改内容(PC端的pull)的时候，会将这些信息从 mobileorg.org 先转移到到 org-mobile-inbox-for-pull 对应的文件中，并对指向的被标记的内容进行进一步操作，进而将能够自动处理内容同步到对应的文件中。Pull的过程大致过程如下:Org将会将 mobileorg.org 中的所有entries移动到 org-mobile-inbox-for-pull 所指向的文件（假设为mobileinbox），每个被捕获的entry和编辑事件都会被做为这个mobileinbox中的顶级entry而存在。（进行操作之后， mobileorg.org 将会被清空）当将entries移动到 org-mobile-inbox-for-pull 指向的文件之后，Org将会开始执行在MobileOrg进行的修改。有些修改直接就会被应用了不需要额外的用户交互（例如修改tag、TODO状态、标题、正文文本可以被简单的应用）。而需要额外动作的entries会接收到一个:FLAGGED:的tag，这样它们才会很容易地被找到。当应用修改或者寻找一个entry之时出现了问题，目标entry将会保持在 org-mobile-inbox-for-pull 中，并且被标记一个错误信息，我们需要之后手动解决这些问题，并将对应内容(entry)转移到期望的位置。(不熟悉)Org之后会生成一个包含所有flagged的entries的agenda view，用户可以遍历这些entries来做一些必要的动作。如果在对MobileOrg中的entry进行标记的时候一个note已经存储了，那么这个note会在光标处于对应agenda line的时候在回显区域显示出来。关于 ?在哪个特定的agenda中按下 ? 将会在另外一个windows中显示整个被标记的笔记(flagging note)，也会将它push到kill ring中。所以，你可以在这个entry中使用 ?z C-y C-c C-c 保存哪个标记笔记为普通笔记。连续键入 ? 两次将会体同将 :FLAGGED:标签联通记录的标记笔记（flagging note）（在一个属性中被保存）一起被移走。这样，你可以用此来表示这个 flagged entry的处理已经完成。如果你不能够直接处理所有的flagged entries，你可以通过 C-c a 回到这个agenda view。PC端的Push推送内容到MobileOrg端(PC端的push)的时候，会推送PC上设置的 org-mobile-files 对应的文件，该变量对应的文件路径是相对 org-directory 的路径，默认使用 org-agenda-files ,被退送的目标是 org-mobile-directory 设定的位置。Push的过程大致如下：拷贝 org-mobile-files 中的内容到同步目录 org-mobile-directory 中，文档中提到，如果待推送的文件是一个链接文件，那么链接文件名称需要和源名称一致。创建特定的agendas.org文件，这些文件可以是用户自定义的agenda view，由 org-mobile-agendas 来设定。最后，orgmode会写一个 index.org 文件，这个文件包含所有到其他文件的链接，Mobile首先在Server中读取这个文件，然后把这个文件中列出的所有agendas文件和org文件下载下来，为了加速下载过程，MobileOrg只读取checksums3被改变的文件。13.4.2.3 Org与MobileOrg的同步目录我们需要注意，在前面的讲述中所涉及到的同步，其实暗含了两种同步：Mobile端的MobileOrg与PC端的Org之间的同步（通过设定一个同步目录做为中转）这个前面也讲到，主要是Mobile端的Sync（包含Push/Pull）操作，以及PC端的Push/Pull操作。同步目录在云端与PC/Mobile端的同步前面MobileOrg和Org同步之时，需要经过它们之间的一个共通的“同步目录”。这个目录在Mobile端和PC端的内容和结构需要首先保持一致，才能保证后续MobileOrg和Org之间数据的同步一致。所以，我们在同步PC端的Org与Mobile端的MobileOrg之前，先将PC端和Mobile端的目录通过某种方式进行同步。这里同步目录的方式使用用git进行，PC端和Mobile端之间的同步目录用某个git托管服务器进行管理（例如github、bitbucket、或者自己的服务器），任意端的同步目录中数据发生变化后都要推送到托管服务器中，而任意端要读取最新数据都需要从托管服务器中拉取数据，同步目录中的数据更新之后，再进行后续MobileOrg和Org的数据更新。我们也可使用其它方式管理同步目录，比如云存储（百度云、DropBox等）、或者ftp、webdav、ssh等。另外，Mobile端的git可以使用pocketgit工具。13.4.3 同步操作13.4.3.1 PC端的Org推送（Pull）命令如下：M-x org-mobile-push 推送之后，会在同步目录（即 org-mobile-directory 对应的路径）中建立 org-mobile-files 对应文件列表的路径结构，并拷贝相应文件到其中。13.4.3.2 PC端的Org拉取（Push）命令如下：M-x org-mobile-pull 运行之后，其对应的 org-mobile-files 便包含了和MobileOrg同步的内容。13.4.3.3 Mobile端的MobileOrg同步（Sync）这里使用Android版本的MobileOrg，大致如下：首先设置好同步目录，然后选择软件界面中的"Sync"按钮，即可完成同步（包含Pull和Push）。13.4.4 使用举例PC上配置好相关变量和目录手机上安装好MobileOrg也设置好同步目录将PC和手机上的同步目录用github/bitbucket管理PC上同步目录更新： git/pullPC上记录之前运行： org-mobile-pull 可以看到手机上修改的内容。PC上记录，记录之后运行： org-mobile-pushPC上的git同步目录上传修改： git add/commit/push手机上的git同步目录下载更新： git pull手机上的MobileOrg同步(点击Sync)手机上看到PC修改的内容手机上修改并同步（点击Sync）手机上更新同步目录： git add/commit/push回到步骤4。缺点：列表中的段落，无法识别断行？13.4.5 其它13.4.5.1 关于Agenda在手机端的Mobileorg上，看到的agenda内容是在 org-mobile-files 范围内的内容。13.4.5.2 MobileOrg的实用之处-CaptureMobileOrg的特长目前看来非编辑和阅读，因为编辑和阅读所支持的格式不全，并且一般都在pc上进行编辑。MobileOrg存在的一个亮点是Capture。在MobileOrg上直接捕获(Capture)， 不设置父标题（即新建笔记到Capture下），在PC端运行 org-mobile-pull 的时候，直接将其抓取到 inbox-from-mobile 中，同步后MobileOrg上的相应Capture也会消失。这样，手机中随手记下简短的内容，再汇集到PC上整理。13.5 orgmode与jekyll的结合主要介绍使用orgmode的发布功能生成html文件，然后将orgmode的发布功能与jekyll结合。13.5.1 部署13.5.1.1 jekyll环境路径为 ~/mygitrepo/quietheart/mydoc/prepub/jekyll/13.5.1.2 orgmode文档环境路径为 ~/mygitrepo/quietheart/mydoc/prepub/orgmode/13.5.1.3 关键文件结构包含各自说明目录的作用~/mygitrepo/quietheart/mydoc/prepub/jekyll/readme~/mygitrepo/quietheart/mydoc/prepub/orgmode/readmeorgmode文档路径中待发布到jekyll的内容在如下路径：~/mygitrepo/quietheart/mydoc/prepub/orgmode/_posts/~/mygitrepo/quietheart/mydoc/prepub/orgmode/data对应的目录内的结构应该是jekyll的镜像子集。其它路径其他路径作用会根据需要确定。如 ~/mygitrepo/quietheart/mydoc/prepub/orgmode/categories/ 当前暂时在_posts中写文，完成的文章可能会转移至categories。又如 ~/mygitrepo/quietheart/mydoc/prepub/orgmode/_includes 这个里面包含为兼容jekyll显示，定义的样式，是html代码片段。13.5.2 配置做如下配置，使得orgmode导出的文件直接被导出到jekyll中：;;;;Publish;;;;;;(require 'org-publish);;old;;(require 'org-html);;old;;(require htmlize);;??(require 'ox-publish)(require 'ox-html)(setq org-publish-project-alist '(    ("org-docs"    :base-directory "~/mygitrepo/quietheart/mydoc/prepub/orgmode/_posts/"    :base-extension "org"    :publishing-directory "~/mygitrepo/quietheart/mydoc/prepub/jekyll/_posts/"    :recursive t    :publishing-function org-html-publish-to-html    :headline-levels 4             ; Just the default for this project.    :language zh-CN    :html-extension "html"    :body-only t ;; Only export section between &lt;body&gt; &lt;/body&gt;        ;;:auto-preamble t    ;;:section-numbers nil     :with-toc nil    :with-smart-quotes t        ;;:with-fixed-width nil    ;;:with-tables t    ;;:with-tasks t    ;;:with-todo-keywords t    ;;:with-timestamps t    ;;:with-footnotes t    ;;:author QuietHeart    ;;:email quiet_heart000@126.com    ;;:with-email t    )    ("org-data"    :base-directory "~/mygitrepo/quietheart/mydoc/prepub/orgmode/data/"    :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf\\|tgz\\|gz\\|tar\\|zip\\|rar\\|7z"    :publishing-directory "~/mygitrepo/quietheart/mydoc/prepub/jekyll/data/"    :recursive t    :publishing-function org-publish-attachment    )    ("org" :components ("org-docs" "org-data")) ))13.5.3 被导出文件与jekyll的集成被导出文件按照类似jekyll的方式命名，即 日期-文章名.org ，再经过上述配置，orgmode导出的文件是只包含 body 部分的相同文件名但是扩展名为 .html 的文件。这个时候，生成的文件已经能够直接被jekyll应用，集成到jekyll框架内生成的站点中，但是生成的文件格式还是可能有些错乱，而且没有包含jekyll所需的头信息（ YAML Front Matter 信息）。13.5.4 为待发布文章添加兼容jekyll显示的信息为使得发布的文章能够更好的兼容jekyll信息，需要对待发布的 *.org 文章， 从最开始，依次添加如下额外信息。13.5.4.1 orgmode html选项首先添加文档选项信息，这些信息不直接体现在文章内容上。可以先输入 C-c C-e # html 以便插入html模板，插入的信息类似如下：#+OPTIONS: html-link-use-abs-url:nil html-postamble:auto#+OPTIONS: html-preamble:t html-scripts:t html-style:t#+OPTIONS: html5-fancy:nil tex:t#+HTML_DOCTYPE: xhtml-strict#+HTML_CONTAINER: div#+DESCRIPTION:#+KEYWORDS:#+HTML_LINK_HOME:#+HTML_LINK_UP:#+HTML_MATHJAX:#+HTML_HEAD:#+HTML_HEAD_EXTRA:#+SUBTITLE:#+INFOJS_OPT:#+CREATOR: &lt;a href="http://www.gnu.org/software/emacs/"&gt;Emacs&lt;/a&gt; 23.3.1 (&lt;a href="http://orgmode.org"&gt;Org&lt;/a&gt; mode 8.3.1)#+LATEX_HEADER:不同版本，可能产生的内容有所不同，根据个人需要对此进行修改，如果不需要，那么就不加这个步骤。这里给出一个实例：#+TITLE:GTD管理方式#+AUTHOR:QuietHeart#+DATE:[2015-11-03 二 12:16]13.5.4.2 jekyll所需的 YAML Front Matter之后再添加用于jekyll识别的 YAML Front Matter 信息，信息位于 #+BEGIN_HTML...#+END_HTML 之间，必须将信息包含在两对 --- 行内，这样生成的导出文件，最开始便是相应的 YAML Front Matter 信息了。具体参见jekyll相关文档。这里给出一个例子：#+BEGIN_HTML---layout: poststitle: GTD管理方式categories: [categories, note]comments: true---#+END_HTML13.5.4.3 包含兼容jekyll显示的css样式信息再后添加导出html样式信息，该信息是html代码片段而非css文件的包含。由默认 C-c C-e hh 导出的单html文件样式修改而来，修改之时结合jekyll的CSS配置，将这个配置插入到导出的html中，便可使导出的文件样式更好地兼容整个jekyll环境中所定义的样式。如前面所述，这里会将该代码片段存成文件 jekyll_orgmode_style.ext ，部署到 orgmode/_includes/ 中，并被包含的待发布的文章中，如下：#+INCLUDE: "../_includes/jekyll_orgmode_style.ext"关于样式代码片段内容，根据个人的jekyll样式定义，以及orgmode导出的html样式各有不同，需要自行修改，这里给出一个例子：#+BEGIN_HTML&lt;style type="text/css"&gt;.title  { text-align: center;           margin-bottom: .2em; }.subtitle { text-align: center;            font-size: medium;            font-weight: bold;            margin-top:0; }.todo   { font-family: monospace; color: red; }.done   { font-family: monospace; color: green; }.priority { font-family: monospace; color: orange; }.tag    { background-color: #eee; font-family: monospace;          padding: 2px; font-size: 80%; font-weight: normal; }.timestamp { color: #bebebe; }.timestamp-kwd { color: #5f9ea0; }.org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }.org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }.org-center { margin-left: auto; margin-right: auto; text-align: center; }.underline { text-decoration: underline; }#postamble p, #preamble p { font-size: 90%; margin: .2em; }p.verse { margin-left: 3%; }pre {  border: 1px solid #0c0;  box-shadow: 1px 1px 1px #0e0;  padding: 8pt;  font-family: italic monospace;  color: #C7EDCC;  background-color: #111111;  overflow: auto;  margin: 1.2em;}pre.src {  position: relative;  overflow: visible;  padding-top: 1.2em;}pre.src:before {  display: none;  position: absolute;  background-color: white;  top: -10px;  right: 10px;  padding: 3px;  border: 1px solid black;}pre.src:hover:before { display: inline;}pre.src-sh:before    { content: 'sh'; }pre.src-bash:before  { content: 'sh'; }pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }pre.src-R:before     { content: 'R'; }pre.src-perl:before  { content: 'Perl'; }pre.src-java:before  { content: 'Java'; }pre.src-sql:before   { content: 'SQL'; }table { border-collapse:collapse; }caption.t-above { caption-side: top; }caption.t-bottom { caption-side: bottom; }td, th { vertical-align:top;  }th.org-right  { text-align: center;  }th.org-left   { text-align: center;   }th.org-center { text-align: center; }td.org-right  { text-align: right;  }td.org-left   { text-align: left;   }td.org-center { text-align: center; }dt { font-weight: bold; }.footpara { display: inline; }.footdef  { margin-bottom: 1em; }.figure { padding: 1em; }.figure p { text-align: center; }.inlinetask {  padding: 10px;  border: 2px solid gray;  margin: 10px;  background: #ffffcc;}#org-div-home-and-up { text-align: right; font-size: 70%; white-space: nowrap; }.linenr { font-size: smaller }.code-highlighted { background-color: #ffff00; }.org-info-js_info-navigation { border-style: none; }#org-info-js_console-label  { font-size: 10px; font-weight: bold; white-space: nowrap; }.org-info-js_search-highlight{ background-color: #ffff00; color: #000000; font-weight: bold; }  &lt;/style&gt;#+END_HTML13.5.4.4 添加文章内容目录索引为保证用于jekyll的 YAML Front Matter 位于文件最前，前面的 :with-toc nil 配置可以确保orgmode不会自动将目录插入到文件开始，但是如果需要为文章加入目录信息，可以手动通过 #+TOC: headlines 3 在需要之处插入目录。实例如下：#+TOC: headlines 313.5.4.5 需要添加信息的汇总这里为清晰起见，做一个汇总，经过前面添加的过程，最终我们在所要发布的 *.org 文章里添加的信息举例如下：#+TITLE:GTD管理方式#+AUTHOR:QuietHeart#+DATE:[2015-11-03 二 12:16]#+BEGIN_HTML---layout: poststitle: GTD管理方式categories: [categories, note]comments: true---#+END_HTML#+INCLUDE: "../_includes/jekyll_orgmode_style.ext" #+TOC: headlines 3注意，文章内容中的链接全部用相对于orgmode配置的发布源路径的相对链接。13.5.5 发布命令配置好信息之后，直接运行orgmode的发布命令即可将相应orgmode文件转换为html文件：M-x org-publish-project RET org RET或者输入 C-c C-e P x注意，因为缓存的关系，如果没有被修改的文件，有时候可能不会被重新发布，可以只发布当前文件： C-c C-e P f13.5.6 其他参考资料：http://orgmode.org/worg/org-tutorials/org-jekyll.htmlhttp://higrid.net/c-art-orgmode_jeklly_github.htmhttp://orgmode.org/worg/org-tutorials/org-publish-html-tutorial.html自行配置的时候，可能在执行的时候发布命令会报错，Publishing file /home/miracle/mygitrepo/quietheart/mydoc/prepub/orgmode/_posts/2015-11-03-GTD_Manage_Method.org using `org-publish-org-to-html'find-buffer-visiting: Wrong type argument: stringp, (:base-directory "~/mygitrepo/quietheart/mydoc/prepub/orgmode/_posts/" :base-extension "org" :publishing-directory "~/mygitrepo/quietheart/mydoc/prepub/jekyll/_posts/" :recursive t :publishing-function org-publish-org-to-html ...)这时候可以参考如下信息：http://www.cnblogs.com/banjia/archive/2012/09/29/2708966.htmlhttp://comments.gmane.org/gmane.emacs.orgmode/76412http://orgmode.org/worg/org-8.0.html13.6 Misc collection杂乱无章的收集的文档，暂时无法分类可能待整理?13.6.1 &#x2014;&#x2014; [2015-12-03 四 14:55]  Agenda view------From:/home/miracle/mydata/orgmode/gtd/inbox.org把当前buffer加入到agenda files中C-c [把当前buffer从agenda files中移除C-c ]14 WAIT/FORWARD FAQ [35/111]([31%])State "WAIT/FORWARD" from              [2015-11-27 五 15:10]  wait for all finishied.14.1 MAYBE/FUTURE 如何隐藏"标题星星"？State "MAYBE/FUTURE" from "INBOX"      [2015-11-23 一 17:53]参考下面的资料：啊，十分感谢，果然也可以隐藏星星，而且没有INDENT所带来的问题，虽然在某级别下行输入普通文本不会自动缩进，不过已经很好了。  另，开启这个变量的方式是在.EMACS文件中加入(SETQ ORG-HIDE-LEADING-STARS T)【 在 UNKNOWNZERX 的大作中提到: 】: 话说有个ORG-HIDE-LEADING-STARS变量14.2 LATER 搜索子树相关State "LATER"      from "INBOX"      [2015-12-03 四 15:33]C-c / d 建立一个包含所有deadline的TODO项目的sparse treeC-c / b 建立一个包含deadline在指定日期前的TODO项目的sparse treeC-c / a 建立一个包含deadline在指定日期后的TODO项目的sparse tree 14.3 DONE 各个级别标题列表如何缩进？用调整的级别的命令即可。例如参考：标题大纲操作 和 列表操作 相关命令。14.4 DONE 各个级别列表标题中的内容段落如何缩进？可以参考列表操作 相关命令。14.5 LATER 如何显示图片State "LATER"      from "INBOX"      [2015-12-03 四 15:33]14.6 DONE 如何删除标题或者项目以及子树下的内容？State "DONE"       from "LATER"      [2015-11-20 五 12:14]目前可以在大纲状态下标记某部分成活动区域，然后删除便会连同子树一并删除。输入 C-c C-x C-w ，具体参考 标题大纲操作14.7 DONE 如何链接文件和位置之类的？参考 链接14.8 DONE 如何行内转义引用?参考格式部分的内容14.9 DONE 如何设置启动时的自动折叠？可以参考标题大纲配置14.10 MAYBE/FUTURE 如何预览效果？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:33]14.11 DONE 标签的预定义参考 标签配置14.12 MAYBE/FUTURE 如何自动对齐ORGMODE文件的格式？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:33]14.13 DONE 如何在标题间跳转？参考 标题大纲操作14.14 DONE 如何缩进列表段落？可以参考列表操作 相关命令。14.15 LATER 貌似自动刷新功能还是没有完全实现State "LATER"      from "NEXT"       [2015-10-10 六 16:32]在refile的时候会体现出来，还需要 C-x C-v 手动进行。14.16 DONE 如何增加状态？参考 TODO配置14.17 DONE 如何定制状态的各种属性？配置属性参考： TODO配置14.18 DONE 如何设置和进行TODO的状态快捷切换？快捷切换参考:TODO操作 14.19 DONE 如何按状态搜索TODO项目？State "DONE"       from "NEXT"       [2015-10-10 六 16:21]输入 C-c a T具体参见Agenda操作14.20 LATER 如何实现代码原样引用？对于:#+BEGIN_SRC  emacs-lisp:#+END_SRC:#+BEGIN_EXAMPLE:#+END_EXAMPLE这样的代码块，最好在相关的引用块中缩进一下。14.21 DONE 配置折叠状态编辑的动作参考：标题大纲配置14.22 LATER 按照TAG进行搜索State "LATER"      from "NEXT"       [2015-10-10 六 16:32]14.23 LATER 导出与发布14.24 DONE 如何调整大纲缩进显示需要设置org=startup-indented，或者indent选项，参考标题大纲配置14.25 DONE 如何写行内引用的文字，类似markdown中的``。等宽字体即可，参考：格式14.26 DONE 如何确保硬换行列表或其他行尾插入 \\具体参考：硬换行14.27 DONE 如何保存一个与文件位置无关的链接？ C-c l 相关参数？配置全局链接。参考:链接配置14.28 DONE 如何简化列表标题等文档复杂度简化结构。参考：建议14.29 CANCEL 如何定制插入的时间戳格式？State "CANCEL"     from "LATER"      [2015-11-20 五 12:15]State "LATER"      from "NEXT"       [2015-10-22 四 09:54]14.30 LATER 如何在Refile的时候新建一个标题？org-refile-allow-creating-parent-nodes?State "LATER"      from "NEXT"       [2015-10-09 五 15:29]14.31 DONE 恢复到默认的大纲内容模式还不太好用使用 C-u C-u TAB 参考：大纲操作。14.32 WAIT/FORWARD 是否可以org-agenda-files只使用一个文件，对应文件中列出所有agenda文件？State "WAIT/FORWARD" from "NEXT"       [2015-10-09 五 15:33]  wait for move to appropriate place.State "NEXT"       from "INBOX"      [2015-10-09 五 15:29]可以参考如下设置：(setq org-agenda-files (concat org-directory "gtd/agendafiles"))对应的文件类似如下：gtd/gtd/next.orggtd/later.orggtd/maybe_future/gtd/cancel/gtd/done/gtd/_active/gtd/_review/gtd/output/14.33 WAIT/FORWARD 如何设置问题Open的时间？State "WAIT/FORWARD" from "NEXT"       [2015-10-10 六 16:22]  没有完全解决，需要将有用信息转移的合适位置，没有解决的部分视情况切换状态。直接方式目前来说，如果直接插入一个TODO项目就暂时没有相应的时间戳，只能间接实现，如后面所述。间接方式设置如下参数：(setq org-todo-keywords '((sequence                            "INBOX(i!)"                           "NEXT(n!)"                           "LATER(l!)"                           "WAIT/FORWARD(w@/!)"                           "MAYBE/FUTURE(m!)"                           "|" "CANCEL(c!)" "DONE(d!)"                           )))注意其中的'!'表示添加时间戳信息。这样插入一个普通项目之后，可以通过切换成INBOX状态达到自动插入时间戳的目的。这样设置之后，也会导致任何的状态切换会自动在相应的TODO项目标题下添加一个时间戳和状态切换信息。14.34 WAIT/FORWARD 确认一下agenda的配置文件是否可以配置目录？State "WAIT/FORWARD" from "NEXT"       [2015-10-10 六 16:29]  等待整理至合适位置将org-agenda-files变量设置成单文件后，将采用这个文件内容列出的文件列表做为agenda的备选文件，目前实践看来可以将这个文件中某项文件列表写成目录路径。14.35 LATER 考虑使用F1-n设置自己日常使用的自定义快捷方式，并且保证不要与其它冲突。State "LATER"      from "NEXT"       [2015-10-10 六 16:32]14.36 LATER 标题如何添加序号？State "LATER"      from "INBOX"      [2015-12-03 四 15:33]14.37 LATER 如何直接插入一个子标题？State "LATER"      from "INBOX"      [2015-10-09 五 15:18]State "INBOX"      from              [2015-10-09 五 15:16]目前的方法是先用 C-Ret 插入一个同级标题，然后没有移动光标的情况下直接用 TAB 缩进到合适级别，或者用特定的标题操作缩进。14.38 DONE 参考并整理结构编辑的相关操作：State "DONE"       from "NEXT"       [2015-11-20 五 12:15]参考网址为：http://orgmode.org/manual/Structure-editing.html#Structure-editingo整理至：大纲操作14.39 DONE 如何对一个子树进行导出？State "DONE"       from "INBOX"      [2015-11-17 二 16:38]输入 C-c C-e 之后，再输入 C-s 选择导出范围。14.40 MAYBE/FUTURE 注意，断行要用'\\'，要么就空白一行。State "MAYBE/FUTURE" from "INBOX"      [2015-11-17 二 16:39]14.41 WAIT/FORWARD 如何解决输入下划线的时候，自动转换为下标？（想要不转换）State "WAIT/FORWARD" from "NEXT"       [2015-10-19 一 12:02]  等待整理至合适位置State "NEXT"       from "INBOX"      [2015-10-12 一 09:36]State "INBOX"      from              [2015-10-08 四 14:48对于上下标引导(_和^)字符，只解释后面'{}'括起来的文字为上下标，其余不解释。设置如下：;;don't interpret"-" and "^" for display(interpret with "{}").(setq org-use-sub-superscripts '{})(setq org-export-with-sub-superscripts '{})变量 org-use-sub-superscripts 用来控制是否显示之时解释 - 引导的下标，还是 ^ 引导的上标；如果解释值为t，则始终对引导的内容解释成上下标；如果不解释，则值为nil；如果只在将文字用'{}'括起来的时候才解释，则设置为'{}； 变量 org-export-with-sub-superscripts 类似，不过解释的时机为导出之时解释，而非显示。8.0这两个变量互相为对方的别名，后来不是了。对于导出html格式，如果设置 org-use-sub-superscripts 不管用，设置 org-export-with-sub-superscripts 才管用。效果：正常文字_正常文字正常文字_{下标}正常文字^正常文字正常文字^{上标}normal_normalnormal_{sub}normal^normalnormal^{sup}14.42 LATER orgmode refile如何创建新的文件和条目，如何定位设置之外的路径State "LATER"      from "INBOX"      [2015-12-03 四 15:33]Time:&lt;2015-10-02 五 14:10&gt;14.43 DONE orgmode如何只对一个指定的子标题生成html等导出文件？State "DONE"       from "INBOX"      [2015-11-17 二 16:41]Time:&lt;2015-10-07 三 11:12&gt;参考：导出操作14.44 DONE 如何在capture模板中将时间戳设置为非活跃时间戳，以减少Agenda的显示负担？State "DONE"       from "INBOX"      [2015-10-09 五 15:26]在模板中使用 %u/%U 来替代 %t/%T ，例如：;;Capture template(setq org-capture-templates '(;;                            ("t" "Tasks" entry (file+headline "gtd/inbox.org" "Tasks") "* INBOX %?\nTime:%T\n")                              ("t" "Tasks" entry (file+headline "gtd/inbox.org" "Tasks") "* INBOX %?\nTime:%U\n")                              ("p" "Projects" entry (file+headline "gtd/inbox.org" "Projects")  "* %?\nTime:%U\n")                              ("i" "Item notes" item (file+headline "gtd/inbox.org" "Items")  "+ %?\n  Time:%U\n  From:%F\n")                              ("m" "Misc notes" entry (file+headline "gtd/inbox.org" "Notes")  "* ------Time:%U------\nFrom:%F\n%?")                             ))14.45 DONE orgmode如何插入带有时间（而不仅仅是日期）的时间戳？State "DONE"       from "NEXT"       [2015-10-22 四 09:55]State "NEXT"       from "DONE"       [2015-10-09 五 15:26]State "DONE"       from "NEXT"       [2015-10-09 五 14:26]State "NEXT"       from "INBOX"      [2015-10-09 五 09:41]Time:[2015-10-09 五 09:37]具体参考：时间戳操作使用 C-u C-c !14.46 LATER 整理一下emacs_orgmodeusage的文档格式State "LATER"      from "INBOX"      [2015-11-17 二 16:41]Time:&lt;2015-10-09 五 09:36&gt;14.47 MAYBE/FUTURE 如何在活跃与非活跃时间戳之间进行切换？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:33]State "INBOX"      from              [2015-10-09 五 15:26]14.48 NEXT 如何打开链接的时候不新开一个窗口？State "NEXT"       from "INBOX"      [2015-11-17 二 16:41]State "INBOX"      from              [2015-10-09 五 15:09]14.49 WAIT/FORWARD orgmode 的BEGIN_SRC总是导出错误，提示输入的语言参数，如何确定有哪些语言参数？State "WAIT/FORWARD" from "DONE"       [2015-10-10 六 16:15]  need move to right place.State "DONE"       from "INBOX"      [2015-10-10 六 16:14]Time:[2015-10-09 五 14:26]参考：orgmode相关文档网址目前大致支持如下格式：LanguageIdentifierAwkawkC++C++CSScssditaaditaaEmacs CalccalcFortranfortranHaskellhaskellJavascriptjsLedgerledgerLilypondlilypondMscgenmscgenOctaveoctaveOzozPlantumlplantumlPythonpythonRubyrubySchemeschemeSedsedSQLsqlSQLitesqliteAsymptoteasymptoteCCClojureclojureDdGraphvizdotEmacs Lispemacs-lispgnuplotgnuplotJavajavaLaTeXlatexLisplispMATLABmatlabObjective CamlocamlOrg modeorgPerlperlProcessing.jsprocessingRRSasssassGNU Screenscreenshellsh例如，如果使用Emacs Lisp的格式那么这样：#+BEGIN_SRC emacs-lispxxx#+END_SRC14.50 LATER 如果Agenda对应TODO状态发生变化，如何刷新Agenda view?State "LATER"      from "INBOX"      [2015-10-10 六 16:26]Time:[2015-10-10 六 16:21]在Agenda的TODO筛选界面（如 C-c a T ）上按照提示操作 (如 r )。14.51 DONE orgmode有没有离线帮助手册在emacs中直接使用？State "DONE"       from "INBOX"      [2015-11-17 二 16:41]Time:[2015-10-09 五 14:27]输入 M-x info ， 之后能够看到orgmode相关的文档。14.52 LATER 如何自由切换orgmode的活跃和非活跃时间戳？State "LATER"      from "INBOX"      [2015-12-03 四 15:34]Time:[2015-10-09 五 15:46]14.53 LATER 如何在orgmode中调整已有列表条目的缩进级别？State "LATER"      from "INBOX"      [2015-12-03 四 15:35]Time:[2015-10-09 五 16:11]14.54 MAYBE/FUTURE Orgmode表格格式如何自动添加分割横线？为何导出时没有列分割？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:34]Time:[2015-10-10 六 12:05]14.55 MAYBE/FUTURE Agenda view不折行？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:34]Time:[2015-10-10 六 16:36]例如 C-c a T14.56 MAYBE/FUTURE 如何格式化块？如删除块？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:35]14.57 LATER 如何自动触发状态变化？State "LATER"      from "INBOX"      [2015-12-03 四 15:35]例如自动触发状态切换，自动触发refile之类的？14.58 DONE orgmode与mobile org整合State "DONE"       from "WAIT/FORWARD" [2015-11-27 五 10:49]目前感觉不是非常好用，mobile org中Capture功能相对实用一些，可以将片段捕捉下来，同步到电脑上。具体参见：orgmode与mobile org整合14.59 MAYBE/FUTURE Orgmode refile如何到特定的标题上而非仅仅追加或者插入？State "MAYBE/FUTURE" from "LATER"      [2015-12-03 四 17:21]State "LATER"      from "INBOX"      [2015-12-03 四 15:35]Time:[2015-10-19 一 09:54]另外，如何新建文件？新建标题之类的？关于refile之时不将被refile的标题做为子标题，参见如下回答：If you specify org-refile-use-outline-path to be 'file it is possible to just use the path of the file as the refile target and the node will be entered at the top-level.(setq org-refile-use-outline-path 'file)(setq org-refile-targets '((org-agenda-files :level . 1)))You can see the full documentation of org-refile-use-outline-path with C-h v org-refile-use-outline-path RET.网址：http://stackoverflow.com/questions/21334817/emacs-org-mode-refile-to-main-tree-and-not-as-a-subtree14.60 CANCEL orgmode attachment的内容需要看一下State "CANCEL"     from "WAIT/FORWARD" [2015-11-20 五 12:18]State "WAIT/FORWARD" from "CANCEL"     [2015-11-20 五 12:18]State "CANCEL"     from "CANCEL"     [2015-11-20 五 12:18]State "CANCEL"     from "CANCEL"     [2015-11-20 五 12:18]State "CANCEL"     from "NEXT"       [2015-11-20 五 12:17]State "NEXT"       from "INBOX"      [2015-10-14 三 10:17]Time:[2015-10-13 二 08:45]attachment功能感觉不是很适用于当前自己的内容管理体系，故取消。设置当前标签的附件目录输入 C-c C-a s, 然后输入附件的目录,之后会增加一个 ATTACH_DIR 属性,指向你设置的目录路径.附件操作输入 C-c C-a, 然后有相应的子命令,进行操作,具体参见帮助.添加附件输入 a, 会视 org-attach-method 的值, 将相应的附件复制/拷贝/链接到 ATTACH_DIR 对应目录中,并追加一项 Attachments 属性.14.61 NEXT 如何在orgmode中打开链接的时候不会自动新开窗口而是使用已有窗口？State "NEXT"       from "WAIT/FORWARD" [2015-11-09 一 10:26]State "WAIT/FORWARD" from "LATER"      [2015-11-05 四 11:12]  等待整理至合适的位置。State "LATER"      from "INBOX"      [2015-10-21 三 15:10]Time:[2015-10-19 一 11:11]配置帮助等新开弹出窗口为上下方式分割后，这个问题消失了，跟踪链接会自动使用当前窗口而非新开了。配置如下：;; perfer split 'pop' window vertically(whole-&gt;up+lower).(setq split-height-threshold 0)(setq split-width-threshold nil)后来有出现了，跟踪链接的时候都会新开一个窗口。14.62 LATER orgmode 如何修改时间戳？直接编辑？State "LATER"      from "INBOX"      [2015-12-03 四 15:35]Capture Time:[2015-10-23 五 11:36]14.63 MAYBE/FUTURE agenda如何不扫描有些状态，如done、cancel、maybe/futureState "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:35]Capture Time:[2015-10-23 五 09:15]14.64 MAYBE/FUTURE orgmode的块是否可以嵌套？比如quote块内是否可以quote？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:35]Capture Time:[2015-10-23 五 09:48]14.65 LATER orgmode如何在导出子树的时候自动以标题命名？State "LATER"      from "INBOX"      [2015-10-12 一 10:01]Time:[2015-10-12 一 09:50]14.66 LATER orgmode如何指定导出的路径和文件名称？State "LATER"      from "INBOX"      [2015-10-12 一 10:02]Time:[2015-10-12 一 09:54]14.67 LATER orgmode光标如何定位到下一个链接？State "LATER"      from "INBOX"      [2015-10-12 一 10:02]Time:[2015-10-12 一 09:58]14.68 LATER orgmode如何实现任务自动触发定时切换以及refileState "LATER"      from "NEXT"       [2015-10-12 一 10:07]State "NEXT"       from "INBOX"      [2015-10-12 一 10:07]Time:[2015-10-12 一 10:03]14.69 WAIT/FORWARD 列表与换行State "WAIT/FORWARD" from "INBOX"      [2015-10-26 一 09:48]  等待移动至合适的位置[2015-10-19 一 07:52]想到一个方法解决列表内多段落的问题。换行 :: 杜绝硬换行的习惯硬换行用“\\”，但是输入不便且有些情况不支持（如MobileOrg），所以想要换行，就新起一段落，那么新行前多一个空行。这是一个新行，也是新段落。一个段落，实际就是一行。逻辑关系有标点表示。列表内换行 :: 用描述列表有时为美观，列表第一换行若用一空行则显得与列表项标题相距有点远，并且第一行内容一般也很少，一般都是总体描述性文字。所以，建议第一行是简短描述时用描述列表，第一行在描述的“::”后，之后的段落也用空行。若直接第一行就很长不是描述，那么不用描述列表，并且宁可与列表项标题多空一行，也不用断行符。14.70 WAIT/FORWARD orgmode建议State "WAIT/FORWARD" from "INBOX"      [2015-10-26 一 09:49]  等待移动至合适的位置[2015-10-20 二 07:44]建议标题以2级开始（题目视作一级）14.71 LATER Orgmode中checkbox和header也可以结合使用State "LATER"      from "INBOX"      [2015-10-27 二 14:26]Capture Time:[2015-10-26 一 11:01]例子如下：TODO list [0%]+ [ ] Read previous resource manage files.+ [ ] Read current header file.+ [ ] Read current document.+ [ ] Design work.14.72 LATER 确认一下orgmode中的引用块相关细节，例如begin example和begin quote之间的区别State "LATER"      from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-10-26 一 11:02]14.73 CANCEL 考虑orgmode中，是否应该每一个状态添加!，将处理信息和状态信息集成。State "CANCEL"     from "NEXT"       [2015-11-30 一 18:03]  当前没有必要State "NEXT"       from "INBOX"      [2015-10-27 二 14:27]Capture Time:[2015-10-26 一 14:09]14.74 LATER orgmode 如何递归折叠光标所在节点？State "LATER"      from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-10-28 三 13:54]14.75 WAIT/FORWARD emacs markdown 导出State "WAIT/FORWARD" from "INBOX"      [2015-10-30 五 10:27]  等待转移至合适位置Capture Time:[2015-10-30 五 10:25]可以参考一下这个网址：http://stackoverflow.com/questions/22988092/emacs-org-mode-export-markdown使用官方提供的 C-c C-e 后没有导出markdown的m选项。I have some weird behavior, I don't actually know if it's a bug or something else. When I do C-c C-e the option to convert to markdown doesn't appear. Nonetheless I can type the option M-x org-md-export-as-markdown and after I do that, the option export to markdown appears in the C-c C-e menu.Any Ideas?解决方案是If you are using Org-mode version 8.0 or later (check with M-x org-version), the export framework is broken up into several libraries that are not necessarily loaded by default.Something like this in your Emacs configuration can load the Markdown exporter automatically with Org-mode:(eval-after-load "org"  '(require 'ox-md nil t))shareimprove this answer14.76 DONE orgmode与jekyll的结合State "DONE"       from "WAIT/FORWARD" [2015-12-18 五 14:12]State "WAIT/FORWARD" from "NEXT"       [2015-11-04 三 15:27]  待转移至合适位置State "NEXT"       from "INBOX"      [2015-11-03 二 15:30]State "INBOX"      from              [2015-11-03 二 15:28]大致思路是：建立一个与jekyll目录结构类似的orgmode路径，org文件存于其中，发布导出路径是jekyll。具体参见：orgmode与jekyll的结合14.77 LATER orgmode如何输入成块的原样文字而不解释、缩进之类的？State "LATER"      from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-10-30 五 11:17]14.78 LATER 为什么orgmode定义好的refile如果是单个文件，那么这个文件内容会自动变化？State "LATER"      from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-11-05 四 10:27]14.79 LATER Jekyll与orgmode结合的问题State "LATER"      from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-11-16 一 09:18]添加postamble包含文件的“绝对”相对路径如何实现？使用orgmode结合jekyll的策略和功能的分开。策略在jekyll的readme里，功能在orgmode文档中。14.80 NEXT 如何为orgmode导出添加作者信息？State "NEXT"       from "INBOX"      [2015-11-16 一 10:31]Capture Time:[2015-11-11 三 16:54]14.81 LATER emacs如何导出的时候不缓存上次修改差异而直接强制导出？State "LATER"      from "INBOX"      [2015-11-16 一 10:31]Capture Time:[2015-11-13 五 11:16]14.82 DONE 是否应该为取消的项目在切换到取消之前添加备注，类似wait/forward，指明为什么取消？State "DONE"       from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-11-16 一 10:35]14.83 MAYBE/FUTURE orgmode多文件文档State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-11-18 三 10:33]各个分片文档组成整体文档14.84 LATER orgmode中导出时的include关键字所基于的路径能否配置？State "LATER"      from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-11-18 三 17:37]14.85 LATER 如何在orgmode中时间戳中选择特定的时间插入？需要知道相关的指令和按键，而非手动修改。State "LATER"      from "INBOX"      [2015-12-03 四 15:37]Capture Time:[2015-11-23 一 10:41]14.86 NEXT orgmode导出utf8问题State "NEXT"       from "LATER"      [2015-12-03 四 15:37]State "LATER"      from "INBOX"      [2015-12-03 四 15:37]Capture Time:[2015-11-23 一 14:09]14.87 CANCEL orgmode sub task and summary.State "CANCEL"     from "INBOX"      [2015-11-24 二 11:54]  no need , it is described in TODO operation.Capture Time:[2015-11-24 二 11:06]14.88 DONE 切换和设置优先级State "DONE"       from "WAIT/FORWARD" [2015-11-27 五 11:44]State "WAIT/FORWARD" from "LATER"      [2015-11-27 五 11:39]State "LATER"      from "NEXT"       [2015-11-27 五 11:39]State "NEXT"       from "INBOX"      [2015-11-27 五 11:39]State "INBOX"      from              [2015-11-27 五 11:39]参考: TODO项目 相关配置和操作。大致如下：配置;;set priority(setq org-highest-priority ?A)(setq org-lowest-priority ?D)(setq org-default-priority ?A)(setq org-priority-faces '(                           (?A . org-warning)                           (?B . (:background "DodgerBlue" :foreground "black" :weight bold))                            (?C . (:foreground "SkyBlue" :weight bold))                           (?D . (:foreground "DodgerBlue" :weight bold))                            ))操作切换优先级输入 S-UP/S-DOWN14.89 WAIT/FORWARD archiveState "WAIT/FORWARD" from "INBOX"      [2015-11-27 五 14:36]  wait for move.State "INBOX"      from              [2015-11-27 五 11:57]14.89.1 配置具体内容可以参见： C-h v org-archive-default-command, C-h v org-archive-location, C-h v org-archive-save-context-info14.89.1.1 配置归档位置将内容根据“年-月-日-包含文件名的标题-被归档的标题”的层次，归档在指定路径的文档中，如下(setq org-archive-location (concat org-directory "gtd/_archive/201511_archive.org::datetree/* Archive from %s"));;(setq org-archive-location (concat org-directory "gtd/_archive/session" (format-time-string "%Y%m") "_archive.org::datetree/* Archive from %s"))14.89.1.2 配置归档包含的信息归档之后，被归档节点属性包含：时间、文件、标签、todo状态、分类、节点在归档前的路径等信息：(setq org-archive-save-context-info '(time file ltags itags todo category olpath))14.89.2 操作采用默认的方式归档输入 C-c C-x C-a 这会默认将当前标题归档为同名，但是后缀为 .org_archieve 的归档文件(无论状态是不是done)。这个命令具体会怎么执行，会根据 org-archive-default=command 的设置而定， 默认值为： org-archive-subtree(no term)归档命令C-c C-x C-s 或者 C-c $执行 org-archive-subtree ， 将所选内容归档至指定文件指定标题，具体可通过 org-archive-location 指定。C-u C-c C-x C-s类似前面，但是归档之前会检测被归档的标题子标题是否有open的todo项目，如果没有就移动，否则提示。如果光标不再标题，则对所有顶级标题开始依次遍历并检测归档。C-u C-u C-c C-x C-s类似前面，但是检测之时，检测的是过期的时间戳，而非todo项目。以上命令中，第一个经常用到，后面两个不怎么用，如果保存被归档内容的更多信息，需要配置 org-archive-save-context-info , 归档之后，标题中的链接和引用仍然有效。14.89.3 举例如上配置之后，例如*Title1**DONE sub title1 CLOSED: [2015-11-27 五 14:17]- State "DONE"       from              [2015-11-27 五 14:17]***subsub title1****DONE subsubsub title1CLOSED: [2015-11-27 五 14:18]- State "DONE"       from              [2015-11-27 五 14:18]****subsubsub title2****subsubsub title3***subsub title2**sub title2注意以上格式中，标题前面应该和'*' 之间有一个空格。执行 C-c C-x C-a 之后，会在相应路径生成一个201510_archive.org文件，追加了如下内容：*2015**2015-11 十一月***2015-11-27 星期五****Archive from orgmodetest.org*****DONE subsubsub title1CLOSED: [2015-11-27 五 14:18]:PROPERTIES::ARCHIVE_TIME: 2015-11-27 五 14:23:ARCHIVE_FILE: ~/test/emacs/orgmodetest.org:ARCHIVE_TODO: DONE:ARCHIVE_CATEGORY: orgmodetest:ARCHIVE_OLPATH: Title1/sub title1/subsub title1:END:- State "DONE"       from              [2015-11-27 五 14:18]14.90 NEXT orgmode中为何example块中的标题还遵从orgmode的格式？State "NEXT"       from "INBOX"      [2015-12-03 四 15:37]Capture Time:[2015-11-27 五 15:05]14.91 NEXT orgmode导出为utf8报告错误State "NEXT"       from "INBOX"      [2015-12-04 五 15:37]Capture Time:[2015-12-04 五 10:31]错误信息如下org-export-numbered-headline-p: Wrong type argument: number-or-marker-p, nil目前看来是在一个标题下添加了对其他内容的引用（通过id）之后出现这个问题，例如:** DONE wk1548CLOSED: [2015-12-04 五 10:09]:PROPERTIES::ID:       b287eddd-9629-49d9-9949-6042f71b8047:END:- State "DONE"       from "NEXT"       [2015-12-04 五 10:09]参考:[[id:3f6910c4-e8ea-4cf7-8dad-c13ab7127074][周报回顾]]14.92 LATER orgmode在引用块中缩进的标题问题State "LATER"      from "INBOX"      [2015-12-04 五 15:37]Capture Time:[2015-12-04 五 10:36]参见：http://comments.gmane.org/gmane.emacs.orgmode/10325814.93 MAYBE/FUTURE orgmode导出markdown有太多的引用标记，如何尽可能原样展示而非很多的'style'类似的东西？State "MAYBE/FUTURE" from "LATER"      [2015-12-04 五 15:37]State "LATER"      from "INBOX"      [2015-12-04 五 15:37]Capture Time:[2015-12-04 五 10:40]14.94 LATER orgmode 番茄钟、时间记录State "LATER"      from "INBOX"      [2015-12-10 四 10:36]Capture Time:[2015-12-07 一 09:53]14.95 MAYBE/FUTURE orgmode为什么refile 目标会跟踪软链接到其他目录中？State "MAYBE/FUTURE" from "INBOX"      [2015-12-11 五 17:39]Capture Time:[2015-12-10 四 11:27]14.96 LATER 属性State "LATER"      from              [2015-12-16 三 08:56]14.96.1 操作在当前所在标题插入属性输入 C-c C-x p, 输入之后,按照提示输入属性名和属性值. * 测试属性 :PROPERTIES::test:     name:what:     no:END:移除一个属性在相应的属性区域输入 C-c C-c d, 输入之后,按照提示输入待删除的属性名.14.97 WAIT/FORWARD ormode项目管理State "WAIT/FORWARD" from "INBOX"      [2015-12-10 四 11:25]  等待整理至合适位置Capture Time:[2015-12-10 四 10:33]子项目的管理：如果子项目中有未完成的项目，理论上说，这些子项中的最高优先级别状态，就是父项目的状态。项目优先级为：NEXT&gt;LATER&gt;WAIT&gt;INBOX&gt;DONE=CANCEL14.98 DONE orgmode考虑是否应该将状态文件以'_' 做为前缀，便于angenda中一目了然不和其他文件混淆？State "DONE"       from "INBOX"      [2015-12-18 五 13:37]Capture Time:[2015-12-15 二 10:57]已经将状态文件冠以 _ 前缀，便于在Agenda View中集中浏览。14.99 NEXT orgmode应用聚合有哪些场景？ [2/7]State "NEXT"       from "LATER"      [2015-12-18 五 14:03]State "LATER"      from "INBOX"      [2015-12-18 五 13:39]Capture Time:[2015-12-16 三 11:25][X] 与MobileOrg的结合参见 orgmode与mobile org整合[&#xa0;] (no term)基本语法[&#xa0;] (no term)如何安装?[&#xa0;] (no term)如何管理文档?[X] 如何与jekyll结合参见 orgmode与jekyll的结合[&#xa0;] 如何管理gtd?参见[&#xa0;] (no term)学习之路？基本语法-&gt;capture+refile-&gt;export+publish 开始就写文档，并且记录 FAQ等等.14.100 LATER orgmode记时功能可以提高集中力State "LATER"      from "INBOX"      [2015-12-18 五 13:38]Capture Time:[2015-12-17 四 09:51]14.101 NEXT Orgmode如何官方发问？State "NEXT"       from "INBOX"      [2015-12-21 一 15:57]Capture Time:[2015-12-18 五 16:55]14.101.1 订阅邮件列表首先订阅相关邮件列表，定位参见：Emacs-orgmode &#x2013; General discussions about Org-mode.14.101.2 参考http://www.catb.org/esr/faqs/smart-questions.htmlMailing list and IRC channel14.102 MAYBE/FUTURE Ascii artState "MAYBE/FUTURE" from "INBOX"      [2016-01-05 二 15:38]Capture Time:[2015-12-31 四 14:20]14.103 MAYBE/FUTURE artist mode in emacsState "MAYBE/FUTURE" from "INBOX"      [2016-01-05 二 15:38]Capture Time:[2015-12-31 四 14:31]http://www.emacswiki.org/emacs/ArtistMode14.104 MAYBE/FUTURE Emacs中的plantuml配置如何与ascii art格式图形结合？State "MAYBE/FUTURE" from "INBOX"      [2016-01-05 二 15:38]Capture Time:[2015-12-31 四 16:35]14.105 LATER orgmode画图State "LATER"      from "INBOX"      [2016-01-05 二 15:38]Capture Time:[2015-12-30 三 13:42]14.106 LATER pdflatex for orgmodeState "LATER"      from "INBOX"      [2016-01-05 二 15:38]Capture Time:[2015-12-31 四 11:56]sudo apt-get install latex-beamer14.107 NEXT mobileorg的加密功能，可以防止隐私的泄漏；orgmode的加密功能既能管理工作又能防止工作隐私泄漏。State "NEXT"       from "INBOX"      [2016-01-05 二 15:38]Capture Time:[2015-12-30 三 10:00]14.108 WAIT/FORWARD orgmode中图片链接导出之时如何不是文字链接而直接图片？State "WAIT/FORWARD" from "INBOX"      [2016-01-11 一 16:46]  有待整理Capture Time:[2016-01-11 一 16:43]根据文档，当图片链接有描述文字之时，会在html导出之时显示该图片的描述性文字链接。如果想要直接显示图片可以：添加链接的时候，不给出链接描述文字；当图片链接的描述为图片的路径之时（可以为另外一个图片做为其缩略图），导出的时候显示的便不是图片的链接文字，而直接是图片。如下：[[/home/miracle/mydata/orgmode/data/image/2010-04-02-editor_study_line.jpg]][[/home/miracle/mydata/orgmode/data/image/2010-04-02-editor_study_line.jpg][/home/miracle/mydata/orgmode/data/image/2010-04-02-editor_study_line.jpg]]问题：实践发现，应该是没有描述的比较实用，描述为图片的有时候似乎不好用？14.109 LATER orgmode表格导出之后，文本或者html没有竖线只有横线State "LATER"      from "INBOX"      [2016-01-13 三 16:36]Capture Time:[2016-01-11 一 16:22]14.110 NEXT orgmode导出文章pdf问题State "NEXT"       from "INBOX"      [2016-01-13 三 16:37]Capture Time:[2016-01-11 一 11:20]14.111 LATER orgmode中搜索相关命令的整理State "LATER"      from "INBOX"      [2016-01-13 三 16:39]Capture Time:[2016-01-11 一 10:38]15 参考资料：http://www.fuzihao.org/blog/2015/02/19/org-mode%E6%95%99%E7%A8%8B/http://orgmode.org/worg/doc.htmlhttp://orgmode.org/manual/比较不错的参考资料：http://www.cnblogs.com/bamanzi/archive/2010/04/04/emacs-indent.htmlhttp://orgmode.org/worg/org-faq.html#outline-container-shortcuts-for-entering-source-blocks      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2015-09-11 五 14:08]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-09-11]<a href="/categories/study/emacs/emacs_orgmode_tips.html"> Emacs Orgmode学习笔记  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = '测试自动分类'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '将文章放到当前/xxx1/xxx2/_posts/下会自动指定其分类为[xxx1,xxx2]categories/others';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-09-09]<a href="/categories/others/test_categories.html"> 测试自动分类  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Emacs学习笔记'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 文件操作2. 文件管理2.1. 目录显示2.2. 文件操作2.3. 标记操作2.3.1. 删除标记2.3.2. 普通标记2.3.3. 正则表达式标记2.3.4. 结合标记能使用的操作：2.3.5. 其它3. 编辑3.1. 插入3.2. 撤销与重复3.3. 标记3.4. 删除、移除、复制、粘帖3.5. 杂乱编辑4. 窗口操作5. 跳转操作5.1. 搜索5.2. 基本跳转5.3. 书签6. Buffer操作7. 基本配置8. 编程相关9. 帮助10. 原理10.1. 关于递归编辑10.2. 关于mark/region/active region/transient-mark-mode/Text Selection10.3. 关于自动临时保存和备份10.3.1. 临时文件10.3.2. 自动备份10.3.3. 其他10.4. Emacs撤销、重做和重复10.4.1. 插件10.4.2. 标准操作10.4.3. 比较详细的解释10.4.4. 官方文档10.4.5. 总结10.5. 关于Narrow11. 其他11.1. 意外操作12. WAIT/FORWARD FAQ [27/114]([23%])12.1. NEXT 前进后退？12.1.1. 插件12.1.2. 链接的后退12.1.3. 查找的后退12.1.4. 输入 C-u C-@12.2. DONE TAB标签栏?12.2.1. 下载地址12.2.2. 关键配置12.3. DONE 如何删除一行12.4. MAYBE/FUTURE 如何移动一行？12.5. DONE 如何删除至行首？12.6. DONE 如何save all?12.7. DONE 只读切换?12.8. DONE 如何删除备份文件，或者不使用自动备份？12.9. DONE 跳转到当前buffer工作目录？12.10. WAIT/FORWARD Emacs当前工作目录？12.11. LATER 如何重做？12.12. LATER 如何成块缩进?12.13. LATER 如何创建空文件12.14. NEXT 如何跳转至上次编辑内容？12.15. DONE 如何save all？12.16. DONE emacs如何加载插件？12.17. LATER TAB标签显示？12.18. LATER 跳至上次编辑的位置？12.19. WAIT/FORWARD 插件在哪配置12.20. DONE kill buffer?12.21. DONE 直接执行lisp函数？12.22. LATER 如何实现自动缩进？12.23. WAIT/FORWARD 如何插入确定的缩进TAB？12.24. NEXT 如何输入上次输入的内容或者重做？12.25. DONE 交换行12.26. WAIT/FORWARD 动态加载配置立即生效？12.27. DONE 如何执行命令时在回显区快速输入和删除？12.28. DONE 如何查看某一配置变量的值？12.29. MAYBE/FUTURE 如何恢复默认配置？12.30. WAIT/FORWARD 如何文件刷新？12.31. DONE 如何显示匹配括号？12.32. NEXT 关于Tab缩进12.32.1. &#x2014;&#x2014;Time:[2015-09-30 三 15:19]------12.33. LATER 如何显示空白字符？12.34. LATER 如何复制一行？12.35. LATER 缩进提示线？12.36. DONE 重命名当前文件？12.37. MAYBE/FUTURE 如何表示当前文件名？12.38. WAIT/FORWARD 宏录制12.39. WAIT/FORWARD 如何块缩进？12.40. WAIT/FORWARD C-/是Undo12.41. DONE 如何操作目录12.42. CANCEL 如何管理配置目录12.43. LATER 如何定位光标下路径的文件？12.44. LATER 如何按项目组织目录12.45. WAIT/FORWARD 如何让Emacs在光标到达当前Buffer最后一行尾部不自动recenter?12.46. LATER 考虑一下用el-get插件管理插件12.47. MAYBE/FUTURE eshell如何操作？12.48. WAIT/FORWARD 如何配置自动新开“弹出”窗口的分割方向？12.49. LATER Emacs如何控制Pop分割窗口的大小？12.50. WAIT/FORWARD emacs如何进行会话保存？12.51. DONE Emacs背景配色设置？12.51.1. 下载地址：12.51.2. 配置默认主题12.52. WAIT/FORWARD emacs的光标滚动如何让其不在屏幕尾部自动滚屏到中间？12.53. WAIT/FORWARD 如何控制鼠标滚轮滚动的行数12.54. LATER emacs如何清除所有buffer?12.55. LATER 配置调试12.56. NEXT 不喜欢emacs新开"提示窗口"是垂直方向12.57. DONE Emacs如何定制颜色？12.58. LATER 如何设置撤销的次数？目前貌似撤销只有有限的几次12.59. LATER 重复最近的命令12.60. WAIT/FORWARD elisp library12.60.1. 关于 load-file, load, require, autoload12.60.2. 关于 Library, Package, Feature12.61. WAIT/FORWARD Emacs自定义配置12.62. LATER 默认启动xemacs的窗口大小12.63. NEXT emacs-desktop的会话存储默认位置12.64. NEXT 如何高亮？12.65. NEXT Emacs如何进行特定模式下的按键绑定映射？12.66. LATER 如何为当前的Emacs编辑器升级？12.67. DONE Emacs撤销、重做和重复12.68. NEXT Emacs 如何远程访问？12.69. LATER 将emacs custom config变成手动的config12.70. WAIT/FORWARD 恢复文件12.71. LATER 无需远端安装emacs，用本地emacs直接访问远端，可否？12.72. MAYBE/FUTURE Emacs 任务管理？12.73. LATER 崩溃后下次启动自动提示回复文件的方式？12.74. LATER Emacs如何粘帖复制文本到X剪切板中？12.75. LATER Emacs中如何在require后卸载插件？12.76. LATER 拼音输入法12.77. NEXT Emacs为什么有时候缩进无法删除？12.78. NEXT Emacs如何搜索光标下的内容12.79. LATER Emacs如何格式化全部代码？12.80. NEXT 为什么Emacs有时候无法删除缩进？12.81. DONE Emacs如何反撤销重做？12.82. WAIT/FORWARD emacs剪切板和x剪切板共享12.83. DONE 完善自己的开发环境，代码跳转、扫描、定位等，不用每次都要手动配置12.84. LATER Emacs 括号跳转12.85. DONE 关于Narrow12.86. LATER emacs如何搜索光标所在字符的内容12.87. LATER C-x =12.88. MAYBE/FUTURE 定义自己的Emacs环境12.89. MAYBE/FUTURE 将emacs插件分层整理一下，最好能尝试一下新版本的emacs12.90. NEXT Emacs如何撤销以及反撤销？12.91. WAIT/FORWARD &#x2014;&#x2014; [2015-12-02 三 15:06]  Emacs标签跳转------12.92. LATER &#x2014;&#x2014; [2015-12-02 三 16:58]  Emacs mark ring------12.93. MAYBE/FUTURE 意外发现 ESC-` 在minibuf打开菜单栏12.94. NEXT 学习资源12.95. LATER Emacs如何自定义按键映射不冲突12.96. NEXT Emacs高级搜索12.97. WAIT/FORWARD Emacs如何显示括号匹配？如何显示行号？12.98. LATER 设置输入法12.99. DONE 使用Emacs阅读代码12.100. LATER emacs自动保存间隔12.101. NEXT emacs如何替换文本?12.102. LATER Emacs如何设置多重功能的按键?12.103. NEXT Emacs如何切换最近buffer,而非只有一个最近buffer?12.104. WAIT/FORWARD Emacs如何高亮多个单词?12.104.1. 利用emacs自带的 hi-lock-mode12.104.2. 利用插件12.105. DONE 如何在Emacs直接预览markdown效果？12.106. MAYBE/FUTURE 如何执行脚本12.107. NEXT Emacs崩溃后的恢复策略12.108. NEXT emacs如何跳转到匹配的括号？12.109. NEXT 一些基本操作12.110. NEXT emacs如何返回上次编辑的位置12.111. NEXT Emacs如何定期自动保存文件?12.112. DONE emacs打开文件等，如何实现部分匹配文件或者命令而非精确开头匹配12.112.1. ido12.112.2. smex12.113. LATER 意外发现的 M-* 和 M-. 是做什么的？12.114. NEXT Emacs代码折叠这里是学习Emacs过程记录的笔记，可供日后查阅以及参考。简单的emacs操作提示，不做过多解释。心中的疑问放在后面。M可以是&lt;ALT&gt;或者&lt;ESC&gt;。&lt;Delback&gt;=&lt;Backspace&gt;=1 文件操作启动emacs输入如下内容：$emacs  $emacs -nw另外，启动之后，在键盘上键入 q 跳过系统欢迎的信息.打开目录 输入 C-x d 之后可输入具体路径，如果直接回车则默认打开当前buffer文件所在目录。新建目录输入 M-x make-directory 然后输入路径，回车。新建文件输入 C-x C-f 然后输入路径，写文件(这样不创建新文件)。载入一个文件输入 C-x C-f 之后输入路径，回车。其实打开的是对应文件的一个buffer，每个文件对应一个buffer，buffer名一般就是文件名去掉后缀。查看当前buffer所在的路径M-x pwd重新载入当前buffer对应文件输入 C-x C-v 保存文件输入 C-x C-s 输入之后，再输入路径，回车。全部保存输入 C-x s 输入之后，会依次询问每个文件的是否保存，输入 y 表示保存相应文件； n 表示不保存； ! 保存所有; . 保存当前buffer并退出询问; q 直接退出询问；更多的信息可以用 C-h 来查阅。关闭文件输入 C-x k 输入之后，会进入一个交互命令，输入想要关闭的buffer名字，即可关闭对应的文件再回车，如果什么都不输入直接回车，则默认退出当前buffer关闭对应的文件。退出编辑器输入 C-x C-c2 文件管理Emacs自带一个文件管理器，为dired模式。进入目录浏览输入 C-x d输入之后，可键入要进入的目录，如果不选择直接 Ret 那么会直接进入当前buffer所在目录。进入目录后，可以输入 h 查看帮助信息，查看回显区简洁帮助输入 ? 进入dired模式之后，可以通过下面命令管理文件，此时Emacs可以做为一个文件管理器来使用。2.1 目录显示上一层目录输入 ^上下移动光标选择不同文件项输入 n / p上下移动至下一个目录子项输入 &lt; / &gt;上下移动至被标记项输入 M-{ / M-}退出目录缓冲输入 q刷新目录缓冲输入 g切换名称日期排序输入 =s=使用View模式查看文件输入 v ， 会以只读方式显示文件内容另一个窗口查看文件输入 o查看文件类型输入 y跳转文件输入 j ,输入之后，会提示选择将要打开的文件路径复制文件名输入 w2.2 文件操作对应位置创建目录输入 +删除对应文件对应行输入 D , 会提示是否删除拷贝对应文件对应行输入 C ， 会提示目标路径创建硬链接对应行输入 H ， 会提示目标路径创建软链接绝对路径对应行输入 S ，相对路径对应行输入 Y ， 会提示目标路径重命名文件对应行输入 R , 会提示重命名的名称修改文件权限对应行输入 M , 会提示修改成什么权限，比如 777修改属组对应行输入 G修改属主对应行输入 O压缩解压缩对应行输入 z执行文件对应行输入 X新建文件输入 C-x C-f2.3 标记操作2.3.1 删除标记标记删除对应行输入 d将所有备份文件标记为删除输入 ~将存盘文件标记为删除输入 #对标记删除的文件执行删除对应行输入 x2.3.2 普通标记普通标记对应行输入 m普通标记所有可执行文件输入 **普通标记所有目录项输入 */普通标记所有符号链接输入 *@2.3.3 正则表达式标记正则表达式标记匹配名称的文件输入 % m , 输入之后，会提示输入满足正则表达式待标记文件名称正则表达式标记匹配内容的文件输入 % g , 输入之后，会提示输入待标记文件包含的满足正则表达式的内容正则表达式标记依次拷贝文件输入 % C , 输入之后提示输入被拷贝文件满足的正则表达式例如:\(.+\).cpp之后再输入目标例如在前面匹配的基础上输入： =\1.h2.3.4 结合标记能使用的操作：以下操作可以结合上述描述的普通标记和某些正则来使用，达到批量处理的目的。删除文件DcopyC重命名或移动R改变用户O改变群组G改变权限M符号链接S硬链接H压缩Z复制文件名w 删除行，刷新后可恢复k2.3.5 其它取消标记删除对应行输入 u取消所有标记输入 U将文件列表读写切换输入 C-x C-q读写切换之后，底部会提示为 [(Editable Dired)] ，可以修改对应文件名等。更多命令参见 h 给出的帮助信息。参考：Emacs文件管理3 编辑3.1 插入插入其他文件输入 C-x i3.2 撤销与重复这里列出最基本的，具体可以参考：Emacs撤销、重做和重复撤销输入 C-x u 或输入 C-/重复操作输入 C-u &lt;数字&gt; &lt;操作&gt; 或输入 C-&lt;数字&gt; &lt;操作&gt; 这两种方法，通过 C-u &lt;数字&gt; 或 C-&lt;数字&gt; 指定好重复次数之后，输入你想进行的操作，就可以重复相应的次数了。3.3 标记标记整个buffer输入 C-x h标记块标记块开始定位到待移除的首部，输入 C-@ (或 C-&lt;SPC&gt; ，如果不冲突)，标记完成。此时底部有指示是标记状态。移除相应块移动光标，这时候光标经过的地方会高亮，也就是被标记。3.4 删除、移除、复制、粘帖注意：这里的移除类似剪切可再次粘帖回来 、删除的内容不可粘帖回来。移除当前行输入 C-S-DEL, 这里的 DEL 就是 Backspace 。移除至行尾，可粘帖回来输入 C-k, 再次 C-k 会将换行符号移除。删除至行首，可粘帖回来输入 C-0 C-k 或输入 M-- C-k 或 C-u 0 C-k删除光标前面字符输入 &lt;Backspace&gt;, 删除之后，不可通过 C-y 来“粘帖”回来。删除光标后面字符输入 C-d 删除之后，不可通过 C-y 来“粘帖”回来。移除光标前至面第一个单词首输入 M-&lt;Backspace&gt; 会移除光标前面的内容至单词首部（单词和数字字符，没有标点和其他字符，如"&lt;"，"&gt;"）。移除光标后至第一个单词尾输入 M-d会移除光标后面的内容至单词尾部（单词和数字字符，没有标点和其他字符，如"&lt;"，"&gt;"）。删除到指定字符输入 M-z &lt;char&gt;输入 M-z 之后再输入字符 &lt;char&gt; ，会删除光标到 &lt;char&gt; 之间的内容。块移除标记块后，输入 C-w 。块复制标记块后，输入 M-w 。粘帖最近一次移除或复制的内容输入 C-y, 输入之后，可以粘帖最近一次被移除的内容。粘帖最近某次移除的内容输入 M-y不断的 M-y 会不断的变换遍历之前移除的内容（不是复制），直至选择到待粘帖的内容便可结束。3.5 杂乱编辑交换当前行与上一行的位置输入 C-x C-t输入之后，会将当前行与前一行交换，并且将当前光标移动到两行的后面。4 窗口操作关掉当前窗口输入 C-x 0关掉其他窗口输入 C-x 1水平创建窗口输入 C-x 2垂直创建窗口输入 C-x 3切换窗口输入 C-x o, 在各个窗口之间循环切换。5 跳转操作5.1 搜索正向搜索C-s连续正向搜索C-s C-s ...逆向搜索C-r5.2 基本跳转向前翻页C-v向后翻页M-v跳至指定行输入 M-g g &lt;line number&gt;, 再输入待跳转的行号。跳至缓冲区文件首输入 M-&lt;跳至缓冲区文件尾输入 M-&gt;跳转到同一层次下一个括号结束位置输入 C-M-n跳转到同一层次上一个括号开始位置输入 C-M-p5.3 书签创建"书签"输入 C-x r &lt;SPC&gt;, 然后随便按一个键，做为书签名比如'a'跳转到"书签"输入 C-x r j, 输入刚才创建的书签"a"，就会跳到你刚在的书签所在的那个光标处。6 Buffer操作查看所有buffer列表输入 C-x C-b切换至指定buffer输入 C-x b 输入之后，进入一个交互模式，输入指定buffer名称即可。如果直接回车，会在上次buffer与本次buffer之间切换。关闭buffer输入 C-x k 会提示想要关闭的buffer，默认关闭当前buffer。关闭3天内未使用的buffer输入 M-x clean-buffer-list依次询问式关闭指定（是否保存）的buffer输入 M-x kill-some-buffers7 基本配置这里给出Emacs基本使用时可能需要配置的一些内容，不涉及复杂插件的相关内容。这里配置文件大致做如下布局：~/.emacs是emacs配置文件的入口，一般保存整体配置信息，~/.emacs.d存放插件等具体配置子脚本。8 编程相关9 帮助查看帮助信息的帮助输入 = C-h C-h =, 这样可以显示如何查询其他帮助信息。查看某个按键序列帮助输入 C-h k xxx输入 C-h k 后会有一个交互，让你输入按键序列，输入 xxx 之后，会显示相应的按键绑定以及帮助信息。自定义绑定一个按键之前通过这条命令，可以确认是否被绑定的按键会发生冲突，亦可通过这个命令，在已有的基础上，添加自己扩展的绑定功能。查看某个elisp函数的作用输入 C-h f使用自定制的功能，带来的问题至少有：通用性降低，依赖性增强，与其他功能冲突可能性增加。所以之前使用vim，基本不会用太多的插件以及按键映射，大多数操作使用其默认的配置。但是对于一个通过自定制扩展而闻名的emacs来说，我觉得这一点可以有所改变。通用性降低这方面，我们可以通过将相关配置进行合理组织，然后通过版本控制或者其他方式备份，便于在其他机器上使用；依赖性增强，一方面通过对配置和插件备份可以解决，一方面经常总结文档，以及对相关内容的熟练程度也会让这个问题不了了之；与其他功能的冲突，我们可以通过帮助查看已有按键绑定以及被占用的功能，使用未被使用的做为扩展，由此避免冲突。使用原生功能，以及使用自定制功能，是两种不同的理念。前者通用、简单，后者可扩展、高效，还有其他不同，但是各有所长，关键在于根据实际情况，使用最适合的方式来解决问题，方式因人而异，没有绝对的，我个人的倾向是：在vim倾向前者，在emacs倾向后者，但是emacs使用之时，尽量保持原有的功能而不改变成其它的，如果实在不行，可以扩展原有功能。查看按键绑定输入 C-h b根据正则表达式模糊查找输入 C-h a xxx, 这样会列出所有匹配 xxx 的帮助信息。查看某前缀按键集合的帮助输入 C-c C-h, 会查看C-c为前缀的按键绑定帮助，查看某命令前缀的按键绑定帮助输入 &lt;命令前缀&gt; C-h, 例如 C-c C-x C-h 会查看 C-c C-x 为前缀的按键绑定帮助。查看info输入 M-x info, 或者输入 C-h i输入之后，会显示info手册，和linux的一样，不过在emacs中阅读更方便。查看当前模式信息C-h m退出帮助信息输入 qEmacs FAQ输入 C-h C-f10 原理10.1 关于递归编辑所谓的“递归编辑”是指递归编辑状态，由位于状态栏的方括号所指示，其中包含了用小括号来指明的模式名称。比如说，你有时可能会看到[(Fundamental)]，而不是 (Fundamental)。（比如在用 M-% 进行交互式替换的时候你又用了 C-s 进行搜索，这时替换模式并没有结束，但你又进入了搜索模式，这就是所谓的递归编辑。）10.2 关于mark/region/active region/transient-mark-mode/Text Selection内容主要参考 Emacs: What's Region, Active Region, transient-mark-mode? 大致如下：mark一个用户可以设置的位置，用来进行文本选择。通过调用 set-mark-command （即 C-@ ）设置mark，在list代码中你可以调用 push-mark或者set-mark设置标记。region最后一次mark的位置知道当前光标所在位置，这一段的区域。用户一旦在buffer中设置了mark，region就存在了。可以通过函数 region-beginning , region-end 来获取region的位置。active region当变量 mark-active 为true的时候，region就是active状态。transient-mark-modetransient-mark-mode也是emacs的一种minor mode，当emacs的 transient-mark-mode 为on的时候，active region将被高亮， 当变量 transient-mark-mode 为true的时候，该模式就是on的状态，默认该模式是on的状态。因为默认为on，并且Buffer中始终有一个region，所以前面对active region需要用 mark-active 进行控制，防止文本中的region始终高亮。什么时候region被active?当 set-mark-command 被调用的时候，region就会变成active(高亮状态)，当执行了一个命令后，一般region的状态就会被设置成inactive。总之，你用鼠标或者键盘设置mark之后，被选择的文本就会被高亮，你执行一些操作之后，文本高亮就被取消。什么是Text Selection？Text Selection就是被选择的文本，一般与active region同义。Text Selection就是非空的active region，可以通过 use-region-p 检测Text Selection， 这个函数其实检测的是三个内容：a. trasient-mark-mode 是否为on；b. mark-active 是否为true；c.通过 =use-empty-active-region来检测region非空。10.3 关于自动临时保存和备份10.3.1 临时文件一般是在Emacs中编辑时,在编辑文件的同一个目录内生成一个以#file-name#这样的文件，这个文件会在我们保存文件之后被emacs删除。这个文件的作用是为了防止在进行编辑的时候异常退出造成的损失。临时文件存在大致过程如下：1. 在Emacs内使用[C-x,C-f]打开要编辑的文件(test-file.txt)2. 在打开的buffer中编辑内容3. Emacs自动侦测buffer是否更改，如果更改会自动Auto-Save4. 此时我们能够在编辑的文件同一目录下看到临时文件为:    #test-file.txt#5. 使用[C-x,C-s]保存当前buffer6. 当前buffer中的内容被写入文件,#test-file.txt#消失——被Emacs自动删除崩溃时恢复的方式1. 打开要恢复的文件，如：test.txt2. [M-x]3. 输入:recover-file 回车4. 确认恢复关闭自动保存临时文件功能，在你启动的.emacs文件内添加下面这行(setq auto-save-default nil) ;; default is t, close with nil10.3.2 自动备份第一次保存的时候，如果保存的文件已经存在，Emacs会自动将保存前的文件重命名作为备份文件，而备份文件使用的是一个“～”作为后缀(如：file-name~)。备份文件默认仅会发生在Emacs第一次写入的时候，即，开启Emacs之后，第一次打开文件并保存的时候，编辑期间多次保存并不能产生多次备份动作。然而，下次重新打开Emacs，再次执行同样的动作的时候，同样在第一次保存时，Emacs是会将上次的备份文件覆盖的（如果有）。大概的流程如下：1. 打开文件,如:MitchellChu.txt2. 编辑...（这涉及到临时文件的问题，忽略）3. 在emacs内发出保存指令4. emacs先将MitchellChu.txt保存为：MitchellChu.txt~5. 保存完成后，Emacs将当前buffer的内容写入MitchellChu.txt注意：此时的MitchellChu.txt已经不再是原来的那个文件，但所有连接到原来那个文件的，现在被这个新文件接管。取消该功能设置如下(setq make-backup-files nil)更多设置，比如拷贝、路径、多个备份版本等，可参考：backup-by-copying version-control backup-directory-alist 等。10.3.3 其他参考：http://blog.useasp.net/archive/2014/07/18/emacs-temporary-files-and-backup-files-for-edited-file.aspxhttp://blog.csdn.net/flytomysky/article/details/709656110.4 Emacs撤销、重做和重复简单说来，撤销是取消上次的操作，重做是对撤销的撤销，重复是对上次命令进行重做。下面重点对撤销和重做进行叙述。“Emacs中只有撤销，没有重做” 或许是初学者的迷惑，也或许让Emacs蒙受了"很烂的编辑器，怪不得很多人不愿意用"的评价。其实，真正的答案很简单： 撤销是取消上次的操作，重做是对撤销的撤销 对这简单的两句话若能真正理解，你或许便能知晓真正的答案。当知晓真正的答案之时，你或许会感觉到，Emacs如峰回路转般，让你不得不收回对它以前的无知评论，重新对它产生新的认识。不光是这个小小的功能，其实在整个Emacs的前进过程中，如果能坚持下去，你会遇到很多类似的境况，也许，这也是为什么Emacs的学习曲线不同于其它，是“螺旋”的吧。这里给出众多Emacs学修中的一员，在经历众多Emacs道路中的困难之一，对其现象做一个简单的重现，希望能让没有使用过Emacs的朋友，能体会到一点使用它的感觉。10.4.1 插件通过undo-tree插件选择需要恢复的操作C-x u 进入 undo-tree-visualizer-mode , p n 上下移动，在分支之前 b f 左右切换，t 显示时间戳，选定需要的状态后， q 退出。这是主要的操作，其它的自己摸索好了……参考：http://www.dr-qubit.org/undo-tree/undo-tree.el 和 emacs 新手必看: undo-tree10.4.2 标准操作对撤销的撤销便是重做（或者向前撤销）第一，执行 C-x u 向后撤销第二，执行 C-g 然后 C-x u 就是向前撤销了。参考：Emacs中的撤销10.4.3 比较详细的解释10.4.3.1 Emacs中所有命令均可undo所有命令均可undo, 包括undo本身，所有命令emacs都一视同仁，所以：undo+undo=redoemacs 把相同类型的操作，合并为一个事件。比如说往缓冲区里打字，也就是 self-insert-command，如果每次 undo ，只是撤消掉一个字符，那就太僵硬了，所以 self-insert-command 的操作，每20次合并为一个事件，一次 undo ，撤消掉20个字符。而 undo 的猥琐之处在于，只要连续的 undo ，无论多少个，都是一个事件……当然，这也是必需的，不然你 undo 了20次之后，又突然开始 redo ……而恰巧这时又是夜深人静的话……10.4.3.2 Emacs中撤销操作序列的表示方式undo 之后想要 redo ，就要进行一个其它类型的操作，随便输入一个字符或者移动一下光标都可以，不过标准答案是 C-g 。s1--s2--s3--s4              )    s3  u3--u4   / | (  |   \ s5--s6--s7--s8--s9  |    \                  )  |     u5--u6--u7--u8--u9   \     s10----sn假设 u3 表示 undo s3 。从 s9 开始 undo，顺着 emacs 的“undo蛇”往回走，到了 u3 的时候，就是 undo undo s3，也就是 s3 了，而这一串 undo，也成了“undo贪吃蛇”的一部分。虽然 emacs 保留了全部的操作状态，但是从 s10 返回 s1 却要将近20步，而普通的编辑器只要两步。这个必需得动手实验后才能有一个直观的印象，按以下步骤操作: (g C-g) (u undo)1g2g3g4guu5g6g7g8g9guuuuuu10(可以把end-of-line绑到空格代替C-g)10.4.3.3 引入插件undo-tree来"改变"Emacs中的undo模式：其实这种“undo蛇”完全可以表示成 undo tree。s10 到 s1 ，两步;再到 s4，四步(有一步是切换分支)……          s10----sn         /s1--s2--s3--s4         \          s5--s6--s7--s8--s9不知道 emacs 为什么没有使用这种方式，可能是因为选择分支之类的操作很难描述吧。好了，不提这么伤感的事，现在有一个扩展叫作 undo-tree ，基本解决了这个问题。 undo-tree 安装使用都很简单:;放到load-path中，配置文件中添加(require 'undo-tree)(global-undo-tree-mode)由于篇幅所限，就不截图了C-x u 进入 undo-tree-visualizer-mode , p n 上下移动，在分支之前 b f 左右切换，t 显示时间戳，选定需要的状态后， q 退出。这是主要的操作，其它的自己摸索好了……参考：emacs 新手必看: undo-tree10.4.4 官方文档查阅Emacs C-h i 信息中有关Undo的内容，如下：Any command other than an undo command breaks the sequence of undo commands. Starting from that moment, the entire sequence of undo commands that you have just performed are themselves placed into the undo record, as a single set of changes. Therefore, to re-apply changes you have undone, type C-f or any other command that harmlessly breaks the sequence of undoing; then type C-/ to undo the undo command.亦可参考：http://www.cnblogs.com/wendellyi/archive/2013/08/29/3290366.html10.4.5 总结其实redo就是对undo的undo，undo会将本身当作被redo的对象，但是连续的undo之间不会被打断，（当然其中的每次undo仍然会视为一个change)，通过 C-g 打断连续的Undo操作，再 C-/ 就实现了对上次的undo 进行 undo，其实感觉上，Emacs将一切操作线性化，即简化了设计，又符合人的思维次序，而通过undo-tree却将这个undo变成了树状结果，便于理解，但是实践上未必更实用。目前暂时不用相关的插件。10.5 关于NarrowNarrowing的意思是将焦点集中到buffer的指定区域上, 有助于集中精力到特定的段落上，而将无关信息屏蔽掉。Narrow后，你能看到的内容就是被Narrow的部分，但是并非删除了其他的内容，而是将相应的内容隐藏了。Narrow后，其他内容好像不存在了一样，正常的跳转/搜索操作也被限制在Narrow范围内。Narrow后，能够看见的区域被称作可访问区域，当取消narrow的时候，其他不可见的区域也变回可见了。主要命令：将Narrow范围设定在光标与Mark范围之间输入 C-x n n ，其实一般也就是被选区域。取消Narrow输入 C-x n w将Narrow范围设定为当前页输入 C-x n p将Narrow范围设定为当前函数输入 C-x n d具体可以参考 C-x n C-h 或 http://www.gnu.org/software/emacs/manual/html_node/emacs/Narrowing.html11 其他切换模式输入 M-x &lt;mode name&gt; 这里&lt;mode name&gt;是模式名称，自己输入，可以&lt;Tab&gt;补全。只读切换输入 C-x C-q输入之后，当前buffer会在只读以及可读写之间切换。终止现在正在执行的命令输入 C-g这个命令只能终止本层编辑正在执行的指令，当你处于 recursive edit level 的时候，你就不能够利用 C-g 来取消命令了，那么你需要利用 &lt;Esc&gt;&lt;Esc&gt;&lt;Esc&gt; （或者更多次）来取消。交互执行lisp命令并插入结果输入如下命令序列:M-x lisp-interaction-mode&lt;lisp expressions&gt;C-j切换 lisp-interaction-mode 模式之后，输入lisp表达式， C-j 计算并插入结果。千万注意 C-j 的光标位置。交互执行lisp命令不插入结果输入如下命令序列：M-x lisp-interaction-mode&lt;lisp expressions&gt;C-x C-e切换 lisp-interaction-mode 模式之后，输入lisp表达式， C-x C-e 计算并将结果显示在底部mini buffer中。千万注意 C-x C-e 的光标位置。查看所有安装的包输入 M-x list-packages插入原样字符输入 C-q &lt;待输入字符&gt;输入之后将会插入相应字符（包括控制字符），而不是执行字符对应的按键绑定命令。进入elisp交互解释界面输入 eilm11.1 意外操作这里列出平时意外操作发现的一些功能，可能会整理至合适位置。快速文本块选择输入 C-S-n/p/a/e 或者可以表达为 C-N/P/A/E 好像可以进行块选择，按其它的按键会导致退出“选择模式”。新开一行输入 C-o, 默认输入这个命令可以可以在当前位置上面新开一行。当前位置内容帮助在光标单词处输入 C-h xxx 直接回车默认会解释光标下的帮助内容。选择标记整个buffer输入 C-x h将选择的数据块按照上行缩进（上一行缩进几个空格，则此处也缩进几个空格，而不是tab?）选择后输入 =C-M-\=，如果上行没有缩进则自动缩进一个tabstop。其实选择块之后，直接Tab也会缩进。12 WAIT/FORWARD FAQ [27/114]([23%])State "WAIT/FORWARD" from              [2015-11-27 五 15:07]  wait for all done12.1 NEXT 前进后退？State "NEXT"       from "WAIT/FORWARD" [2015-12-17 四 15:30]State "WAIT/FORWARD" from "LATER"      [2015-12-03 四 13:52]  前进后退的插件已经基本阅读完毕，使用自定义markring不会影响已有的系统markring；可行，其他前进后退的更多文档可能需要借助系统的mark以及使用的经验。State "LATER"      from "NEXT"       [2015-11-02 一 11:41]12.1.1 插件使用recent-jump插件。12.1.1.1 配置举例;; set recent-jump(setq recent-jump-threshold 4)(setq recent-jump-ring-length 10)(global-set-key (kbd "C-o") 'recent-jump-jump-backward)(global-set-key (kbd "M-o") 'recent-jump-jump-forward)(require 'recent-jump)12.1.1.2 常用操作前进C-o后退M-o12.1.1.3 其他对该插件可以自行修改其源代码，以定制什么情况下针对什么命令、多大举例进行跳转。具体参见插件的源码和文档。;;; Commentary:;; ;; sometimes, we start a big jump, e.g. go to the beginning of buffer, search,;; page down etc, it is handy that you can go back to where you start. For;; example, when we writing program source code, we ofter search for some;; reference and go back to where you start and continue writing. But how can we;; define "Big Jump". I can not find a proper hook for the big jump, so at last;; I choose the pre-command-hook. Now what my defination for "Big Jump" is :;; ;; 1. you issued some special command, it can be defined by;; recent-jump-hook-commands ;;;; 2. you jumped really much. that is you move more than `recent-jump-threshold';; lines.参考: http://blog.waterlin.org/articles/%E5%9C%A8emacs%E4%B8%AD%E5%BF%AB%E9%80%9F%E5%9C%B0%E8%B7%B3%E8%BD%AC%EF%BC%9Arecent-jumpel.html12.1.2 链接的后退跳转一次链接后，会记录上次链接。使用 C-c &amp; 可以后退。具体需要仔细确认。12.1.3 查找的后退查找一个字符串，回车后，会记录开始查找时的位置。使用 C-u C-@ 可以退回查找前的位置。12.1.4 输入 C-u C-@12.2 DONE TAB标签栏?State "DONE"       from "MAYBE/FUTURE" [2016-03-03 四 11:02]State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:38]使用 tabbar 插件。具体参考相关文档。12.2.1 下载地址wget https://www.emacswiki.org/emacs/download/tabbar.el12.2.2 关键配置;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;tabbar;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(require 'tabbar)(tabbar-mode t)12.3 DONE 如何删除一行State "DONE"       from "NEXT"       [2015-11-02 一 11:43]删除一行输入 C-S &lt;BS&gt;12.4 MAYBE/FUTURE 如何移动一行？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:39]State "INBOX"      from              [2015-11-02 一 11:43]12.5 DONE 如何删除至行首？State "DONE"       from "NEXT"       [2015-11-02 一 11:53]输入 C-0 C-kn或输入 M-- C-k或 C-u 0 C-k12.6 DONE 如何save all?State "DONE"       from "WAIT/FORWARD" [2016-02-10 三 11:08]State "WAIT/FORWARD" from "NEXT"       [2015-10-10 六 16:46]  待整理至合适的位置。输入 C-x s参考: 文件操作12.7 DONE 只读切换?State "DONE"       from "WAIT/FORWARD" [2016-02-10 三 11:11]State "WAIT/FORWARD" from "DONE"       [2015-10-10 六 16:45]  需要转移到合适的位置。State "DONE"       from "NEXT"       [2015-10-10 六 16:45]输入 C-x C-q参见 其他12.8 DONE 如何删除备份文件，或者不使用自动备份？State "DONE"       from "NEXT"       [2015-11-02 一 11:55]具体参考：关于自动临时保存和备份;;disable auto backup file("xxx~") when save(default t).(setq make-backup-files nil);; all backups goto ~/.backups instead in the current directory;;(setq backup-directory-alist (quote (("." . "~/.backups"))));;disable recovery file("#xxx#") when modify(default t);;(setq auto-save-default nil)12.9 DONE 跳转到当前buffer工作目录？State "DONE"       from "WAIT/FORWARD" [2016-02-10 三 11:14]State "WAIT/FORWARD" from "NEXT"       [2015-10-12 一 09:23]  待整理到合适位置State "NEXT"       from "INBOX"      [2015-10-12 一 08:50]输入 C-x d参考： 文件管理另外，不知道在哪里看到的文章上讲 C-x C-j 可以用 dired mode 打开正在编辑的文件的所在目录，但是我的版本的 Emacs 居然没有这个快键，而且这个键没有绑定任何命令。 于是加了一段代码实现这个功能。;; C-x C-j open the directory of current buffer(global-set-key (kbd "C-x C-j")(lambda ()(interactive)(if (buffer-file-name)(dired default-directory))))12.10 WAIT/FORWARD Emacs当前工作目录？State "WAIT/FORWARD" from "NEXT"       [2015-10-20 二 17:02]  等待整理到合适的位置。参考： 文件管理当前buffer的目录， 输入 C-x d 。 设置默认工作目录可以如下：(setq default-directory "/home/quieheart")但是=default-directory= 是buffer-local,参考：http://zhidao.baidu.com/link?url=ZDHfOcxIDLzxiCRDi2yEWusjiqu9NRag0IFU7J3KGYFMiibAGC_MVL5Tm-aFWaekODyF0uhXf0aDLVtyalqk74eKy6H_CoJWfNp1_mWD3Ci&gt;&gt; windows下的emacs怎么改按c-x c-f出现的路径。C-x C-f 使用的目录是 default-directory 的值。default-directory 是 buffer-local variable, 用 setq 写在 .emacs 里面没什么用。在没有与文件关联的buffer中default-directory 的值是启动emacs时的当前目录。所以你可以修改启动emacs时的当前目录(PWD)。修改启动emacs的当前目录，有多种方法：修改emacs快捷方式属性的起始位置为你希望的文件夹，路径有空格的要加双引号。写一个bat/cmd脚本来启动emacs，该脚本内容：先CD到目标路径，然后执行emacs如果当前buffer已经打开了文件，default-directory 会变成文件的所在路径。这个行为是不建议更改的。如果希望任何时候 C-x C-f 都是默认到某个目录，建议自己写一个函数来代替默认C-x C-f 绑定的函数。例如：(defun my-find-file ()  (interactive)  (let ((default-directory "mnt"))    (call-interactively #'find-file)))(global-set-key (kbd "C-x C-f") 'my-find-file)查看当前buffer所在的路径：M-x pwd12.11 LATER 如何重做？State "LATER"      from "INBOX"      [2015-12-03 四 15:39]12.12 LATER 如何成块缩进?State "LATER"      from "INBOX"      [2015-12-03 四 15:40]12.13 LATER 如何创建空文件State "LATER"      from "INBOX"      [2015-12-03 四 15:40]12.14 NEXT 如何跳转至上次编辑内容？12.15 DONE 如何save all？State "DONE"       from "INBOX"      [2015-12-03 四 15:40]输入 C-x s , 根据弹出的提示选择待保存的buffer, !表示保存剩余的全部。12.16 DONE emacs如何加载插件？State "DONE"       from "WAIT/FORWARD" [2016-03-03 四 11:19]State "WAIT/FORWARD" from "INBOX"      [2015-12-03 四 15:41]  填写配置文件，待整理下载插件，插件都是elisp脚本，一般自动加载都是修改配置文件，比如 recent-jump.el 将加载语句写入配置文件：;;plugins(load "recent-jump.el")或者(require 'recent-jump) ;; back/forward或者如果直接在当前会话中加载插件，可以到 *scratch* buffer中或者其他地方将加载语句写下来，然后则直接执行加载语句（在相应的语句结尾输入 C-x C-e ）具体可参考：elisp library12.17 LATER TAB标签显示？State "LATER"      from "INBOX"      [2015-12-03 四 15:41]12.18 LATER 跳至上次编辑的位置？State "LATER"      from "INBOX"      [2015-12-03 四 15:41]12.19 WAIT/FORWARD 插件在哪配置State "WAIT/FORWARD" from "INBOX"      [2015-12-03 四 15:41]  有emacs plugin相关文章，待整理可能需要整理到原理中。~/.emacs是emacs配置文件的入口，一般保存整体配置信息，~/.emacs.d存放插件等具体配置子脚本。12.20 DONE kill buffer?State "DONE"       from "INBOX"      [2015-12-03 四 15:42]输入 C-x k, 默认是当前buffer.12.21 DONE 直接执行lisp函数？State "DONE"       from "NEXT"       [2015-11-02 一 12:18]State "NEXT"       from "INBOX"      [2015-11-02 一 12:17]已有elisp函数： M-x &lt;functionname&gt;自定义函数，在函数体结尾后执行 C-x C-e12.22 LATER 如何实现自动缩进？State "LATER"      from "INBOX"      [2015-12-03 四 15:43]12.23 WAIT/FORWARD 如何插入确定的缩进TAB？State "WAIT/FORWARD" from "NEXT"       [2015-10-19 一 16:41]  如果有确定的答案，就直接给出一个简单的提示操作，或者关闭问题。参考：关于Tab缩进12.24 NEXT 如何输入上次输入的内容或者重做？C-x z12.25 DONE 交换行State "DONE"       from "WAIT/FORWARD" [2016-03-03 四 11:26]参考：编辑输入： C-x C-t12.26 WAIT/FORWARD 动态加载配置立即生效？不重启 Emacs 让 .emacs 配置文件生效有四个函数可以做到：eval-last-sexp,eval-region,eval-buffer 和load-fileM-x eval-last-sexp 使.emacs中光标前的那一条语句立刻生效。M-x eval-region 使.emacs中选中的region中的语句立刻生效。M-x eval-buffer 使当前的buffer中的设置语句立刻生效。M-x load-file ~/.emacs 载入.emacs文件，从而使其中的设置生效。用 emacs 打开 .emacs 文件，C-x C-e 光标前面的运行一条语句。立即生效。注意，有时候，需要重新载入当前buffer才能看见效果，有时候只对当前buffer起效果（可以查看相关配置的帮助说明）。12.27 DONE 如何执行命令时在回显区快速输入和删除？State "DONE"       from "INBOX"      [2015-12-03 四 16:00]回显区和正常buffer一样对待，它就是minibuffer.更多参考：http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer.html#Minibuffer12.28 DONE 如何查看某一配置变量的值？State "DONE"       from "INBOX"      [2015-12-03 四 16:01]查看该变量的帮助信息即可。输入 C-h v ,然后输入变量名称，默认为当前光标所在变量。12.29 MAYBE/FUTURE 如何恢复默认配置？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 16:02]12.30 WAIT/FORWARD 如何文件刷新？用于重新载入配置和文件变化。http://blog.csdn.net/horstlinux/article/details/7857123http://www.emacswiki.org/emacs/RevertBuffer有四个可以revertbuffer的方法：    M-x revert-buffer RET yes RET    C-x C-v RET    (global-set-key [(control c) r] 'revert-buffer)    C-x RET r RET RET除了手动设置revert-buffer，我们还可以自动设置，加入如下配置：(global-auto-revert-mode 1)另外注意，C-x C-v 是打开一个文件，取代当前缓冲区，缓冲区名字也改变了，就算再次重新打开相应的缓冲区文件，其之前对应的Agenda View也不可用了。12.31 DONE 如何显示匹配括号？State "DONE"       from "INBOX"      [2015-12-03 四 16:03]输入如下配置：;;paren(show-paren-mode 1)12.32 NEXT 关于Tab缩进State "NEXT"       from "INBOX"      [2015-10-10 六 16:47]State "INBOX"      from              [2015-10-10 六 16:47]12.32.1 &#x2014;&#x2014;Time:[2015-09-30 三 15:19]------12.32.1.1 文档中的描述文档上关于indent的一些变量和函数，翻译过来大致意思如下：C-h f indent-for-tab-command依赖于 tab-always-indent 的设置，会为当前主模式的行或者区域进行合适的缩进，或者插入 TAB 。在大多数主模式中，如果光标在行缩进区域，它会在缩进后移动到第一个非空的字符上，否则光标会呆在当前文本的同样的位置。如果给定了一个前缀参数，也会严格缩进以当前行首开始的整个balanced expression，来反映当前行缩进的变化。如果 transient-mark-mode 被打开，并且当前region是active的，会将当前的区域缩进（这个时候，任何前缀参数都会被忽略）。实际上被调用来缩进行的函数取决与 indent-line-function 变量的设置。C-h v indent-line-function这个变量是buffer local的变量，表示用来缩进当前行的函数；这个函数被调用的时候没有任何参数，如果函数在一个auto-indentation无法发生的地方被调用了（比如一个字符串的中间），这个函数将只会返回 noindent ；我们可以设置这个函数来们组自己的需求，使得 TAB 能够合适的被缩进，如果并非必须，最好不要重新绑定 TAB 按键。关于这个变量的值，比如我当前打开一个 emacs_tips.org 文件，然后查看这个变量，可以看到如下：Local in buffer emacs_tips.org; global value is indent-relative说明，在文件 emacs_tips.org 中它的值为 org-indent-line （这是orgmode的设置），其它位置默认为 indent-relative 。C-h v tab-always-indent如果为 t ，则键入 TAB 会缩进当前行；如果为 nil ，并且光标在左边的空白区或者行缩进区，则键入 TAB 会缩进当前行；如果为 nil ，并且光标没有在空白或缩进区，则键入 TAB 会直接插入 TAB 字符；如果为 complete=，则键入 =TAB 首先会缩进当前行，如果当前行已经缩进了，就尝试补全光标所在单词。有些编程语言有他们自己的变量控制这个行为，例如 c-tab-always-indent ，这时候不会考虑这个变量。C-h v indent-tabs-mode这个是在C语言代码中定义的变量，设置成任何内容都会编程buffer-local的变量，这个变量做为文件局部变量保存，是安全的。如果 non-nil ，将会插入 TAB .12.32.1.2 参考：关于emacs 缩进有一篇不错的文章参考：http://www.cnblogs.com/bamanzi/archive/2010/04/04/emacs-indent.html主要包括了：默认的Tab行为、需要的行为、以及配置的方式摘抄一些部分不插入tab字符，不插入tab字符每次缩进4个空格(setq default-tab-width 4)缩进完全自行控制，不用syntax indentation来自动 （按语法格式化完全可以使用C-_）?按TAB键时如果选择多行，则缩进(行首插入多个空格)如果未选择多行，当前光标在行首（不管是indentation区还是第一个字符上)，则缩进光标不在行首，插入多个空格(如果要将代码补齐考虑进来，则:如果光标在一个单词的末尾，则TAB键需要激活补全函数,如果单词后有一个空格，再按TAB键则添加空格)按Shift-TAB键时如果选择多行，则反缩进(行首删除多个空格)如果未选择多行，光标在行首，反缩进光标不在行首，发向移动光标或者什么也不做从最后两条来看，原来的indent-for-tab-command不能满足需求，需要将TAB键绑定到别的函数才行。在网上搜了半天，找到这篇文章提供的方法正是我所要的：emacs, indent/unindent region as a block using the tab keyhttp://ignaciopp.wordpress.com/2009/06/17/emacs-indentunindent-region-as-a-block-using-tab-key/上面链接中的实现也考虑了，如果要对接其它的代码补齐，只需要将(hippie-expand nil)换成其它的即可，比如auto-complete的ac-start缩进可能涉及到的配置可查阅参考：http://crushon.blog.163.com/blog/static/21440415520121117105642762/一些变量：(setq indent-tabs-mode nil)(setq default-tab-width 4)(setq tab-width 4)(setq tab-stop-list '(4 8 12 16 20 24 28 32 36 40      44 48 52 56 60 64 68 72 76 80 84 88 92 96))    总结根据上面资料，默认的情况：选择块之后Tab会缩进相应的选择块如果没有选择块tab-always-indent为t时会依据当前语法体系缩进，而不管光标是在行首还是其它；tab-always-indent为nil时根据光标三种情况：行首空白区(即在indentation区内)，则取消所有缩进;行首第一个非空白字符上， 则按第一次则语法缩进，第二次则插入tab字符或者空格(插入TAB还是空格则依赖于indent-tabs-mode设置);不在行首,插入tab字符或者空格另外，实践发现，默认情况下还有如下行为：Tab对应的空格长度，需要设置：tab-width如果Tab缩进长度达到Tab长度，是否自动将达到Tab长度的部分转换为Tab字符，需要设置：indent-tabs-mode多次tab时，光标依次缩进（前进）的长度，需要设置：tab-stop-list每次tab会缩进上行缩进的长度（无论是否为Tab的整数倍）需求：每个人需求各不相同，大致需求如下：orgmode下，采用其默认行为即可，缩进方面可以？12.33 LATER 如何显示空白字符？State "LATER"      from "INBOX"      [2015-12-03 四 16:05]12.34 LATER 如何复制一行？State "LATER"      from "INBOX"      [2015-12-03 四 16:07]12.35 LATER 缩进提示线？State "LATER"      from "INBOX"      [2015-12-03 四 16:07]12.36 DONE 重命名当前文件？State "DONE"       from "WAIT/FORWARD" [2016-03-03 四 11:30]State "WAIT/FORWARD" from "INBOX"      [2015-12-03 四 16:07]  参考dired相关命令输入 M-x rename-file或参考 文件管理12.37 MAYBE/FUTURE 如何表示当前文件名？State "MAYBE/FUTURE" from              [2016-03-03 四 11:29]12.38 WAIT/FORWARD 宏录制开始录制宏，用 C-x ( 结束录制宏，用 C-x )使用宏，用 C-x e 来使用宏。可以利用C-u来重复使用100次这个宏，即命令C-u 100 C-x e。 C-x e e e &#x2026;将宏重复。命名宏输入: M-x name-last-kbd-macro输入之后，提示输入名称，输入名称后即可完成宏命名。使用已命名的宏输入: M-x yourmacroname输入之后，便执行之前保存的"yourmacroname"对应的宏了，输入时候，输入的宏名支持Tab补全。保存宏实现输入： M-x insert-kbd-macro输入之后，提示输入宏名，输入宏名称后（这里支持Tab补全），就会将宏的实现以文本的形式插入到你的当前文本中。例如：(fset 'ins_4spc_nextline   "\C-n\C-a    ")这个宏实现是之前录制的，命名为"ins_4spc_nextline"的宏，如果将这个实现插入到你的emacs配置文件中，那么就可以通过 M-x yourmacroname 的方式来进行调用了。n重命名宏？12.39 WAIT/FORWARD 如何块缩进？State "WAIT/FORWARD" from "NEXT"       [2015-10-19 一 16:42]  如果有确定的答案就简单给出操作提示，或者直接关闭问题。参考：关于Tab缩进12.40 WAIT/FORWARD C-/是UndoState "WAIT/FORWARD" from "INBOX"      [2015-10-16 五 16:58]  wait for move12.41 DONE 如何操作目录State "DONE"       from "INBOX"      [2015-11-30 一 13:57]参考：文件管理12.42 CANCEL 如何管理配置目录State "CANCEL"     from "DONE"       [2015-12-03 四 16:10]  因人而异，可能会在将来整理相关文档。这里暂时不做深入回答。State "DONE"       from "INBOX"      [2015-12-03 四 16:09]12.43 LATER 如何定位光标下路径的文件？State "LATER"      from "INBOX"      [2015-12-03 四 16:11]12.44 LATER 如何按项目组织目录State "LATER"      from "INBOX"      [2015-12-03 四 16:11]12.45 WAIT/FORWARD 如何让Emacs在光标到达当前Buffer最后一行尾部不自动recenter?State "WAIT/FORWARD" from "NEXT"       [2016-03-03 四 11:04]  wait for arranged.State "NEXT"       from "LATER"      [2015-12-03 四 16:11]State "LATER"      from "INBOX"      [2015-12-03 四 16:11]需设置滚动参数，具体参考如下配置以及文档 和 emacs的光标滚动如何让其不在屏幕尾部自动滚屏到中间？;;auto scroll behavior, '0' is center point while outof screen, or don't center.;;(setq scroll-conservatively)(setq scroll-step 1);;(setq scroll-up-aggressively);;(setq scroll-down-aggressively);;wheel scroll step(setq mouse-wheel-scroll-amount '(1 ((shift) . 5) (control)))12.46 LATER 考虑一下用el-get插件管理插件State "LATER"      from "INBOX"      [2015-12-03 四 16:11]12.47 MAYBE/FUTURE eshell如何操作？State "MAYBE/FUTURE" from "LATER"      [2015-12-03 四 16:11]State "LATER"      from "INBOX"      [2015-12-03 四 16:11]Time:&lt;2015-10-02 五 09:53&gt;From:/media/sda6/study/mygitrepo/quietheart/misc/mylinux_home/home.user/_emacs.d/elisp/plugins.el12.48 WAIT/FORWARD 如何配置自动新开“弹出”窗口的分割方向？State "WAIT/FORWARD" from "LATER"      [2015-11-05 四 11:02]  等待整理至合适的位置。State "LATER"      from "INBOX"      [2015-11-05 四 10:49]State "INBOX"      from              [2015-10-09 五 15:10]查看 M-x info 获取到帮助信息。默认查看帮助信息的的时候，窗口会分割成左右两个，如果我们想要分割成上下，那么配置如下：;; perfer split 'pop' window vertically(whole-&gt;up+lower).(setq split-height-threshold 0)(setq split-width-threshold nil)这里我们需要注意的是， split vertically 意思是将窗口分割成上下两个部分； split horizontally 意思是将窗口分割成左右两个部分。具体查看 C-h f split-window-sensibly 。12.49 LATER Emacs如何控制Pop分割窗口的大小？State "LATER"      from "INBOX"      [2015-12-03 四 16:12]State "INBOX"      from              [2015-11-05 四 11:05]12.50 WAIT/FORWARD emacs如何进行会话保存？State "WAIT/FORWARD" from "LATER"      [2015-10-10 六 11:08]  等待整理到合适的位置。State "LATER"      from "INBOX"      [2015-10-10 六 11:05]Time:[2015-10-10 六 10:19]暂时参考：保存和恢复工作环境大致如下：可借助desktop.el来完成buffer等缓存文件、位置等加载的保存和恢复。自动恢复与保存相关的配置：(desktop-save-mode 1)手动保存会话：输入 M-x desktop-save输入之后，选择保存的目录。手动恢复以前的会话：输入 M-x desktop-change-dir输入之后，选择之前会话所在目录，之后即可加载。退回之前的会话：输入 M-x desktop-revert输入之后，可以退回之前加载的会话。如果保存变量之类的信息，需要额外的插件：session.el，插件可能有些问题暂不考虑。12.51 DONE Emacs背景配色设置？State "DONE"       from "INBOX"      [2015-12-03 四 16:14]Time:[2015-10-09 五 16:07]关于对emacs的颜色主题配置，有相关的插件：12.51.1 下载地址：http://ftp.twaren.net/Unix/NonGNU/color-theme/color-theme-6.6.0.tar.gz12.51.2 配置默认主题当把主题下载下来后 解压，然后将文件夹整个复制到到我们的load-path中然后添加如下配置：;;================================ ;;为我的emacs配置主题色彩 (color-theme-色彩名称) ;;================================ (require 'color-theme) (color-theme-initialize) (color-theme-calm-forest)12.52 WAIT/FORWARD emacs的光标滚动如何让其不在屏幕尾部自动滚屏到中间？State "WAIT/FORWARD" from "DONE"       [2016-01-18 一 16:44]  等待整理State "DONE"       from "NEXT"       [2016-01-16 六 17:18]State "NEXT"       from "INBOX"      [2015-12-03 四 16:14]Time:[2015-10-09 五 16:16]依照优先级别，依次可以设置如下三类变量，具体参见变量文档，这里设置 scroll-step, 默认0表示光标到达屏幕顶或者尾之后就立即自动滚动到屏幕中心，其它值表示滚动的行数。;;auto scroll behavior, '0' is center point while outof screen, or don't center.;;(setq scroll-conservatively)(setq scroll-step 1);;(setq scroll-up-aggressively);;(setq scroll-down-aggressively)12.53 WAIT/FORWARD 如何控制鼠标滚轮滚动的行数State "WAIT/FORWARD" from              [2016-01-18 一 16:44]  等待整理可以通过设置 mouse-wheel-scroll-amount 实现，具体可以通过 C-h v mouse-wheel-scroll-amount 查看其文档。大致含义是：该变量是一个列表，列表元素是 ("行数" . “控制按键”) 表示按下特定控制按键时滚轮滚动的行数；如果没有 “控制按键” 那么表示单纯滚轮滚动行数；如果没有指定行数，那么按下控制按键滚轮滚动将近一个屏幕。下面是一个例子：;;wheel scroll step(setq mouse-wheel-scroll-amount '(1 ((shift) . 5) (control)))12.54 LATER emacs如何清除所有buffer?State "LATER"      from "INBOX"      [2015-12-03 四 16:14]Time:[2015-10-10 六 10:21]12.55 LATER 配置调试State "LATER"      from "NEXT"       [2015-10-14 三 13:27]State "NEXT"       from "INBOX"      [2015-10-14 三 13:27]如果某项没有生效的话，可以尝试 =emacs &#x2013;init-debug- 启动，看看哪错了12.56 NEXT 不喜欢emacs新开"提示窗口"是垂直方向State "NEXT"       from "LATER"      [2015-12-03 四 16:14]State "LATER"      from "INBOX"      [2015-12-03 四 16:14]State "INBOX"      from              [2015-10-19 一 09:37]12.57 DONE Emacs如何定制颜色？State "DONE"       from "INBOX"      [2015-11-02 一 12:14]Time:[2015-10-12 一 11:12]可以使用特定插件，例如;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;color themes;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(require 'color-theme)(color-theme-initialize) (color-theme-calm-forest);;we can also select and preview with 'M-x color-theme-select'.12.58 LATER 如何设置撤销的次数？目前貌似撤销只有有限的几次State "LATER"      from "INBOX"      [2015-12-03 四 16:14]Time:[2015-10-14 三 14:53]12.59 LATER 重复最近的命令State "LATER"      from "INBOX"      [2015-12-03 四 16:14]输入 C-x z12.60 WAIT/FORWARD elisp libraryState "WAIT/FORWARD" from "NEXT"       [2015-11-30 一 17:45]  等待移动到合适的位置State "NEXT"       from "INBOX"      [2015-11-02 一 12:13]State "INBOX"      from              [2015-10-21 三 09:23]整理至原理部分。主要介绍：library, package, features的区别，以及 load-file, load, require, autoload 的区别。12.60.1 关于 load-file, load, require, autoloadload-file加载特定文件。加载特定的文件（".el", ".elc"文件扩展名不会自动加载，但是".gz"会被自动加载）。档不想让emacs猜测文件扩展名".el", ".elc" 或者没有扩展名的时候使用这个函数。load加载一个文件。通过搜索变量 load-path 加载一个文件，参数可以是一个文件名称（不用是全路径）， 比如 (load "undo") 。如果有".elc"编译版本的内容，这个命令将会自动加载之， 否则会自动加载".el", 或者".gz"的文件。当不需要知道文件的具体路径的时候不，使用这个函数加载。require如果一个package没有被加载的时候，加载一个package。检测 features变量， 如果没有相应的标号，那么调用 load 进行加载， 文件名是根据feature 名进行猜测的， 也可通过一个选项参数进行。最好在elisp库或者脚本中使用这个函数，这个和其他语言的 "require"或者"import"类似。autoload在函数被调用的时候加载文件。将一个函数名称和一个文件路径相关联，档这个功能被调用的时候，会加载这个文件，并且执行函数。如果你正在写一个major mode，尽可能将你的package安装使用autoload完成，因为这样可以节省启动的时间。12.60.2 关于 Library, Package, Feature12.60.2.1 Emacs lisp没有命名空间所有的东西都是全局的动态的作用域，它只有一些隐藏的机制，所以，不能将library或者module当作像perl、python、java类似的具有命名空间的语言的Package系统。12.60.2.2 Package和Library的区别是什么呢？其实，这些概念在elisp中没有专门的定义，我们只能大致这样来看待它们：Library包含许多组建的elisp文件，比如 comment-dwim 命令定义在 newcomment.el 中，它是一个包含众多函数的库。Package任何对emacs用户有用的elisp库，无论是在major还是在minor模式下。另外在emacs中，不使用 "module"这个概念。12.60.2.3 Package/Library/Feature不会被管理在package/library/feature/autoload的概念和文件名称之间没有绝对的对应关系。默认来说，如果一个elisp文件名称是xyz-mode.el，那么它会提供一个"xyz-mode"的lisp标号做为feature名称，然后用来执行这个mode的命令一般都是 xyz-mode 。 有时候， -mode 部分在任何 {file name, feature symbol name, command name} 中被忽略。这只是一个松散的规则，有许多不按照这个规则的例子，比如：文件 lisp-mode.el 会提供一个 lisp-mode 的标记做为feature，激活的命令可能是 emacs-lisp-mode 。文件 cua-base.el 提供一个 cua-base 的标记，feature名称为 cua, 并且激活的命令是 cua-mode 。文件 text-mode.el 没有提供任何标记做为feaure, 它通过命令 text-mode 被激活。文件 desktop.el 提供一个 desktop 标记做为feature， 并且激活的命令是 desktop-save-mode 。从以上即可看出，你可以有一个文件名称为 Joe-xyz-mode-v2.1.el, 它提供了名为 abc 的feature, 同时用来激活它的命令可能是 opq, 在 mode line中可能会被显示为 OPQ helper 。 这个文件可以被看作是一个package或者libaray。12.60.2.4 其它没有 "name space" "不被管理"的 module系统并不一定非常糟糕，这只是做为一个软件状态存在，许多流行的语言例如 C, C++, PHP 表现的更差，他们没有module系统，并且通过 include 来包含文件。我们需要注意的是，Scheme lisp也没有module系统，在2007年发布的R6RS添加了严格的module系统控制，但是这导致了Scheme社区的分裂。更多内容参考：http://ergoemacs.org/emacs/elisp_library_system.html12.61 WAIT/FORWARD Emacs自定义配置State "WAIT/FORWARD" from "INBOX"      [2015-10-21 三 15:08]  待整理到合适的位置Capture Time:[2015-10-21 三 14:22]在帮助菜单里配置，而非手动修改配置文件时产生的配置信息，会以类似如下的形式写到~/.emacs中：(custom-set-variables  ;; custom-set-variables was added by Custom.  ;; If you edit it by hand, you could mess it up, so be careful.  ;; Your init file should contain only one such instance.  ;; If there is more than one, they won't work right. '(ecb-options-version "2.40") '(ecb-primary-secondary-mouse-buttons (quote mouse-1--mouse-2)))12.62 LATER 默认启动xemacs的窗口大小State "LATER"      from "INBOX"      [2015-10-21 三 15:09]Capture Time:[2015-10-21 三 09:46]12.63 NEXT emacs-desktop的会话存储默认位置State "NEXT"       from "INBOX"      [2015-10-21 三 15:09]Capture Time:[2015-10-21 三 09:39]12.64 NEXT 如何高亮？参考：http://www.xuebuyuan.com/729481.html12.65 NEXT Emacs如何进行特定模式下的按键绑定映射？State "NEXT"       from "INBOX"      [2015-10-21 三 15:09]Capture Time:[2015-10-21 三 08:39]12.66 LATER 如何为当前的Emacs编辑器升级？State "LATER"      from "INBOX"      [2015-10-21 三 15:10]Capture Time:[2015-10-20 二 11:51]12.67 DONE Emacs撤销、重做和重复State "DONE"       from "WAIT/FORWARD" [2015-12-10 四 17:24]State "WAIT/FORWARD" from "NEXT"       [2015-12-10 四 16:45]  等待进一步整理State "NEXT"       from "INBOX"      [2015-12-03 四 16:14]Capture Time:[2015-10-23 五 11:03]撤销是取消上次的操作，重做是对撤销的撤销，重复是对上次命令进行重做。大致如下：撤销（undo）输入 C-x u 或 C-/重做（redo）输入 C-g C-x u  或 C-g C-/ 重复（repeat）输入 C-x z具体参考：Emacs撤销、重做和重复 和 编辑12.68 NEXT Emacs 如何远程访问？State "NEXT"       from "INBOX"      [2015-10-23 五 12:03]Capture Time:[2015-10-22 四 15:02]12.69 LATER 将emacs custom config变成手动的configState "LATER"      from "INBOX"      [2015-12-03 四 16:15]Capture Time:[2015-10-23 五 13:11]12.70 WAIT/FORWARD 恢复文件State "WAIT/FORWARD" from "NEXT"       [2015-10-23 五 15:22]  等待转移至合适的位置。State "NEXT"       from "INBOX"      [2015-10-23 五 15:21]State "INBOX"      from              [2015-10-23 五 15:21]回复上次崩溃之时没有来得及修改的文件。输入 M-x recover-file输入之后，可以补全，输入文件路径即可。如果文件已经保存，则不存在恢复文件，如果文件上次没有保存，就会有一个 .#filename# 之类的文件，通过它来恢复上次没有来得及保存的内容。12.71 LATER 无需远端安装emacs，用本地emacs直接访问远端，可否？State "LATER"      from "INBOX"      [2015-12-03 四 16:15]Capture Time:[2015-10-26 一 11:46]12.72 MAYBE/FUTURE Emacs 任务管理？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 16:15]Capture Time:[2015-10-27 二 10:14]12.73 LATER 崩溃后下次启动自动提示回复文件的方式？State "LATER"      from "INBOX"      [2015-12-03 四 16:15]Capture Time:[2015-10-27 二 14:19]12.74 LATER Emacs如何粘帖复制文本到X剪切板中？State "LATER"      from "INBOX"      [2015-12-03 四 16:15]Capture Time:[2015-10-28 三 11:02]12.75 LATER Emacs中如何在require后卸载插件？State "LATER"      from "INBOX"      [2015-12-03 四 16:15]State "INBOX"      from              [2015-11-04 三 09:36]12.76 LATER 拼音输入法State "LATER"      from "INBOX"      [2015-12-03 四 16:15]Capture Time:[2015-10-30 五 09:35]意外发现的情况： C-\ 会切换Emacs的输入法。12.77 NEXT Emacs为什么有时候缩进无法删除？State "NEXT"       from "INBOX"      [2015-12-03 四 16:17]Capture Time:[2015-11-02 一 09:50]12.78 NEXT Emacs如何搜索光标下的内容State "NEXT"       from "INBOX"      [2015-11-05 四 09:18]Capture Time:[2015-11-05 四 08:56]目前是先 M-b 到单词首，再 C-s C-w 搜索光标后至单词尾的内容。12.79 LATER Emacs如何格式化全部代码？State "LATER"      from "INBOX"      [2015-12-03 四 16:17]Capture Time:[2015-11-05 四 16:01]12.80 NEXT 为什么Emacs有时候无法删除缩进？State "NEXT"       from "INBOX"      [2015-12-03 四 16:17]Capture Time:[2015-11-09 一 11:06]ttbb12.81 DONE Emacs如何反撤销重做？State "DONE"       from "NEXT"       [2016-03-03 四 11:11]State "NEXT"       from "INBOX"      [2015-11-16 一 10:33]Capture Time:[2015-11-13 五 14:13]参考：Emacs撤销、重做和重复12.82 WAIT/FORWARD emacs剪切板和x剪切板共享State "WAIT/FORWARD" from "NEXT"       [2015-12-21 一 15:22]  有待进一步整理State "NEXT"       from "INBOX"      [2015-11-16 一 10:33]Capture Time:[2015-11-10 二 11:35];;clipboard share for gui emacs(setq x-select-enable-clipboard t)参考：http://www.th7.cn/system/lin/201410/72664.shtml12.83 DONE 完善自己的开发环境，代码跳转、扫描、定位等，不用每次都要手动配置State "DONE"       from "INBOX"      [2015-11-30 一 14:10]Capture Time:[2015-11-20 五 15:35]需要借助插件： cedet 和 ecb 。 cedet 主要用于建立索引已经提供跳转等功能, ecb 主要提供方便的窗口布局。当然，最好还是用 understand 或者 sourceinsight 之类的工具，简易点的也可用 geany 。12.84 LATER Emacs 括号跳转State "LATER"      from "INBOX"      [2015-11-30 一 14:10]Capture Time:[2015-11-23 一 14:38]`C-M-n‘Move forward over a parenthetical group (`forward-list‘).`C-M-p‘Move backward over a parenthetical group (`backward-list‘).`C-M-u‘Move up in parenthesis structure (`backward-up-list‘).`C-M-d‘Move down in parenthesis structure (`down-list‘).12.85 DONE 关于NarrowState "DONE"       from "WAIT/FORWARD" [2016-02-09 二 16:02]State "WAIT/FORWARD" from "NEXT"       [2015-11-30 一 14:10]  等待移动到合适的位置。State "NEXT"       from "INBOX"      [2015-11-24 二 17:32]可参考：关于Narrow12.86 LATER emacs如何搜索光标所在字符的内容State "LATER"      from "NEXT"       [2016-02-09 二 16:02]State "NEXT"       from "INBOX"      [2015-11-24 二 11:53]Capture Time:[2015-11-24 二 10:06]http://emacser.com/next-pre-word.htm如果图个简单，可以C-&lt;left&gt; 定位到单词首，然后 C-s C-w 将当前单词搜索，连续 C-w 可以扩展搜索的单词12.87 LATER C-x =State "LATER"      from "INBOX"      [2015-12-03 四 16:17]State "INBOX"      from              [2015-11-30 一 14:09]12.88 MAYBE/FUTURE 定义自己的Emacs环境State "MAYBE/FUTURE" from "NEXT"       [2016-02-09 二 16:02]State "NEXT"       from "INBOX"      [2015-11-30 一 14:15]State "INBOX"      from              [2015-11-30 一 14:15]最好兼容，与将要拥有以及已有的插件快捷键不冲突高亮当前光标单词搜索当前光标单词http://emacser.com/next-pre-word.htm12.89 MAYBE/FUTURE 将emacs插件分层整理一下，最好能尝试一下新版本的emacsState "MAYBE/FUTURE" from "LATER"      [2016-02-09 二 16:03]State "LATER"      from "INBOX"      [2015-12-01 二 17:02]Capture Time:[2015-11-26 四 16:57]12.90 NEXT Emacs如何撤销以及反撤销？State "NEXT"       from "INBOX"      [2015-11-30 一 14:36]Capture Time:[2015-11-30 一 14:35]12.91 WAIT/FORWARD &#x2014;&#x2014; [2015-12-02 三 15:06]  Emacs标签跳转------State "WAIT/FORWARD" from              [2015-12-03 四 14:15]  wait for moveFrom:/home/miracle/mydata/orgmode/gtd/output/emacs_tips.org主要有如下功能设置书签输入 C-x r m跳转到指定书签输入 C-x r b , 输入之后，提示跳转的书签，可以 TAB 补全。列出书签输入 C-x r l另外获取帮助信息输入 C-x r C-h , 其中的m/l/b子项和书签有关。12.92 LATER &#x2014;&#x2014; [2015-12-02 三 16:58]  Emacs mark ring------State "LATER"      from              [2015-12-03 四 14:15]From:/home/miracle/work/androidL/gitlocalcode/device/tpvision/tvsoc/tvsoc_mtk/test/tpapi_pvr_test.cppC-x C-x 在上次Mark和光标之间切换，并且高亮C-u C-x C-x 同上，但是不高亮,效果类似在上次位置和下次位置来回切换C-@ C-@ 将记录mark到mark ring, 实际是activate，再deactivate除了这个命令，许多命令在操作后，会自动保存操作之前的mark位置到mark ring(有当前buffer的、和全局的两种mark ring)， 这样的命令运行之后，在回显区域有 Mark set 提示， 便于回到之前的位置。例如：使用 C-y 粘帖之时,使用 M-&lt; / M-&gt; 跳转buffer首尾之时，退出增量搜索之时， 插入buffer/file之时……C-u C-@ 跳到上一次记录的mark, 范围是当前bufferC-x C-@ 范围是global mark ring.参考：http://www.gnu.org/software/emacs/manual/html_node/emacs/Setting-Mark.html#DOCF5http://www.gnu.org/software/emacs/manual/html_node/emacs/Mark-Ring.html#Mark-Ring12.93 MAYBE/FUTURE 意外发现 ESC-` 在minibuf打开菜单栏State "MAYBE/FUTURE" from "WAIT/FORWARD" [2015-12-03 四 16:19]State "WAIT/FORWARD" from "LATER"      [2015-12-03 四 16:19]State "LATER"      from "NEXT"       [2015-12-03 四 16:19]State "NEXT"       from "INBOX"      [2015-12-03 四 16:19]State "INBOX"      from              [2015-12-03 四 16:19]12.94 NEXT 学习资源State "NEXT"       from "INBOX"      [2015-12-04 五 10:38]State "INBOX"      from              [2015-12-04 五 10:38]如何在官方网址上或者邮件上提问？http://blog.gmane.org/gmane.emacs.orgmode官网http://www.gnu.org/software/emacs/对于每个插件，找到该插件发布的地方（如github），然后以报告bug的形式，或者查看前人报告的问题。12.95 LATER Emacs如何自定义按键映射不冲突State "LATER"      from "NEXT"       [2016-02-09 二 16:03]State "NEXT"       from "INBOX"      [2015-12-04 五 15:36]Capture Time:[2015-12-02 三 14:59]12.96 NEXT Emacs高级搜索State "NEXT"       from              [2015-12-14 一 17:47]在当前文件列出所有匹配行M-x list-maching-lines在多个文件和目录中搜索M-x grep 或 M-x rgrep , 后者交互性更好。在目录中查找文件M-x find-name-dired参考：http://www.cnblogs.com/cobbliu/p/3745474.html12.97 WAIT/FORWARD Emacs如何显示括号匹配？如何显示行号？State "WAIT/FORWARD" from "DONE"       [2015-12-17 四 10:58]  等待整理State "DONE"       from "INBOX"      [2015-12-17 四 10:57]Capture Time:[2015-12-02 三 17:46];;paren(show-paren-mode 1);;line number(global-linum-mode t)启动后,显示行号输入 M-x  global-linum-mode12.98 LATER 设置输入法State "LATER"      from              [2016-02-09 二 16:11]M-x set-input-methodC-x Ret C-\12.99 DONE 使用Emacs阅读代码State "DONE"       from "LATER"      [2016-02-09 二 16:14]State "LATER"      from "INBOX"      [2015-12-18 五 13:37]Capture Time:[2015-12-15 二 16:42]主要涉及到的插件包括：cedet+ecb+globalcedet 是一个代码索引后端ecb 可以操作显示方式global 是代码索引生成和查找的工具，类似ctags参考：http://www.newsmth.net/nForum/#!article/Emacs/84691http://blog.csdn.net/bigmarco/article/details/693450212.100 LATER emacs自动保存间隔State "LATER"      from "INBOX"      [2015-12-18 五 13:38]Capture Time:[2015-12-16 三 10:07]12.101 NEXT emacs如何替换文本?State "NEXT"       from "INBOX"      [2015-12-18 五 13:38]Capture Time:[2015-12-17 四 09:25]12.102 LATER Emacs如何设置多重功能的按键?State "LATER"      from "INBOX"      [2015-12-18 五 13:38]Capture Time:[2015-12-17 四 15:16]例如我想在按下鼠标后,先定位到对应位置,然后再执行特定的函数(这里是 gtags-find-tag-from-here )(local-set-key (kbd "C-M-&lt;mouse-1&gt;") '(lambda ()(interactive);;(mouse-set-point &lt;mouse-1&gt;) ;; how to position at first?(gtags-find-tag-from-here)))12.103 NEXT Emacs如何切换最近buffer,而非只有一个最近buffer?State "NEXT"       from "INBOX"      [2015-12-18 五 13:38]Capture Time:[2015-12-17 四 15:24]12.104 WAIT/FORWARD Emacs如何高亮多个单词?State "WAIT/FORWARD" from "NEXT"       [2016-02-09 二 19:17]  等待进一步整理。State "NEXT"       from "INBOX"      [2015-12-18 五 13:38]Capture Time:[2015-12-17 四 15:42]12.104.1 利用emacs自带的 hi-lock-mode高亮指定单词 M-s h p 输入之后，再输入待高亮的单词，以及高亮的颜色（可补全），即可。高亮特定正则表达式M-s h r 类似前面，输入之后输入正则表达式以及颜色即可。高亮匹配正则表达式的行M-s h l 类似前面。取消高亮M-s h u 输入之后，默认自动取消刚刚设置的高亮，或者输入想要取消高亮的正则表达式来进行取消。12.104.2 利用插件主要有 highlight-symbol 和 idle-highlight可实现光标处自动高亮，以及类似 vim 中的 * 和 # 搜索。参考：http://www.cnblogs.com/bamanzi/archive/2012/12/03/emacs-find-modify-all-occurences.html12.105 DONE 如何在Emacs直接预览markdown效果？State "DONE"       from "LATER"      [2016-02-09 二 16:10]State "LATER"      from "INBOX"      [2015-12-21 一 15:57]Capture Time:[2015-12-18 五 14:54]可以使用 markdown-mode 插件。参考网址：官方网址LinuxToy的文档12.106 MAYBE/FUTURE 如何执行脚本State "MAYBE/FUTURE" from              [2015-12-22 二 16:36]$emacs -batch -l ~/.emacs -eval '(org-batch-agenda "t")' | lpr12.107 NEXT Emacs崩溃后的恢复策略State "NEXT"       from              [2015-12-31 四 14:50]输入 M-x recover-session 之后根据时间，选择需要恢复的会话情况。12.108 NEXT emacs如何跳转到匹配的括号？State "NEXT"       from "INBOX"      [2016-01-05 二 15:36]Capture Time:[2015-12-22 二 17:08]12.109 NEXT 一些基本操作State "NEXT"       from              [2016-02-04 四 13:54]前进后退跳转至光标下的路径关闭所有buffer跳至指定百分比12.110 NEXT emacs如何返回上次编辑的位置State "NEXT"       from "INBOX"      [2016-01-31 日 16:56]Capture Time:[2016-01-31 日 16:56]12.111 NEXT Emacs如何定期自动保存文件?State "NEXT"       from "INBOX"      [2016-01-21 四 10:28]Capture Time:[2016-01-21 四 10:27]12.112 DONE emacs打开文件等，如何实现部分匹配文件或者命令而非精确开头匹配State "DONE"       from "WAIT/FORWARD" [2016-03-03 四 11:34]State "WAIT/FORWARD" from "NEXT"       [2016-02-10 三 11:22]  等待整理至合适位置。State "NEXT"       from "INBOX"      [2016-02-09 二 11:45]Capture Time:[2016-02-09 二 10:52]对打开buffer的 C-x b 以及打开文件的 C-x C-f 实现增加部分匹配可使用 ido 插件。对于运行Emacs命令 M-x xxx 可以使用基于 ido 的 smex 插件实现部分匹配，省去了记忆许多快捷键的麻烦。另外 helm 也是另外一套替换 ido 的补全方案，也可支持命令输入补全。12.112.1 ido具体参考相关文档。12.112.1.1 下载http://repo.or.cz/w/emacs.git/blob_plain/HEAD:/lisp/ido.el12.112.1.2 配置;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ido;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(require 'ido)(ido-mode t)12.112.2 smex12.112.2.1 下载https://github.com/nonsequitur/smex12.112.2.2 配置;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;smex;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(require 'smex)(global-set-key (kbd "M-x") 'smex)(global-set-key (kbd "M-X") 'smex-major-mode-commands);; This is your old M-x.(global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)12.113 LATER 意外发现的 M-* 和 M-. 是做什么的？State "LATER"      from "NEXT"       [2016-02-11 四 14:41]State "NEXT"       from              [2016-02-09 二 19:19]12.114 NEXT Emacs代码折叠State "NEXT"       from              [2016-02-10 三 12:15]http://www.cnblogs.com/bamanzi/archive/2011/10/09/2203866.html      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2015-09-09 三 14:08]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-09-09]<a href="/categories/study/emacs/emacs_tips.html"> Emacs学习笔记  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = '租房三要素'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '找房子不一定非要跑很多趟。可以只把握住以下三要素:  价格对策:打电话，问中介。注意:为防止骚扰，可用阿里小号，虚拟号码联系。区域对策:上网，查地图注意:根据自身喜好，可按地铁，公交，价格区域查找。特色对策:实地考察';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-09-05]<a href="/categories/life/three_points_for_rent.html"> 租房三要素  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = '测试代码'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '测试文章链接[文章（引用错误）](/_posts/2015-08-14-first_page.md)文章（引用错误）[文章（html引用成功）](/others/2015/08/14/first_page.html)文章（html引用成功）[文章（html引用成功，建议这样）](/others/2015/08/14/first_page.html &quot;2015-08-14-first_page.md&quot;)文章2（html引用成功，建议这样）  测试图片链接![图片（大小不协调）](/data/2015-08-19-test_link.files/image/2015-08-19-test_image.jpg)  测试文件链接[Sing for You(音乐无法播放?可下载)](/data/2015-08-19-test_link.files/audio/sing_for_you.mp3)Sing for You(音乐无法播放?可下载)[普通文件（可下载）](/data/2015-08-19-test_link.files/misc/2015-08-19-lxr-2.0.3.tgz)普通文件（可下载）  测试子分类代码：&lt;ul&gt;    &lt;li onclick=&quot;lev1.style.display=&#39;block&#39;&quot;&gt;        记事        &lt;ul id=&quot;lev1&quot; style=&quot;display:none; margin-left:10px;&quot;&gt;            &lt;li&gt;备忘&lt;/li&gt;            &lt;li&gt;计划&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;    &lt;li onclick=&quot;lev2.style.display=&#39;block&#39;&quot;&gt;        学习        &lt;ul id=&quot;lev2&quot; style=&quot;display:none; margin-left:10px;&quot;&gt;            &lt;li&gt;第2节点--1&lt;/li&gt;            &lt;li&gt;第2节点--2&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;&lt;/ul&gt;效果：      记事          备忘      计划            学习          第2节点--1      第2节点--2      ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-08-19]<a href="/categories/others/test_link.html"> 测试代码  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Jekyll+github建站实践'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '本文通过实践介绍使用Jekyll+github建立个人站点的过程。假设我们已经申请了一个github账户，账户名称为username。  创建一个用来建站的仓库#仓库名：  username/username.github.io  检出仓库：  $git clone https://github.com/username/username.github.io  个人主页的网站内容是在master分支下的。  创建主页：  $cd username.github.io  $echo &quot;Hello World&quot; &gt; index.html  $git add --all  $git commit -m &quot;Initial commit&quot;  $git push -u origin master  注意：第一次push的时候使用`-u origin master`，以后直接用`git push`命令即可。访问主页：  http://username.github.io  至此，个人站点创建完毕，我们可以自己添加html内容来完善自己的站点。完全手写html代码建立站点的过程过于复杂，下面我们将讲述如何使用Jekyll来创建个人站点。搭建Jekyll环境 #使用Jekyll可以帮助我们自动生成静态网站，减少建站的负担，使我们将主要精力集中到文章和内容上。github使用的就是Jekyll来生成站点项目的网页，所以这里我们可以在本地先搭建一个和github一样的环境。发布文章之前可以预览效果，确认可以了就能直接push到github。安装ruby过程大致如下:$wget -c https://cache.ruby-lang.org/pub/ruby/2.2/ruby-2.2.2.tar.gz$tar -xzvf ruby-2.2.2.tar.gz$mkdir -p ~/myinstalled$mv ruby-2.2.2 ~/myinstalled$cd ~/myinstalled/ruby-2.2.2$./configure$make$sudo make install这里要求ruby大于2.0.0，所以直接从官方下载源代码安装。安装bundle  $ sudo gem install bundle[sudo] password for quietheart:Fetching: bundler-1.10.6.gem (100%)Successfully installed bundler-1.10.6Fetching: bundle-0.0.1.gem (100%)Successfully installed bundle-0.0.1Parsing documentation for bundler-1.10.6Installing ri documentation for bundler-1.10.6Parsing documentation for bundle-0.0.1Installing ri documentation for bundle-0.0.1Done installing documentation for bundler, bundle after 4 seconds2 gems installed注：  此处安装可能会有错误，提示类似如下：  $gem install bundleERROR:  While executing gem ... (Gem::Exception)Unable to require openssl, install OpenSSL and rebuild ruby (preferred) or use non-HTTPS sources如果这样，我们可以查看一下源信息：  $ gem sources -l*** CURRENT SOURCES ***https://rubygems.org/然后换一个没有被“墙”的代理，如下尝试：  $ gem sources --remove https://rubygems.org/https://rubygems.org/ removed from sources$ gem sources -a http://ruby.taobao.org/http://ruby.taobao.org/ added to sources$ gem sources -l*** CURRENT SOURCES ***http://ruby.taobao.org/配置Gemfile文件  $&gt;Gemfile$vim Gemfile内容如下：source &#39;http://ruby.taobao.org/&#39;gem &#39;github-pages&#39;安装jekyll环境下面根据实际安装时出现的状况，给出两种方式。  方式一、利用bundle安装与更新(报错, 待解决)  $ bundle install$ bundle update至此，通过bundle方式安装完毕，可以用如下命令启动和转化本地服务:  $ bundle exec jekyll serve（失败）方式二、手动安装：  $sudo gem update --system$sudo gem install jekyll$jekyll --version至此，jekyll安装完毕，通过jekyll --version可以检测安装是否成功。可能遇到的问题：  如果jekyll --version运行失败，安装依赖  $sudo gem install directory_watcher$sudo gem install liquid$sudo gem install open4$sudo gem install maruku$sudo gem install classifier$sudo gem install rdiscount$sudo gem install rouge$sudo gem install therubyracer$sudo gem install execjs$sudo apt-get install nodejs$jekyll --version如果nodejs安装失败，手动源码安装  $ sudo apt-get install python$ sudo apt-get install build-essential$ sudo apt-get install gcc$ sudo apt-get install g++$ wget -c https://nodejs.org/dist/v0.12.7/node-v0.12.7.tar.gz$ tar -xzvf node-v0.12.7.tar.gz$ mkdir -p ~/myinstalled$ mv node-v0.12.7 ~/myinstalled &amp;&amp; cd ~/myinstalled$./configure$make$sudo make install$node -vv0.12.7使用Jekyll建站  建立用户构建站点的文件需要建立的文件不多解释，大致如下：  $ pwd/home/quietheart/github/vaqeteart.github.io$ tree.├── assets├── _config.yml├── _includes├── index.html├── _layouts│   └── default.html├── _plugins├── _posts│   └── 2015-08-14-first_page.md├── readme.md使用Jekyll生成站点根据前面建立的文件，生成站点。运行编译如下：  $ jekyll buildConfiguration file: /media/sda6/study/github/vaqeteart.github.io/_config.ymlSource: /media/sda6/study/github/vaqeteart.github.ioDestination: /media/sda6/study/github/vaqeteart.github.io/_siteGenerating...done.Auto-regeneration: disabled. Use --watch to enable.如果语法错误会有提示。  运行服务器：  $ jekyll serverConfiguration file: /media/sda6/study/github/vaqeteart.github.io/_config.ymlSource: /media/sda6/study/github/vaqeteart.github.ioDestination: /media/sda6/study/github/vaqeteart.github.io/_siteGenerating...done.Auto-regeneration: enabled for &#39;/media/sda6/study/github/vaqeteart.github.io&#39;Configuration file: /media/sda6/study/github/vaqeteart.github.io/_config.ymlServer address: http://127.0.0.1:4000/Server running... press ctrl-c to stop.Regenerating: 1 file(s) changed at 2015-08-14 18:56:40 ...done in 0.018106602 seconds.运行之后，可以在浏览器上通过http://127.0.0.1:4000/预览生成的站点。  注意：如果对于jekyll想知道更多的命令可以运行jelly --help。如果需要每次修改文件jekyll会自动检测到变化并生成对应新页面。可以直接使用jekyll server -w。这样就不用每次修改文件都运行jekyll build&amp;jekyll server了。参考资料下面列出一些不错的参考资料：http://www.cnblogs.com/purediy/archive/2013/03/07/2948892.htmlhttp://blog.csdn.net/on_1y/article/details/19259435https://github.com/minixalpha/minixalpha.github.iohttp://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.htmlhttp://higrid.net/c-art-blog_jekyll.htmhttp://www.tuicool.com/m/articles/INBnMzhttp://higrid.net/c-art-jeklly_template_data.htmhttp://holbrook.github.io/http://jekyllrb.com/docs/datafiles/  其它的还有：http://www.pchou.info/web-build/2014/07/04/build-github-blog-page-08.htmlhttps://pages.github.com/https://help.github.com/articles/using-jekyll-with-pages/http://www.cnblogs.com/netbuddy/p/3501147.htmlhttp://segmentfault.com/q/1010000000476530http://www.cnblogs.com/hwpayg/archive/2012/11/04/2753404.html  ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-08-19]<a href="/categories/study/jekyll_on_github.html"> Jekyll+github建站实践  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'My first page'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '第一篇文章这是我的第一篇文章直接在github上用Markdown书写。';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-08-14]<a href="/categories/others/first_page.html"> My first page  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = '理解repo'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2014-10-09 四]	  	    		  Update	  	    Table of Contents1. 须知1.1. repo1.2. git项目1.3. repo项目2. repo init3. repo sync4. 关于分支4.1. repo分支4.2. 清单文件指定的分支4.3. git分支5. 其它1 须知1.1 reporepo用于管理多个git项目，同一产品可能包含多个git项目，不同的git项目集合，可能形成不同产品，通过repo可以实现方便的管理。repo主要包含repo配置信息、以及repo所管理的git项目集合。1.2 git项目对于所有git管理的项目，例如 mygitproject ，其中 mygitproject/.git 是git目录（或git库）； mygitproject/ 中除 .git 之外的内容为git工作目录，来自相应git目录中的某个版本。1.3 repo项目对于所有repo管理的项目，例如 myrepoproject ，其中 myrepoproject/.repo 是repo目录（或repo库）； myrepoproject/ 中除 .repo 之外的内容为repo工作目录，来自相应repo目录中的某个版本。2 repo initrepo init 的作用是下载或更新好repo配置和脚本集（相当于对repo配置和repo脚本集进行 git pull ，但是它还额外做了更多的事情），repo配置和脚本本身又是由git管理的，repo配置指定使用哪些git项目，脚本是repo命令本身的实现。在空目录中执行这个目录后，会生成一个 .repo 目录，查看 .repo 目录，会看到有如下内容：$ls .repomanifests/  manifests.git/  manifest.xml  repo/具体解释如下：.repo此为repo目录，可用于提取相应项目工作目录到外面的repo工作目录。.repo/manifests.git此为repo配置信息的git库，不同版本包含不同配置信息，配置信息大致描述内容见后面。.repo/manifests此为repo配置信息的工作目录（将配置信息的工作目录和相应的实际git目录分离管理，并且配置信息中的.git目录实际只是指向实际git库的软连接），其中可能包含一个或多个xml文件描述的配置。每个xml文件是独立的一套配置，配置内容包括当前repo工作目录包含哪些git项目、所有git项目所处的默认公共分支、以及远端地址等。.repo/manifest.xmlrepo工作目录中的内容同一时刻只能采用manifests中的一个xml文件做为其配置，该文件就是其软连接，通过init的-m选项指定采用哪个文件；另外，同一xml文件也可能处于manifests库的不同版本或者不同分支，通过 init 的 -b 选项指定使用manifests中的哪个分支，每次init命令都会从服务器更新最新的配置。这里通过 -m 指定的manifests中的xml文件中，有两个需要注意：default.xml是稳定版，default_head.xml是开发版，开发版始终包含最新的内容。.repo/repo此为repo脚本集的git库，用于repo管理所需的各种脚本，repo的所有子命令就是其中的对应脚本实现。该脚本也通过git管理， .repo/repo/.git 为对应的git目录。这里包含repo命令所需的所有子命令脚本实现，由python完成（我们可以在 .repo/repo/subcmds 中看到类似repo的init等的子命令脚本实现，如repo的 init 子命令即 repo init ，它由 .repo/repo/subcmds/init.py 实现），这个目录本身又由git来管理。不同的repo库或者不同版本的repo库，其repo命令实现会有些不同，所以也对应不同的repo脚本集，建议每次采用对应repo项目的最新的repo库做为其repo命令集实现。第一次使用repo时，采用的repo脚本实际是一个简单的repo的引导脚本，它既符合shell语法，又符合python语法，最终会将所需的具体脚本实现下载至最新的 .repo/repo 中，后面类似 repo init 、 repo sync 等脚本的实现，全都有这里的内容来实现。我们发现 .repo/repo/repo ，这个文件其实就是当前repo库中最新的repo引导脚本，可供其它没有使用过repo的用户做为repo的引导脚本来使用。3 repo syncrepo sync 的作用是下载当前repo配置的所有项目，并生成对应的repo工作目录。执行之后，会看到.repo目录包含如下内容：$ls .repomanifests  manifests.git  manifest.xml  projects  repo还有 .repo 外面也多出了许多目录。也就是说，多出了一个 projects 目录，和 .repo 外面的许多目录，具体内容如下：.repo/projects此为repo所管理的所有git项目集，包含repo当前配置所指定的所有git项目对应的git目录。不同的清单文件（即 manifest.xml ）内容，指定不同的git项目集组合，表征不同的项目版本或者项目，而如上所述，manifest.xml文件的内容又由其指向的manifests中的、具体的分支下的、xml文件来决定。.repo/../*此为repo的工作区。在repo目录（即 .repo ）之外，根据repo配置（即 .repo/manifest.xml 文件），从 .repo/projects/* 中提取出指定分支的各个git项目（即 .repo/projects 中git项目的子集）的工作目录，形成repo工作目录，可供开发使用。其中每个git工作目录中的 .git 只是指向 .repo/projects/* 的软连接，在repo工作目录中的某个git工作目录更新相应的git库，其实最终会更新到 .repo/projects 中对应的git库。刚刚repo sync之后，当前工作目录不处于任何分支，其中的修改只能本地保存无法提交至远端，若想提交工作，需要先创建一个分支保存工作内容。4 关于分支以上描述，有几个分支的概念需要明确。4.1 repo分支这里通过 repo init -b ，中的 -b 所指定的分支，是manifests的分支，不同分支，其中的文件清单内容有所不同。4.2 清单文件指定的分支通过清单文件 manifest.xml 中的default实体的revision属性，指定版本库默认的分支为revision属性值，该属性值做为 repo sync 之后工作目录中所有git项目的公共起点分支，也就是说，该manifest对应所有的git项目都有一个以revision属性值为名的分支， repo sync 之后，在任意一个repo工作目录下的git库中，使用 git branch 或者 repo start 创建的分支，都是基于该git库中revision属性值为名的分支来创建。我们可以将这个分支设置为和repo分支类似的名字。4.3 git分支除了repo管理的用于repo配置的repo分支，和用于设置工作目录起点的清单文件分支，每个工作目录对应的git库，也可设置自己的工作分支，和平时使用git时的含义一样。5 其它以上参考《git权威指南》和网络，如有错误之处，欢迎指正，谢谢。';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2014-10-09]<a href="/categories/study/repo_understand.html"> 理解repo  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = '使用git进行版本控制'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '本文将介绍一种强大的版本控制工具，git的基本使用。与之前svn工具类似，首先给出一些常见的使用需求，然后以这些需求为中心，来展开git的学习过程。由于我也是在学习当中所以其中不准确之处可以通过后面的联系方式来交流，谢谢。_^主要内容+ 简介+ 基本概念+ 常用命令+ 具体实践+ 其它  简介本文将介绍一种强大的版本控制工具，git的基本使用。与之前svn工具类似，本文首先给出一些常见的使用需求，然后以这些需求为中心，来展开git的学习过程。带着问题学习：从svn过渡过来的用户初次使用git，会遇到许多的问题，这里以习惯了svn用户的角度，来考虑学习使用git需要解决的一些问题：  如何查看库路径信息？如何合并和创建分支？如何恢复到指定的版本？如何查看指定版本的信息？如何理解分布式存储？什么是索引？什么是工作树？如何查看log详细信息？这些问题也可作为学习之后的练习，我们可以尝试自己来解决一下_。一、基本概念 ###这部分内容，大部分来自git的man手册，更为具体的信息可以参见man gittutorial的命令输出。svn和git都是用于进行代码版本控制的工具。但是两者有许多不同，这里只对两个重要的地方：分布式管理、是否可更改历史，进行说明，随着以后的学习，我们会发现两者之间更多的不同之处。使用过svn的用户可知svn有两个比较重要的特点：  在svn中一个项目已经提交的历史无法被修改。不同的svn代码库之间不能相互同步不同的代码修改。svn服务器通过其中的某个统一的代码库集中管理某个项目代码，其他部分的代码都是这个服务器中库的工作拷贝，提交时都提交到这个统一的服务器代码库中。当然这并不是绝对的，我们可以通过特殊方法修改svn的历史，也可以让svn实现“分布”管理）。而对于git，至少在这两点上与svn不同：  在git中，我们可以任意修改已经提交的内容的历史信息。git中的服务器可以不只一个，服务器中同一项目的的代码库也可以不止是一个。我们可以将一台机器器上面的git代码库拷贝到另外一台机器上，然后提交的时候只往那个库中提交，而这些库之间还可以相互同步它们之间不同的修改部分。下面是学习git时需要了解的一些重要内容，其中有些涉及到的内容，在后面的部分会详细提及。  1、git中的status和diff，以及add和commit ####git中，每次提交修改文件之前要add，然后再commit。git的add命令和许多版本控制系统不一样，不是增加新增的文件，而是以内容为单位，将最新修改的内容，添加到一个临时的索引中，等待commit。实践发现，如果修改一个文件，然后diff查看修改，然后add，然后再修改，然后在commit，那么只把第一次修改提交了。commit的时候，建议遵守这样的格式：开始是简短的一行描述（不超过50字符），然后根着一个空行，最后是详细的描述。这样，就便于有些软件将开始的简短行作为email的题目，后面的详细描述作为email的信息内容，完成自动化转换。另外，如果修改了一个文件然后没有git add，那么可以用git diff查看修改的内容，而git status无法看到修改的内容；当git add这个文件之后，用git diff就看不到这个内容了，用git status就可以看到。例如：  lv-k@quietheart:~/temp/temp/git_t$ echo hello5 &gt;&gt;hellolv-k@quietheart:~/temp/temp/git_t$ git diffdiff --git a/hello b/helloindex 0863c71..bba0e39 100644--- a/hello+++ b/hello@@ -3,3 +3,4 @@ hello1hello2hello3hello4+hello5    &lt;===这里说明在&quot;git add hello&quot;之前，对hello文件进行了修改。lv-k@quietheart:~/temp/temp/git_t$ git status# On branch master# Changes not staged for commit:   &lt;===这里说明修改没有被添加（stage）,并且提示用&quot;git add&quot;。#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)##       modified:   hello    &lt;===这里说明修改了hello文件#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)    &lt;===说明不会提交修改，可用&quot;git add&quot;或者&quot;git commit -a&quot;来提交修改。lv-k@quietheart:~/temp/temp/git_t$ git add hellolv-k@quietheart:~/temp/temp/git_t$ git diff    &lt;===添加之后，没有任何输出。lv-k@quietheart:~/temp/temp/git_t$ git status# On branch master# Changes to be committed: &lt;===提示将会提交修改的内容，并且提示用&quot;git reset&quot;来取消stage。#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##       modified:   hello#lv-k@quietheart:~/temp/temp/git_t$ echo hello6 &gt;&gt;hello    &lt;===提交之前又修改了lv-k@quietheart:~/temp/temp/git_t$ git diffdiff --git a/hello b/helloindex bba0e39..34e8bc5 100644--- a/hello+++ b/hello@@ -4,3 +4,4 @@ hello2hello3hello4hello5+hello6       &lt;===显示最新没有add的修改lv-k@quietheart:~/temp/temp/git_t$ git status# On branch master# Changes to be committed: &lt;===显示提交时会提交一部分修改#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##       modified:   hello## Changes not staged for commit:   &lt;===显示提交时也会有一部分修改不会提交上去。#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)##       modified:   hello#lv-k@quietheart:~/temp/temp/git_t$ git add hellolv-k@quietheart:~/temp/temp/git_t$ git difflv-k@quietheart:~/temp/temp/git_t$ git status# On branch master# Changes to be committed:#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##       modified:   hello#lv-k@quietheart:~/temp/temp/git_t$ git reset hello    &lt;===撤消&quot;git add&quot;的动作Unstaged changes after reset:M       hellolv-k@quietheart:~/temp/temp/git_t$ git diffdiff --git a/hello b/helloindex 0863c71..34e8bc5 100644--- a/hello+++ b/hello@@ -3,3 +3,5 @@ hello1hello2hello3hello4+hello5+hello6lv-k@quietheart:~/temp/temp/git_t$ git status# On branch master# Changes not staged for commit:#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)##       modified:   hello#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)lv-k@quietheart:~/temp/temp/git_t$ git add hello   &lt;===再次&quot;git add&quot;lv-k@quietheart:~/temp/temp/git_t$ git difflv-k@quietheart:~/temp/temp/git_t$ git status# On branch master# Changes to be committed:#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##       modified:   hello#对于以上内容中出现的命令，我们可以在后续的学习中看到。2、pull、push和fetchgit中的pull子命令做两个工作：从远处库的分支fetch相应的修改，然后将修改合并到当前分支。如果发生冲突，那么也会进行fetch但是会拒绝对冲突的文件进行合并（这时需要解决冲突然后再次pull???）。git-fetch用于从另一个reposoitory下载objects和refs，但是并不提交到本地库。其中表示远端的仓库路径。其中的标准格式应该为:，表示源的分支，如果不为空，则表示本地的分支；如果为空，则使用当前分支。而push和pull相反，是向远端发送本地提交的修改，当然需要让远端设置成可以接受本地提交的修改。具体参见后面的实践。3、常用常量和范围表示有一些常用常量可以表示特定的版本，它们是：  HEAD：表示最近一次的commit。MERGE_HEAD：如果是merge产生的commit，那么它表示除HEAD之外的另一个父母分支。FETCH_HEAD：使用git-fetch获得的object和ref的信息都存储在这里，这些信息是为日后git-merge准备的。HEAD：表示HEAD父母的信息HEAD：表示HEAD父母的父母的信息HEAD~4：表示HEAD上溯四代的信息HEAD1：表示HEAD的第一个父母的信息（和HEAD相同）HEAD2：表示HEAD的第二个父母的信息COMMIT_EDITMSG：最后一次commit时的提交信息。  当我们表示两个特定版本之间的内容的时候，一般有如下表示：使用&quot;..&quot;表示两个提交版本之间的内容例如：  $ git log v2.5..v2.6表示查看v2.5到v2.6之间的log信息；再如：  HEAD..FETCH_HEAD表示显示抓取的开始之后的信息不显示HEAD开始之后的信息(也就是显示的时候不显示自HEAD以来本地库的信息，而是只显示远端的信息)；还有:   $ git log v2.5..表示自v2.5之后提交的内容。  使用&quot;...&quot;表示包含更多的范围：例如HEAD...FETCH_HEAD，可以用来查看两者都修改了什么，是两者分别修改的而不是同时修改的。二、常用命令这里给出常用的基本命令。获取git的子命令的帮助信息的方式：  $man git-log$git help log这里，子命令用git log或git log --graph之类的log子命令进行举例。为git添加自己的名字以及邮箱信息：  $ git config --global user.name &quot;Your Name Comes Here&quot;$ git config --global user.email you@yourdomain.example.com另外，通过当前目录的.git/config，来查看类似svn info输出的url相关的信息等等。将一个目录添加到git控制中过程如下：初始化目录：  $ tar xzf project.tar.gz$ cd project$ git init将当前目录下所有文件的快照(snap)加入git  $ git add .`  这样会告诉git将当前目录下所有的修改的文件，以及以前不在git下面的文件等的当前状态，添加到git的一个临时&quot;stage area&quot;中(但是还没有被保存下来)，git称它为索引(index)。将索引(index)的内容保存到git库中：  `$git commit`  这样会提示你输入日志信息，之后就将当前的目录所有最新内容存放到git中管理了。另外需要注意的是，commit有一个--amend选项，可以给修改版本的信息，例如注释信息，具体参见man手册。修改文件并提交  将新增或者修改等变化的文件添加到git的索引(index)中：  $ git add file1 file2 file3这里，添加之后，后面的commit命令将会把此次添加的内容都提交上去(由此可见git的&quot;add&quot;添加的不仅仅是文件，它是以内容为单位的，添加的是当前的修改)。提交之前，查看修改状态：$git diff --cached或者$git status这里，diff如果没有--cached选项，信息更多（有则只显示没有add的内容），status显示的使概要的简洁信息。  提交修改：$ git commit这样，会提示你输入日志信息，然后更新git库的版本。其实，每次提交修改文件之前都要用add将修改的内容添加进去，然后才能commit，如果合并两步，可以这样：$git commit -a这样会自动将修改的文件（不包含新增的文件）添加到索引，并且提交。  注意提交时候的日志信息，最好用一个简单行开始，然后一个空行，因为许多工具将其日志第一行自动转换作为邮件标题，剩下内容作为邮件内容。查看历史信息  $git log或者  $git log -p或者  $git log --stat --summary这里，-p 查看完整历史消息并且重定向到 less 之类的pager程序查看，--stat --summary也会重定向到pager但是信息比较简要，而只有 git log 则更简要并且不会将输出重定向到pager程序中。另外，使用git log --graph可以用文本图形的方式显示版本之间的关系。分支管理  创建分支：  $ git branch experimental查看分支：  $ git branch这样，会列出所有分支，并且当前分支前面用&#39;*&#39;标识出来。  切换分支：$ git checkout experimental这样，会切换到experimental分支，默认分支是&#39;master&#39;分支，它是被自动创建的。  合并分支：  $ git merge experimental这里，如果正常则合并成功，如果冲突，那么冲突文件中会有冲突标记。合并之后可以提交。使用diff可以查看冲突。  删除分支：  $ git branch -d experimental这里分支要确保被合并到上层才行，如果不考虑合并状态，那么使用-D代替-d。  使用git合作开发假设用户A有一个git库，地址为：/home/alice/project；B和A同为一台机器，其用户主目录为/home/bob。B在A库的基础上面工作：bob$ git clone /home/alice/project myrepo(edit files)bob$ git commit -a(repeat as necessary)这里，首先B从A拷贝一份库到本地，然后在本地进行修改，并且提交，这个时候，提交的内容都是提交到B自己的库中。A合并B的修改：alice$ cd /home/alice/projectalice$ git pull /home/bob/myrepo master这里，当A想要合并B的内容的时候，可以通过pull实现；如果A已经在本地有过一些修改，那么可能会出现并处理一些合并的冲突问题。其实，pull=fetch+merge，就是先获取远端修改的内容，然后合并到本地。只查看B的修改，但是不合并：alice$ git fetch /home/bob/myrepo masteralice$ git log -p HEAD..FETCH_HEAD这里，fetch只是将修改信息抓取下来，并不进行合并，这样就能够在合并之前看到远端（抓取端）进行了哪些修改HEAD是最新的一次commit，FETCH_HEAD使抓取端的信息。HEAD..FETCH_HEAD表示显示抓取的开始之后的信息不显示HEAD开始之后的信息(也就是显示的时候不显示自HEAD以来本地库的信息，而是只显示远端的信息).而用HEAD...FETCH_HEAD可以用来查看两者都修改了什么，是两者分别修改的而不是同时修改的。A设置fetch时使用的B的远端位置的简写：alice$ git remote add bob /home/bob/myrepo如果A经常和B进行交互，那么可以使用remote命令，这样以后A便可以通过这个简写来获取B的修改而不用输入完整名称了。A使用remote设置的B的简写来获取B的修改并合并：alice$ git fetch bobalice$ git merge bob/master这里，也可以用如下命令来完成合并：  alice$ git pull . remotes/bob/masterB获取A最新修改的内容：bob$ git pull这里，B不需要给出A的库的位置，因为B是来自A的一个拷贝，A的位置信息在拷贝的时候被记录到库的配置中了，这个位置信息在B使用没有参数的pull的时候会被自动地应用。使用如下命令可以查看B的配置中的这个url信息：bob$ git config --get remote.origin.url/home/alice/project查看B来自A的原始master拷贝：bob$ git branch -rorigin/master拷贝B的时候，git会自动将一份原始的A的master分支拷贝到&quot;origin/master&quot;中，用这个命令可以看到。与A在不同主机上的B拷贝A的库到本地：  bob$ git clone alice.org:/home/alice/project myrepo这里，可以使用特定的本地协议例如“rsync”或者“http”，可以查看git-pull的信息来获取更多帮助。另外，查看git-push(1)和gitcvs-migration(7)，可以知道git还可以设置成像cvs那样集中控制版本的模式。由上面的过程我们可以知道，git版本控制工具中分布式管理的含义。与svn不同的是，在svn中，只能有一个svn服务器集中存放版本控制库，其他的客户端全部都是这个版本库的工作拷贝，提交的时候全部都提交到这个集中的svn库中或者库的某个分支中。git分步式管理的意思就是可以将一个由git创建的版本控制库拷贝到另外的地方，所有这个git库的拷贝都可以各自作为一个“版本控制中心”，管理自己工作拷贝以及本地分支的提交，同时这些库之间还可以相互合并其修改到另外的库的特定分支中。指定版本操作这里将git中的版本号假设为特定的commit的id。查看所有历史信息：  $git log这样会显示所有的历史信息，包括commit的id，使用git log --graph会以文本图形的方式直观地显示出每个历史版本之间的合并关系等。其实，我们可以将历史看成一系列的commit。查看特定id的历史信息：  $git show c82a22c39cbc32576f64f5c6b3f24b99ea8149c7或$git show c82a22c39c这样，我们可以看到指定commit的id为&quot;c82a22c39cbc32576f64f5c6b3f24b99ea8149c7&quot;的历史信息。这里，只要能够保证前缀唯一，也可指定部分id的前缀作为相应历史的标识。查看当前分支当前的历史状态：  $git show HEAD这里，HEAD表示当前分支最新版本。关于查看时候指定的类似&quot;HEAD&quot;的常量大致如下：HEAD：表示最近一次的commit。MERGE_HEAD：如果是merge产生的commit，那么它表示除HEAD之外的另一个父母分支。FETCH_HEAD：使用git-fetch获得的object和ref的信息都存储在这里，这些信息是为日后git-merge准备的。HEAD：表示HEAD父母的信息HEAD：表示HEAD父母的父母的信息HEAD~4：表示HEAD上溯四代的信息HEAD1：表示HEAD的第一个父母的信息（和HEAD相同）HEAD2：表示HEAD的第二个父母的信息COMMIT_EDITMSG：最后一次commit时的提交信息。自定义commit的id名称：  $ git tag v2.5 1b2e1d63ff这样定义之后，就可以使用v2.5这样比较容易理解的方式来引用&quot;1b2e1d63ff&quot;这种看起来没有意义的字符串，如果想要和别人共享这个定义的名称，需要创建一个tag对象，并且给它&quot;sign&quot;，具体参见git help tag。比较两个不同的版本：  $git diff HEAD bc32576f64f5c6b3f24b99ea8149c7这里，比较&quot;HEAD&quot;和&quot;bc32576f64f5c6b3f24b99ea8149c7&quot;之间的区别，也可以使用自己定义的名称。回退到指定版本，清除该版本之后所有的信息：  $ git reset --hard HEAD这样将会把当前工作分支的内容回退到HEAD^版本。注意，这个命令不仅会把当前的修改给移除，而且还会把自HEAD^以后的所有commit给删除（HEAD^版本本身保留为当前的HEAD），如果当前的分支是唯一的分支的话，那么运行这个命令之后，之前HEAD^以后的修改将会完全丢失（当然可以通过pull再将之前的HEAD拉取回来，但是自己没有提交的本地修改是无法找回来的了）；另外如果在一个公共的分支上面执行这个命令将会导致其他开发者pull的时候都进行一遍这个清除的工作，如果不加--hard选项，那么可能当前HEAD基础上有修改的情况导致这个命令不会成功。回退到指定版本，并作为新版本提交上去（保留该版本之后所有的信息）：  $ git revert HEAD^这样只会把内容回退为HEAD^之前的版本（即HEAD^^），再将这样的内容做为新的HEAD提交上去，原来的HEAD变成HEAD^（即在库中保留HEAD^之后的版本的提交，而不像reset那样完全清除）。这里，运行之后，会打开一个编辑窗口让你编辑提交的log信息，退出就直接提交了，或者revert命令也有不编辑提交log信息的选项。使用checkout的“回退”：  $ git checkout v2.5这样，会将当前v2.5版本重新检出，效果是使用v2.5做为当前的HEAD了，但是，原来的HEAD对应的commit id还存在于库中，可以使用那个id用checkout重新检回。另外，如果检出v2.5之后做了修改并且提交到库中，那么会以v2.5为基础重新生成一个版本，并且提交上去，这时候可以再用原来那个HEAD检查出，但是就“隐藏”了这个v2.5之后提交的新HEAD相关的一系列修改版本，这时候一般git会提醒你为此次提交创建一个新分支，并且会给出提示命令。实践发现，如果修改了没有提交，那么checkout会有问题，就是修改的内容并到了checkout的版本中，具体需要实践。从指定版本搜索某个字符串：  $ git grep &quot;hello&quot; v2.5这样将会从&quot;v2.5&quot;这个自定义的commit名字的版本中的所有文件搜索&quot;hello&quot;字符串。如果没有指定&quot;v2.5&quot;类似的commit的号码的话，将会从当前路径搜索这个&quot;hello&quot;字符串。介于v2.5和v2.6之间的commit信息：  $ git log v2.5..v2.6介于v2.5之后的commit信息：  $ git log v2.5..两周以前的commit信息：  $ git log --since=&quot;2 weeks ago&quot; # commits from the last 2 weeks自Makefile修改之后的commit信息：  $ git log v2.5.. Makefile       # commits since v2.5 which modify两个没有前后关系的commit之间的信息：  $git log v2.5 s2.5这里，v2.5和s2.5是两个没有直系关系的版本，这样会只显示关于s2.5的提交信息。指定某个版本的文件并进行操作：  $ git diff v2.5:Makefile HEAD:Makefile.in或  $ git show v2.5:Makefile这里，我们运行操作文件的命令的时候，可以给文件名称添加一个commit的ID，以标识对那个版本的文件进行操作。三、具体实践下面用一个具体的实践展示使用git的简单过程。若有更多内容，再做更新。  简单命令查看帮助：  $ git具体如下：lv-k@quietheart:~/temp/git_test$ gitusage: git [--version] [--exec-path[=&lt;path&gt;]] [--html-path]           [-p|--paginate|--no-pager] [--no-replace-objects]           [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;]           [-c name=value] [--help]           &lt;command&gt; [&lt;args&gt;]The most commonly used git commands are:   add        Add file contents to the index   bisect     Find by binary search the change that introduced a bug   branch     List, create, or delete branches   checkout   Checkout a branch or paths to the working tree   clone      Clone a repository into a new directory   commit     Record changes to the repository   diff       Show changes between commits, commit and working tree, etc   fetch      Download objects and refs from another repository   grep       Print lines matching a pattern   init       Create an empty git repository or reinitialize an existing one   log        Show commit logs   merge      Join two or more development histories together   mv         Move or rename a file, a directory, or a symlink   pull       Fetch from and merge with another repository or a local branch   push       Update remote refs along with associated objects   rebase     Forward-port local commits to the updated upstream head   reset      Reset current HEAD to the specified state   rm         Remove files from the working tree and from the index   show       Show various types of objects   status     Show the working tree status   tag        Create, list, delete or verify a tag object signed with GPGSee &#39;git help &lt;command&gt;&#39; for more information on a specific command.这里，通过这个命令我们可以看见git最常用的一些命令。关于分支  查看当前分支：  $ git branch具体如下：lv-k@quietheart:~/temp/git_test$ git branch*master这里，可知当前处于主分支&quot;master&quot;，当前分支用&#39;*&#39;和高亮标记出来。创建分支：  $ git branch quietheart具体如下：  lv-k@quietheart:~/temp/git_test$ git branch quietheartlv-k@quietheart:~/temp/git_test$ git branch*masterquietheart这里，创建了一个&#39;quietheart&#39;分支，但是创建之后并没有切换过去。切换分支：  $ git checkout quietheart具体如下：lv-k@quietheart:~/temp/git_test$ git checkout quietheartSwitched to branch &#39;quietheart&#39;lv-k@quietheart:~/temp/git_test$ git branchmaster*quietheart这里，使用&#39;checkout&#39;命令切换到了指定的分支。分别在分支中进行修改：lv-k@quietheart:~/temp/git_test$ git checkout masterlv-k@quietheart:~/temp/git_test$ echo &#39;change in master&#39; &gt;&gt;hellolv-k@quietheart:~/temp/git_test$ git commit -m &#39;change in master&#39; -alv-k@quietheart:~/temp/git_test$ git checkout quietheartlv-k@quietheart:~/temp/git_test$ echo &#39;changed in quietheart&#39; &gt;&gt;example lv-k@quietheart:~/temp/git_test$ git commit -m &#39;change in quietheart&#39; -a具体如下：lv-k@quietheart:~/temp/git_test$ git checkout masterSwitched to branch &#39;master&#39;lv-k@quietheart:~/temp/git_test$ git branch*masterquietheartlv-k@quietheart:~/temp/git_test$ lsexample  hello  mydirlv-k@quietheart:~/temp/git_test$ echo &#39;change in master&#39; &gt;&gt;hellolv-k@quietheart:~/temp/git_test$ git diffdiff --git a/hello b/helloindex 1b11f8b..60cacc0 100644--- a/hello+++ b/hello@@ -1,3 +1,4 @@hello worldhello worldhello world+change in masterlv-k@quietheart:~/temp/git_test$ git commit -m &#39;change in master&#39; -ifatal: No paths with --include/--only does not make sense.lv-k@quietheart:~/temp/git_test$ git commit -m &#39;change in master&#39; -a[master d8f32e0] change in masterCommitter: lv-k &lt;lv-k@quietheart.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:  git config --global user.name &quot;Your Name&quot;  git config --global user.email you@example.comAfter doing this, you may fix the identity used for this commit with:  git commit --amend --reset-author1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test$ git difflv-k@quietheart:~/temp/git_test$ git logcommit d8f32e0e0b16e6dc499d5295a8a13ec3938664f8Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:54:10 2012 +0800  change in mastercommit fa4abf6455aa01cf7d74810b96e2279983287fc8Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:41:51 2012 +0800  add modify2commit 07ee8b68e90a470aec9a5194079e54332093fc70Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:29:00 2012 +0800  add modifycommit 098e14c671f8cef3507a8b43fba7b386892ed5bcAuthor: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 16:59:04 2012 +0800  initial commit contents这里，在执行本例子之前提交过一次，而那次提交没有在本文档记录所以所以多了一条记录&#39;add modify2&#39;。lv-k@quietheart:~/temp/git_test$ git checkout quietheartSwitched to branch &#39;quietheart&#39;lv-k@quietheart:~/temp/git_test$ git logcommit fa4abf6455aa01cf7d74810b96e2279983287fc8Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:41:51 2012 +0800  add modify2commit 07ee8b68e90a470aec9a5194079e54332093fc70Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:29:00 2012 +0800  add modifycommit 098e14c671f8cef3507a8b43fba7b386892ed5bcAuthor: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 16:59:04 2012 +0800  initial commit contentslv-k@quietheart:~/temp/git_test$ echo &#39;changed in quietheart&#39; &gt;&gt;example lv-k@quietheart:~/temp/git_test$ git diffdiff --git a/example b/exampleindex 6e93434..0706323 100644--- a/example+++ b/example@@ -1 +1,2 @@my example+changed in quietheartlv-k@quietheart:~/temp/git_test$ git commit -m &#39;change in quietheart&#39; -a[quietheart 8a95074] change in quietheartCommitter: lv-k &lt;lv-k@quietheart.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:  git config --global user.name &quot;Your Name&quot;  git config --global user.email you@example.comAfter doing this, you may fix the identity used for this commit with:  git commit --amend --reset-author1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test$ git logcommit 8a95074a30e32a4df3cdf50648fce2d6a0a73a97Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 18:00:10 2012 +0800  change in quietheartcommit fa4abf6455aa01cf7d74810b96e2279983287fc8Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:41:51 2012 +0800  add modify2commit 07ee8b68e90a470aec9a5194079e54332093fc70Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:29:00 2012 +0800  add modifycommit 098e14c671f8cef3507a8b43fba7b386892ed5bcAuthor: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 16:59:04 2012 +0800  initial commit contents合并某分支到当前分支最新：$ git checkout master$ git merge quietheart具体过程如下：lv-k@quietheart:~/temp/git_test$ git branchmaster*quietheartlv-k@quietheart:~/temp/git_test$ git checkout masterSwitched to branch &#39;master&#39;lv-k@quietheart:~/temp/git_test$ git branch*masterquietheartlv-k@quietheart:~/temp/git_test$ git merge quietheartMerge made by recursive.example |    1 +1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test$ git difflv-k@quietheart:~/temp/git_test$ git logcommit 83548b1a87668a5dbd606c6bcefdc984970ffb40Merge: d8f32e0 8a95074Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 18:09:51 2012 +0800  Merge branch &#39;quietheart&#39;commit 8a95074a30e32a4df3cdf50648fce2d6a0a73a97Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 18:00:10 2012 +0800  change in quietheartcommit d8f32e0e0b16e6dc499d5295a8a13ec3938664f8Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:54:10 2012 +0800  change in mastercommit fa4abf6455aa01cf7d74810b96e2279983287fc8Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:41:51 2012 +0800  add modify2commit 07ee8b68e90a470aec9a5194079e54332093fc70Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:29:00 2012 +0800  add modifycommit 098e14c671f8cef3507a8b43fba7b386892ed5bcAuthor: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 16:59:04 2012 +0800  initial commit contents这样，就将刚才在quietheart分支上面的从master继承过来之后的所有修改合并到了master主分支上面来了，同时提交分支quietheart时候的日志信息也合并进来了。使用clone、pull、push实践多人合作拷贝两份远端库到本地：  $ git clone /home/lv-k/temp/git_test git_test_clone具体如下：lv-k@quietheart:~/temp$ git clone /home/lv-k/temp/git_test git_test_cloneCloning into git_test_clone...done.lv-k@quietheart:~/temp$ git clone /home/lv-k/temp/git_test_clone/ /home/lv-k/temp/git_test_clone1Cloning into /home/lv-k/temp/git_test_clone1...done.这里，其实拷贝的是当前库所在的分支，通过git branch查看可知，得到的git_test_clone其实只有master分支，因为拷贝的时候，git_test库所在的当前分支是master。在一个拷贝上面修改并提交：$ cd git_test_clone1/$ echo &quot;hello after clone&quot; &gt;&gt;hello$ git commit -a -m &#39;commin in clone&#39;具体如下：lv-k@quietheart:~/temp$ cd git_test_clone1/lv-k@quietheart:~/temp/git_test_clone1$ echo &quot;hello after clone&quot; &gt;&gt;hellolv-k@quietheart:~/temp/git_test_clone1$ git commit -a -m &#39;commin in clone&#39;[master bf44b20] commin in clone Committer: lv-k &lt;lv-k@quietheart.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:    git config --global user.name &quot;Your Name&quot;    git config --global user.email you@example.comAfter doing this, you may fix the identity used for this commit with:    git commit --amend --reset-author 1 files changed, 1 insertions(+), 0 deletions(-)这里，修改之后，本地库便和远端的原始库发生了变化。将远端拷贝修改的内容拉取过来：$ cd git_test_clone/$ git pull /home/lv-k/temp/git_test_clone1/具体如下：lv-k@quietheart:~/temp$ cd git_test_clone/lv-k@quietheart:~/temp/git_test_clone$ git pull /home/lv-k/temp/git_test_clone1/remote: Counting objects: 5, done.remote: Compressing objects: 100% (3/3), done.remote: Total 3 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.From /home/lv-k/temp/git_test_clone1 *branch            HEAD       -&gt; FETCH_HEADUpdating 83548b1..bf44b20Fast-forward hello |    1 + 1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test_clone$ cat hellohello worldhello worldhello worldchange in masterhello after clonelv-k@quietheart:~/temp/git_test_clone$ git log |head -n 10commit bf44b2085fe716b1fdb4c04b0dabbca60c451f39Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Wed Jun 13 16:28:32 2012 +0800    commin in clonecommit 83548b1a87668a5dbd606c6bcefdc984970ffb40Merge: d8f32e0 8a95074Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 18:09:51 2012 +0800从这里我们可以看到，拉取过来的内容被自动地提交上去了，其实拉取内容的时候应该指明是哪个分支。实际如果没有参数则从clone时候的来源来pull，这里可以通过.git/config中查看来源。将本地库拷贝的修改推送到远程库中：$ cd git_test_clone1/$ echo &quot;test push&quot; &gt;&gt;hello$ cd ../git_test_clone1/$ vim .git/config###编辑内容，添加如下###[receive]    denyCurrentBranch = ignore###编辑内容，添加如上###$ cd ../git_test_clone1$ git push /home/lv-k/temp/git_test_clone具体如下：lv-k@quietheart:~/temp$ cd git_test_clone1/lv-k@quietheart:~/temp/git_test_clone1$ echo &quot;test push&quot; &gt;&gt;hellolv-k@quietheart:~/temp/git_test_clone1$ git push /home/lv-k/temp/git_test_cloneEverything up-to-datelv-k@quietheart:~/temp/git_test_clone1$ cat /home/lv-k/temp/git_test_clonecat: /home/lv-k/temp/git_test_clone: Is a directorylv-k@quietheart:~/temp/git_test_clone1$ cat /home/lv-k/temp/git_test_clone/hellohello worldhello worldhello worldchange in masterhello after clonelv-k@quietheart:~/temp/git_test_clone1$ git commit -a -m &#39;to be pushed&#39;[master c478225] to be pushed Committer: lv-k &lt;lv-k@quietheart.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:    git config --global user.name &quot;Your Name&quot;    git config --global user.email you@example.comAfter doing this, you may fix the identity used for this commit with:    git commit --amend --reset-author 1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test_clone1$ git status# On branch master# Your branch is ahead of &#39;origin/master&#39; by 2 commits.#nothing to commit (working directory clean)lv-k@quietheart:~/temp/git_test_clone1$ git pullFrom /home/lv-k/temp/git_test_clone   83548b1..bf44b20  master     -&gt; origin/masterAlready up-to-date.lv-k@quietheart:~/temp/git_test_clone1$ git status# On branch master# Your branch is ahead of &#39;origin/master&#39; by 1 commit.#nothing to commit (working directory clean)lv-k@quietheart:~/temp/git_test_clone1$ git pushCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 339 bytes, done.Total 3 (delta 1), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.remote: error: refusing to update checked out branch: refs/heads/masterremote: error: By default, updating the current branch in a non-bare repositoryremote: error: is denied, because it will make the index and work tree inconsistentremote: error: with what you pushed, and will require &#39;git reset --hard&#39; to matchremote: error: the work tree to HEAD.remote: error: remote: error: You can set &#39;receive.denyCurrentBranch&#39; configuration variable toremote: error: &#39;ignore&#39; or &#39;warn&#39; in the remote repository to allow pushing intoremote: error: its current branch; however, this is not recommended unless youremote: error: arranged to update its work tree to match what you pushed in someremote: error: other way.remote: error: remote: error: To squelch this message and still keep the default behaviour, setremote: error: &#39;receive.denyCurrentBranch&#39; configuration variable to &#39;refuse&#39;.To /home/lv-k/temp/git_test_clone/ ! [remote rejected] master -&gt; master (branch is currently checked out)error: failed to push some refs to &#39;/home/lv-k/temp/git_test_clone/&#39;lv-k@quietheart:~/temp$ cd ../git_test_clone/lv-k@quietheart:~/temp/git_test_clone$ git config --bool core.bare truelv-k@quietheart:~/temp$ cd ../git_test_clone1/lv-k@quietheart:~/temp/git_test_clone1$ git pushCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 339 bytes, done.Total 3 (delta 1), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.To /home/lv-k/temp/git_test_clone/   bf44b20..c478225  master -&gt; masterlv-k@quietheart:~/temp/git_test_clone1$ cat ../git_test_clone/hellohello worldhello worldhello worldchange in masterhello after clonelv-k@quietheart:~/temp$ cd git_test_clone/lv-k@quietheart:~/temp/git_test_clone$ git reset --hardfatal: This operation must be run in a work treelv-k@quietheart:~/temp/git_test_clone$ git  config --bool core.bare falselv-k@quietheart:~/temp/git_test_clone$ git reset --hardHEAD is now at c478225 to be pushedlv-k@quietheart:~/temp/git_test_clone$ cat hello hello worldhello worldhello worldchange in masterhello after clonetest pushlv-k@quietheart:~/temp/git_test_clone$ vim .git/config添加如下：[receive]    denyCurrentBranch = ignorelv-k@quietheart:~/temp$ cd git_test_clone1lv-k@quietheart:~/temp/git_test_clone1$ echo &quot;push2&quot; &gt;&gt;hellolv-k@quietheart:~/temp/git_test_clone1$ git commit -a -m &#39;push2&#39;[master 8b45c2f] push2 Committer: lv-k &lt;lv-k@quietheart.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:    git config --global user.name &quot;Your Name&quot;    git config --global user.email you@example.comAfter doing this, you may fix the identity used for this commit with:    git commit --amend --reset-author   1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test_clone1$ git pushCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 332 bytes, done.Total 3 (delta 1), reused 0 (delta 0)  Unpacking objects: 100% (3/3), done.   To /home/lv-k/temp/git_test_clone/   c478225..8b45c2f  master -&gt; master  lv-k@quietheart:~/temp$ cd git_test_clonelv-k@quietheart:~/temp/git_test_clone$ lsexample  hello  mydirlv-k@quietheart:~/temp/git_test_clone$ cat hello hello worldhello worldhello worldchange in masterhello after clonetest pushlv-k@quietheart:~/temp/git_test_clone$ git reset --hardHEAD is now at 8b45c2f push2lv-k@quietheart:~/temp/git_test_clone$ cat hello hello worldhello worldhello worldchange in masterhello after clonetest pushpush2这里我们可见，本地修改之后，直接使用git push无法提交，还需要远端用git config --bool core.bare true配置好之后，才能push，push之后，如果远端也在同样分支上面，并不能立即反应，需要将core.bare设置为&quot;false&quot;然后再git reset --hard。根据网上查询的资料，push无法进行有如下解决方法：方法1：    git config --bool core.bare true方法2：修改.git/config添加如下代码：[receive]    denyCurrentBranch = ignore我们使用第1个方法，比较麻烦，使用第二个方法，就不用再从服务端重新设置&quot;core.bare&quot;了。另外，参考资料还提到，最好用git -bare init初始化库，而不是git init，本例子因为使用git init初始化，所以这样。待整理版本回退的实践：这里分别对reset,revert,checkout三种方式进行一下实践具体过程如下：lv-k@quietheart:~/temp$ git clone git_test git_test_clone2Cloning into git_test_clone2...done.lv-k@quietheart:~/temp$ cd git_test_clone2/lv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit 8a95074a30e32a4df3cdf50648fce2d6a0a73a97| Author: lv-k &lt;lv-k@quietheart.(none)&gt; | Date:   Thu Feb 9 18:00:10 2012 +0800 | |     change in quietheart|  *commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|  *commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:29:00 2012 +0800| |     add modify|  *commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;  Date:   Thu Feb 9 16:59:04 2012 +0800   initial commit contentslv-k@quietheart:~/temp/git_test_clone2$ git reset --hard fa4abf6455aa01cf7d74810b96e2279983287fc8HEAD is now at fa4abf6 add modify2lv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|*commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt; | Date:   Thu Feb 9 17:29:00 2012 +0800 ||     add modify|*commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;   Date:   Thu Feb 9 16:59:04 2012 +0800      initial commit contentslv-k@quietheart:~/temp/git_test_clone2$ git pullUpdating fa4abf6..8a95074Fast-forward example |    1 + 1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit 8a95074a30e32a4df3cdf50648fce2d6a0a73a97| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 18:00:10 2012 +0800| |     change in quietheart|  *commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|  *commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:29:00 2012 +0800| |     add modify|  *commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;  Date:   Thu Feb 9 16:59:04 2012 +0800     initial commit contentslv-k@quietheart:~/temp/git_test_clone2$ git revert fa4abf6455aa01cf7d74810b96e2279983287fc8...自动打开编辑器，编辑log，退出编辑器（不用保存）...[quietheart d707529] Revert &quot;add modify2&quot; Committer: lv-k &lt;lv-k@quietheart.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:    git config --global user.name &quot;Your Name&quot;    git config --global user.email you@example.comAfter doing this, you may fix the identity used for this commit with:   git commit --amend --reset-author 1 files changed, 0 insertions(+), 1 deletions(-)lv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit d707529ef6ed1b2bca493d22d367e56751ae3f3d| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Jun 14 16:24:51 2012 +0800| |     Revert &quot;add modify2&quot;|     |     This reverts commit fa4abf6455aa01cf7d74810b96e2279983287fc8.|  *commit 8a95074a30e32a4df3cdf50648fce2d6a0a73a97| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 18:00:10 2012 +0800| |     change in quietheart|  *commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|  *commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:29:00 2012 +0800| |     add modify|  *commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;  Date:   Thu Feb 9 16:59:04 2012 +0800   initial commit contentslv-k@quietheart:~/temp/git_test_clone2$ git diff d707529ef6ed1b2bca493d22d367e56751ae3f3d:hello 07ee8b68e90a470aec9a5194079e54332093fc70:hellolv-k@quietheart:~/temp/git_test_clone2$ git reset --hard fa4abf6455aa01cf7d74810b96e2279983287fc8HEAD is now at fa4abf6 add modify2lv-k@quietheart:~/temp/git_test_clone2$ git pullUpdating fa4abf6..8a95074Fast-forward example |    1 + 1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit 8a95074a30e32a4df3cdf50648fce2d6a0a73a97| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 18:00:10 2012 +0800| |     change in quietheart|  *commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|  *commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:29:00 2012 +0800| |     add modify|  *commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;  Date:   Thu Feb 9 16:59:04 2012 +0800   initial commit contentslv-k@quietheart:~/temp/git_test_clone2$ git checkout fa4abf6455aa01cf7d74810b96e2279983287fc8Note: checking out &#39;fa4abf6455aa01cf7d74810b96e2279983287fc8&#39;.You are in &#39;detached HEAD&#39; state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example:  git checkout -b new_branch_nameHEAD is now at fa4abf6... add modify2lv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|  *commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:29:00 2012 +0800| |     add modify|  *commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;  Date:   Thu Feb 9 16:59:04 2012 +0800   initial commit contentslv-k@quietheart:~/temp/git_test_clone2$ git commit -a -m &#39;add&#39;[detached HEAD 9bd6059] add Committer: lv-k &lt;lv-k@quietheart.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:   git config --global user.name &quot;Your Name&quot;   git config --global user.email you@example.comAfter doing this, you may fix the identity used for this commit with:   git commit --amend --reset-author 1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit 9bd605958283f6b33264af3ec6c9a0faa07feb55| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Jun 14 16:28:51 2012 +0800| |     add|  *commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|  *commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:29:00 2012 +0800| |     add modify|  *commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;  Date:   Thu Feb 9 16:59:04 2012 +0800      initial commit contentslv-k@quietheart:~/temp/git_test_clone2$ git checkout 8a95074a30e32a4df3cdf50648fce2d6a0a73a97Warning: you are leaving 1 commit behind, not connected toany of your branches:  9bd6059 addIf you want to keep it by creating a new branch, this may be a good timeto do so with: git branch new_branch_name 9bd605958283f6b33264af3ec6c9a0faa07feb55HEAD is now at 8a95074... change in quietheartlv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit 8a95074a30e32a4df3cdf50648fce2d6a0a73a97| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 18:00:10 2012 +0800| |     change in quietheart|  *commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|  *commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:29:00 2012 +0800| |     add modify|  *commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;  Date:   Thu Feb 9 16:59:04 2012 +0800   initial commit contents这里，根据前面的运行可知，reset可以将包括注释以及以前的提交全部清除，实现根本的回退；revert只是将指定版本的内容做为新的HEAD重新提交（类似打反向补丁），并且不会清除已有原来的提交；checkout是检出一个版本，已有的版本信息仍然保存在库中，但是在检出的旧版本上提交会导致新的分支。没有解决的问题：使用git checkout &lt;commit id&gt;可以提取以前的版本，并且也可以回到以前之后的版本，但是如何回到以前的版本之后，知道以后有什么版本？参考资料本文实践的库http://www.cnblogs.com/abeen/archive/2010/06/17/1759496.htmlhttp://stackoverflow.com/questions/2816369/git-push-error-remote-rejected-master-master-branch-is-currently-checked-ouman gittutorial  作者：QuietHeartEmail：quiet_heart000@126.com日期：2012年6月14日  ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2012-06-14]<a href="/categories/study/git/git_basic.html"> 使用git进行版本控制  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = '努力'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '我正在努力着让自己成为一个真正努力的人……From:努力 in cublog';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2011-04-04]<a href="/categories/others/rambles/213516cublog.html"> 努力  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = '清明'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '清明时节雨纷纷，路上行人欲断魂，借问酒家何处有，牧童遥指杏花村。From:清明 in cublog';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2011-04-02]<a href="/categories/others/rambles/211013cublog.html"> 清明  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-09其他'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '查看vim的简易教程：输入:!vimtutor.这里实际vimtutor是shell终端下的一个命令，这里实际是执行的shell命令，可以在终端直接输入vimtutor。  保存与恢复上次的编辑状态：  保存会话与状态，步骤如下：输入:cd src。这将切换到./src目录输入:mksession vim70.vim这将在./src目录创建一个会话文件，该会话文件保存了当前的窗口状态（例如打开几个窗口）输入:wviminfo vim70.viminfo这将在./src目录创建一个viminfo文件，该会话文件保存了当前的命令历史，缓冲等等状态。输入:qa这样，退出vim。根据上次保存的文件恢复会话与状态，步骤如下：1）输入:source ~/src/vim70/src/vim70.vim    这样，载入vim70.vim会话文件(mksession建立的不一定非要.vim后缀)，当前立即会出现上次保存vim70.vim时候的窗口布局状态。2）输入rviminfo vim70.viminfo    这样，读入viminfo文件（wviminfo建立的），当前的历史、缓冲等状态会被恢复（如set nu等）。更新并重新载入.vimrc：输入:source ~/.vimrc。这里，当我们修改完了.vimrc文件之后，执行这句话，不用重启vim就能载入.vimrc中的新设置。  查找当前光标位置单词的man手册：输入[Shift]k.这个命令经常用来查某个库函数，等同于:!man &lt;当前光标单词&gt;。  显示所有命令：输入:[Ctrl]d.按[Tab]可以依次选择每一个。  显示所有以e开始的命令：输入:e[Ctrl]d.这里先在命令模式下面输入一个字母e（其他字母类似），然后按[Ctrl]D就会显示所有以e开始的命令。按[TAB]选择一个命令。  在vi中暂时进入shell:输入:shell.这样,临时从vi进入shell,当前路径就是刚才vi的路径。从shell返回vi,则敲入exit。  一个基于vi的比较工具，vimdiffvimdiff可以同时打开两个或者多个文件,进行比较。它会将两个文件的相同指出尽量列在同一位置上面，便于查对比较。其实vimdiff就是vim，只是一个符号链接而已，你可以用file /etc/alternatives/*|grep bin/vim看看, 其命令基本和vim是一致的。  命令格式:vimdiff [options] file1 file2 [file3]  启动后，vimdiff使用vim加载两个或者多个文件，每个文件有其自己的窗口。每个文件中不同的地方会用高亮显示出来。它在进行改变的检查以及将改动从一个版本的文件移动到另一个版本的情况下非常方便。首先你得保证安装了vim才能是用vimdiff.用这个命令安装：#apt-get install vim-full其他类似的工具还tkdiff,meld 和 xfdiff4等。   同时打开main.cpp和main2.cpp，垂直方向分屏:输入$vimdiff main.cpp main2.cpp或$vim -d main.cpp main2.cpp这样会同时打开两个文件垂直在两栏显示，可以打开不止两个文件。同时打开main.cpp和main2.cpp，水平方向分屏：$vimdiff -o main.cpp main2.cpp这样会同时打开两个文件在上下两栏显示.打开文件之后可以看见不同的地方会高亮显示，相同的地方默认会被折叠起来。如下常用操作：  跳到下一个不同的地方:输入]c.跳到上一个不同的地方：输入[c.用另外一个窗口的不同处替换当前：输入do.这里，前提是用]c或者[c跳到相应的不同处,执行完毕之后，当前窗口当前位置内容被替换为另外一个窗口的当前位置内容。注意这里是两个文件的情况,当前窗口有多于两个文件时无法进行。先指定范围1-100行，再用另外一个窗口的不同处替换当前：输入1,100 diffg.或输入1,100 diffget.这里，等同于do不过指定了范围，如果有缓冲还可在diffg后面指定缓冲名字。先指定范围1-100行，再用指定3号缓冲(假设是文件file3)的不同处替换当前：输入1,100 diffg 3.或输入1,100 diffget 3.这里，在diffg后面指定缓冲名字。用当前替换另外一个窗口的不同处：输入dp.这里，前提是用]c或者[c跳到相应的不同处,执行完毕之后，另外一个窗口的当前位置内容被替换成当前窗口当前的位置内容。注意这里是两个文件的情况,当前窗口有多于两个文件时无法进行。先指定范围1-100行，再用另外一个窗口的不同处替换当前：输入1,100 diffpu.或输入1,100 diffput.这里，等同于dp不过指定了范围，如果有缓冲还可在diffpu后面指定缓冲名字。先指定范围1-100行，再用指定3号缓冲(假设是文件file3)的不同处替换当前：输入1,100 diffpu 3.或输入1,100 diffput 3.这里，在diffpu后面指定缓冲名字。新开一个水平窗口载入file文件进行对比：输入:diffsplit file.这里新开的窗口是水平排列的,在不同窗口间移动的命令同vim。新开一个垂直窗口载入file文件进行对比：输入vert diffsplit file.这里,vert实际是vertical前缀的简写。新开的窗口是垂直排列的,在不同窗口间移动的命令同vim。强制更新文件的不同状态：输入:diffupdate.这里，当我们修改某一个文件的时候，vim会试图使它和另外一个文件的不同之处保持更新，例如插入和删除行。但是，更复杂的修改或者在一个行内的修改可能会导致不同处(vimdiff)没有及时更新，这时候可以运行这个命令diffupdate进行强制更新。修改缺省的上下文行为3行:输入:set diffopt=context:3.这里vimdiff 缺省是会把不同之处上下各 6 行的文本都显示出来以供参考。其他的相同的文本行被自动折叠。如果希望修改缺省的上下文行数，可以这样设置.打开折叠的文本：输入zo.折叠折叠的文本：输入zc.修改完毕之后保存所有文件：输入wqa.杂项  关于vim的配置文件：如果让vim启动自动执行某些命令可以在主目录（~/）下建立一个.vimrc文件，填入相关命令即可。Vim启动时会自动读取这个文件，当然可以在编辑文件的状态下输入:source ~/.vimrc实时读取该文件，这样修改了这个文件的时候就不用重新启动vim了。例如：设置vi启动后，不备份当前修改文件，输入：echo &#39;set nobackup&#39; &gt;&gt;~/.vimrc ，这样相当于把set nobackup加到.vimrc中去了。  举例：一个简单的程序员的vi编辑器, 创建或修改~/.vimrc文件,内容如下:  set tabstop=4  set softtabstop=4  set shiftwidth=4  set autoindent  set cindent  set number  set showmatch  set mouse=a  更多的选项，具体有待研究，如：  打开语法高亮：输入:syntax enable。或输入:syntax on。这里前者设置完了还可以用hilight设置自己喜欢的颜色，后者只用默认的颜色（??help这样说??）；都只在当前编辑中起作用。换行时自动缩进：输入:set si。或输入:set smartindent。红色的不确定据说X/Windows 的剪贴板的内容是存在寄存器+中，粘贴命令为：输入&quot;+P.将简单的 y 和 p命令与系统剪贴板联系起来:输入:set clipboard+=unnamed &quot; set clipboard.注释代码块的步骤：先移到第一行，输入 I// (就是ESC键).这样，将第一行注释。移到第二行，按 V 进行 line visual mode，再按j 或其它方向移动键选好要注释的所有代码行。最后按..实际这只是在visual mode 里使用 redo 的功能而已。这样应该就将许多代码块一并注释了。（可以看看先用V选择，再i插入//）用一個 &#39;適當&#39; 的 space數量取代 tab：输入:set expandtab.这里，需要和shiftwidth一块使用，在多人一起开发项目时，为了使代码风格尽量保持一致，一般不允许在代码使用TAB符，而以4个空格代之。我们可以编辑一个文件，包含下面的内容：  set shiftwidth=4  set expandtab  遇到make不做expandtab：输入:au FileType make set noexpandtab.这里，make和python中[Tab]有特殊的含义，所以不做[Tab]向[Space]的转换。  遇到python不做expandtab：输入:au FileType python set noexpandtab.这里，make和python中[Tab]有特殊的含义，所以不做[Tab]向[Space]的转换。据说可以把下面的命令加入到.vimrc中：autocmd FileType c,cpp set shiftwidth=4 | set expandtab就可以只在编辑c和cpp文件时实行相应的设置了  快速输入匹配的小技巧这里介绍一个小技巧，可以快速输入{},()等匹配对里面的内容。  经常在编程的时候输入{},()等等需要成对输入的元素，如果不一下输入一对，很容易就会忘记了匹配，这是一个好习惯，但是这样，我们在往匹配对里面输入字符的时候还要按方向键进入匹配对里面，输入之后还要再按方向键从匹配对里面出来，这样很麻烦，手的动作很大，所以我用如下方法解决这个问题。  原理：利用vim里面编辑状态的[Ctrl]o临时切换程命令行状态执行命令，然后自动回到编辑状态。  举例：如果我输入{good}a，则：  输入{}。这里意思是先输入匹配对输入[Ctrl]o.临时切换到命令行状态输入i.命令行状态下}一般都会在行尾，所以按i就回到了{}里面；注意如果按左方向键，就到了{}的左面了，当然若你的{}不在行尾的话可以用左方向键进入{}。 输入good.这里，自动回到了编辑状态，所以输入的good是在{}里面的。 输入[Ctrl]o.这里输入完了{}的内容，想要从{}出来，所以又临时切换成命令模式。 输入o.或输入a.如果输入o则在新行继续输入你要输入的内容，如果输入a则在{}的后面继续输入你要输入的内容。 继续输入你想要输入的内容。过程说着很麻烦，但是，如果实践一下很简单的，任何知识都是说着麻烦做着简单的。试试看，你一定会有所收获，如果养成了习惯，一定会提高效率的。根据原理，你还可以扩展其它的类似技巧。_^配置cscope配置好cscope之后，可以在代码中完成函数跳转、搜索代码标号、以及查看被调用函数、搜索文件等等。cscope与ctags的不同之处在于，cscope产生的索引是静态的，文件内容改变之后，定位信息就不准确了。可以在vim的配置中加入相关的配置，如cscope.vim的内容如下：  &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; CSCOPE settings for vim           &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; This file contains some boilerplate settings for vim&#39;s cscope interface,&quot; plus some keyboard mappings that I&#39;ve found useful.&quot;&quot; USAGE: &quot; -- vim 6:     Stick this file in your ~/.vim/plugin directory (or in a&quot;               &#39;plugin&#39; directory in some other directory that is in your&quot;               &#39;runtimepath&#39;.&quot;&quot; -- vim 5:     Stick this file somewhere and &#39;source cscope.vim&#39; it from&quot;               your ~/.vimrc file (or cut and paste it into your .vimrc).&quot;&quot; NOTE: &quot; These key maps use multiple keystrokes (2 or 3 keys).  If you find that vim&quot; keeps timing you out before you can complete them, try changing your timeout&quot; settings, as explained below.&quot;&quot; Happy cscoping,&quot;&quot; Jason Duell       jduell@alumni.princeton.edu     2002/3/7&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; This tests to see if vim was configured with the &#39;--enable-cscope&#39; option&quot; when it was compiled.  If it wasn&#39;t, time to recompile vim... if has(&quot;cscope&quot;)    &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; Standard cscope/vim boilerplate    &quot; use both cscope and ctag for &#39;ctrl-]&#39;, &#39;:ta&#39;, and &#39;vim -t&#39;    set cscopetag    &quot; check cscope for definition of a symbol before checking ctags: set to 1    &quot; if you want the reverse search order.    set csto=0    &quot; add any cscope database in current directory    if filereadable(&quot;cscope.out&quot;)        cs add cscope.out      &quot; else add the database pointed to by environment variable     elseif $CSCOPE_DB != &quot;&quot;        cs add $CSCOPE_DB    endif    &quot; show msg when any other cscope db added    set cscopeverbose      &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; My cscope/vim key mappings    &quot;    &quot; The following maps all invoke one of the following cscope search types:    &quot;    &quot;   &#39;s&#39;   symbol: find all references to the token under cursor    &quot;   &#39;g&#39;   global: find global definition(s) of the token under cursor    &quot;   &#39;c&#39;   calls:  find all calls to the function name under cursor    &quot;   &#39;t&#39;   text:   find all instances of the text under cursor    &quot;   &#39;e&#39;   egrep:  egrep search for the word under cursor    &quot;   &#39;f&#39;   file:   open the filename under cursor    &quot;   &#39;i&#39;   includes: find files that include the filename under cursor    &quot;   &#39;d&#39;   called: find functions that function under cursor calls    &quot;    &quot; Below are three sets of the maps: one set that just jumps to your    &quot; search result, one that splits the existing vim window horizontally and    &quot; diplays your search result in the new window, and one that does the same    &quot; thing, but does a vertical split instead (vim 6 only).    &quot;    &quot; I&#39;ve used CTRL-\ and CTRL-@ as the starting keys for these maps, as it&#39;s    &quot; unlikely that you need their default mappings (CTRL-\&#39;s default use is    &quot; as part of CTRL-\ CTRL-N typemap, which basically just does the same    &quot; thing as hitting &#39;escape&#39;: CTRL-@ doesn&#39;t seem to have any default use).    &quot; If you don&#39;t like using &#39;CTRL-@&#39; or CTRL-\, , you can change some or all    &quot; of these maps to use other keys.  One likely candidate is &#39;CTRL-_&#39;    &quot; (which also maps to CTRL-/, which is easier to type).  By default it is    &quot; used to switch between Hebrew and English keyboard mode.    &quot;    &quot; All of the maps involving the macro use &#39;^$&#39;: this is so    &quot; that searches over &#39;#include &quot; return only references to    &quot; &#39;time.h&#39;, and not &#39;sys/time.h&#39;, etc. (by default cscope will return all    &quot; files that contain &#39;time.h&#39; as part of their name).    &quot; To do the first type of search, hit &#39;CTRL-\&#39;, followed by one of the    &quot; cscope search types above (s,g,c,t,e,f,i,d).  The result of your cscope    &quot; search will be displayed in the current window.  You can use CTRL-T to    &quot; go back to where you were before the search.      &quot;    nmap s :cs find s =expand(&quot;&quot;)    nmap g :cs find g =expand(&quot;&quot;)    nmap c :cs find c =expand(&quot;&quot;)    nmap t :cs find t =expand(&quot;&quot;)    nmap e :cs find e =expand(&quot;&quot;)    nmap f :cs find f =expand(&quot;&quot;)    nmap i :cs find i ^=expand(&quot;&quot;)$    nmap d :cs find d =expand(&quot;&quot;)    &quot; Using &#39;CTRL-spacebar&#39; (intepreted as CTRL-@ by vim) then a search type    &quot; makes the vim window split horizontally, with search result displayed in    &quot; the new window.    &quot;    &quot; (Note: earlier versions of vim may not have the :scs command, but it    &quot; can be simulated roughly via:    &quot;    nmap s :cs find s =expand(&quot;&quot;)    nmap s :scs find s =expand(&quot;&quot;)    nmap g :scs find g =expand(&quot;&quot;)    nmap c :scs find c =expand(&quot;&quot;)    nmap t :scs find t =expand(&quot;&quot;)    nmap e :scs find e =expand(&quot;&quot;)    nmap f :scs find f =expand(&quot;&quot;)    nmap i :scs find i ^=expand(&quot;&quot;)$    nmap d :scs find d =expand(&quot;&quot;)    &quot; Hitting CTRL-space *twice* before the search type does a vertical     &quot; split instead of a horizontal one (vim 6 and up only)    &quot;    &quot; (Note: you may wish to put a &#39;set splitright&#39; in your .vimrc    &quot; if you prefer the new window on the right instead of the left    nmap s :vert scs find s =expand(&quot;&quot;)    nmap g :vert scs find g =expand(&quot;&quot;)    nmap c :vert scs find c =expand(&quot;&quot;)    nmap t :vert scs find t =expand(&quot;&quot;)    nmap e :vert scs find e =expand(&quot;&quot;)    nmap f :vert scs find f =expand(&quot;&quot;)    nmap i :vert scs find i ^=expand(&quot;&quot;)$    nmap d :vert scs find d =expand(&quot;&quot;)    &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; key map timeouts    &quot;    &quot; By default Vim will only wait 1 second for each keystroke in a mapping.    &quot; You may find that too short with the above typemaps.  If so, you should    &quot; either turn off mapping timeouts via &#39;notimeout&#39;.    &quot;    &quot;set notimeout     &quot;    &quot; Or, you can keep timeouts, by uncommenting the timeoutlen line below,    &quot; with your own personal favorite value (in milliseconds):    &quot;    &quot;set timeoutlen=4000    &quot;    &quot; Either way, since mapping timeout settings by default also set the    &quot; timeouts for multicharacter &#39;keys codes&#39; (like ), you should also    &quot; set ttimeout and ttimeoutlen: otherwise, you will experience strange    &quot; delays as vim waits for a keystroke after you hit ESC (it will be    &quot; waiting to see if the ESC is actually part of a key code like ).    &quot;    &quot;set ttimeout     &quot;    &quot; personally, I find a tenth of a second to work well for key code    &quot; timeouts. If you experience problems and have a slow terminal or network    &quot; connection, set it higher.  If you don&#39;t set ttimeoutlen, the value for    &quot; timeoutlent (default: 1000 = 1 second, which is sluggish) is used.    &quot;    &quot;set ttimeoutlen=100endif';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_09Others.html"> Vim实践与学习-09其他  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-08配置相关'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '查看vim的版本及功能：输入:version.这样会显示当前vim的版本，编译选项，vim配置路径等信息。  查看所有set选项:输入:set all.或输入:se all.这样可以查看所有可以设置的选项。  显示当前set设置：输入:set.或输入:se这样，可以显示当前set设置。  显示制定选项的设置:输入:set {option}?.或输入:se {option}?这里，可以查看选项{option}的值，例如:set nu?可以查看是nu或是nonu（是否显示行号）。  显示所有行行号：输入:set nu。  设置搜索时显示高亮：输入:set hls。或输入set hlsearch。  取消搜索时高亮显示：输入:set nohls。或输入:set nohlsearch。或输入:nohl.这里，查找一个字符，程序会用高亮显示出来，这样设置就不高亮了，当然查找一个不存在的字符也可取消当前高亮状态。通过:nohlsearch只是暂时关闭高亮显示，下次搜索时将自动恢复高亮(当然是在一次启动vim的期间，如果关闭vim再重新启动，那么状态是.vimrc规定的)。高亮就不能用:hls需要用:set hls.实践发现，:set nohls之后，关闭vi,再打开之后上次搜索的还是高亮状态，但是用:nohls之后再打开那么上次的搜索就不是高亮了.  搜索时忽略大小写：输入set ic.这样输入/进行搜索的时候，就不考虑大小写了。  取消搜索时忽略大小写：输入set noic.也即搜索不忽略大小写，这也是默认的情况。  对netrw插件（文件浏览）窗口方向的配置：输入:let g:netrw_preview=0.或输入:let g:netrw_preview=1.设置内部变量g:netrw_preview.假设光标在目录的某一个文件上面，如果为0（默认）则按p的时候水平开窗口预览文件，为1则垂直。  高亮当前行：输入:set cursorline.或输入:set cul.这样光标当前行会有一个下划线。  取消高亮当前行：输入:set no cursorline.或输入:set no cul.这样取消了当前行的下划线。  在’complete‘选项中去掉i标记:输入:set complete -=i如果CTRL-N和CTRL-P补全时查找所包含的头文件，耗时会比较久。此时，可以在 ’complete‘ 选项中去掉i标记:set complete-=i 。  让vi自动缩进对齐代码:输入:set ai.或输入:set autoindent.这样在你敲入一个新行的时候,会自动将上一行的缩进拷贝过来,这样上下两行的缩进就会一样了,并且即使输入{之后,再新起一行也会这样,而不是多缩进一个,为了保持代码的语法缩进输入{之后新行要手动再输入一个缩进.如果该行没有任何内容就进入下一行,那么这个缩进会自动被删除.  让vi智能缩进对齐代码:输入:set si.或输入:set smartindent.亦或:set cindent.这里，si是smartindent的简写，它比ai智能，而ai只管复制上一行缩进。如果有si那么ai就会自动也有了，并且在输入{或者一些cinwords关键字的时候会自动插入一个缩进(不止是复制，还多插入一个缩进，这导致输入这样字符之后新起一行看起来像是自动又缩进了)，而且输入}的时候如果它是一行的第一个字符会自动让它和与它匹配的那个{取相同的缩进。smartindent和cindent有点不一样，前者在多数语言中比较通用，而后者比较严格像c.cindent如果打开那么smartindent就会关闭。  设置在敲},]或)显示出对应匹配的{,[或(:输入:set sm.这样,在敲入右半括号的时候会自动把前面的左半括号高亮一下.  设置简写：输入:ab.这里，会将做为的简写，例如：输入:ab usa United States of America之后，当你在文见里插入 usa 之后，按下回车或空格等，这时 United States of America 就蹦出来了。  设置显示的颜色主题为ron：输入:color ron.或输入:colorscheme ron.这里，ron主题是我个人感觉比较好看的一种主题，可以先输入:colorscheme再[Ctrl]d可以查看所有的可选主题。  打开语法高亮：输入:syntax on.或输入:syn on.这里，syntax还有enable等值，具体察看:help syntax,之后搜索syntax on.  关于缩进的宽度：  一個tab用4个space寬度顯示：输入:set tabstop=4.这里，定义tab所等同的空格长度，一般来说最好设置成8，因为如果是其它值的话，可能引起文件在打印之类的场合中看起来很别扭。除非你设置了 expandtab模式，也就是把tabs转换成空格，这样的话就不会一起混淆，不过毕竟制表符为8是最常用最普遍的设置，所以一般还是不要改。一個縮排 (indent) 跳的 space 數为4：输入:set shiftwidth=4.或输入:set sw=4.这个是用于程序中自动缩进（(auto)indent）所使用的空白长度指示的。一般来说为了保持程序的美观，和tabstop参数最好一致。同时它也是符号移位长度的制定者。一個 tab 含幾個 space (under editing operation)：输入:set softtabstop=4.这里，若我们希望改变程序中的缩进，shiftwidth和tabstop不一样的话，你会发现程序比较难看的。这时需要设置这个softtabstop。从vim说明可知，一旦设置了softtabstop的值，你按下tab键，插入的是空格和tab制表符的混合，具体如何混合取决于你设定的softtabstop。例如，如果设定softtabstop=8,那么按下tab键，插入的就是正常的一个制表符;如果设定 softtabstop=16,那么插入的就是两个制表符；如果softtabstop=12,那么插入的就是一个制表符加上4个空格；如果 softtabstop=4呢？那么一开始，插入的就是4个空格，此时一旦你再按下一次tab，这次的四个空格就会和上次的四个空格组合起来变成一个制表符。换句话说，softtabstop是逢8空格进1制表符,前提是你tabstop=8。设置举例1(建议使用)：  set shiftwidth=4  set tabstop=4  这样，缩进的宽度和制表宽度都是4个空格的宽度，也没有前面的在Makefile等需要制表符的语法里需要敲两次[Tab]才产生一个制表符号的缺点了。  设置举例2：  set shiftwidth=4  set tabstop=8  set softtabstop=4  这样，代码自动缩进(shiftwidth)的宽度是4个空格，一个制表符的宽度(tabstop)是8个空格,按下一次[Tab]会产生4个空格，产生8个空格的时候会自动转换成一个制表符号（很智能地，删除的时候可以判断是删[Tab]产生的4个空格）。缺点是这样的设置在Makefile等需要制表符的语法里需要敲两次[Tab]才产生一个制表符号。  设置当前目录自动跟随当前文件:输入:set autochdir.或输入:set acd.这样之后，当切换到另一个文件的时候，vim的当前工作目录就会自动地切换到那个文件所在的目录。这里即使有tab标签打开多个文件，当前显示的文件，所在的目录就是vim的工作目录。取消这个选项的命令是set noacd.  不要备份编辑的文件:输入:set nobackup.这里，当vi打开一个文件开始编辑的时候，会创建一个原始文件的备份文件（一般以原名加~结尾），如果不想创建这个备份，那么就设置这个选项。一般这个选项可以和writebackup一块使用，两者的值的组合决定了不同的备份策略。当backup和writebackup同时为no的时候就会什么备份也不创建了。使用具体参见帮助help backup。一般默认的设置就是:set nobackup和:set writebackup,就是备份当前文件，过后（成功写入之后）再删除？。  备份编辑的文件：输入:set backup.这样设置之后，会在你编辑并且保存写好的文件的时候，备份文件。  ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_08Config.html"> Vim实践与学习-08配置相关  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-07显示相关'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'vi 有时候可以用特殊的方式来显示你编辑的文件，例如多个窗口等。这里就将这类相关的命令集中了。  让vi显示多个窗口（多缓冲区）:  水平分割当前窗口：输入:split。或输入:sp。这样窗口会分为上下两部份，可以继续分割；之后在某一个窗口下，可以用:n filename或者:e filename在这个窗口内载入新文件。垂直分割当前窗口：输入:vsplit。这样窗口会分为左右两部份，可以继续分割；之后在某一个窗口下，可以用:n filename或者:e filename在这个窗口内载入新文件。一次打开多个窗口：输入vi -on file1 file2。这里只用两个文件举例，同时打开file1和file2，打开的窗口按水平方向分为上下两部份。在多窗口内操作：  在上次和本次窗口间切换：输入[Ctrl]w w。跳到左边的窗口：输入[Ctrl]w h。或输入[Ctrl]w [Left]。最后一个键表示移动方向，和移动光标类似。跳到右边的窗口：输入[Ctrl]w l。或输入[Ctrl]w [right]。最后一个键表示移动方向，和移动光标类似。跳到上边的窗口：输入[Ctrl]w k。或输入[Ctrl]w [up]。最后一个键表示移动方向，和移动光标类似。跳到下边的窗口：输入[Ctrl]w j。或输入[Ctrl]w [down]。最后一个键表示移动方向，和移动光标类似。扩大当前水平窗口：输入[Ctrl]w +。这里‘＋’前面可以加输入一个数字，表示迭代次数。缩小当前水平窗口：输入[Ctrl]w -。这里‘-’前面可以加输入一个数字，表示迭代次数。扩大当前垂直窗口：输入[Ctrl]w &gt;。这里‘&gt;’前面可以加输入一个数字，表示迭代次数。缩小当前垂直窗口：输入[Ctrl]w &lt;。这里‘&lt;’前面可以加输入一个数字，表示迭代次数。最大化当前水平窗口:输入[Ctrl]w _。最大化当前垂直窗口:输入[Ctrl]w |。平分窗口:输入[Ctrl]w =。水平分割窗口：输入[Ctrl]w s.垂直分割窗口:输入[Ctrl]w v.退出当前窗口：输入:q.退出并保存当前窗口：输入：wq.退出全部窗口：输入:qa.退出并保存全部窗口：输入wqa.移动窗口上下左右移动窗口位置的命令，是CTRL-W J/K/H/L (:help CTRL-W_H, …)。前提是开了多个窗口(:split或:vsplit)。注意，这里的H, J, K, L是大写的,小写的则表示移动到相应的窗口里面了.  将窗口移动到左面：输入[Ctrl]w H.将窗口移动到右面：输入[Ctrl]w L.将窗口移动到上面：输入[Ctrl]w K.将窗口移动到下面：输入[Ctrl]w J.颜色相关：  改变颜色主题（为evening）：输入color evening。或输入colorscheme evening。改变主题颜色为默认：输入color default。或输入colorscheme default。pages tab标签打开多文件：自从Vim发布7.0之后, 就开始支持标签或者叫标签页. 不像其它程序中的普通标签, Vim的标签页就像是将你打开的文件分组的一种方法. 每个标签能够保存几个打开的缓冲, 并且也能同时处理几个窗口. 实际上一个标签中用yy在另一个page中也可以p上去的。这里给出常用命令，更多帮助可以查看:help tabpage。  启动的时候为每一个文件打开新的page：输入vi -p file1 file2注意：这里file1，file2是文件。打新page：输入tabnew。在当前tab page的后面打开一个新的空窗口的tab page.打新page并且编辑file：输入tabnew file打开新page并执行命令：输入[count] tab {cmd}.这里，新的tabpage在后面第[count]个page上面出现，:0tab {cmd}将会在第一个位置得到一个新的标签.:tab split 使用一个新的标签页打开当前的缓存,即把split的分割窗口放到两个pages里面了。:tab help gt 打开一个tab page 同时执行了:help gt命令.打开新page，并编辑在cursor下的文件:输入CTRL-W gf。关闭tab page当关闭最后一个窗口的时候也会关闭这个标签页命令如下。  关闭当前page:输入:tabclose!。这里加&#39;!&#39;是强制关闭不管保存了，tabclose可以简化为tabc，实践发现:q也行。关闭编号为{count}的page:输入:tabclose count。或输入:tabclose! count。这里加&#39;!&#39;是强制关闭不管保存了，tabclose可以简化为tabc。关闭除了自身的其他pages：输入tabonly。或输入tabonly!。这里加&#39;!&#39;是强制关闭不管保存了，tabonly可以简化为tabo。切换到另外page:  切换到下一个page：输入gt。或输入:tabnext。或输入[Ctrl]PageDown。这里，tabnext可以简化为tabn，都是循环切换的最后一个之后就是第1个(第3个方法好像不管用?)。切换到第{count}号page：输入{count}gt。或输入:tabnext {count}。或输入{count}[Ctrl]PageDown。这里，tabnext可以简化为tabn，第一个page是1，都是循环切换的(第3个方法好像不管用?)。切换到上一个page：输入gT。或输入:tabprevious。或输入:tabN[ext]。或输入[Ctrl]PageUp。这里，tabprevious可简化为tabp，tabNext可简化为tabN,没有tabP，切换循环,第1个之后就是最后一个(第4个方法好像不管用?).切换到前{count}个page:输入{count}gT。或输入:tabprevious{count}。或输入:tabNext{count}。或输入{count}[Ctrl]PageUp。也就是后退{count} page，也是循环的，tabprevious可简化为tabp，tabNext可简化为tabN(第4个方法好像不管用?)。去第一个page:输入:tabfirst。这里tabfirst可简化为tabfir。去最后一个page:输入:tablast。这里tablast可简化为tabl。列出所有pages它们包含的windows:输入:tabs。这里结果中&gt;是当前的window，+是被修改的缓存。移动当前page到第N个后面：输入tabmove[N]。这里，tabmove可以简化为tabm使用0表示移动当前page成为第1个，不使用N表示当前page成为最后一个。在每一个page 中执行命令{cmd}输入:tabd[o] {cmd}。注意的是：它只执行每个page的当前窗口，如果有一个窗口出现了错误，那么就中断后面的访问。这里，tabdo可以简化为tabd。文件浏览：在vim 7.0以前，文件浏览功能由explorer.vim插件提供，在vim 7.0中，这个插件被netrw.vim插件所代替。这里说得是netrw.vim插件。使用vim尝试打开目录时，vim会自动调用netrw.vim插件打开该目录。  打开当前文件的目录:输入:E。水平分割窗口，并打开当前文件目录:输入:He。或输入:Se。垂直分割窗口，并打开当前文件目录:输入:Ve。在前一个窗口打开文件:输入:P。这里，假设光标在目录的某一个文件上面，则在上次打开的窗口打开该文件（适合多文件窗口）.新开一个垂直窗口，打开该文件：输入:v。假设光标在目录的某一个文件上面，则新开一个垂直窗口，打开该文件。新开一个水平窗口预览文件：输入:p。假设光标在目录的某一个文件上面，新开一个水平窗口预览文件，光标仍在该目录中，如果换其他文件再按p则仍在上面的预览窗口中显示新文件新开一个标签打开文件输入:t。假设光标在目录的某一个文件上面，新开一个标签打开文件。以不同模式显示目录中文件：输入i。这里，直接输入i就以不同的模式循环切换显示目录中的文件，如树型，列表等等。更多的命令查看帮助：输入：[F1]下面,列出一些简短的常用操作：  &gt; 显示帮助  &gt; 如果回车，光标下为目录，则进入该目录；光标下是文件，则打开该文件  &gt; -           返回上级目录  &gt; c           切换vim的当前工作目录为正在浏览的目录  &gt; d           创建目录  &gt; D           删除文件或目录  &gt; i           切换显示方式  &gt; R           改名文件或目录  &gt; s           选择排序方式  &gt; x           定制浏览方式，使用你指定的程序打开该文件  关于历史窗口：  打开命令历史：输入q:.这样，就可以打开命令历史窗口，查看以前输入过的命令行命令（就是在:提示符号后面输入的命令）。选择其中的任何一个回车，相应的命令都会被执行。在最后一个空行上面回车就退出相应窗口。打开查找历史：输入q/.这样，就可以打开查找历史窗口，查看以前查找过的字符串。选择其中的任何一个回车，相应的查找都会被执行。在最后一个空行上面回车就退出相应窗口。';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_07View.html"> Vim实践与学习-07显示相关  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-06编程'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '这里的内容是针对编程序或者阅读源代码时候使用的，本来它的有些内容可以属于其它类的，但是这里单独用&quot;编程相关&quot;将这类命令集中起来了。编译并自动定位第一个错误：输入:make filename。注意：在vi中编译test.c,直接用:make test就可以了,注意是不带后缀的哟。如果有makefile的话可以再vi直接敲:make，然后就能够定位到第一个错误上面了。关于ctags跳转：通常我们需要使用名为ctags的程序来生成这样的tag文件。vim能直接使用ctags程序所生成的tag文件。  安装ctags：  $sudo apt-get install ctags注意这里是在ubuntu下。为当前目录文件生成tags文件：  $ctags -R ./或  $ctags -R这里，如果ctags -R ../将会也生成父目录文件的tags，ctags利用tags进行跳转。载入当前标签：输入:set tags=tags.这将载入（当前目录的）所需标签文件，如果不载入则没有ctags所需要的tags文件，为了实现自动载入启动可以在~/.vimrc加入如下内容：  if has(&quot;ctags&quot;)    if filereadable(&quot;tags&quot;)        set tags=tags    endifendif直接打开文件并跳转到函数:    $vim -t func这样，将打开vim并且直接跳转到func函数的位置。跳转到当前光标函数实现内部：输入[Ctrl]].实现这个功能需要有tags标签。回到[Ctrl][之前的位置：输入[Ctrl]T.这里，应该是[Ctrl]]之前的位置，有待修改。分割一个窗口并跳转到当前光标函数实现内部：输入[Ctrl]w ].  跳转到指定函数实现处：输入:tag func.或输入:tselect func这样将跳到func函数的实现地方,tag func如果有多个将自动跳到第1个,tselect func如果多个则显示一个所有匹配列表，让你选择哪个。这里标签名可以用[Tab]进行命令补全.新开一个窗口，查看tag的函数：输入:stag tagname.这里，tagname是一个tag标签（例如函数名）效果相当于首先用:split，再用tag tagname.窗口是水平的。如果有多个tag匹配则：  切换到下一个匹配标签处：输入:tnext切换到上一个匹配标签处：输入:tprev切换到第一个匹配标签处：输入:tfirst切换到最后一个匹配标签处：输入:tlast显示所有匹配标签:输入:tags显示所有匹配标签并让你选择指定的：输入:tselect。关于代码折叠  设置可以折叠输入:set fdm=syntax.或输入:set fdm=indent.这里，fdm实际上是foldmethod的简写,第1个syntax方式是按照语法进行折叠（我倾向用这个所以后面都是对这个方式折叠下的命令），第2个是对大括号内的进行折叠。对当前代码块进行折叠：输入zc.这里，需要把当前光标放置到需要折叠的代码块的内部，因为一般程序结构都是嵌套的，这个命令折叠的是最内层的代码块。对当前代码块所在范围代码块全部折叠：输入zC.这里，折叠的不仅仅是最内层的代码块了，而是连带着递归地折叠了包含该代码块的这个代码块。展开当前代码最外层折叠：输入zo.这里，是对光标下的折叠代码块最外层折叠进行打开，内层的折叠仍旧折叠着，除非你移动到那里再次用这个命令打开折叠，有时候你按一下左右方向键也会打开折叠。展开当前代码包含的所有折叠：输入zO.这里，展开的不仅仅是最外层的代码块了，而是连带着递归地展开了该代码块包含的所有内层代码块。折叠当前文件所有可能折叠的代码：输入zM.这样，将把当前文件的所有可以折叠的代码进行折叠。展开当前文件所有折叠的代码：输入zR.或输入:set foldlevel=999.这样，将把当前文件的所有折叠的代码展开。全部展开或折叠当前文件所有可以折叠的代码：输入zi.这里，相当于zR和zM命令的“综合”，这个命令在全部折叠和全部展开两个命令之间进行“开关”切换。到当前打开的折叠的开始处:输入[z.到当前打开的折叠的末尾处:输入]z.跳到下一个折叠的开始处:输入zj.这里，关闭的折叠也被计入。跳到上一个折叠的末尾处:输入zk.这里，关闭的折叠也被计入。cscope的使用  cscioe功能：可以解决类似如下的问题：符号在哪里实用的？在哪里定义的？变量从哪里得到它的值的？全局变量的定义？这个函数在源代码中的什么文件中？什么函数调用了这个函数？这个函数调用了什么函数？消息“out of space”来自哪里？这个源文件在目录中的结构？哪些文件包含了这个头文件？软件下载：http://sourceforge.net/project/showfiles.php?group_id=4664软件安装:./configure --with-flex (注：如果平台是Linux,最好带上 --with-flex选项)make (注：我没有遇到错误)make install (注： 直接安装好了)cscope配置修改vim配置文件vimrc.你可以修改/etc/vimrc使用所有用户都使用本配置文件，当然你还可以修改~/.vimrc下载cscope配置文件：cscope_map.vim  （http://cscope.sourceforge.net/cscope_maps.vim）把cscope_map.vim里从 if has(&quot;cscope&quot;)? 到 endif里边的内容复制到/etc/vimrc里边去里边的命令意思自己琢磨cscope相关命令生成索引文件,在源代码目录中输入：$cscope -Rb另外，有的时候：$cscope -Rbkq&lt;回车&gt;这里，R 表示把所有子目录里的文件也建立索引b 表示cscope不启动自带的用户界面，而仅仅建立符号数据库q生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度k在生成索引文件时，不搜索/usr/include目录更多查看man.vim下的相关命令：  简单的帮助命令列表：输入:cs help或输入:cscs是cscope的简写命令，后面也是如此。添加一个新的cscope数据库链接:输入:cs add cscope.out这样，把当前目录下面的cscope.out这个cscope数据文件添加了，就可以利用其中的内容了，如果没有链接数据库，那么就用不了相应的功能了。可以把这个命令加入到.vimrc中，省得人工输入。查看当前已经链接的cscope数据库链接:输入:cs show查找相关命令：查找C语言符号，即查找函数名、宏、枚举值等出现的地方输入:cs find s &lt;符号名&gt;.或输入cs f s &lt;符号名&gt;.这里,等价于:cs find 0.    2. 查找函数、宏、枚举等定义的位置，类似ctags所提供的功能:          输入`:cs find g &lt;符号名&gt;`.          或输入`cs f g &lt;符号名&gt;`.      这里,等价于`:cs find 1`.    3. 查找本函数调用的函数:          输入`:cs find d &lt;符号名&gt;`.          或输入`:cs f d &lt;符号名&gt;`.          这里,等价于`:cs find 2`.    4. 查找调用本函数的函数:          输入`:cs find c &lt;符号名&gt;`.          或输入`:cs f c &lt;符号名&gt;`.          这里,等价于`:cs find 3`.    5. 查找指定的字符串:          输入`:cs find t &lt;符号名&gt;`.          或输入`:cs f t &lt;符号名&gt;`.          这里等价于`:cs find 4`    6. 查找egrep模式，相当于egrep功能，但查找速度快多了:          输入`:cs find e &lt;字符串&gt;`.          或输入`:cs f e &lt;字符串&gt;`.          这里,等价于`:cs find 6`，注意没有5.    7. 查找并打开文件，类似vim的find功能:          输入`:cs find f &lt;文件&gt;`.          或输入`:cs f f &lt;文件&gt;`.          这里,等价于`:cs find 7`.    8. 查找包含本文件的文件:          输入`:cs find i &lt;文件&gt;`          这里等价于`:cs find 8`.          以上的`cs find`均可简写为`cs f`.  - 将cscope的数据库内容作为tags:      输入`:set cst`.      或输入`:set cscopetag`.      这样就 会把cscope的数据库当成tag文件了，在只有cscopt.out的情况下可以用[Ctrl]]进入相应的函数了。这样只用cscope不用ctags了。关闭这个功能是`:set nocst`.但是cscope无法在tag的时候自动不全标号，另外，cscope虽然搜索全局字符串似乎挺好，但是在用cscope的方式tag函数的时候，如果源文件修改了例如增加几个空行之类的，那么回出现定位错位，而ctags就不会。  - 察看光标下的函数:      输入`[Ctrl]\g`.      这里，是加入cscope.vim的相关语句到.vimrc中之后有的快捷键。cscope.vim内容在“其他相关“里面最后有列出了。  - 察看调用光标下函数的函数：      输入`[Ctrl]\c`.      还有其他等等，察看脚本内容就知道了，实际是`[Ctrl]\`等价于输入`:cs f`，之后输入相应的字符f,g,c等，就可以查找当前光标下标号的东西了。  到当前局部变量的定义处:输入gd.这里，当前的意思是光标停留其上的单词。  到当前全局变量的定义处:输入gD.  跳转到当前代码块的开头:输入[{.这里代码块一般是用{}扩起来的。  查找在头文件中的某个相关定义：输入[Ctrl]w[Ctrl]i.这样，vim可以直接根据头文件进行查看，察看当前光标下的符号在头文件的相关定义。  注释第1行到第20行:输入:1,20s/^/\/\//g.这里，^表示在行首插入,因为Vim/Vi替换命令格式中默认/为分隔符，这样就需要使用转义符\，表示/就要写成\/才可以，所以命令如上所示。强烈建议各位看官使用，省时省力省键盘还，如果shell的注释符号&#39;#&#39;就不用转义了。  简单重排功能  当前行向右移一个shiftwidth:输入&gt;&gt;.这里， 整行会向右移一个 shiftwidth（预设是 8 个字元，可重设）。当前行向左移一个shiftwidth:输入&lt;&lt;.这里， 整行会向左移一个 shiftwidth（预设是 8 个字元，可重设）。将{},()或[]等符号括起来的文本都右移:输入&gt;%.这里,您必须把光标放在这些符号({},()或[])上面.将{},()或[]等符号括起来的文本都左移:输入&lt;%.这里,您必须把光标放在这些符号({},()或[]`)上面.自动缩进选中代码的格式：输入v，移动光标，选择待调整的代码块，输入=。这里，关键是先进入选择模式选择相应的代码，然后按‘＝’键，如果只按=就格式化当前行（需移动一下光标才看得出来）。打开一个预览窗口来显示函数 write_char：输入:ptag write_char.这样之后，光标会自动移动回原来的位置。窗口是水平的。  关闭预览窗口：输入:pclose.这里，尽管当前光标不在预览窗口，也会关闭预览窗口。  在预览窗口中编辑一个指定的文件:输入 :pedit。这在编辑头文件时很有用，这里的是要编辑的文件名,还可以同时定位到函数比如：:pedit +/funcs defs.h。这样可以在原有光标不变的情况下在预览窗口中修改。  查找当前文件和任何包含文件中的单词并在预览窗口中显示匹配:输入psearch &lt;函数名&gt;。这在使用没有标签文件的库函数时十分有用。虽然它不是很智能，但是它能够到库头文件中搜索。  quickfix定位代码错误的使用Quickfix模式的主要思想是保存一个位置列表，然后提供一系列命令，实现在这个位置列表中跳转。加快你的开发速度。假设:你编写了一个程序，在vi中输入:make调用makefile来编译的时候程序中有错误，回车就会返回编辑界面（实际会自动定位到第一个错误）。运行如下命令可以定位错误：  显示并定位到第n个错误：输入:cc n.这样就会自动定位到第n个错误的位置，并显示相应的错误信息，如果没有n参数，就重现当前错误信息。定位到当前错误的下一个错误处：输入:cn.这样如果当前在第n个错误的状态，这样会切换到第n+1个错误并定位到相应的位置。定位到当前错误的上一个错误处：输入:cp.这样如果当前在第n个错误的状态，这样会切换到第n-1个错误并定位到相应的位置。列出当前所有错误列表：输入:cl.这样列出一个错误列表，只是显示出了所有错误回车就又回到先前界面了。在当前窗口底部打开一个quickfix窗口列出所有错误信息：输入:cw.这样会在当前窗口底部新开一个窗口，方便的看到所有错误信息，还可以把光标移动到相应的错误之处然后回车，就会回到代码窗口并定位到相应的错误位置。回到上一个错误列表：输入:colder.或输入:col.这样回到上一次的quickfix错误列表，例如再次编译还有错误，这个命令返回的是上次而不是这次的错误列表，运用cw等都是上次的错误信息。进入较新的错误列表：输入:cnewer.或输入:cnew.这个命令的作用和前面colder相反，进入更新的错误列表。关于自动补全：  显示自动补全列表：输入[Ctrl]p这里，是在插入模式下进行的，例如当前输入了aa字符，然后输入[Ctrl]p这样会列出所有以aa为开头的单词列表。它们会在当前缓冲区、其它缓冲区，以及当前文件所包含的头文件中查找以光标前关键字开始的单词。选择自动补全列表中匹配的下一项：输入[Ctrl]n.这样如果有多个匹配的单词项那么会高亮下一项进行选择。如果不够则循环显示。选择自动补全列表中匹配的上一项：输入[Ctrl]p.这样如果有多个匹配的单词项那么会高亮上一项进行选择。如果不够则循环显示。自动匹配整个行：输入[Ctrl]x[Ctrl]l.这里，注意要在编辑状态下面运行的，会弹出文件中所有的整个行，之后用[Ctrl]p等就可以自动匹配了。如果CTRL-N和CTRL-P补全时查找所包含的头文件，耗时会比较久。此时，可以在’complete‘选项中去掉&#39;i&#39;标记:set complete-=i 。';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_06Programing.html"> Vim实践与学习-06编程  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-05定位'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '定位到指定行n:输入:nG.或输入:ngg.或输入::n这里,n就是指定的行的行号.注意，有时候G=gg.跳到屏幕顶部：输入:H.这里，停在第一个非空字符上。加一个数字N，是指距窗口顶部的行数（如NH正数第N行）跳到屏幕底部：输入:L.这里，停在第一个非空字符上。加一个数字，是指距窗口底部的行数（如NL倒数第N行）跳到屏幕中间：输入:M.这里，停在第一个非空字符上。跳到文件首：输入:gg.  跳到文件尾：输入:G.  光标移至句尾:输入:).  光标移至句首:输入:(.   光标移至段落开头:输入:}.   光标移至段落结尾:输入:{.   跳到行末尾：输入:$.  跳到行首:输入:^.或输入:0.这里输入^是移动到首的第一个非空白字符。  向后跳到整文件最近距离的单词末尾：输入:e.  向前跳到整文件最近距离的单词首部：输入:b.  跳到整文件下个单词首部:输入:w.  行内移动以下均可可以加上数字N前缀表示移动N次（如3fc表示执行fc3次。）  移动到光标右面第一个字符c的后面:输入:fc.移动到光标右面第一个字符c的前面:输入:tc.移动到光标左面第一个字符c的前面:输入:Fc.移动到光标左面第一个字符c的后面:输入:Tc.重复前一次输入的f, t, F, T命令:输入:;.例如刚才是fc，输入;相当于还是fc。会反方向重复前一次输入的f, t, F, T命令:输入:,.例如刚才是fc，输入,相当Fc。在较长行内的移动：这里做一个小小的约定：较长的一行如果占据了屏幕的多行，那么这一行我们把它叫“长行”，屏幕上的一行叫做“屏幕行”。所以对于一个&#39;长行&#39;需要有多个&#39;屏幕行&#39;来显示。  在“长行”中移动到下一个“屏幕行”：输入:gj.在“长行”中移动到上一个“屏幕行”：输入:gk.在&quot;长行&quot;中移动到当前&quot;屏幕行&quot;首：输入:g^.在&quot;长行&quot;中移动到当前&quot;屏幕行&quot;尾：输入:g$.这里，如果一行超过了屏幕宽度，会显示在屏幕的多行，显示的虽然是多行，但是实际上还是一行，在输入上下移动的时候虽然是进入了上一行或者下一行，但是往往会呈现出在屏幕中一下跳过n行的样子。g$,g^, gj ,gk 在行超过长度时好用。 j,k下上移动的是文本中的一行，当文本一行的长度超过屏幕的一行的时候，j,k移动的时候在屏幕上可能是移动多行。这时候可以用gj,gk来移动屏幕的一行而不是文本的一行。 同理g^和g$是屏幕的行首行尾，而不是文本的行首行尾。按百分比来跳转,跳转到文件50%处：输入:50%.这里利用%实现按百分比来跳转，如果想跳到75%处，输入75%。  翻页可以跟数字前缀N表示执行的倍数，翻页可以用[PageUP]/[PageDown].  向下翻页：输入:C-f.向上翻页：输入:C-b.向下翻半页：输入:C-d.向上翻半页：输入:C-u.相对于光标的翻页效果是行向相应的方向滚动了，光标仍然在原来的行，好像是将这个文本拖动了一样.  光标所在行移动窗口的顶端:输入:zt.光标所在行移动窗口的中间:输入:zz.光标所在行移动窗口的底端:输入:zb.将第n行滚至屏幕顶部：输入:nzt。将第n行滚至屏幕底部：输入:nzb。将第n行滚至屏幕中部：输入:nzz。设置书签：输入:ma.这样，会在当前光标的位置标记一个书签，名字为 a。书签名只能是小写字母。你看不见书签的存在，但它确实已经在那里了。只能记录当前文件里的书签,退出vim后再次进入将不会保留这些书签, 书签只是当前文件中的一个位置，但是我实践一下发现，设置完了书签之后，保存文件，这样也把书签保存了。  到书签a处：输入:`a.注意,这个不是单引号，它一般位于大部分键盘的 1 的左边。  到书签a所在的行：输入:&#39;a.这里用的是单引号，将跳到书签所在的行。  到上次编辑文件的地方：输入:`..这个命令很有用，而且你不用自己去标记它，注意这里输入的是反引号`,精确到点。  到上次编辑文件所在行：输入:&#39;.注意这里是精确到行，输入的是引号&#39;。  回到最后一次插入状态返回的位置：输入:&#39;^.或输入:`^.这里&#39;.精确到行，`.精确到点（行+列）。  查看当前所有书签的列表：输入::marks.  搜索相关：  搜索一个字符串：输入:/string。这里string就是将要被搜索的字符串，会自动跳到光标后面第一个string处。在上次搜索的基础上向前搜索：输入:N。在上次搜索的基础上向后搜索：输入:n.逆向搜索一个字符串：输入:?string。这里string就是将要被搜索的字符串，会自动跳到光标前面第一个string处。之后使用的:n和:N命令方向也会相反了。列出查找的历史记录：输入:q/.或输入:q?.这会在vim窗口最下面打开一个新的窗口，列出你的查找历史记录可以选择。向下完全匹配当前光标下单词：输入:*。之后也可以按n继续向下查找。向上完全匹配当前光标下单词：输入:#。之后也可以按N继续向上查找。向下匹配包含当前光标单词的字符串：输入:g*。向上匹配包含当前光标单词的字符串：输入:g#。跳到匹配的另一半括号：输入:%。这样可以查找配对的括号，即： )、]、}。  打开当前光标单词下的文件：输入:gf。这里，假设当前的光标在相应的文件名上面，例如main.c等等。  切换到上次打开文件：输入:C-^。这里，例如我们输入了gf进入某个文件，可以输入C-^来回到刚才的文件，这个命令只能在当前和上一个文件之间切换，不能后退多步。  后退到某个曾经浏览过的位置:输入:C-o.流行的文本编辑器通常都有前进和后退的功能，可以在文件中曾经浏览过的位置之间来回移动。在vim中多次输入C-o可以执行后退。  前进到某个曾经浏览过的位置:输入:C-i.或输入:[Tab].这样，如果执行过后退，在vim中多次输入C-o可以执行前进。  ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_05Jump.html"> Vim实践与学习-05定位  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-04编辑'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '输入模式进入输入模式:输入i.或输入a.这里，输入i是在字符前开始插入，输入a是在字符后开始插入。直到输入ESC退回到命令模式。删除当前光标字符并进入插入模式（替换字符）：输入s.这里注意 是小写的s,这个命令和 R 不同，R 是覆盖式的取代并不切换模式，s 则是插入式的取代，相当于输入x删除一个字符，再输入i进入插入状态。清空当前行并进入插入状态（替换当前行）：输入cc.或输入S.这里，第二个是大写 S。这个命令的效果相当于dd删除一行并且在原来行的位置上面插入一个空行，光标放在空行上面再进入插入状态。 这里和c相关的操作与和d相关的操作类似，不过最后c操作会进入插入模式。清空一个字（替换一个字）并进入插入状态：输入cw.这里， cw 替换一个英文字(word)，中文不适用。(change)相当于用dw删除一个词，然后进入插入状态。取代至行尾并进入插入状态：输入C。或输入c$。这里，注意第一个是大写C，第二个是小写c.这个命令会把当前光标(包含光标下字符)至行尾内容删除在进入插入状态。即相当于D之后进入插入状态。取代至行首并进入插入状态：输入c0.或输入c^.这里，将会把当前光标(不含光标下字符)至行首内容删除。经过实践，发现两者区别是c0 取代至行最开始无论原来行以什么字符开始，而 c^则当原来行以空白开始的时候，不会删除开头的那几个空白。删除之后，两者都自动进入插入状态。总结一下：我们可以结合后面这样理解：s操作类似x，不过最后也进入插入模式，一般是单字符的命令；c相关的操作类似d，不过最后进入插入模式，一般是多字符的命令（即cc,dd,cw,dw等）；删除删除一个字符：输入x。注意：结果是光标所处的字符的消失，后面的文字左移动，假如没有任何文字了，喇叭就叫，同时将删除的内容保存到剪切板中。如果x前面有数字N那么就是重复N次。删除当前行:输入dd。注意： 可以跟数字，（如：5dd 将删除 5 行），同时将删除的内容保存到剪切板中。删除从光标到行尾:输入D。或输入d$.这样，将当前光标（包含当前光标所在的内容）一直到以后的内容全部删除。删除到当前词尾输入dw.删除整个单词输入daw.删除当前字符输入dl.上面许多例子实际是d{motion}，即d--删除对象的命令,d命令的右边要有一定的文字对象,文字对象就是控制光标移动的那些字符;例如 w 表示到下一个单词首，那么 dw 将删除光标至当前单词尾;同理，5w 表示前进 5 个单词，那么 d5w 将删除他们(daw比较特殊， delete a word)。用&quot;数学语言&quot;描述，上面的删除范围是：[光标起始，光标终点)。也可用d /text 删除从文本中出现&quot; text&quot;中所指定字样的位置，具体需要实践。c也有相应的c{motion}不过删除之后紧接着会进入插入模式的。删除当前光标至&quot;text&quot;之间的文本：输入d/text.这样， 删除从文本中出现&quot;text&quot;中所指定字样的位置，一直向前直到下一个该字样所出现的位置（但不包括该字样）之间的内容。复制复制当前行:输入yy。或输入Y。注意： 可以跟数字，（如：5yy 将复制当前和后面的共5 行）到剪切板中。复制当前光标到词尾：输入yw.复制这个单词：输入yaw.复制书签a和当前光标之间内容：输入y`a.这样，可以利用标签进行成块数据复制，需要注意的是，这里`a是反引号的，复制的内容包含设置书签时所在光标的字符，但不包含当前光标所在字符。复制当前光标行和书签a所在行之间内容：输入y&#39;a.这样包括当前光标行以及书签行在内的两行之间的内容全被复制，这里&#39;a用的是单引号。这里的例子同d--删除对象一样的道理，不多说了。粘贴:  粘帖上次删除或复制的内容输入p.注意：按p会将最近删除或复制的粘贴(vim中的删除一般就是我们平时所说的“剪切”）。交换两个字符位置：输入xp.这里，实际是先x删除字符，再p粘贴先前删除的字符。上下两行调换:输入ddp.这里，原理同xp.指定范围的编辑：把n,m之间的内容拷贝到k行的下面(空格可省略):输入:n,m co k。或输入:n,m copy k.只复制不粘贴第n,m行之间的内容(空格可省略):输入n,m y。剪切n,m行之间的内容到剪切板中(空格可省略):输入:n,m d。或输入:n,m delete k。把n,m之间的内容拷贝到k行的下面(空格可省略):输入:n,m m k.或输入n,m mo k.或输入:n,m move k.粘帖到k行下：输入:k pu.或输入:k put.后面可以接寄存器名字。可视模式下：进入可视模式：输入v。或输入V。这里，进入可视模式后，如果进行移动操作（例如h、j、k、l等），将会高亮显示进入可视模式时的光标所在字符（行）和你移动之后的字符（行）之间的部分表示你选择了这块文本。输入v是按字符单位进行选择，输入V是按行单位进行选择。选择之后，可以对选中文本进行操作。选择一块数据：输入C-v.按方向键选择相应的数据。这里，按下方向键之后，选择的数据会以列为单位选择，不想v是以行为单位了。实践一下就知道我说的是什么意思了。剪贴可视模式选择的内容到剪贴板：输入d。拷贝可视模式选择的内容到剪贴板：输入y。剪贴可视模式选择的内容到剪贴板并且进入插入模式：输入c。如果你很清楚的知道你想拷贝或者剪切什么，那你根本就不需要进入可视选择模式。这样也会节省时间。所选内容向右移动n个Tab：输入[n]Shift &gt;.这里Tab次数用[]括起来,也可以没有这个[n]代表只有一个Tab.所选内容向左移动n个Tab：输入[n]Shift &lt;.这里Tab次数用[]括起来,表示也可以没有这个[n]，即只有一个Tab.替换相关替换当前光标一个字符步骤：  定位到待替换字符A.输入r.输入要替换成的字符B。这样，字符A就变成了字符B。替换多个字符步骤：输入R。定位到将要被替换的字符A.输入要替换成的字符B.如果继续替换，则再次回到2执行否则输入[ESC]完成替换。这样就完成了多个字符的替换。在当前行替换全部：输入:s/old/new/g。这里，可以把当前行的所有字符串“old”替换为“new”。在当前行替换第一个：输入:s/old/new。这里，将只替换当前行第一个匹配的字符串old为new。指定范围的替换：输入:#,#s/old/new/g。这里，#,#表示表示范围的两个行号，命令会把两个行号之间的所有字符串“old”替换为“new”。整个文件的替换：输入:%s/old/new/g.这里将把整个文件中的所有字符串“old”替换为“new”。忽略大小写的替换：输入:%s/old/new/gi.这里加上i，替换时忽略大小写即大小写是一样的。带有确认的替换：输入:s/old/new/gc.这里，加c仅以当前行范围内替换确认进行举例了，其他范围类似。结果是，在替换字符串“old”为“new”之前，将会询问(replace with to (y/n/a/q/l/E/Y) )。 输入y表示替换当前这个，n表示这个不要替换，a表示全部替换，q表示退出，不替换了,l表示把当前这个替换后就退出，^E([Ctrl]e,好像大小写都可以)表示向下滚动一行， ^Y([Ctrl]y,好像大小写都可以)表示向上滚动一行。令游标所在处之大小写互换:输入~.这里，只适用于英文，当然不要忘记输入的时候按SHIFT.为光标下或者光标后面的数字增1：输入CTRL-a.这样，当前光标或者光标后面有数字的话，光标就会跳到那个数字的地方，并给那个数字增1。例如有一个326那么就会变成327.上下两行合并输入J.这里实际就是把当前行的换行符号变成了空格，这样下一行就合并到这行中了。撤销刚才的操作:输入u。恢复:输入CTRL-r。和u相反。重复上次编辑:输入.。寄存器关于寄存器相关的命令帮助输入:help redo-register或寄存器的其它引用方式:h i_CTRL-R数字寄存器vim中最常用到的寄存器，当不指定寄存器时，复制操作的内容被保存到&quot;1，删除操作的内容被压到&quot;2，同时原先&quot;2的内容转到&quot;3，依此类推，原先&quot;8转到&quot;9，原先&quot;9的内容丢失。如果指定操作的寄存器，如&quot;ayy和&quot;bdd，则上述的数字寄存器无影响（有些例外情况，详见Vim手册,这里我发现用&quot;add等删除的时候，&quot;d,&quot;1,&quot;&quot;三个寄存器内容就都一样是最近的操作了）。寄存器&quot;&quot;未命名寄存器&quot;&quot;保存最近一次复制或删除操作内容，无论是否指定寄存器。寄存器&quot;.保存上一次插入的文字,也就是你上次切换到插入状态下(包括临时切换的CTRL-o)，输入的文字。寄存器&quot;%保存当前文件名,&quot;#保存替换文件名(即上次操作的文件)文件是相对vi当前路径的路径名。寄存器&quot;_这是一个特殊的“黑洞”寄存器&quot;_，当指定其进行删除时，包括&quot;&quot;在内的任何寄存器都不受影响，当然，你也没法把掉进黑洞的物质p出来。寄存器&quot;/vim将最近一次的搜索文字保存在&quot;/中，对应的变量@/决定了n/N命令和查找高亮的对象。@/被所有buffer共享，也就是说在一个buffer里进行新的查找，其它buffer的匹配高亮和n/N命令也随着更新。寄存器&quot;=这个寄存器与众不同，它不存储文本，而是在可以使用寄存器的场合中提供了用表达式求值并取得其结果的途径。简单的说，就是在指定&quot;=时，Vim会提示输入一个表达式，然后将求值结果返回，至于这串文本如何使用，就看在什么地方使用了。寄存器&quot;:这个寄存器记录最近一次运行的命令行命令，因此@:是重复上次的命令行操作(也就是:提示的命令而不是dd和yy等)。值得注意的是，@x宏运行的是normal命令，而@:运行的是Ex命令。如果某个寄存器&quot;x保存的是Ex命令，你可以用:@x来执行。比如在测试vimrc中的某条命令时，先yy，然后:@&quot;执行。总之不管什么是normal命令和Ex命令？了，&quot;:寄存器里面存的就是命令行:提示下输入的命令，其他寄存器（假设为x）内容如果是:set nu那么可以直接由@x来运行，如果是set nu,那么需要用:@x来运行。&quot;和&quot;+寄存器两个特殊的“全局性”寄存器：帮助入口:help clipboard.在vi中用:reg看一下,有没有&quot;+一项.如果没的话,就不支持对&quot;+的访问，需要安装一下vim-gtk（或者vim-full）.$apt-get install vim-gtk&quot;+寄存器，是一个“全局性”的寄存器，对应于X11的剪切板，当使用vi和其他gui程序进行互相复制粘贴的时候，实际使用的就是&quot;+寄存器（xterm不行，xterm的双击自动复制是用&quot;寄存器）。&quot;*寄存器，也是一个“全局性“的寄存器，可以在vi和其他vi程序之间互相访问或者vi和xterm等一些特殊的程序之间互相访问（个别时候没有&quot;+的时候也充当X11剪切板）。察看当前各个寄存器中的内容用：输入:display.或输入:di.或输入:reg.察看寄存器1的内容：输入:display 1.或输入:di 1.总之，diaplay后面接寄存器的名就可以显示寄存器的内容了。将当前行放入寄存器a中：输入 &quot;aY.或输入&quot;ayy.这里，vim 有多个所谓寄存器来寄存剪切的内容,寄存器引用要使用&quot;r(r是寄存器名字).粘贴寄存器a的内容:输入&quot;aP.粘贴寄存器中的内容：输入：&lt;C-r&gt;。或输入：&lt;寄存器名&gt;这里，寄存器名可以是26个字母或者数字等等，具体应该参见编辑相关里面的寄存器相关操作。例如我在输入模式下想要把寄存器a中的内容粘上去，就输入&lt;C-r&gt;再输入a.粘贴1号寄存器中的内容(并重复循环粘贴)：输入&quot;1p.这里，若p命令时指定数字寄存器，则后续的.命令会自动将数字寄存器的编号加一，也就是说执行&quot;1p之后，第一个.执行的是&quot;2p，依次类推,到最后一个之后就会粘贴空的内容了。粘贴之后光标停留在粘贴出的文字之后：输入gp.或输入gP.这里结果相当于先p后dw.问题是要重新定位需要删除的部分。与p/P功能一样，不过光标停留在粘贴出的文字之后，便于随后的删除。(p与P区别是：P粘贴之后，光标位置不变，而p粘贴之后，光标始终随着刚在被在前面粘贴的字符向前走)在插入模式或命令行中或搜索时候的/等之后插入寄存器&quot;x的内容：输入x.这样寄存器&quot;x的内容将插入到相应的位置，x是寄存器名称。在命令行中直接引用寄存器x内容：输入:@x.这样，相当于把寄存器x中的内容输入进去了,x同样是寄存器名称，这里使用@把寄存器当作变量来使用可以用于脚本。使用&quot;=寄存器十六进制转十进制：  插入模式下输入CTRL-r输入=输入0x1234这样，回车之后就会自动插入十进制的4660了。+ 在不同vi程序之间互相复制粘贴：    1. 在vi中输入v之后，选择一段文字（或者定位到某一行）。    2. 在vi中输入&quot;*y(或者行复制用&quot;*yy).    这样就把内容复制到寄存器&quot;中了。    3. 在另一个vi输入`&quot;p`。  这样就把刚才vi中复制到&quot;*中的内容粘贴出来了。+ 使用vi和其他图形程序（例如gedit）之间剪切板互访：    1. 在gedit中用鼠标选中文本，并且右键-&gt;复制。    2. 在vi中输入&quot;+p。    这样就将之前在gedit中复制的文本粘贴到vi中了,注意这里是三个字符&#39;&quot;&#39;,&#39;+&#39;,&#39;p&#39;.    3. 在vi中输入v之后，选择一段文字（或者定位到某一行）。    4. 在vi中输入&quot;+y(或者行复制用&quot;+yy).    这样就把相应的内容复制到寄存器&quot;+中了。    5. 在gedit中右键-&gt;粘贴。  这样就把vi的寄存器&quot;+中的内容粘贴上去了。+ 设置&quot;寄存器共享且默认：    输入:set clipboard=unnamed.    设置之后，使用vi中的复制命令的时候，会自动把内容也放在&quot;寄存器中。粘贴的时候，也自动使用&quot;寄存器了,而不是默认的数字寄存器。这样多个vi程序之间可以方便地互相复制粘贴了，而不用在加&quot;前缀指定寄存器了。    当然如果另外一个vi程序没有设置这个选项那么它还是要用&quot;前缀的。去掉这个设置好像是:set clipboard=.  宏寄存器与宏是紧密相连的宏的相关帮助命令入口如下：:h q:h @:h :@宏是Vim中非常重要的功能，用来重复执行多个连续操作。当包含移动、查找、插入、修改等不同类型的命令时，宏显得尤其方便，很多时候用:s和:g难以实现的功能，宏都可以轻松搞定。  用q录制宏实际上是将键盘输入记录到寄存器的过程，而用@运行宏则是将指定寄存器内容作为normal命令执行的过程。q命令提供了“所做即所得”，但有时候直接修改寄存器更为方便。比如当你录制完一个非常复杂的宏，但发现有一个小毛病（例如应该是de而不是dw），不必重新录制一遍，只需要将寄存器的内容p出来修改好再y回去。宏有一些运用的技巧：容许错误：录制过程中如果有错不必放弃重来，可以undo或，只要保证这些操作和处理文本无关，寄存器里有些乱七八糟的东西又何妨。分而治之：当录制一个很复杂的宏时可以考虑分成几段，比如qa第一步，qb第二步，然后在qc中调用a和b，各个击破简单易行。重复运行：@@命令可以重复上次的宏调用。另作它用：q命令是向寄存器里录入命令，你也可以什么都不录！用处例如清除&quot;a最快的方法：qaq。假设进行的操作为&lt;某操作&gt;，使用宏你可以重复多个不同的操作. 使用宏的步骤如下：输入qa.这里，开始把一段宏记录入寄存器变量a中，共有26个可用的寄存器供你记录宏。输入&lt;某操作&gt;.这里，象平常一样键入要进行的操作, 只是这些操作都会被Vim记录进前面名为a的宏中。输入q.这里再次再下q键, 就结束了宏a的录制.输入@a.这里，重复执行你刚才记录的那些操作时只要使用@a命令，引用那个宏。可以前面加数字前缀表示执行次数。重定向：信息重定向会把你输入的命令的输出重定向到指定的寄存器或者文件中。帮助入口是:help redir.把命令的输出重定向到寄存器中：输入:redir @a.这里，指定输出会定向到寄存器a中，当前显示中会看到相应的输出。输入&lt;你要输入的一个或者多个命令&gt;.这里，命令可以是命令状态下的命令如搜索命令/等,用:引出的命令等,甚至进入插入提示的--INSERT--。输入:redir END.这里，小写的也行。执行以上三步之后，那些命令的输出了被显示的同时也存在了寄存器&quot;a中。把命令的输出重定向到文件中：输入:redir &gt;&gt;file.这里，指定输出会定向到file中，当前显示中会看到相应的输出。使用&gt;&gt;表示追加，使用&gt;表示清空并加入。输入&lt;你要输入的一个或者多个命令&gt;.这里，命令可以是命令状态下的命令如搜索命令/等,用:引出的命令等,甚至进入插入提示的--INSERT--。输入:redir END.这里，小写的也行。执行以上三步之后，那些命令的输出了被显示的同时也存在了文件file中。';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_04Edit.html"> Vim实践与学习-04编辑  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-03文件'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '这里包含在shell下执行vim,以及vim中关于文件操作的内容。打开一个文件file进行编辑等操作：$vi file打开文件，并将光标置于第n行首：$vi +n filename这里输入得都是shell下进行得，是shell命令，打开之后光标在屏幕中间，而屏幕中间的行就是第n行。打开文件，并将光标置于第一个与pattern匹配的串处：$vi +/pattern filename这里输入得都是shell下进行得，是shell命令。在上次正用vi编辑时发生系统崩溃，恢复filename:$vi -r filename 以只读方式打开文件:$vi -R file或$view file这里输入得都是shell下进行得，是shell命令。其中view是unix得命令，有的linux有。vi下临时切换到shell执行shell命令:输入:!command。注意：这里command是命令名字(例如ls).查看当前编辑的文件和行号:输入&lt;C-g&gt;。或输入:args,查看当前编辑缓冲文件状态(文件名).显示当前光标所在行的行号：输入:nu.这里只是在底部“状态栏”的位置显示一下当前光标所在的行号以及行。保存:输入:w。若输入:w file(效果和另存为文件file一样).载入（创建）一个新文件（&quot;file&quot;）:输入:e file。或输入:n file。或输入:hide e filename。这里，类似于新建文件或者新打开一个文件，当前文件的窗口将会被待编辑的文件所占用，如果当前文件没有保存会提示的。实质上是隐藏当前文件到buffer缓存,打开另一个文件进行编辑，具体见缓存部分。在新窗口载入（创建）一个文件(file)输入:vnew file。或输入:vsplit file或输入:split file这将新开一个垂直的分割窗口，并在新开的窗口中载入相应的文件（:split file是水平窗口）。将当前文件以及改动保存到另外文件中输入:w FILENAME.这里，FILENAME是另外的文件名，执行之后仍然停留在当前文件中,只是目录中多了一个FILENAME文件（即另存为）.只保存文章的某个部分到另外文件：输入:#,# w TEST。这里的 #,# 就是要求您记住的行号范围(最小行号,最大行号)，而 TEST就是选定的文件名。向当前光标中插入另外的文件的内容：输入:r FILENAME.这里，FILENAME是要插入的文件名,r前面可以指定一个行号，表示把内容插在这个行号后面。在buffer缓冲内操作文件相关  列出当前打开的文件，以及编号:输入:buffers.或输入:ls.假设我们打开一个文件，之后用n来切换到另外一个文件中，或者用tabnew打开新文件，那么原来的文件以及现在的文件都会在buffers中，并且yy等命令复制的原来的文件的内容还能用。列表前面的前缀%表示当前文件，#表示可以用[Ctrl]^等切换的可用buffer,其他的可以查看:help ls或者:help buffers.切换成第N个缓冲:输入N ctrl^.或输入:buffer N.这里，注意第一种方法不用输入:，两个buffer文件之间也可用yy,pp.新开一个窗口，载入第N个缓冲区的文件：输入:sbuffer N.窗口默认是水平的。切换到下一个文件:输入:bn.切换到上一个文件:输入:bp.关闭当前文件:输入:bw.这样会关闭当前文件进入下一个buffer的文件，并且当前文件也会从buffer列表中删除。跳至下一个文件:输入:n.当然这里打开文件的方法应该是$vi file1 file2 file3才行。如果用vi file1之后用:n file2这样不行。回到刚才编辑的文件:输入:e#.或输入[Ctrl]^例如运行了vi a b c,当前编辑文件为a，:n跳至b,再:n跳至c,:e#回到b,想回到a的话用:ea。退出:输入:q。保存退出:输入:wq.或者输入:x.或输入ZZ.强制退出:输入:q!(可能未保存)。退出所有：输入:qa.这里如果打开多个窗口或者文件的时候，使用这个命令可以实现一次性退出。查看当前编辑缓冲文件状态(文件名)：输入:args。';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_03File.html"> Vim实践与学习-03文件  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-02输入模式'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Vim基本模式Vim中有6个基本模式和6个基本模式的变种的辅助模式，后面的讲述中会涉及到这些模式。这里将这些模式做一个简单介绍，更多文档请参考vim手册中 *vim-modes-intro* *vim-modes* 部分的内容（可通过:help vim-modes浏览）。Normal Mode也被称作Command Mode。是Vim启动后默认进入的模式（除非设置设置了insertmode选项），该模式下不能编辑文件内容，但是可以接收大多数编辑指令（例如拷贝、删除、修改保存等）。Visual mode类似Normal Mode Mode，在Normal mode中通过V或v可进入该模式下，该模式中任何移动光标的动作都会将光标所经过的区域高亮，非光标移动的指令作用于高亮区域；设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- VISUAL --。具体可参见 :help Visual-mode。Select mode类似Visual mode，但是命令有很大不同。在Visual mode中输入&lt;C-g&gt;、或者在Normal中输入gh、gH、g &lt;C-h&gt;等可以进入该模式。它有点像MS Windows中的选择模式，键入一个可打印的字符后，会删除选择区域并进入插入模式。设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- SELECT --。Insert mode在该模式下你键入类似打开普通编辑器（如记事本）的状态，在Normal mode中键入i、a、o、s等都可以进入该模式。在该模式下可以键入你想插入的字符，字符会被插入到当前文件缓存中。设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- INSERT --。具体可参见:help Insert-mode。Command-line mode/Cmdline mode该模式下你可以在窗口底部键入一行文本，完成复杂的操作指令。从Normal mode进入该模式的方式，比如用于 Ex命令键入:，用于搜索键入/和?，用于过滤内容键入!、=……具体参见:help Cmdline-mode。Ex mode类似Command-line mode，在Normal mode中通过键入Q、gQ可以进入该模式。该模式下输入的命令和Command-line mode中的差不多，但是输入完一条命令之后，你会保持在Ex mode中继续输入其他命令，期间当前屏幕不会刷新，键入vi会退出该模式。具体参见:help Ex-mode。Vim的辅助模式除了基本模式之外，Vim还有六个辅助模式，如下。Operator-pending mode该模式类似Normal Mode，但是在一个操作命令开始之后，Vim会等待一个{motion}（移动），来指定操作对应的文本。Replace mode该模式是一种特殊的Insert mode，你可以进行和Insert mode一样的操作，但是不同的是每次你键入一个被插入的字符之时，插入之处原来所在的字符就会被替换成你键入的字符。设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- REPLACE --。Virtual Replace mode该模式类似Replace mode，不同的是它会替换屏幕当前的内容状态，在Normal mode中键入gR会进入该模式。设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- VREPLACE --。Insert Normal mode该模式类似Normal mode，在Insert mode下键入&lt;C-o&gt;可以进入该模式，该模式下执行一条Normal mode命令后，又会回到之前的Insert mode。设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- (insert) --。Insert Visual mode这个模式类似Visual mode，是在Insert mode中进入 Insert Normal mode后再键入v、V、&lt;C-v&gt;，该状态结束后，会回到Insert mode。设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- (insert) VISUAL --。Insert Select mode这个模式类似Select mode，是在Insert mode中进入 Insert Normal mode后再键入从Normal进入Select mode的命令，会进入该模式，该状态结束后，会回到Insert mode。设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- (insert) SELECT --。最常见的模式及相关操作前面介绍了Vim的多种模式，内容较多，为便于理解和继续，这里给出其中最常见的模式和相关操作。深入理解可在学习完本系列文章后再回顾。内容是在输入模式下的功能。输入模式主要有如下的操作：回到指令模式(Command mode)：输入：&lt;Esc&gt;.输入内容：输入：...[你要输入的字符串]...在这里，直接输入相应的字符即可。临时切换到指令模式，执行完命令之后自动回到输入模式(Insert mode)：切换指令模式时输入：&lt;C-o&gt;.回到输入模式时输入：&lt;Esc&gt;本文剩余部分介绍的大部分都是指令模式的相关操作。';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_02Input.html"> Vim实践与学习-02输入模式  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-01简介'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '什么是Vim没有明确的定义，这里给出一些经验性的概括Vim是上世纪这个世界上诞生的两款最著名的编辑神器之一，另外一个是EmacsVim和Emacs若只提两者之一而不提另外一个，这个世界便显得不平衡这两款编辑器均诞生在Linux/Unix平台上，后来也被移植到其他操作系统中二者是软件世界中的神话，历经半个世纪的洗礼、淘汰筛选、甚至它们本身相互之间的圣战至今，仍然长盛不衰，其强大之处让其它同类工具望尘莫及虽说是传闻但是在各个不同版本和来源上的传闻都意指：真正强悍的程序员开发使用的不是IDE，而是Vim和Emacs本人喜欢寻找各类功能强大、灵活、方便的开发以及文档撰写编辑等工具，随着经验、技术和实践、成长的积累，最终也渐渐将目标集中在这两款编辑器中有人甚至总结出世界上有三种程序员：使用Vim的程序员、使用Emacs的程序员、和其它程序员本文主要介绍Vim编辑器，Emacs的介绍放在其它之处目前我们实际使用的都是Vim，它其实是vi的改进版本之一，是最流行的改进版本，所以现在所说的Vi基本上就是Vim了Vim能做什么Vim能够处理的事情很多，前面说了那么多空话，为避免有广告之嫌，这里列出其中一些常用的功能应用：  编辑和浏览文本文件浏览和管理文件目录阅读程序源代码提供编程、调试环境利用自带的脚本语言扩展自身自动化智能、批量地处理文本等等……与其他编辑器的比较这里的比较主要是针对与它的“对手”Emacs而言，前面众多说法中，有一种可以这样解释：在Linux/Unix界，有三种编辑器：一种是Emacs，一种是Vim，还有一种是除此之外的编辑器，由此可见Vim在编辑器领域的地位。操作理念不同Vim与Emacs，两者各有千秋，下面只列出其中少许Vim侧重简洁、快速、高效；Emacs侧重大而全、具有超强的扩展与配置能力Vim更专注于编辑功能本身，将编辑功能发挥到极致，将每一次的操作任务一气呵成Emacs注重全面，集成了编辑中你能想到的方方面面，将因频繁切换被打断的思路减至最少等等……其实，Vim更算是一款编辑器，而Emacs则像是隐藏在编辑器下的操作系统。工作方式不同有人做过这样的比喻，Vim是编辑器之神，Emacs是神之编辑器。使用Vim时其编辑之高效，将所思想如行云流水般实现随着对Vim的熟练，甚至不注意时操作会超越思维，还没有想完下一步的操作，手指就已经被Vim控制着完成了任务使用Vim容易让人有种走火入魔，成为“编辑器神之奴”的感觉使用Emacs时总会不满当前操作效率，对当前的编辑操作提出更高要求；不满过后，总能在后续的完善配置扩展中找到能够达到、甚至超过预期需求的特性达到需求后，又再次陷入不满、配置、扩展、满足的循环当中在这种不断进步并且提高效率过程中，让人不断地因找到更好方式而满足，因不断发现缺陷而失落，使得Emacs逐渐成为让我们踏足“神域”的桥梁两者除各自擅长之处外，又各自在对方擅长的领域表现优异，令其它类编辑器“无可乘之机”，也另对方不敢有丝毫“松懈”。建议历史上两者的阵营之间爆发过多次“圣战”，涉及的方面太多，这里不一一列举，在实用的原则上，这里给出一点建议：* 对两者的选择，应当建立在对它们的了解之上* 使用Vim之时要给自己的思维一点空闲时间，防止进入“走火入魔”的境地* 而对Emacs的使用，其配置和扩展能够达到一定实用价值即可，避免为了不断提升Emacs而使用Emacs（虽然不断的提升是值得的）Vim的特征本文并无意加入Vim和Emacs的圣战中来；因讲述的是Vim的使用，所以针对其特点进行叙述；相应地Emacs也有它的特点，在讲述Emacs之时也会相应提到。一般使用过两者的人，可能会有如下的感觉：相比Emacs而言，Vim更为“通用”，这里的通用是指，并不是所有机器上都配有Emacs、但是大多数机器上都配有vi编辑器使用Vim不会像Emacs那样过度依赖本地配置与扩展，有些配置可以在使用Vim时按需即时开启（比如语法高亮与代码折叠）Vim启动迅速（启动Vim时，一般不需加载过多增强插件），按键简短（Vim的按键命令一般不会过长，组合键的情况很少）Vim只将编辑相关操作发挥极致，不做多余之事（与其它工具配合度高，编辑外的事情在Linux中自然有专门软件替它实现，如搜索文本通过grep完成）还有许多，这里也不过多叙述，为避免卷入圣战，还是需要做一点补充：当然，若不频繁切换自己的环境，或者能找到一种方式稳定在同一环境下工作的话，Emacs迟早也同样能做到甚至超越这些方面（记得有一款Emacs插件叫&quot;evil&quot;，作用是将vim的功能包含到Emacs中来，可见这款插件的意图是多么的邪恶_）。总之，使用工具的方式，决定工具的价值。与Emacs的共通之处Vim与Emacs其实也有许多共通之处，这里只给出我们最容易遇见和理解的两条：相比其他编辑器，Vim的入门门槛高一些，这里给出一个编辑器的学习曲线图：虽然两者入门难度较大，但是两者又都有一个非常好的学习捷径：避免只看理论，尽早让实践成为习惯，在实践中学习。开始学习本文约定特殊按键表示：Space: &lt;SPC&gt;  Ctrl: &lt;CTRL&gt;或&lt;C&gt;  Alt: &lt;ALT&gt;或&lt;M&gt;  Esc: &lt;ESC&gt;（注意，Emacs也将Esc键归为&lt;M&gt;）  Shift: &lt;SHIFT&gt;或&lt;S&gt;  Tab: &lt;Tab&gt;  Enter: &lt;Enter&gt;（有些时候为&lt;RET&gt;或&lt;CR&gt;）  BackSpace:&lt;&lt;BS&gt;（注意，Emacs上表示为&lt;DEL&gt;，Emacs上&lt;DEL&gt;不是Delete按键）  Delete:&lt;Del&gt;  组合键的表示：&lt;Esc&gt;: Escape key&lt;C-G&gt;: CTRL-G&lt;Up&gt;: cursor up key&lt;C-LeftMouse&gt;: Control- left mouse click&lt;S-F11&gt;: Shifted function key 11&lt;M-a&gt;: Meta- a  (&#39;a&#39; with bit 8 set)&lt;M-A&gt;: Meta- A  (&#39;A&#39; with bit 8 set)&lt;t_kd&gt;: &quot;kd&quot; termcap entry (cursor down key)更多内容可以打开Vim并输入:help keycode，参考其帮助手册给出的Key表示。在没有歧义的情况下，可以使用任何方式表示。模式的概念　　Vim具有多种模式，后面会详述，初学时，我们最好能理解其中两种最常见的模式：输入模式又可称为或插入模式、编辑模式。输入模式下输入字符，字符会插入至文本中，并显示在屏幕上。  指令模式又可称为命令模式，是Vim启动后默认的模式。指令模式下输入字符，并不会将相应的字符插入文本，而是将字符解释为一个输入命令并执行，理解指令模式最简单方式就是想象平时剪切、复制以及粘贴数据时所发生的情况。  行命令模式是在指令模式下一种特殊的情况，可以输入复杂的命令用户 。进入行命令模式后，vim底部会有一行空间，供用户输入。用户输入的字符会在这里显示，键入回车后执行相应的命令。总结起来，在本文中，“插入模式”＝“输入模式”＝“编辑模式”、“指令模式”＝“命令模式”、“行命令模式”是特殊的指令模式。基本操作这里提供了使用vi得最基本的操作，能够实现基本的编辑目的。如果你肯花几分钟把这里的内容都实践一下，那么至少能够独立地在Vim中朝你想要得方向“前进”。如果你不想学习，也可以把它当作一个“便签”，现查现用。打开一个文件：输入vi filename。这里，filename就是你要打开的文件的名字，默认打开文件后vi处于指令模式。进入编辑模式编辑打开的文件：输入i.或输入a.进入编辑模式后，你可以直接敲入想要输入的字符到文件，两者的区别是i在当前字符前面开始插入，a在当前字符后面开始插入。退出编辑模式：输入&lt;ESC&gt;.这样，将返回指令模式，准备接收你要传达给vi的指令并执行，如果之前已经在指令模式下，那么系统将响铃提醒一下。以下命令都是在命令模式下进行：撤销修改输入u.这里，相比以前的vi来说，vim支持多步撤销。恢复修改输入&lt;C-r&gt;.这里，和撤销命令相反，是撤销的撤销，也可多步。复制行到剪切板：输入yy.复制选定内容到剪切板：  输入v。按方向键将高亮选择的内容。输入y。这里，开始输入v使vi临时进入了一个&quot;选择模式&quot;，输入方向键可以选择，输入y将选择的内容复制剪切板。  删除行：输入dd.注意，vi的删除等价于剪切，删除的内容会保存到剪切板中。删除选定内容：  输入v。按方向键将高亮选择的内容。输入d。这里，开始输入v使vi临时进入了一个“选择模式”，输入方向键可以选择，输入d将选择的内容删除。粘贴：输入p.这样会将剪切板的内容粘贴到光标位置或者光标下一行。查找字符并定位到第一个匹配处：输入/character.这里character是待查找的字符，只要先输入/，再输入待查字符，最后回车即可定位到第一个匹配的字符处。定位到匹配查找的下一个字符处：输入n.定位到匹配查找的上一个字符处：输入N.保存文件：输入:w.注意w前面的:，输入:之后，vim会将:之后的输入解释为待执行的指令。退出：输入:q.这里，如果文件没有保存，将提示无法退出，除非你强制退出，不保存文件，或者保存退出。强制退出：输入:q!.保存退出：输入:wq.或输入:x.或输入ZZ.  察看帮助输入:help.';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_01Introduction.html"> Vim实践与学习-01简介  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Linux命令学习手册-install'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 功能2. 描述3. 举例4. 其它install [OPTION]... SOURCE... DIRECTORYinstall [OPTION]... -t DIRECTORY SOURCE...install [OPTION]... -d DIRECTORY...1 功能拷贝文件并设置属性， install 可以安装或升级软件或备份数据，它的使用权限是所有用户。 2 描述在前两种格式中，会将 &lt;来源&gt; 复制至 &lt;目的地&gt; 或将多个 &lt;来源&gt; 文件复制至已存在的 &lt;目录&gt; ，同时设定权限模式及所有者/所属组。在第三种格式中，会创建所有指定的目录及它们的主目录。长选项必须用的参数在使用短选项时也是必须的。 主要参数 ：&#x2013;backup[=CONTROL]：为每个已存在的目的地文件进行备份。 -b：类似 &#x2013;backup，但不接受任何参数。 -c：(此选项不作处理)。 -d，&#x2013;directory：所有参数都作为目录处理，而且会创建指定目录的所有主目录。 -D：创建&lt;目的地&gt;前的所有主目录，然后将 &lt;来源&gt; 制至 &lt;目的地&gt; 在第一种使用格式中有用。 -g，&#x2013;group=组：自行设定所属组，而不是进程目前的所属组。 -m，&#x2013;mode=模式：自行设定权限模式 (像 chmod )，而不是 rwxr-xr-x 。 -o，&#x2013;owner=所有者：自行设定所有者 (只适用于超级用户)。 -p，&#x2013;preserve-timestamps：以 &lt;来源&gt; 文件的访问/修改时间作为相应的目的地文件的时间属性。 -s，&#x2013;strip：用 strip 命令删除 symbol table ，只适用于第一及第二种使用格式。 -S，&#x2013;suffix=后缀：自行指定备份文件的 &lt;后缀&gt; 。 -v，&#x2013;verbose：处理每个文件/目录时印出名称。 &#x2013;version：显示版本信息并离开。 &#x2013;help：显示此帮助信息并离开。 3 举例把test拷贝到目录 dir1$install test dir1这里将 test 文件复制到 dir1 目录中，如果 dir1 中有 test 将被替换；不会自动建立目录， dir1 必须已存在，否则把 test 拷贝成 dir1 文件了。创建 dir2/dir21/ 目录$install -d dir2/dir21这里将创建一个 dir2/dir21 目录,如果存在，不会被覆盖，不存在那么就创建这样的多层目录。把 test1 test2 两个文件拷贝到 dir1 目录里面$install -t dir1 test1 test2这里，把 test1 和 test2 文件拷贝到 dir1 目录中，如果没有目录不会自动创建。4 其它这个命令好像不常用， man 手册内容也不多，可以现用现查，一般我在软件 makefile 里面常常看见这个命令的使用。参考资料：http://blog.chinaunix.net/u2/75269/showart_1206016.html      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2009-11-23 一 14:20]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2009-11-23]<a href="/categories/study/linux/command/linux_command_install.html"> Linux命令学习手册-install  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Linux命令学习手册-df'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 功能2. 描述3. 举例4. 其它df -[选项] [文件...]1 功能检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 df 命令可显示所有文件系统对i节点和磁盘块的使用情况。2 描述该命令各个选项的含义如下：  -a 显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如 /proc 文件系统。-k 以k字节为单位显示。  -m 使用 MBytes 显示结果-h 增加显示方式可读性，例如上G了则以G为单位显示-i 显示i节点信息，而不是磁盘块。  -t 显示各指定类型的文件系统的磁盘空间使用情况。  -x 列出不是某一指定类型文件系统的磁盘空间使用情况（与t选项相反）。  -T 显示文件系统类型。  如果给定了文件或者路径名，那么显示的只是和该文件相关的文件系统的相关信息。3 举例列出各文件系统的磁盘空间使用情况输入输出如下:$ dfFilesystem           1K-blocks      Used Available Use% Mounted on/dev/sda1            150837820   8446552 134729068   6% /varrun                 4097572        92   4097480   1% /var/runvarlock                4097572         0   4097572   0% /var/lockudev                   4097572        32   4097540   1% /devdevshm                 4097572         0   4097572   0% /dev/shmlrm                    4097572     44976   4052596   2% /lib/modules/2.6.24-22-generic/volatile192.168.2.5:/store/home                     2399169216 323220096 1954078368  15% /home这里，输出清单的第1列是代表文件系统对应的设备文件的路径名（一般是硬盘上的分区）；第2列给出分区包含的数据块（1024字节）的数目；第3，4列分别表示已用的和可用的数据块数目。用户也许会感到奇怪的是，第3，4列块数之和不等于第2列中的块数。这是因为缺省的每个分区都留了少量空间供系统管理员使用。即使遇到普通用户空间已满的情况，管理员仍能登录和留有解决问题所需的工作空间。清单中Use% 列表示普通用户空间使用的百分比，即使这一数字达到100％，分区仍然留有系统管理员使用的空间。最后，Mounted on列表示文件系统的安装点。另外,实践之后发现：如果未 mount 也会显示信息，但是显示几乎未使用，信息含义不明，但肯定不是使用的剩余空间； mount 之后如果没有进入 mount 点也和未 mount 的结果是一样的；当 mount 之后也进入过 mount 点了，那么用 df /dev/sda* 则显示正确地信息了。列出所有文件系统的磁盘空间使用情况输入输出如下:$df -aFilesystem           1K-blocks      Used Available Use% Mounted on/dev/sda1            150837820   8446596 134729024   6% /proc                         0         0         0   -  /proc/sys                         0         0         0   -  /sysvarrun                 4097572        92   4097480   1% /var/runvarlock                4097572         0   4097572   0% /var/lockudev                   4097572        32   4097540   1% /devdevshm                 4097572         0   4097572   0% /dev/shmdevpts                       0         0         0   -  /dev/ptslrm                    4097572     44976   4052596   2% /lib/modules/2.6.24-22-generic/volatile192.168.2.5:/store/home                     2399169216 323220192 1954078304  15% /homesecurityfs                   0         0         0   -  /sys/kernel/security这里，输出的结果包括0块（block）的文件系统，如 /proc 文件系统.更友好地列出所有文件系统的磁盘空间使用情况输入输出如下:$df -ahFilesystem            Size  Used Avail Use% Mounted on/dev/sda1             144G  8.1G  129G   6% /proc                     0     0     0   -  /proc/sys                     0     0     0   -  /sysvarrun                4.0G   92K  4.0G   1% /var/runvarlock               4.0G     0  4.0G   0% /var/lockudev                  4.0G   32K  4.0G   1% /devdevshm                4.0G     0  4.0G   0% /dev/shmdevpts                   0     0     0   -  /dev/ptslrm                   4.0G   44M  3.9G   2% /lib/modules/2.6.24-22-generic/volatile192.168.2.5:/store/home                      2.3T  309G  1.9T  15% /homesecurityfs               0     0     0   -  /sys/kernel/security这里，可以看出，输出的方式更为友好，具有合适的单位之后，可读性更强。列出各文件系统的i节点使用情况输入输出如下:$ df -iaFilesystem            Inodes   IUsed   IFree IUse% Mounted on/dev/sda1            19169280  279092 18890188    2% /proc                       0       0       0    -  /proc/sys                       0       0       0    -  /sysvarrun               1024393      57 1024336    1% /var/runvarlock              1024393       1 1024392    1% /var/lockudev                 1024393    2760 1021633    1% /devdevshm               1024393       1 1024392    1% /dev/shmdevpts                     0       0       0    -  /dev/ptslrm                  1024393      14 1024379    1% /lib/modules/2.6.24-22-generic/volatile192.168.2.5:/store/home                     304676864 9339216 295337648    4% /homesecurityfs                 0       0       0    -  /sys/kernel/security这里，如果用 df -i 则应该不会输出 /proc 等0 Inodes的行了。列出文件系统的类型输入输出如下:$ df -TFilesystem    Type   1K-blocks      Used Available Use% Mounted on/dev/sda1     ext3   150837820   8446628 134728992   6% /varrun       tmpfs     4097572        92   4097480   1% /var/runvarlock      tmpfs     4097572         0   4097572   0% /var/lockudev         tmpfs     4097572        32   4097540   1% /devdevshm       tmpfs     4097572         0   4097572   0% /dev/shmlrm          tmpfs     4097572     44976   4052596   2% /lib/modules/2.6.24-22-generic/volatile192.168.2.5:/store/home               nfs   2399169216 323220352 1954078112  15% /home这里，可以发现增加了 Type 这列。列出ext3这种类型文件系统的使用情况输入输出如下:$ df -t ext3Filesystem           1K-blocks      Used Available Use% Mounted on/dev/sda1            150837820   8446636 134728984   6% /这里，只列出了ext3类型文件系统的使用情况。列出除ext3类之外的文件系统使用情况输入输出如下:$df -x ext3Filesystem           1K-blocks      Used Available Use% Mounted onvarrun                 4097572        92   4097480   1% /var/runvarlock                4097572         0   4097572   0% /var/lockudev                   4097572        32   4097540   1% /devdevshm                 4097572         0   4097572   0% /dev/shmlrm                    4097572     44976   4052596   2% /lib/modules/2.6.24-22-generic/volatile192.168.2.5:/store/home                     2399169216 323220480 1954078016  15% /home这里，没有列出ext3类型文件系统的使用情况。4 其它主要参考资料:http://fanqiang.chinaunix.net/a1/b1/20010508/133026.html      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2009-11-23 一 15:20]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2009-11-23]<a href="/categories/study/linux/command/linux_command_df.html"> Linux命令学习手册-df  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Linux命令学习手册-awk'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 功能2. 描述2.1. awk 的处理流程2.2. 常用变量（变量名称 代表意义）2.3. 逻辑运算符号3. 举例3.1. 假设输入输出如下：3.2. 假设如下表(pay.txt)4. 其它awk '条件类型1{动作1} 条件类型2{动作2} ...' filename1 功能相较于 sed 常常作用于一整个行的处理， awk 则比较倾向于一行当中分成数个『字段』来处理。2 描述2.1 awk 的处理流程读入第一行，并将第一行的资料填入 $0, $1, $2&#x2026;. 等变数当中；依据 "条件类型" 的限制，判断是否需要进行后面的 "动作"；做完所有的动作与条件类型；若还有后续的『行』的数据，则重复上面 1~3 的步骤，直到所有的数据都读完为止。经过这样的步骤，您会晓得， awk 是『以行为一次处理的单位』， 而『以字段为最小的处理单位』。2.2 常用变量（变量名称 代表意义）NF 每一行 ( $0 ) 拥有的字段总数 NR 目前 awk 所处理的是『第几行』数据 FS 目前的分隔字符，预设是空格键 每一行的每个字段的变量名称就是 $1, $2 &#x2026; 等。还有个例外,那就是 $0 代表一整行的意思。注意， awk 后续的所有动作以 ' 括住， 所以，内容如果想要以 print 打印时，记得，非变量的文字部分， printf 提到的格式中，都需要使用双引号.2.3 逻辑运算符号&gt; 大于 &lt; 小于 &gt;=  大于或等于 &lt;= 小于或等于 ==  等于 !=  不等于 3 举例3.1 假设输入输出如下：$lastdmtsai   pts/0        192.168.1.12     Mon Aug 22 09:40   still logged inroot     tty1                          Mon Aug 15 11:38 - 11:39  (00:01)reboot   system boot  2.6.11           Sun Aug 14 18:18         (7+15:41)dmtsai   pts/0        192.168.1.12     Fri Aug 12 12:07 - 12:08  (00:01)打印每行的第1列和第三列，并且用[TAB]隔开输入输出如下$last | awk '{print $1 "\t" $3}'dmtsai  192.168.1.12root    Monreboot  bootdmtsai  192.168.1.12这里，我们没有设定条件，也就是无论哪一行都做同样处理，所以第2，3行显示的有点"不正常"。由此可知awk是“迭代”处理每一行的。列出每一行的账号，目前处理的行数， 以及该行有多少字段输入输出如下$last | awk '{print $1 "\t lines: " NR "\t columes: " NF}'dmtsai   lines: 1        columes: 10root     lines: 2        columes: 9reboot   lines: 3        columes: 9dmtsai   lines: 4        columes: 10查阅 /etc/passwd ，第3栏小于 10 以下的数据，并且仅列出账号与第3栏输入输出如下：$cat /etc/passwd | awk '{FS=":"} $3 &lt; 10 {print $1 "\t " $3}'root:x:0:0:root:/root:/bin/bashbin      1daemon   2......(以下省略)......这里，在 /etc/passwd 当中是以冒号 ":" 来作为字段的分隔，所以需要设置一下。但是我们读入第一行的时候， 那些变数 $1, $2&#x2026; 预设还以空格键为分隔，所以虽然我们定义了 FS=":" 了， 但是却仅能在第二行后才开始生效（可能因为一般第一行仅仅是列名不需处理，而这里却是特例，见例4改进）。对上面过滤的操作改进输入输出如下：$ cat /etc/passwd | awk 'BEGIN {FS=":"} $3 &lt; 10 {print $1 "\t " $3}'root     0bin      1daemon   2......(以下省略)......利用 BEGIN 这个关键词，可以从第一行就生效了。实际除了BEGIN，还有END。3.2 假设如下表(pay.txt)Name    1st     2nd     3thVBird   23000   24000   25000DMTsai  21000   20000   23000Bird2   43000   42000   41000计算每一行总额，添加追加到最后一列输入输出如下：$awk 'NR==1{printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total" }NR&gt;=2{total = $2 + $3 + $4printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'Name        1st        2nd        3th      TotalVBird      23000      24000      25000   72000.00DMTsai      21000      20000      23000   64000.00Bird2      43000      42000      41000  126000.00注意：所有的动作在 {} 内，如需多个指令辅助，可利用分号 ; 间隔或直接以 [Enter] 按键来隔开每个指令，例如上面的 NR&gt;=2 后面接的动作， 利用 total = &#x2026; 那个指令来指定加总，而后续则以 printf 来格式化输；格式化输出时，在 printf 的格式设定当中，务必加上 \n ，才能进行分行；与 bash shell 的变量不同，在 awk 当中，变量可以直接使用，不需加上 $ 符号（如total）。4 其它参考资料： 《鸟哥的私房菜》      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2009-11-23 一 14:10]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2009-11-23]<a href="/categories/study/linux/command/linux_command_awk.html"> Linux命令学习手册-awk  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
	   var article = 'Linux命令学习手册-0前言'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 读者须知2. 本文内容3. 本文约定3.1. 对于每一个命令，大致分为如下三个部分3.2. 对于每个命令的使用例子，如下说明4. 基本知识4.1. 命令组成4.2. 关于项4.3. 关于项的参数4.4. 基本命令4.4.1. 文件管理相关4.4.2. 权限管理相关4.4.3. 磁盘管理相关4.4.4. 其他操作4.4.5. GNome桌面下面的操作4.4.6. 任务的前台和后台控制4.4.7. 最基本的文件编辑操作1 读者须知这篇文章纯粹是我个人在学习Linux过程中实践的积累，其中语言文字上面也许会有些错误，希望读者发现之后能够帮我纠正，在此先谢了。这里的每个命令都经过我亲身的实践，linux多数命令使用起来并不难，关键是读懂命令的输出信息，以及如何使用命令帮助。我的愿望是大家能够花费尽可能短的时间，熟悉Linux操作系统。如果你仅仅是为了临时做一些事情，那么本文也适合你，你只需要看本前言中的 基本命令 一节即可。如果有人转载，希望您能注明出处和作者；如果将本文用于商业行为，希望您能先通知我；希望大家能够互相体谅，尊重对方的劳动成果。2 本文内容本文档最开始介绍Linux命令相关的基本知识，然后给出一些基本的Linux命令。后面每个章节将分别对每个重要的Linux命令进行详细的讲解，并给出详细的举例。这是一个没有终点的学习，这个手册的内容会随着学习的命令的更多而增加。侧重应用，重在举例，所以想要了解每个命令的具体细节还需要察看man或者info手册。如机会，每个命令可能会在今后完善更新。3 本文约定3.1 对于每一个命令，大致分为如下三个部分功能简单介绍该命令功能。举例给出该命令最常使用的例子。描述详细描述该命令。其他该命令其他杂乱或者补充性的内容。3.2 对于每个命令的使用例子，如下说明以orgmode格式做为文档格式, orgmode格式一方面可读性强,另一方面便于将来导出为各种格式.对于单个命令操作+ 开始的列表项第一行给出要操作的目的，然后是具体的命令，最后给出该命令的详细解释。例如：+ 列出当前目录的内容  =$ls=  这里，将会列出当前目录所文件。如果命令过长，则使用 #+BEGIN_SRC/#+END_SRC 对。对于某个系列的命令具体的命令使用列表给出,而命令所述的系列使用子标题(orgmode中,列表的排版比较容易出错,所以使用子标题,尽量避免嵌套列表)。例如：** 使用vi编辑：   + 编辑之前首先打开文件&lt;filename&gt;:     =$vi filename=   打开文件之后，操作如下：   + 插入     输入 =a=   + 退出     输入 =:q=4 基本知识这里简单介绍linux命令行的一般语法格式。这对初学者很重要，尤其是查找某个命令的帮助手册( man 手册)的时候，不会什么也看不懂。4.1 命令组成一般linux的命令语法格式如下： 命令名称 项 项参数(值) 命令参数(值)例如： od [OPTION]... [FILE]... 这里，命令名称是 =od= ,项是OPTION。这里项用'[]'括起来表示这个部分在 =od= 命令里面可可无。命令的参数是FILE也是可可无；'...'表示其前面的东西（这里是OPTION和FILE可以不只一个.一般来说(不是绝对的)，在 =man= 手册里面，命令中像OPTION和FILE这样的变量形式的参数（即其值取决于用户的键入部分会用特殊颜色显示出来；而 =od= 这样本身是固定的部分（即不是用户能改变的用另外一种颜色显示（例如加粗）。也有的描述中把可变的部分用'&lt;&gt;'括起来。再如： cp [OPTION]... SOURCE... DIRECTORY 从这里可以看出，=cp= 命令参数SOURCE和DIRECTORY,其中SOURCE参数可以是多个，DIRECTORY只能一个。OPTION部分可可无，但是SOURCE和DIRECTORY部分必须要。 具体的例子： =$cp -r file1 file2 dir=4.2 关于项项简单书写形式也复杂书写形式。简单形式的项一般用 - 引出，复杂形式一般用 -- 引出等等。例如: $cp -v file1 file2 等价于 $cp --verbose file1 file2这里，=-v= 和 --verbose 是一样的, -v 是简写形式， --verbose 是复杂形式。 又例如: cp -r src des其中， -r 就是其中的[OPTION]部分，也可以是 --recursive 。另外，有些命令的项不用 - 来引出，例如： $unrar e test.rar使用 e 项指定 unrar 命令解压 test.rar 文件。 有些命令项用 - 做为前缀，然后可以接多个选项,例如： $tar -czvf dir.tgz dir这个命令使用 tar 命令的 -c -z -v -f 四个项，给 dir 目录打包并且压缩，生成结果文件为 dir.tgz.在项用'[]'包含起来表示可的同时，如果几个值其中只能出现一个的话那么用'|'来分开。例如： command [-a|-b]这里， command 是假设的一个命令，这表示这个命令 command 中， -a 和 -b 项，两者要么都没，要么只一个。 4.3 关于项的参数不光是命令，命令的项也可以参数。 这里举一个复杂点的命令gdb [-help] [-nx] [-q] [-batch] [-cd=dir] [-f] [-b bps] [-tty=dev] [-s symfile] [-e prog] [-se prog] [-c core] [-x cmds] [-d dir] [prog[core|procID]]这是 gdb 命令的语法格式，关键的几个部分如下： [-d dir] 就是指,运行gdb命令，可以添加一个可的项 -d ，这个项的参数是 dir.在本文的描述中，不太容易一下子看出 [-d dir] 里面哪部分是固定的字符串，哪部分是随用户输入而变的字符串,但是 man 手册里面都把它们标记为不同的颜色了，实际通过分析也很容易知道哪个部分是可变的。 有些命令项和项的参数之间可以没空格,的项和项参数之间用 = 连接,例如这里的 ~[-cd=dir]'再举一个例子minicom [-somMlwz8] [-c on|off] [-S script] [-d entry] [-a on|off] [-t term] [-p pty] [-C capturefile] [configuration]这是minicom的命令语法，其中[-c on|off]表示-c项是可的（即在命令中可可无，它一个选项参数，参数值可以是on或者off. 4.4 基本命令这里是经常使用的linux命令,用于平时查阅之用.一般而言，超级用户(root)的命令提示符号是 #,一般用户的命令提示符号是 $. 4.4.1 文件管理相关创建名字为1的目录$mkdir 1创建名字为1的文件$touch 1删除名字为1的文件$rm 1查看文件1的内容 $cat 1强制删除一个目录$rm -rf dirname这里， rm -r dirname 是递归删除的意思，如果加上 -i 项，表示删除之前提示是否删除。 重命名/移动文件$mv ./origin ./newname这里，Linux中没专门的重命名命令，这里实际是使用了移动命令来进行的。原来的文件名 origin,新文件名 newname.把文件file1拷贝一份到file2 $cp file1 file2这里，操作都是在当前目录下面进行的,如果拷贝到别的目录，可以指定路径，例如 cp file1 /anotherdir/file2.把目录dir1考到另一个地方为dir2$cp -r dir1 dir2这里， -r 表示递归拷贝所子目录。 进入到一个目录中$cd dirname查看目录dirname中所包含的文件$ls dirname查看目录dirname中所包含的文件的详细信息$ls -l这样，会显示相应文件的详细信息，包括属主，大小，权限等信息。 查看当前的目录$pwd这样，会输出当前所在目录的路径。 创建文件file的硬链接$ln file lnfile这里，使用链接的目录格式类似 cp 。建立硬链接之后，如果删除源，还可以通过这个硬链接访问到这个文件的内容，除非所的硬链接都被删除了，否则文件内容就一直存在的。硬链接不能够跨越文件系统，不能够建立目录的硬链接。 创建文件 file 的软链接$ln -s file lnfile这里，创建软链接，文件名里面 $ 就用了转义 \$ 表示 $,尽量用绝对路径防止出错。软链接可以跨越文件系统，可以为目录创建软链接，但是软链接的文件，如果删除源，链接会失效，类似windows中的快捷方式。 4.4.2 权限管理相关修改文件的权限为所人可读可写可执行$chmod 777 filename这里，文件属主必须是当前用户，否则就只能进入超级用户才能执行这个命令了。 修改文件filename的权限,为other用户添加写权限： $chmod o+w filename修改目录以及所子目录的权限为777$chmod 777 -R dir查看在线登陆用户 $who将一个用户添加到用户组中#usermod -a -G groupA user这里，不要忘记 -a 项。如果用： usermod -G groupA,这做会使 user 用户离开其他用户组，仅仅做为这个用户组 groupA 的成员。 更改用户user的组为groupA#usermod -G groupA user查看所的用户$cat /etc/passwd这里，用户都保存在了 passwd 文件中，所以查看这个文件的内容就可以看到所的用户了。 成功创建一个新用户以后，在 /etc/passwd 文件中就会增加一行该用户的信息，其格式如下： 〔用户名〕：〔密码〕：〔UID〕：〔GID〕：〔身份描述〕：〔主目录〕：〔登陆Shell〕其中每个字段被冒号 : 分成7各部分。 由于小于500的 UID 和 GID 一般都是系统自己保留，不用做普通用户和组的标志，所以新增加的用户和组一般都是 UID 和 GID 大于500的。 查看所的组$cat etc/group查看所的组$cat etc/group这里，用户都保存在了 group 文件中，所以查看这个文件的内容就可以看到所的用户了。 添加一个用户testusr#useradd testusr这里，注意在超级用户模式才能用,刚建立没密码，没自己的home,其他项可以参见man 添加一个用户testusr,并自动建立其用户主目录#useradd -m testusr运行完毕，自动生成用户的家目录，目录里面 .bashrc 等文件。 删除一个用户 testusr#userdel testusr这里，命令不会把主目录删除. 删除一个用户testusr,连同主目录和邮箱缓存等#userdel -r testusr切换到用户testusr$su testusr如果用户需要密码，那么需要输入密码才能登录这个用户。 切换到超级用户$su这样，会提示输入超级用户的密码，输入之后，就会切换成超级用户了。 以超级用户身份运行一个程序$sudo app这样，会以超级用户身份运行app程序，如果当前权限不够的时候，这条命令是很用的。当然，运行之前需要输入自己的密码。还有如 sudo su 也是类似的。 设置更改一个用户testusr的密码#passwd testusr这里，需要在超级用户下，输入之后，按照提示输入旧密码和新密码就行了。如果运行的 passwd 没参数，那么会修改当前用户的密码。更改自己的密码只需输入 passwd 不用切换到超级用户下。 修改用户testusr的主目录和登录的shell#usermod -d/home/quietheart -s/bin/bash testusr这里，用户名 testusr 的主目录路径设置在 /home/testusr,登陆的Shell设置为 /usr/bin/gcc ( -d 更新使用者新的登陆目录, -s 指定新用户Shell),空格无均可. 修改用户testusr名称为test#usermod -l test testusr把用户名 testusr 改成 test ( -l 变更用户登陆时的名称，手册说同时使用者目录名也会跟着更动成新的名称(实践了没变目录呀)) usermod 不允许改变正在线上的使用者帐号名称. 查看当前用户属于的组$groups查看testusr用户属于的组$groups testusr4.4.3 磁盘管理相关查看当前目录大小$du -sh查看文件的大小$du -sh filename这里， filename 是将要查看的文件名称。 查看分区信息fdisk -l这里，会显示你的电脑上面的所磁盘的信息，例如分区，文件系统等。当前必须是 root 用户，否则没权限。 4.4.3.1 挂载磁盘相关你的linux系统必须将其他硬盘的其他分区(例如windows分区)挂载到根目录树中，才能访问相应的分区。 挂载分区 /dev/sda7 到 /mnt/win#mount -t vfat /dev/sda7 /mnt/win这样的挂载可能会出现显示中文的时候乱码,因为可能没指定解码的字符集。必须是超级用户才能执行。 指定gb2312字符集的挂载#mount -t vfat -o iocharset=gb2312 /dev/sda7 /mnt/win这样的挂载的时候，指定使用gb2312字符集，这样就可能没乱码了。其他常用的字符包括cp936,utf8等等(ntfs的一般用utf8挂载)。必须是超级用户才能执行。 查看已经挂载的分区#mount卸载已经挂载的分区#umount /mnt/win或 #umount /dev/sda7这里，是把 /dev/sda7 分区挂载到了 /mnt/win 上面。重新挂载#mount -o rw,remount /mnt/data这里，时候文件系统变为只读了，试试这个命令. 设置系统启动自动挂载某个分区方法之一是在 /etc/fstab 中加入如下内容：/dev/sda8 /mnt/winG vfat defaults,rw,exec,iocharset=utf8,umask=0000 0 0必须 umask=0000, 否则只 root 可以写，并且 root 也不能更改 chmod 777 -R ... 这是自己尝试出来的。4.4.4 其他操作清屏$clear这样，当前用户的屏幕会被“清理”,并被重新刷新，原来输入的命令和命令的输出都被清理掉了，也可以使用 [Ctrl]l 来达到相同的效果。 查看系统的编码$locale输入之后，例如我的机器输出如下： LANG=zh_CN.UTF-8 LC_CTYPE="zh_CN.UTF-8" LC_NUMERIC="zh_CN.UTF-8" LC_TIME="zh_CN.UTF-8" LC_COLLATE="zh_CN.UTF-8" LC_MONETARY="zh_CN.UTF-8" LC_MESSAGES="zh_CN.UTF-8" LC_PAPER="zh_CN.UTF-8" LC_NAME="zh_CN.UTF-8" LC_ADDRESS="zh_CN.UTF-8" LC_TELEPHONE="zh_CN.UTF-8" LC_MEASUREMENT="zh_CN.UTF-8" LC_IDENTIFICATION="zh_CN.UTF-8" LC_ALL=启动xwindow图形界面$startx这个命令是在纯粹的命令行下面运行的命令。 切换到第一个纯命令行终端输入： [Ctrl][Alt][F1]这样，如果在图形界面中运行这个命令，会切换到第一个命令终端上面。可以是 [F1]~[F7] 等。 切换到图形界面输入： [Ctrl][Alt][F7]这样，如果在命令行终端，那么会切换到图形终端上面的是 [F7] 、 [F8] 等等，都不一定,一般是 [F7] 。 退出图形界面两种方法, 方法1， 注销(不会 umount )方法2， 输入: [Ctrl][Alt][Backspace]退出图形界面之后，不会 umount 之前 mount 过的分区。 查看内核版本号$uname -r这里，如果输入 uname -a 会显示所的内核信息。 查看发行的Linux版本号$cat /etc/issue搜索最近匹配的历史命令使用如下步骤进行： 输入 [Ctrl]r输入以前输入的命令的子字符串根据 2 的输入会自动匹配最近的命令。 如果匹配了一个，但是我们需要的命令是更早的，那么再输入一下 [Ctrl]r 。输入回车，运行匹配的命令。在当前目录中寻找指定的文件$find -name filename这样，会在当前目录下递归地寻找名称为 filename 的文件，并且返回它的位置,这里支持通配符号。 在指定的目录中寻找指定的文件$find dirname -name filename这样，会在 dirname 中递归地寻找名称为 filename 的文件。 在文件中查找字符串$grep 'string' filename这样会在文件 filename 中查找指定的字符串'string'并且返回那个字符串的位置。 在当前目录中所文件中查找指定的字符串$grep -r 'string' *这里,使用了通配符号。 查看当前时间$date4.4.5 GNome桌面下面的操作切换桌面工作区域输入 [Ctrl][Alt]&lt;左右方向键&gt;锁屏幕输入 [Ctrl][Alt]l切换不同任务窗口的快捷键输入 [Alt][Tab]在桌面和上次的程序之间进行切换输入 [Ctrl][Alt]d4.4.6 任务的前台和后台控制假设我们运行了多个vi编辑器，以及其他程序(无论前台还是后台，实际上只一个前台的程序)。将当前的程序放到后台停止输入 [Ctrl]z查看所在后台运行的程序$jobs输入之后,输出如下： [1]-  Stopped                 vi [2]+  Stopped                 vi lex这里，使用前面的数字来标记每一个后台运行的程序。 将后台停止的指定程序变成后台运行$bg %1这样会把第一个后台的作业调到后台运行,实际上，用 bg 1 就行了。 这样做之后，效果相当于运行了 app &amp; ，其中app是运行的程序，&amp;表示放在后台。 将指定的后台运行的作业号放到前台运行$fg %1这样会把第一个后台的作业调到前台运行,实际上，用 fg 1 就行了。 将最近的被停止的程序放到前台运行$fg杀掉指定的后台运行的程序$kill %1这样，会在后台运行的作业 %1 给杀掉。注意：这里的作业号用%来进行标记，而不像进程直接用数字了。 4.4.7 最基本的文件编辑操作这里提供了使用 vi 编辑文件的最基本的操作，能够实现大多数的编辑目的。用 vi 打开一个文件输入 vi filename这里， filename 就是你要打开的文件的名字，默认打开文件后 vi 处于指令模式。 进入编辑模式编辑打开的文件输入 i. 或输入 a. 进入编辑模式后，你可以直接敲入想要输入的字符到文件，两者的区别是 i 在当前字符前面开始插入， a 在当前字符后面开始插入。 退出编辑模式输入 [Esc]这样，将返回指令模式，准备接收你要传达给 vi 的指令并执行，如果之前已经在指令模式下，那么系统将响铃提醒一下。 4.4.7.1 以下命令都是vi在命令模式下进行撤销修改输入 u这里，相比以前的vi来说，vim支持多步撤销。 恢复修改输入 [Ctrl]r这里，和撤销命令相反，是撤销的撤销，也可多步。 复制行到剪切板输入 yy复制定内容到剪切板输入 v 。方向键将高亮择的内容。输入 y 。 这里，开始输入 v 使vi临时进入了一个"选择模式"，输入方向键可以择，输入 y 将择的内容复制剪切板。 删除行输入 dd注意，vi的删除等价于剪切，删除的内容会保存到剪切板中。 删除定内容输入 v 。方向键将高亮择的内容。输入 d 。 这里，开始输入 v 使vi临时进入了一个“选择模式”，输入方向键可以择，输入 d 将择的内容删除。 粘贴输入 p 这样会将剪切板的内容粘贴到光标位置或者光标下一行。 查找字符并定位到第一个匹配处输入 /character这里 character 是待查找的字符，只要先输入 / ，再输入待查字符，最后回车即可定位到第一个匹配的字符处。 定位到匹配查找的下一个字符处输入 n 定位到匹配查找的上一个字符处输入 N 保存文件输入 :w 注意 w 前面的 : ，输入 : 之后，vim会将 : 之后的输入解释为待执行的指令。 退出输入 :q这里，如果文件没保存，将提示无法退出，除非你强制退出，不保存文件，或者保存退出。 强制退出输入 :q!保存退出输入 :wq或输入 ZZ. 察看帮助 输入 :help      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2009-11-23 一 14:05]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2009-11-23]<a href="/categories/study/linux/command/linux_command_00Introduce.html"> Linux命令学习手册-0前言  </a> <br>');
		document.write("<hr id='article_line'>");
	   }
      	
    </script>
  </div>
</article>

	
		</td>

              </tr>
              <tr id="tr_page_comment">
		<td colspan="6" valign="bottom">
		  <!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="" data-title="搜索结果" data-url="http://vaqeteart.github.io//search.html"></div>
<!-- 多说评论框 end -->
<script src="/assets/js/comment.js"></script>
		</td>
	      </tr>
              <tr>
                <td id="td_page_footer" colspan="6">
<footer>
  &copy 2015
</footer>
<a id="bottom"></a>
</td>


              </tr>
            </tbody>
        </table>
  </body>
</html>
