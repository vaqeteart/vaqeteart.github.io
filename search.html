<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />  
<title>搜索结果</title>

<!--theme-->
<link rel="stylesheet" type="text/css"
  href="/assets/css/common_green_black.css" media="screen" />
<script src="/assets/js/jquery-1.11.3.min.js"></script>
<script src="/assets/js/common.js"></script>
<script src="/assets/js/category_list.js"></script>


    <link rel="stylesheet" type="text/css"
      href="/assets/css/search.css" media="screen" />
  </head>

  <body>
        <table class="container">
            <tbody id="tb_container">
	      <tr id="tr_navbar">
		<script src="/assets/js/nav.js"></script>
<th id="th_navbar">
    <table class="navbar"> <tbody> <tr>
	<th class="navitm">
	    <a href='/'>主页</a>
	</th>

	<th class="navblank">
	</th>

	<th class="navitm">
	      <a href=/search.html>分类</a>
	      <div id="category_menus" class="second">
  	      	   

		   <script>
		       var categories = {"id":"categories","path":"/","title":"分类","parent":null,"children":{"note":{"id":"categories_note","path":"/categories/note","title":"记事","parent":"categories","children":{"remind":{"id":"categories_note_remind","path":"/categories/note/remind","title":"备忘","parent":"categories_note","children":null},"plan":{"id":"categories_note_plan","path":"/categories/note/plan","title":"计划","parent":"categories_note","children":null}}},"study":{"id":"categories_study","path":"/categories/study","title":"学习","parent":"categories","children":{"problem":{"id":"categories_study_problem","path":"/categories/study/problem","title":"问题","parent":"categories_study","children":null},"git":{"id":"categories_study_git","path":"/categories/study/git","title":"git","parent":"categories_study","children":null},"os":{"id":"categories_study_os","path":"/categories/study/os","title":"操作系统","parent":"categories_study","children":null},"books":{"id":"categories_study_books","path":"/categories/study/books","title":"books","parent":"categories_study","children":{"apue":{"id":"categories_study_books_apue","path":"/categories/study/books/apue","title":"APUE","parent":"categories_study_books","children":null}}},"linux":{"id":"categories_study_linux","path":"/categories/study/linux","title":"linux","parent":"categories_study","children":{"misc":{"id":"categories_study_linux_misc","path":"/categories/study/linux/misc","title":"杂乱","parent":"categories_study_linux","children":null},"command":{"id":"categories_study_linux_command","path":"/categories/study/linux/command","title":"命令","parent":"categories_study_linux","children":null}}},"jekyll":{"id":"categories_study_jekyll","path":"/categories/study/jekyll","title":"jekyll","parent":"categories_study","children":null},"kits":{"id":"categories_study_kits","path":"/categories/study/kits","title":"工具","parent":"categories_study","children":null},"emacs":{"id":"categories_study_emacs","path":"/categories/study/emacs","title":"emacs","parent":"categories_study","children":null},"vim":{"id":"categories_study_vim","path":"/categories/study/vim","title":"vim","parent":"categories_study","children":null}}},"work":{"id":"categories_work","path":"/categories/work","title":"工作","parent":"categories","children":{"progress":{"id":"categories_work_progress","path":"/categories/work/progress","title":"进度","parent":"categories_work","children":null}}},"life":{"id":"categories_life","path":"/categories/life","title":"生活","parent":"categories","children":{"experience":{"id":"categories_life_experience","path":"/categories/life/experience","title":"经验","parent":"categories_life","children":null},"tips":{"id":"categories_life_tips","path":"/categories/life/tips","title":"技巧","parent":"categories_life","children":null}}},"others":{"id":"categories_others","path":"/categories/others","title":"其它","parent":"categories","children":{"rambles":{"id":"categories_others_rambles","path":"/categories/others/rambles","title":"随笔","parent":"categories_others","children":null},"temp":{"id":"categories_others_temp","path":"/categories/others/temp","title":"临时","parent":"categories_others","children":null},"test":{"id":"categories_others_test","path":"/categories/others/test","title":"测试","parent":"categories_others","children":null}}}}};
		       var categories_count = JSON.parse('{"/categories":0}');

  		       
    		       var post_categories = '/categories/study/linux';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/misc';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/misc';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/kits';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/misc';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/os';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/note';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/note';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/emacs';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/emacs';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/life';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/git';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others/rambles';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/others/rambles';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/vim';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			
    		       var post_categories = '/categories/study/linux/command';
    		       if (typeof(categories_count[post_categories]) == "undefined")
    		       {
				categories_count[post_categories] =0;
    		       }
    		       for(var key in categories_count)
    		       {
				if (key.length <= post_categories.length)
        			{
					if (post_categories.substring(0, key.length) 
                			   == key.substring(0,key.length))
            				{
						categories_count[key]+=1;
            				}
        			}
    			}
    			

    			create_category_menu(categories, 0, categories_count);
    			//document.write("hello")
		    </script>
	      </div>
	</th>

        <th class="navitm">
	      <a href='#'>标签</a>
	      <div id="tag_menus" class="second">
	          
		      <a id="gtd_next" href="#"> gtd_next(13)</a>
		  
		      <a id="study" href="#"> study(10)</a>
		  
		      <a id="gtd_done" href="#"> gtd_done(4)</a>
		  
		      <a id="others" href="#"> others(3)</a>
		  
		      <a id="life" href="#"> life(1)</a>
		  
	      </div>
        </th>

	<th class="navblank">
	</th>

	<th class="navitm">
	      <a href=/more.html>更多</a>
        </th>

        <th class="navitm">
	      <a href=/about.html>关于</a>
        </th>

	<th class="navblank" style="width:25%;">
	</th>

	<th class="navitm" style="margin:0; padding:0;border:none;">
	    <form method="get" id="searchform" action="/search.html" style="margin:0;padding:0;height:100%;">
	    	  <span style= "color:#00FF00;">Q</span>
	    	  <span style="border-style:solid; border-width:1px; border-color:#00FF00;
		  		border-top:0px; border-left:0px;border-right:0px; 
				margin:0;padding:0;height:100%;">
				<input value="Search by title (canbe regex)..." name="s" class="s" 
		  	 	onfocus="if (this.value == 'Search by title (canbe regex)...') {this.value = '';}" 
		  	 	onblur="if (this.value == '') {this.value = 'Search by title (canbe regex)...';}"
			 	style="margin:0;padding:0;height:100%;border:none;background: #000000; color:#00A600;" 
			 	type="text">
		  </span>
		  <!--input type="submit" value="Q" style="width:20%;"-->
	    </form>
	</th>

	<th class="navblank">
	</th>

	<th class="navblank">
	</th>

	<a href='#' id="topbtn">⇑</a>

	<a href='#bottom' id="bottombtn">⇓</a>
	<!--⇐⇑⇒⇓-->

  <tr> </tbody> </table>
</th>

	      </tr>
	      <tr>
                  <td id="td_page_header" colspan="6" valign="top" align="right" style="width:100%;">
    <header style="text-align: center;">
	<h1>
	       <a href="/" title="Home Page">
	       QuietHeart's Site
	       </a>
	</h1>
    </header>
</td>



	      </tr>
	      <tr id="tr_page_nav">
		<td colspan="6" valign="bottom">
		  

<!--div id="pagination">
     <div class="pagenavi">
	<span class="page_number">第页/共页</span>
	<a href="/">第一页</a>
	
		<span><<前一页</span>
	
	
	

	
	   <span>后一页>></span>
	
	
	<a href="/page">最后一页</a>
     </div>
</div-->

		</td>
	      </tr>
              <tr id="tr_page_content">
                <td id="td_posts" colspan="6" valign="top">
		  <article>
  <h1 id='header1' style="text-align: center;">搜索结果</h1>
  <hr id='title_line'>
  <div>
    <script>  
	var search = getQuery("s");
	
	   var article = 'Linux 访问权限控制基本原理'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 安全模型2. DAC 安全模型2.1. 用户和组ID信息控制2.1.1. 用户、组、口令信息2.1.2. 举例2.2. 文件权限控制信息2.2.1. 文件类型2.2.2. 访问权限控制组2.2.3. 可设定的权限2.2.4. 举例2.3. 进程权限控制信息2.3.1. 进程权限2.3.2. 举例2.4. 进程访问文件的权限控制策略2.4.1. 规则2.4.2. 举例这里，我们主要介绍 Linux 系统中，权限控制的基本原理。1 安全模型在 Linux 系统中，我们所有的操作实质都是在进行进程访问文件的操作。我们访问文件需要先取得相应的访问权限，而访问权限是通过 Linux 系统中的安全模型获得的。对于 Linux 系统中的安全模型，我们需要知道下面两点Linux 系统上最初的安全模型叫 DAC, 全称是 Discretionary Access Control ，翻译为自主访问控制。后来又增加设计了一个新的安全模型叫 MAC, 全称是 Mandatory Access Control, 翻译为强制访问控制。注意, MAC 和 DAC 不是互斥的， DAC 是最基本的安全模型，也是通常我们最常用到的访问控制机制是 Linux 必须具有的功能， 而 MAC 是构建在 DAC 之上的加强安全机制，属于可选模块。访问前， Linux系统通常都是先做 DAC 检查， 如果没有通过则操作直接失败; 如果通过 DAC 检查并且系统支持 MAC 模块，再做 MAC 权限检查。为区分两者，我们将支持 MAC 的 Linux 系统称作 SELinux, 表示它是针对 Linux 的安全加强系统。这里，我们将讲述 Linux 系统中的 DAC 安全模型。2 DAC 安全模型DAC 的核心内容是：在 Linux 中，进程理论上所拥有的权限与执行它的用户的权限相同。其中涉及的一切内容，都是围绕这个核心进行的。2.1 用户和组ID信息控制2.1.1 用户、组、口令信息通过 /etc/passwd 和 /etc/group 保存用户和组信息，通过 /etc/shadow 保存密码口令及其变动信息， 每行一条记录。用户和组分别用 UID 和 GID 表示，一个用户可以同时属于多个组，默认每个用户必属于一个与之 UID 同值同名的 GID 。对于 /etc/passwd , 每条记录字段分别为 用户名:口令（在 /etc/shadow 加密保存）：UID:GID（默认UID）:描述注释:主目录:登录shell(第一个运行的程序)对于 /etc/group ， 每条记录字段分别为 组名：口令（一般不存在组口令）：GID：组成员用户列表（逗号分割的用户UID列表）对于 /etc/shadow ，每条记录字段分别为： 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:2.1.2 举例以下是对用户和组信息的举例。 /etc/shadow 中的口令信息为加密存储，不举例。$cat /etc/passwd |head -n 5root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/sync$cat /etc/group |head -n 5root:x:0:daemon:x:1:bin:x:2:sys:x:3:adm:x:4:miracle2.2 文件权限控制信息2.2.1 文件类型Linux 中的文件有如下类型：普通文件， 又包括文本文件和二进制文件， 可用 touch 创建；套接字文件， 用于网络通讯，一般由应用程序在执行中间接创建；管道文件是有名管道，而非无名管道， 可用 mkfifo 创建；字符文件和块文件均为设备文件， 可用 mknod 创建；链接文件是软链接文件，而非硬链接文件, 可用 ln 创建。2.2.2 访问权限控制组分为三组进行控制：user 包含对文件属主设定的权限group 包含对文件属组设定的权限others 包含对其他者设定的权限2.2.3 可设定的权限下面给出常见（但非全部）的权限值， 包括：r 表示具有读权限。w 表示具有写权限。x 一般针对可执行文件/目录，表示具有执行/搜索权限。s 一般针对可执行文件/目录，表示具有赋予文件属主权限的权限，只有 user 和 group 组可以设置该权限。t 一般针对目录，设置粘滞位后，有权限的用户只能写、删除自己的文件,否则可写、删除目录所有文件。旧系统还表示可执行文件运行后将text拷贝到交换区提升速度。2.2.4 举例通过 ls -l 可以查看到其文件类型及权限，通过 chmod 修改权限。举例来说，$ ls -l /usr/bin/qemu-i386 -rwxr-xr-x 1 root root 2149080  8月 13  2014 /usr/bin/qemu-i386$ chmod 1775 test/$ ls -l |grep testdrwxrwxr-t 2 miracle video 4096  7月 20 09:31 test$ chmod 2777 test2/$ ls -l |grep test2drwxrwsrwx 2 miracle video 4096  7月 20 09:32 test2$ chmod 4777 test3/$ ls -l |grep test3drwsrwxrwx 2 miracle video 4096  7月 20 09:33 test3输出中， 第1个字符表示文件类型，其中，普通文件(-)、目录文件 (d)、套接字文件(s)，管道文件(p)，字符文件(c)，块文件(b)，链接文件(l)； 第2个字符开始的 -rwxr-xr-x 部分表示文件的权限位，共有9位。对于文件 /usr/bin/qemu-i386 , 这个权限控制的含义是：第2~4位的 rwx 表示该文件可被它的 owner （属主）以 r 或 w 或 x 的权限访问。第5~7位的 r-x 表示该文件可被与该文件同一属组的用户以 r 或 x 的权限访问第8~10位的 r-x 表示该文件可被其它未知用户以 r 或 x 的权限访问。对于 test/, test2/, test3/ 设定的权限：r,w,x 权限对每一权限控制组的权限用一位8进制来表示； 例如： 755 表示 rwxr-xr-x 。s,t 权限会替代 x 位置显示；设定 s,t 权限则需在对应的、用于控制 r,w,x 的8进制权限控制组前追加数字； s 权限用于属主属组控制， t 用于其它控制。设定属主 s 需追加 4, 设定属组 s 追加 2, 设定其它者 t 权限追加 1 ； 例如前面对 test/ 设定 t, 则用 1775, 表示 rwxrwxr-t 。2.3 进程权限控制信息2.3.1 进程权限对于进程，有如下属性与文件访问权限相关：effective user id : 进程访问文件权限相关的 UID （简写为 euid ）。effective group id : 进程访问文件权限相关的 GID （简写为 egid ）。real user id : 创建该进程的用户登录系统时的 UID （简写为 ruid ）。real group id :  创建该进程的用户登录系统时的 GID （简写为 rgid ）。saved set user id : 拷贝自 euid 。saved set group id : 拷贝自 egid 。2.3.2 举例我们可以使用 ps 和 top 选择查看具有 euid 和 ruid 的进程。或者通过 top 来查看进程的 euid 和 ruid通过 top 来查看的例子：首先输入 top 得到类似如下 $top -d 10.10top - 15:50:39 up 9 days,  1:42,  9 users,  load average: 0.13, 0.16, 0.21Tasks: 287 total,   2 running, 284 sleeping,   0 stopped,   1 zombieCpu(s): 20.8%us,  4.6%sy,  0.0%ni, 72.5%id,  2.1%wa,  0.0%hi,  0.0%si,  0.0%stMem:   7707276k total,  7574252k used,   133024k free,   154872k buffersSwap:  1998844k total,   223744k used,  1775100k free,  3330212k cached  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                                31603 miracle   20   0 2368m 681m  52m S    6  9.1 206:07.74 firefox                                                                                 1507 root      20   0  451m 188m  97m S    2  2.5 193:49.86 Xorg  ....这里通过 -d 选项延长 top 的刷新频率便于操作。此处可见，只有 USER 字段，表示相应进程的 effective user id.打开 read user id 的显示选项在 top 命令运行期间，输入 f, 可以看见类似如下行：c: RUSER      = Real user name输入 c 即可打开 Real user name 的显示开关。* C: RUSER      = Real user name最后 Return 回车回到 top 中，即可看到 real user id 的选项此时输入 o,可调整列次序最终我们可看到包含 effective user id 和 real user id 的输出如下：top - 15:57:58 up 9 days,  1:49,  9 users,  load average: 0.23, 0.22, 0.23Tasks: 286 total,   1 running, 284 sleeping,   0 stopped,   1 zombieCpu(s):  3.9%us,  1.4%sy,  0.0%ni, 94.6%id,  0.1%wa,  0.0%hi,  0.0%si,  0.0%stMem:   7707276k total,  7539776k used,   167500k free,   154996k buffersSwap:  1998844k total,   225132k used,  1773712k free,  3300036k cached  PID USER     RUSER     PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                              31603 miracle  miracle   20   0 2376m 688m  52m S    4  9.2 206:24.14 firefox                     1507 root     root      20   0  451m 188m  97m S    3  2.5 194:06.27 Xorg   ....其中， PID 是对应进程， USER 是对应的 effective user, RUSER 是对应的 real user 。2.4 进程访问文件的权限控制策略2.4.1 规则2.4.1.1 进程访问文件大致权限控制策略对于进程访问文件而言，最重要的是 euid, 所以其权限属性均以 euid 为 "中心"。进程的 euid 一般默认即为 其 ruid 值若可执行文件的可执行权限位为 s ，进程对其调用 exec 后，其 euid 被设置为该可执行文件的 user id进程的 saved set user id 拷贝自 euid.当进程的 euid 与文件的 user id 匹配时，进程才具有文件 user 权限位所设定的权限组权限 egid 的控制规则类似。2.4.1.2 通过 exec 执行文件修改权限属性通过 exec 调用可执行文件之时：进程 ruid 值始终不变；saved set-user ID 始终来自 euid ；euid 值取决于文件的 set-user-ID 位是否被设置。如下：IDset-user-ID bit offset-user-ID bit onreal user IDunchangedunchangedeffective user IDunchangedset from userID of program filesaved set-user IDcopied from effective user IDcopied from effective user ID2.4.1.3 通过 setuid(uid) 系统调用修改权限属性通过 setuid(uid) 修改权限属性之时： superuser 可顺利修改 ruid, euid, saved set-user ID ；unprivileged user 只能在 uid 与 ruid 相等时修改 euid, 其它无法修改。如下：IDsuperuserunprivileged userreal user IDset to uidunchangedeffective user IDset to uidset to uidsaved set-user IDset to uidunchanged2.4.2 举例再举几个比较特别的例子：2.4.2.1 设置了 set-user-id$ ls -l /usr/bin/sudo-rwsr-xr-x 1 root root 71288  2月 28  2013 /usr/bin/sudo如前所述，这个输出的含义是，对于 /usr/bin/sudo 文件，第1~3位的 rws 表示该文件可被它的owner（属主）以 r 或 w 或 s 的权限访问第4~6位的 r-x 表示该文件可被与该文件同一属组的用户以 r 或 x 的权限访问。第7~9位的 r-x 表示该文件可被其它未知用户以 r 或 x 的权限访问。这样设置之后，对于owner，具有读、写、执行权限，这一点没有什么不同。但是对于不属于 root 组的普通用户进程来说，却大不相同。普通用户进程执行 sudo 命令时通过其 others 中的 x 获得执行权限，再通过 user 中的 s 使得普通用户进程临时具有了 sudo 可执行文件属主( root )的权限，即超级权限。这也是为什么通过 sudo 命令就可以让普通用户执行许多管理员权限的命令的原因。2.4.2.2 设置了 stick-bit$ ls -l / |grep tmpdrwxrwxrwt  25 root root 12288  7月 20 09:09 tmp这样设置之后，对于 /tmp 目录，任何人都具有读、写、执行权限，这一点没有什么不同。但是对于 others 部分设置了粘滞位 t, 其功能却大不相同。若目录没设置粘滞位，任何对目录有写权限者都则可删除其中任何文件和子目录，即使他不是相应文件的所有者，也没有读或写许可; 设置粘滞位后，用户就只能写或删除属于他的文件和子目录。这也是为什么任何人都能向 /tmp 目录写文件、目录，却只能写和删除自己拥有的文件或目录的原因。2.4.2.3 举一个 man 程序的应用片断，描述 set-user-id 和 saved set-user-id 的使用man 程序可以用来显示在线帮助手册， man 程序可以被安装指定 set-user-ID 或者 set-group-ID 为一个指定的用户或者组。 man 程序可以读取或者覆盖某些位置的文件，这一般由一个配置文件(通常是 /etc/man.config 或者 /etc/manpath.config )或者命令行选项来进行配置。man 程序可能会执行一些其它的命令来处理包含显示的 man 手册页的文件。为防止处理出错， man 会从两个特权之间进行切换：运行 man 命令的用户特权，以及 man 程序的拥有者的特权。需要抓住的主线：当只执行 man 之时，进程特权就是 man 用户的特权， 当通过 man 执行子进程（如通过 !bash 引出shell命令）时，用户切换为当前用户，执行完又切换回去。过程如下：假设 man 程序文件被用户 man 所拥有，并且已经被设置了它的 set-user-ID 位，当我们 exec 它的时候，我们有如下情况：real user ID = 我们的用户UIDeffective user ID = man用户UIDsaved set-user-ID = man用户UIDman 程序会访问需要的配置文件和 man 手册页。这些文件由 man 用户所拥有，但是由于 effective user ID 是 man,文件的访问就被允许了。在 man 为我们运行任何命令的时候，它会调用 setuid(getuid())) (getuid() 返回的是 real user id).因为我们不是 superuser 进程，这个变化只能改变 effective user ID. 我们会有如下情况：real user ID = 我们的用户UID(不会被改变)effective user ID = 我们的用户UIDsaved set-user-ID = man 的用户UID(不会被改变)现在 man 进程运行的时候把我们得UID作为它的 effective user ID.这也就是说，我们只能访问我们拥有自己权限的文件。也就是说，它能够代表我们安全地执行任何 filter.当 filter 做完了的时候， man 会调用 setuid(euid).这里， euid 是 man 用户的UID.(这个ID是通过 man 调用 geteuid 来保存的)这个调用是可以的，因为 setuid 的参数和 saved set-user-ID 是相等的。(这也就是为什么我们需要 saved set-user-ID).这时候我们会有如下情况：real user ID = 我们的用户UID(不会被改变)effective user ID = man的UIDsaved set-user-ID = man 的用户UID(不会被改变)由于 effective user ID 是 man,现在 man 程序可以操作它自己的文件了。通过这样使用 saved set-user-ID,我们可以在进程开始和结束的时候通过程序文件的 set-user-ID 来使用额外的权限。然而，期间我们却是以我们自己的权限运行的。如果我们无法在最后切换回 saved set-user-ID,我们就可能会在我们运行的时候保留额外的权限。下面我们来看看如果 man 启动一个 shell 的时候会发生什么： 这里的 shell 是 man 使用 fork 和 exec 来启动的。因为这时 real user ID 和 effective user ID 都是我们的普通用户UID(参见step3)， 所以 shell 没有其它额外的权限.启动的 shell 无法访问 man 的 saved set-user-ID(man) ,因为 shell 的 saved set-user-ID 是由 exec 从 effective user ID 拷贝过来的。在执行 exec 的子进程( shell )中，所有的 user ID 都是我们的普通用户ID.实际上，我们描述 man 使用 setuid 函数的方法不是特别正确，因为程序可能会 set-user-ID 为 root .这时候， setuid 会把所有三种uid都变成你设置的id，但是我们只需要设置 effective user ID.      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2017-02-20 一 20:25]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2017-02-20]<a href="/categories/study/linux/linux_system_access.html"> Linux 访问权限控制基本原理 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '小米路由器DIY'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 小米路由器ssh开启1.1. 烧写开发板1.1.1. 网址：ROM 2.0 开发版1.1.2. 烧写：1.1.3. 总结：1.2. 烧写ssh1.2.1. 网址：MiWiFi开放平台1.2.2. 下载：1.2.3. 烧写：1.2.4. 总结：1.3. 访问文件系统权限2. 小米路由器防火墙配置2.1. 开启端口2.2. 端口转发2.3. 禁用端口3. 使用opkg在小米路由器软件管理3.1. 配置软件源地址3.2. 用opkg在小米路由器(openwrt)上进行软件管理3.3. 软件管理中遇到的问题3.3.1. 找不到软件，则需更换软件源3.3.2. 无法安装，则需配置架构信息3.3.3. 安装成功，无法运行，需要更换二进制文件，使之支持当前路由器 cpu 架构3.4. 参考资料4. 小米路由器交叉编译环境配置5. 在小米路由器上搭建基于LNMP的Owncloud云平台5.1. PC上搭建Owncloud5.1.1. 安装openssl5.1.2. 安装php所需依赖5.1.3. 编译、安装php5.1.4. 安装nginx所需依赖5.1.5. 编译、安装nginx5.1.6. Mysql的root帐号建立5.1.7. php的配置和运行5.1.8. ssl key文件的生成5.1.9. nginx的配置和运行5.1.10. 搭建owncloud网站5.1.11. 安装Owncloud5.2. 小米路由器上搭建Owncloud5.2.1. 准备交叉编译环境5.2.2. 下载相关软件包5.2.3. 交叉编译安装MySql5.2.4. 交叉编译安装PHP5.2.5. 交叉编译安装nginx5.2.6. 部署到小米路由器上的内容5.3. 参考资料6. 小米路由器上使用 git 版本控制系统6.1. 下载 git 源码6.2. 非交叉编译 git 过程6.3. 交叉编译 git6.3.1. 配置交叉编译环境路径6.3.2. 生成配置脚本6.3.3. 编译、安装6.3.4. 部署与配置6.3.5. WAIT/FORWARD FAQ [%][/]7. Misc7.1. 小米路由器添加ddns7.2. 小米路由器修改ssh启动的欢迎语8. WAIT/FORWARD FAQ [12/19] [63%]8.1. DONE 小米路由如何开启ssh?8.1.1. 下面内容仅参考暂不用8.2. DONE 小米路由器防火墙如何配置?8.3. DONE 小米路由如何添加域名访问？8.4. DONE 小米路由器交叉编译环境配置8.5. DONE 如何使用软件管理工具管理小米路由上的软件?8.6. DONE 开启ssh后无法获得系统文件夹写入权限?8.7. DONE 在小米路由器上搭建基于LNMP的Owncloud云平台8.8. CANCEL Myowncloud8.8.1. site: &lt;暂不可用&gt;8.8.2. step8.8.3. refer8.9. CANCEL owncloud升级8.10. CANCEL owncloud issue8.11. DONE 如何小米路由器上使用 git 版本控制系统?8.12. MAYBE/FUTURE 交叉编译mysql-5.7.118.12.1. try cmake8.13. LATER 小米路由器搭建ftp服务8.13.1. 交叉编译环境8.13.2. 源代码下载：8.13.3. 编译libcrypt8.13.4. 修改Makefile8.13.5. 编译8.13.6. 开启防火墙8.13.7. 如何运行？8.13.8. 8.14. MAYBE/FUTURE 交叉编译vim8.15. NEXT Seafile8.15.1. DONE PC 上安装Seafile8.15.2. 编译Seafile8.15.3. 交叉编译Seafile8.15.4. 参考资料8.16. WAIT/FORWARD SparkleShare8.16.1. CANCEL PC上的编译安装8.16.2. Ubuntu上直接安装8.16.3. 参考网址：8.17. MAYBE/FUTURE dvcs-autosync8.18. CANCEL git annex8.18.1. 源代码8.18.2. 参考资料8.19. MAYBE/FUTURE git lfs原文参考：小米路由器DIY曾经还以为自己是一枚成长迅速的米粉，但是渐渐却发现，我不适合做为米粉。尽管购买过红米手机、但是我现在觉得目前使用魅蓝更好用。尽管之前购买了小米路由、小蚁摄像机、小米插排……现在也正在使用着，但这并不表示我忠爱小米，只能说我是一个小米“受害者”，宣传的力量真是不可忽视。我相信小米也有它自己的好处，但是真的觉得它不适合我，在这台路由器上如此折腾，只是不得不使用已经花钱用买过的东西，很大程度上也可能是因为对Linux的兴趣。这个文章没有贬低小米的意思，更无意与人争执，只是最开始表达一些个人的情绪，不喜者，可以略过。分享此文出来供喜欢和不喜欢小米的朋友们参考，以及自己记录。通过此文，可以让专业和有些专业背景的朋友们了解如下内容：如何在特定平台上进行交叉编译，实现源码跨平台运行如何在特定平台上搭建自己的云存储体系如何在特定平台上搭建 php/nginx 提供web服务如何在特定平台上搭建 mysql 数据库如何在特定平台上搭建基于 git 的管理代码仓库服务其它，待更新这里的特定平台，小米路由器上实践，在其它 openwrt 或者 linux 系统上，应当能够类似实现。接下来主要介绍在小米路由器上面讲述有关这些方面的问题。1 小米路由器ssh开启开启ssh访问，小米路由器需升级到开发版0.5.28及以上，小米路由器mini需升级到开发版0.3.84及以上。注意：稳定版不支持。1.1 烧写开发板1.1.1 网址：ROM 2.0 开发版下载：http://bigota.miwifi.com/xiaoqiang/rom/r2d/brcm4709_r2d_all_6c01b_2.11.67.bin1.1.2 烧写：U盘刷机步骤：1、准备一个系统格式为FAT或FAT32的U盘；2、到小米路由器的官网miwifi.com下载用来进行刷机的ROM包；重要的事情再说三遍：U盘刷机会清空硬盘上的数据！会清空硬盘上的数据！！会清空硬盘上的数据！！！3、将下载好的ROM包放到U盘的根目录下，并命名为“miwifi.bin”；4、对于指示灯为红色闪烁或者红色常亮的情况，直接将U盘插入路由器的USB接口，用细长的工具按住reset，待路由器指示灯变为黄灯闪烁时，松开reset；对于指示灯为其他状态的情况，需要先断开路由器的电源后，将U盘插入路由器的USB接口，用细长的工具按住reset，接通电源，待路由器指示灯变为黄灯闪烁时，松开reset5、大约3-5分钟后，指示灯变成黄色常亮状态时可以拔掉U盘，此时刷机已经完成正在重启，稍等片刻路由器指示灯变蓝就可以正常使用了。如果在刷机过程中，指示灯黄灯闪烁几秒后变为黄灯常亮状态，说明此次U盘刷机过程失败，请检查以上的刷机过程并重新进行刷机操作。1.1.3 总结：下载rom拷贝到u盘路由器断电、插入u盘(fat32格式)按住reset上电等待黄灯闪烁，松开reset一直等待，直至蓝灯。1.2 烧写ssh1.2.1 网址：MiWiFi开放平台1.2.2 下载：https://d.miwifi.com/rom/ssh1.2.3 烧写：工具包使用方法：小米路由器需升级到开发版0.5.28及以上，小米路由器mini需升级到开发版0.3.84及以上。注意：稳定版不支持。    请将下载的工具包bin文件复制到U盘（FAT/FAT32格式）的根目录下，保证文件名为miwifi_ssh.bin；    断开小米路由器的电源，将U盘插入USB接口；    按住reset按钮之后重新接入电源，指示灯变为黄色闪烁状态即可松开reset键；    等待3-5秒后安装完成之后，小米路由器会自动重启，之后您就可以尽情折腾啦 ：）1.2.4 总结：下载rom拷贝到u盘路由器断电、插入u盘(fat32格式)按住reset上电等待黄灯闪烁，松开reset一直等待，直至蓝灯。1.3 访问文件系统权限开启ssh后无法获得系统文件夹写入权限，只能读写外接硬盘的内容。这对有时候系统级别的配置不太方便。这主要是因为挂载的时候，以只读方式挂载了相应的目录，执行下述命令即可：$mount -o remount -rw /2 小米路由器防火墙配置2.1 开启端口使用WinSCP软件进入192.168.31.1 端口22，用户名 root 密码 admin 文件协议改为SCP进入,进入后打开/etc/config/firewall这个文件的尾部增加：    config rule 'httpdwan'          	option src 'wan'         	option dest_port '8088'    	option proto 'tcp'    	option target 'ACCEPT'    	option name ''\''httpd wan accept tcp port 8088'\'''保存后，SSH到路由的22端口执行 /etc/init.d/firewall restart 重启防火墙。参考：小米路由器防火墙开启端口，让外部网络访问你的小米路由2.2 端口转发修改 /etc/config/firewall# port redirect of remapped ssh port (22001) on wanconfig redirect 'myssh'option src wanoption src_dport 10022option dest lanoption dest_port 22option proto tcp重启防火墙 /etc/init.d/firewall restart参考 小米路由器mini如何设置外网访问ssh2.3 禁用端口默认端口不对外开放。3 使用opkg在小米路由器软件管理小米路由器系统是openwrt系统，该系统基于linux，使用 opkg 工具实现软件管理，该工具类似ubuntu中的 apt-get 或者centeros 中的 yum 工具。目前的现状其实是：找不到适合xiaomi路由器架构的合适的软件源，通过openwrt的所有软件源中相应交叉工具链的信息，发现很难找到和小米路由器相符的软件。这样的结果是，即使使用某一个软件源，强行配置将对应软件安装到小米路由器中，也无法运行。 最稳妥的方式还是使用小米路由器提供的交叉编译工具链，通过源代码交叉编译要使用的软件包，这需要一些专业技术（例如如何通过autotools 配置交叉编译选项等等）， 所以对于小米路由器，普通用户其实也很难自由的安装所需软件。下面给出的信息，也算为遇到相关问题的同仁提供一个参考。使用opkg管理软件的大致方式如下3.1 配置软件源地址配置文件为 /etc/opkg.conf, 下面是一个配置文件完整的例子：#src/gz attitude_adjustment http://downloads.openwrt.org/attitude_adjustment/12.09/brcm4709/R2D/packages#src/gz attitude_adjustment http://downloads.openwrt.org/attitude_adjustment/12.09/brcm63xx/generic/packagessrc/gz attitude_adjustment http://downloads.openwrt.org/attitude_adjustment/12.09/brcm47xx/generic/packages#src/gz attitude_adjustment http://downloads.openwrt.org/attitude_adjustment/12.09/omap4/generic/packagesdest root /datadest ram /tmplists_dir ext /data/var/opkg-listsoption overlay_root /dataarch all 1arch noarch 1arch brcm4709 10arch brcm47xx 100arch brcm53xx 110arch brcm63xx 120arch omap4 130这里的含义不言而喻，最关键的还是最开始列出的地址信息，指明了软件源中所包括的软件从哪里下载。这里为 http://downloads.openwrt.org/attitude_adjustment/12.09/brcm47xx/generic/packages 。其它为安装时的路径和架构信息，用到之时自然会明白。3.2 用opkg在小米路由器(openwrt)上进行软件管理opkg 使用方法类似 ubuntu下的 apt-get, 具体如下：更新软件源当我们修改软件元配置文件 /etc/opkg.conf 中的软件源信息之后，需要更新本地软件源索引，才能继续后面的使用。命令如下：#opkg update查看当前系统支持安装的架构$opkg print-architecture只有符合这里列出的架构的软件包，才能被安装。直接下载 *.ipk 安装我们可以直接下载相应的 *.ipk 文件进行安装， 例如安装screen$wget -c http://downloads.openwrt.org/attitude_adjustment/12.09/brcm47xx/generic/packages/screen_4.0.3-3_brcm47xx.ipk#opkg install screen_4.2.1-2_ralink.ipk这里， ipk 文件的地址，通过软件源配置文件可以猜到。通过软件源配置文件中的软件源库进行安装配置好软件源库，并且更新后，不用将 .ipk 文件下载，直接可以如下安装：#opkg install libgcc#opkg install ./libc_0.9.33.2-1_brcm47xx.ipk #opkg install ./screen_4.0.3-3_brcm47xx.ipk安装之后，工具会在 /data/usr/ 相关的子目录中。查找软件源库中是否存在某软件假设我们查找是否存在包含 screen 字样的软件，可如下：#opkg find screen查看软件源库中所有的软件#opkg list查看已经安装的软件#opkg list-installed卸载#opkg remove --autoremove screen#opkg remove --autoremove --force-removal-of-essential-packages libc#opkg remove --autoremove --force-removal-of-essential-packages libgcc这里对screen这样的普通程序，卸载之时可以加上 --autoremove 同时卸载掉无用的依赖。而对于 libc 这样的特殊库，需要再加额外选项才能强制卸载。更多卸载的命令可以查看帮助信息：$opkg3.3 软件管理中遇到的问题3.3.1 找不到软件，则需更换软件源我们想安装某软件之前，只需找到包含该软件的相应软件源地址后，填入 opkg.conf 中即可，例如你可能会找到如下的源：#src/gz attitude_adjustment http://downloads.openwrt.org/attitude_adjustment/12.09/brcm4709/R2D/packages#src/gz attitude_adjustment http://downloads.openwrt.org.cn/PandoraBox/ralink/packages/packages#src/gz attitude_adjustment http://downloads.openwrt.org/attitude_adjustment/12.09/brcm47xx/generic/packages#src/gz attitude_adjustment http://downloads.openwrt.org/attitude_adjustment/12.09/brcm63xx/generic/packagessrc/gz attitude_adjustment http://downloads.openwrt.org/snapshots/trunk/bcm53xx/generic/packages/packages使用其中一个即可。软件源中实际的软件包文件都是*.ipk格式，是事先用交叉编译方式编译好的二进制程序。3.3.2 无法安装，则需配置架构信息如果无法安装，可能是由于架构不匹配导致，需要通过命令 opkg print-architecture 查看当前系统支持的架构，再根据被安装的安装包名称，确定需支持的架构。如果当前系统不支持被安装软件包所需支持的架构，那么则修改/etc/opkg.conf 添加类似如下：arch all 100arch brcm4716 200arch brcm47xx 300arch bcm53xx 310这里安装的软件包为 screen_4.0.3-3_brcm47xx.ipk, 通过名字可知其架构为 brcm47xx; 而添加的 arch brcm47xx 与该软件包的架构匹配。 添加之后，所以即可安装成功。注意：安装成功不代表可以成功运行，参见后面。修改 /etc/opkg.conf 的操作会修改 opkg print-architecture 默认配置。根据列出的结果，依次按照优先级匹配相应的内容。3.3.3 安装成功，无法运行，需要更换二进制文件，使之支持当前路由器 cpu 架构前面配置好架构之后虽然能够安装软件，但是不一定能够运行。这里仍以 screen 为例，如果仍然无法运行 screen 。则需要确认一下其二进制文件中的cpu架构信息。将安装好的二进制文件 screen, 以及小米路由器上可运行的原生的 busybox 二进制文件拷贝到linux上，用 file 查看其架构是否一样。这里如下，screen 中的架构信息为：$file screenscreen: ELF 32-bit LSB executable, MIPS, MIPS32 version 1, dynamically linked (uses shared libs), corrupted section header size而 busybox 中的架构信息为：busybox: ELF 32-bit LSB executable, ARM, version 1 (SYSV), dynamically linked (uses shared libs), stripped可见 screen 无法运行，是由于实际cpu架构不一致问题（注意，这里的架构不是前面配置的架构，而是运行所需的实际架构），导致无法运行。解决方法有二：直接用小米官网上提供的小米路由器对应的交叉编译工具链，结合相应软件（screen）源代码，编译出一个可执行的程序。在openwrt相关软件源网站中，寻找能够和当前主机架构一致（或最接近）的架构的软件源。寻找匹配架构的软件源这里不讲交叉编译的方法（事实上交叉编译的方法各个软件各不相同）。讲述当软件无法运行之时，如何找到可以运行的软件。首先，需要确定当前小米路由器上的 busybox 支持的cpu架构。如前所述，通过 file 命令，可以看到是 ARM, version 1 (SYSV),... 。只有二进制文件中的信息和此相一致之时，才可能运行得起来。其次，确认配置文件中，软件源中软件所支持的cpu架构。当然，我们可以先配置好架构信息，将软件安装上，然后类似前面，通过 file 命令查看相应的软件程序所支持的架构。但是这样做，太麻烦了，每检查一个软件源，就需要安装该源的软件，并且查看。其实有更简单的方法。我们前面配置中使用的是如下软件源： src/gz attitude_adjustment http://downloads.openwrt.org/attitude_adjustment/12.09/brcm47xx/generic/packages, 所以到 http://downloads.openwrt.org/attitude_adjustment/12.09/brcm47xx/generic/ 中，看到如下类似的链接：Parent directory/	-	-packages/	-	09-Jul-2014 08:05OpenWrt-ImageBuilder-brcm47xx-for-linux-i486.tar.bz2	355705874	03-Apr-2013 08:39OpenWrt-SDK-brcm47xx-for-linux-i486-gcc-4.6-linaro_uClibc-0.9.33.2.tar.bz2	629822123	03-Apr-2013 08:39OpenWrt-Toolchain-brcm47xx-for-mipsel-gcc-4.6-linaro_uClibc-0.9.33.2.tar.bz2这里，注意 xxxToolchainxxx, 由此可知，之前软件源配置中指定的软件源是mipsel相关的架构（这也和前面我们通过file命令中看到的结果一致），和我们的arm不一致。用类似的方法可以找到合适的架构，比如我们看到 http://downloads.openwrt.org/attitude_adjustment/12.09/omap4/generic/ 中的信息：OpenWrt-Toolchain-omap4-for-arm_v7-a-gcc-4.6-linaro_uClibc-0.9.33.2_eabi.tar.bz2发现这个软件源采用的arm架构，大致上和我们小米路由器上显示的 busybox 的架构更为接近，所以这个软件源中的软件可能会在小米路由器上运行起来。当然这里只是一个例子，还需实践一下（重新配置软件源、添加omap4的架构配置、更新软件源、安装软件、运行），才能确定。3.4 参考资料关于软件源的问题参考http://www.right.com.cn/FORUM/thread-158625-1-1.htmlhttp://bbs.xiaomi.cn/t-9915018关于适用与openwrt系统的已有软件源网址，可到如下网站结合自己机器实际情况比对寻找：https://wiki.openwrt.org/doc/techref/opkghttp://downloads.openwrt.org/snapshots/trunk/bcm53xx/generic/packages/packageshttp://downloads.openwrt.org.cn/PandoraBox/ralink/packages/packages/http://downloads.openwrt.org/attitude_adjustment/12.09/brcm47xx/generic/packages/https://downloads.openwrt.org/chaos_calmer/15.05.1/bcm53xx/generic/packages/关于配置软件架构参考https://wiki.openwrt.org/doc/techref/opkg Adjust Architecturesn 部分的内容。关于安装最新ipk包提示postinst出错解决方法参见http://www.ddhow.com/blog/postinst.html4 小米路由器交叉编译环境配置配置好小米交叉编译环境，所有的软件基本上从源码级别上原生即可编译生成，无需上网寻找各种人家做好的软件包。是最理想安装软件的方法。下载首先到官网网站： 小米开放平台 下载交叉编译工具链。根据自己的路由器型号选择其中的 "插件开发文档" 链接。$mkdir -p /home/miracle/work/1_inbox/xiaomirouter/test$cd /home/miracle/work/1_inbox/xiaomirouter/test$wget -c http://bigota.miwifi.com/xiaoqiang/sdk/tools/package/sdk_package.zip设置交叉编译环境$unzip sdk_package.zip$export PATH=/home/miracle/work/1_inbox/xiaomirouter/test/sdk_package/toolchain/bin:$PATH这里设置交叉编译环境是为了让源代码通过该交叉编译工具进行编译，这样生成的可执行文件才符合小米路由器cpu的架构，能够在小米路由器上执行。而pc上直接编译生成的可执行文件只能在pc上执行（因为pc和小米路由器的cpu架构不同）。之后的内容，全部基于该交叉编译工具链进行。从源代码配置、编译、安装生成可运行的软件可执行文件，许多开源软件，基本都是利用GNU Auto tools工具进行，遵循 configure, make, make install 三部曲。5 在小米路由器上搭建基于LNMP的Owncloud云平台Mega Sync、Box、DropBox、苹果icloud、微软Sky Driver、Google的GDriver、腾讯微云、百度云、新浪微盘、坚果云、金山快盘、七牛、115网盘、华为网盘、Ubuntu One、这里介绍如何在小米路由器上搭建自己的个人云存储系统。在此之前，需要注意云存储和云备份是有区别的。在参考英文原文： Cloud services: How do they compare?（译者/刘旭坤） 中提到：云存储的目的是方便地在不同设备之间共享文件，并不意味着一定会在电脑或手机上创建备份。如果发生误删，可能文件永远也找不回来了。云备份则不同，如果本地的文件删除了在云端还有。这里主要侧重的是云存储功能的建立。如果单纯是为了云存储功能的搭建，采用许多可用的服务即可，例如：ftp、webdav等等。这里采用云平台，是考虑到日后扩展而准备的。Web Server：云存储一般都基于Web Server后端，对于Web服务器，考虑到在小米路由器上搭建个人云，也可能会在将来基于此搭建个人站点，这里主要需求是：开源、免费、稳定、以及资源占用少、并发度高、流行度高（比较容易找到学习资料）。比较著名的Web Server有Apache、Tomcat、nginx、lighthttpd……对比众多服务器以及需求之后，选择nginx做为服务器。云平台的选择：对于云，这里的主要需求是，开源、核心功能免费、扩展性强（扩展功能可以收费）。比较流行的个人云平台工具如：seafile、own cloud、SparkleShare、WonderBox等等，在对比了许多的介绍和需求之后，选择Own Cloud做为云平台。由于Own Cloud使用php完成，综上，搭建Own cloud平台，可基于LNMP环境（Linux+Nginx+Mysql+Php）进行。搭建好的Own Cloud云平台，由于其本身的可扩展特点，具有的功能除传统网盘（如百度云、DropBox）外，还能支持webdav服务，以及自行添加插件App，比如OwnNote（基于Owncloud的云笔记）、tasks（基于Owncloud的任务管理）等等，这些应用可在Owncloud第三方插件提供处找到，也可自己基于Owncloud的开放接口开发出来。由于小米路由器Cpu架构与传统PC机不同，所以这里先介绍在PC上搭建LNMP环境以及安装Own Cloud的方法，了解到与平台无关的核心过程后，然后再具体介绍在小米路由器上进行。5.1 PC上搭建OwncloudPC上的Owncloud在两个系统上进行过，即：Ubuntu和Center OS。除个别依赖库外，尽量采用源代码编译的方式进行，这样的过程比较“通用”，在各个平台上过程大同小异。过程大致如下：5.1.1 安装openssl下载： $wget -c http://www.openssl.org/source/openssl-1.0.2g.tar.gz配置、编译、安装如下：$tar -xzvf openssl-1.0.2g.tar.gz &amp;&amp; cd openssl-1.0.2g$./config --prefix=/usr/local/develop/openssl-1.0.2g$sudo make depend$sudo make $sudo make install5.1.2 安装php所需依赖5.1.2.1 在 Ubuntu 12.04 上：$sudo apt-get install libxml2$sudo apt-get install libxml2-dev$sudo apt-get install libxml2-utils$sudo apt-get install libcurl3$sudo apt-get install libcurl$sudo apt-get install libcurl4-gnutls-dev$sudo apt-get install libjpeg-dev$sudo apt-get install libpng-dev$sudo apt-get install libmcrypt-dev5.1.2.2 在 Center OS 上：$sudo yum install libxml2$sudo yum install libxml2-devel$sudo yum install libcurl$sudo yum install libcurl-devel$sudo yum install libjpeg-devel$sudo yum install libpng-devel$sudo yum install libfreetype-devel另外在Center OS上对mysql的安装与启动如下：$yum install mariadb-server mariadb-libs mariadb$systemctl start mariadb.service5.1.3 编译、安装php下载：http://php.net/get/php-5.6.19.tar.bz2/from/a/mirror配置、编译、安装如下：$./configure --prefix=/usr/local/develop/php-5.6.19 --with-config-file-path=/usr/local/develop/php-5.6.19/etc --enable-fpm --with-fpm-user=www-data --with-fpm-group=www-data --with-mysql=mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-iconv-dir --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-magic-quotes --enable-safe-mode --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl --with-curlwrappers --enable-mbregex --enable-mbstring --with-mcrypt --enable-ftp --with-gd --enable-gd-native-ttf --with-openssl=/usr/local/develop/openssl-1.0.2g --with-mhash --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --disable-fileinfo$sudo make$sudo make install另外注：如果遇到如下错误：ext/openssl/.libs/xp_ssl.o: In function `php_select_crypto_method':/home/miracle/myinstalled/php-5.6.19/ext/openssl/xp_ssl.c:947: undefined reference to `SSLv3_client_method'/home/miracle/myinstalled/php-5.6.19/ext/openssl/xp_ssl.c:947: undefined reference to `SSLv3_server_method'那么编译安装如下：$sudo make EXTRA_CFLAGS=-DOPENSSL_NO_SSL35.1.4 安装nginx所需依赖下载：$wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz$wget http://apache.opencas.org//apr/apr-util-1.5.4.tar.gz$wget http://mirrors.cnnic.cn/apache//apr/apr-1.5.2.tar.bz2配置、编译、安装如下：$cd apr-1.5.2$sudo ./configure --prefix=/usr/local/develop/apr-1.5.2$sudo make$sudo make install$cd apr-util-1.5.4$sudo ./configure --prefix=/usr/local/develop/apr-util-1.5.4 --with-apr=/usr/local/develop/apr-1.5.2$sudo make$sudo make install$cd pcre-8.38$sudo ./configure --prefix=/usr/local/develop/pcre-8.38 --with-apr=/usr/local/develop/apr-1.5.2 --with-apr-util=/usr/local/develop/apr-util-1.5.4$sudo make$sudo make install5.1.5 编译、安装nginx下载： wget http://nginx.org/download/nginx-1.8.1.tar.gz配置、编译、安装：$./configure --prefix=/usr/local/develop/nginx-1.8.1 --with-openssl=~/myinstalled/openssl-1.0.2g --with-pcre=~/myinstalled/pcre-8.38 --with-http_ssl_module$sudo make$sudo make install5.1.6 Mysql的root帐号建立启动mysqld服务#service mysqld start当然，可以用 stop 参数停止，用 restart 参数重启mysqld服务。 设置mysql管理员密码#mysqladmin -u root password '123'这里首先启动mysqld服务，然后设置mysql数据库root帐号密码,密码为123。 数据库安装好后，我们应该为mysql数据库创建一个管理帐号。执行这个命令之后， mysql数据库的管理员是root，密码是123(实践发现，不让设置成root之外的名字，应该有其他的方法)。 使用root用户登录mysql#mysql --user=root --password=123 或者#mysql -uroot -p123 或者#mysql -uroot -p &lt;手动输入密码&gt;这里，假设root用户的密码是123,最后一个命令会提示你额外输入密码。这样会有 mysql&gt; 提示符号，提示你和mysql进行交互。操作这些命令的时候，应该把mysqld服务器打开。注意，如果是连接到另外的机器上，则需要加入一个参数 -h 机器IP。至此，mysql服务确认完毕。5.1.7 php的配置和运行5.1.7.1 对mysql的配置为了能够安装owncloud，需要做php对mysql支持的配置，将源代码解压包中的 php.ini-development 拷贝到安装好的目录中（ /usr/local/develop/php-5.6.19/etc ），命名为 php.ini 修改如下： pdo_mysql.default_socket=/var/run/mysqld/mysqld.sock 。注意，这个mysql默认的socket路径，通过 ls /var/run/mysqld 发现是这个路径，也可能是别的路径，可以通过在 /etc/mysql/my.cnf 中查看到。如果不进行这个配置，后面搭建好owncloud网站之后，设置的时候可能会出现类似如下错误：ownCloud is not installed - only a limited number of commands are availableError while trying to create admin user: Failed to connect to the database: An exception occured in driver: SQLSTATE[HY000] [2002] No such file or directory -&gt;5.1.7.2 运行php运行 ./php-fpm.sh start停止 ./php-fpm.sh stopphp-fpm.sh 脚本如下（根据自己的情况，将开头定义的 $PHP_PATH 等变量做相应修改）：$cat /etc/init.d/php-fpm.sh #!/bin/sh#PHP_PATH=/userdisk/data/opt/usr/local/developDESC="php-fpm daemon"NAME=php-fpm# php-fpmDAEMON=$PHP_PATH/sbin/$NAMECONFIGFILE=$PHP_PATH/etc/php-fpm.confPIDFILE=/var/run/$NAME.pidrh_start() {  $DAEMON -c $PHP_PATH/etc -y $CONFIGFILE || echo -n " already running"}rh_stop() {  kill -QUIT `cat $PIDFILE` || echo -n " not running"}case "$1" in  start)        echo -n "Starting $DESC: $NAME"        rh_start        echo "."        ;;  stop)        echo -n "Stopping $DESC: $NAME"        rh_stop        echo "."        ;;  restart)        echo -n "Restarting $DESC: $NAME"        rh_stop        sleep 1        rh_start        echo "."        ;;  *)         echo "Usage: $SCRIPTNAME {start|stop|restart}" &gt;&amp;2         exit 3        ;;esacexit 05.1.8 ssl key文件的生成因为要使用https方式访问搭建的网站，需要生成ssl的认证文件，在后面配置nginx之时会用到。$openssl genrsa -des3 -out server.key 1024$openssl req -new -key server.key -out server.csr$cp server.key server.key.org$openssl rsa -in server.key.org -out server.key$openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt5.1.9 nginx的配置和运行5.1.9.1 运行脚本先给出运行nginx的脚本，后面会用到（根据自己的情况，将开头定义的 $NGINX_BIN 等变量做相应修改）。$cat /etc/init.d/nginx.sh#!/bin/shNGINX_BIN=/usr/local/develop/nginx-1.8.1/sbin/nginxNGINX_CONF_FILE="/usr/local/develop/nginx-1.8.1/conf/nginx.conf"NGINX_PREFIX="/usr/local/develop"start() {        #mkdir -p /var/log/nginx        #mkdir -p /var/lib/nginx        $NGINX_BIN -p $NGINX_PREFIX -c $NGINX_CONF_FILE        return $?}stop() {        $NGINX_BIN -p $NGINX_PREFIX -s stop        return $?}reload() {        $NGINX_BIN -p $NGINX_PREFIX -s reload        return $?}shutdown() {        $NGINX_BIN -p $NGINX_PREFIX -s quit}case "$1" in    start)        start &amp;&amp; echo "Start success" || echo "Start fail."        ;;    stop)        stop &amp;&amp; echo "Stop success" || echo "Stop fail."        ;;    reload)        reload &amp;&amp; echo "Reload success" || echo "Reload fail."        ;;    shutdown)        shutdown        ;;    *)        echo $"Usage: $0 {start|stop|reload|shutdown}"        exit 2esac5.1.9.2 测试网站先写一个测试的php脚本，用来检测是否正确。$mkdir -p ~/nginx$cd ~/nginx$vim index.php&lt;?php    const CONSTANT = 'Hello World';    echo CONSTANT;    phpinfo();   ?&gt;在nginx上配置测试站点$cd /usr/local/develop/nginx-1.8.1/conf/$vim nginx.conf...前面省略...server {        listen       18080;          server_name localhost;          location / {                     root   /home/miracle/nginx;                     index  index.php index.html;        }          location ~ \.php$ {                     fastcgi_pass   127.0.0.1:9000;                     fastcgi_index  index.php;                     fastcgi_param  SCRIPT_FILENAME  /home/miracle/nginx$fastcgi_script_name;                     include        fastcgi_params;          }}....后面省略...$/etc/init.d/nginx.sh start访问站点经过前面配置之后，打开浏览器，输入 http://localhost:18080 若打开对应的测试站点并运行 index.php 脚本成功，说明配置成功。5.1.10 搭建owncloud网站对前面LNMP环境建立并且测试完成之后，搭建owncloud网站其主要工作就是修改 nginx.conf 配置文件了。在owncloud官网上有一个对nginx的配置说明，这里给出当前实践过，并且好用的配置。不做过多解释,根据自身情况，做相应修改应当不难。5.1.10.1 OwnCloud相关软件和文档获取服务端：$wget -c https://download.owncloud.org/community/owncloud-8.2.2.tar.bz2客户端客户端有用于PC的Linux、Window，也有用于手机IOS、Android版本。IOS版本的OwnCloud客户端竟然是收费的，不过没有关系，搭建好的Owncloud支持webdav，可以随便寻找一款文件同步工具（比如foldersync等）实现客户端的功能，具体可在后面列出的参考资料中寻找。官方客户端下载网址是：https://software.opensuse.org/download/package?project=isv:ownCloud:desktop&amp;package=owncloud-client文档文档的下载和在线版本，可在如下网站获取： https://doc.owncloud.org/5.1.10.2 配置用于OwnCloud的Nginx配置选项$cat /usr/local/develop/nginx-1.8.1/conf/nginx.conf...前面省略###myown cloud with ssl        upstream php-handler {                server 127.0.0.1:9000;#server unix:/var/run/php5-fpm.sock;        }        server {                listen 18000;                server_name 172.16.246.39;# enforce https                return 301 https://$server_name$request_uri;        }        server {                listen 443 ssl;                server_name 172.16.246.39;                ssl_certificate /usr/local/develop/nginx-1.8.1/conf/server.crt;                ssl_certificate_key /usr/local/develop/nginx-1.8.1/conf/server.key;# Add headers to serve security related headers                add_header Strict-Transport-Security "max-age=15768000; includeSubDomains; preload;";                add_header X-Content-Type-Options nosniff;                add_header X-Frame-Options "SAMEORIGIN";                add_header X-XSS-Protection "1; mode=block";                add_header X-Robots-Tag none;                add_header X-Download-Options noopen;                add_header X-Permitted-Cross-Domain-Policies none;# Path to the root of your installation                root /media/sda6/mycloud/owncloud;# set max upload size                client_max_body_size 1G;                fastcgi_buffers 64 4K;# Disable gzip to avoid the removal of the ETag header                gzip off;# Uncomment if your server is build with the ngx_pagespeed module# This module is currently not supported.#pagespeed off;                index index.php;                error_page 403 /core/templates/403.php;                error_page 404 /core/templates/404.php;                rewrite ^/.well-known/carddav /remote.php/dav/ permanent;                rewrite ^/.well-known/caldav /remote.php/dav/ permanent;# The following 2 rules are only needed for the user_webfinger app.# Uncomment it if you're planning to use this app.#rewrite ^/.well-known/host-meta /public.php?service=host-meta last;#rewrite ^/.well-known/host-meta.json /public.php?service=host-meta-json last;                location = /robots.txt {                        allow all;                        log_not_found off;                        access_log off;                }                location ~ ^/(build|tests|config|lib|3rdparty|templates|data)/ {                        deny all;                }                location ~ ^/(?:\.|autotest|occ|issue|indie|db_|console) {                        deny all;                }                location / {                        rewrite ^/remote/(.*) /remote.php last;                        rewrite ^(/core/doc/[^\/]+/)$ $1/index.html;                        try_files $uri $uri/ =404;                }                location ~ \.php(?:$|/) {                        fastcgi_split_path_info ^(.+\.php)(/.+)$;                        include fastcgi_params;                        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;                        fastcgi_param PATH_INFO $fastcgi_path_info;                        fastcgi_param HTTPS on;                        fastcgi_param modHeadersAvailable true; #Avoid sending the security headers twice#fastcgi_pass   127.0.0.1:9000;                                fastcgi_pass   php-handler;                        fastcgi_intercept_errors on;                }                location ~* \.(?:css|js)$ {                        add_header Cache-Control "public, max-age=7200";# Add headers to serve security related headers                        add_header Strict-Transport-Security "max-age=15768000; includeSubDomains; preload;";                        add_header X-Content-Type-Options nosniff;                        add_header X-Frame-Options "SAMEORIGIN";                        add_header X-XSS-Protection "1; mode=block";                        add_header X-Robots-Tag none;                        add_header X-Download-Options noopen;                        add_header X-Permitted-Cross-Domain-Policies none;# Optional: Don't log access to assets                        access_log off;                }# Optional: Don't log access to other assets                location ~* \.(?:jpg|jpeg|gif|bmp|ico|png|swf)$ {                        access_log off;                }        }...后面省略5.1.11 安装Owncloud具体安装过程以及期间遇到的问题，可参考文档进行，下面给出大致过程。5.1.11.1 设置OwnCloud的安装目录先将Owncloud解压，然后设置文件权限。需要设置owncloud中data和config目录等的用户和组为 www-data 。在文档中具体介绍了为什么要这样设置。这里简化起见，设置之后，再将权限设置为777，并不是最优方案。$tar -xjvf owncloud-8.2.2.tar.bz2$mv owncloud-8.2.2 /media/sda6/mycloud/owncloud$cd /media/sda6/mycloud$sudo chown -R www-data.www-data owncloud$sudo chmod 777 -R owncloud$mkdir oc_data$sudo chown -R www-data.www-data oc_data$sudo chmod 777 -R oc_data5.1.11.2 配置Owncloud添加管理员账户基本配置我们可以根据前面的 nginx.conf 设置，直接使用 https://localhost 访问，进入Owncloud初始设置界面。为便于描述，这里直接用命令行方式对其进行设置，效果相同。命令实质是运行owncloud中的 occ php脚本，运行之时要以 www-data 身份进行（不同系统，可能为不同的http名称，参考官方文档）。如下：$ cd /media/sda6/mycloud/owncloud$ sudo -u www-data php occ maintenance:install --database "mysql" --database-name "ownclouddb" --database-user "root" --database-pass "&lt;之前设置的mysql数据库root密码&gt;" --admin-pass "&lt;owncloud 的管理员admin 账户密码&gt;" --data-dir "/media/sda6/mycloud/oc_data"上述命令是设置owncloud采用哪种数据库、使用的管理员账户是什么，以及数据存放的位置。运行之后，我们便可以登录 https://localhost 进行访问了。期间创建的文件数据都存放在 media/sda6/mycloud/oc_data 中，能够直接浏览。额外配置如上配置之后，可以本地访问owncloud，但是如果想要实现远程其它机器也能访问，还需修改 owncloud/config/config.php 如下：将array (    0 =&gt; 'localhost',    ),修改为：array (    0 =&gt; 'localhost',    1 =&gt; '112.74.19.38',    ),这里， 112.74.19.38 是本地机器对外的ip地址，也可使用DNS域名。5.2 小米路由器上搭建Owncloud网上找到过别人搭建的Nginx环境，但是不能直接使用（还是需要php和mysql等其他环境），也用opkg 工具尝试过安装相关的工具，基本没有适用于自己架构的软件源（或者很难找到）。最终还是完全从源代码开始，交叉编译、安装了所需的所有软件包和依赖库，完成LNMP下Own cloud环境的搭建，还是自给自足可靠，当前期间也参考了许多其他人的过程。5.2.1 准备交叉编译环境参考：小米路由器交叉编译环境配置5.2.2 下载相关软件包State "INBOX"      from              [2016-04-27 三 11:15]$cd /home/miracle/work/1_inbox/xiaomirouter/test$wget -c http://xmlsoft.org/sources/libxml2-2.7.8.tar.gz$wget -c http://zlib.net/zlib-1.2.8.tar.gz$wget -c ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz$wget -c http://www.openssl.org/source/openssl-1.0.2g.tar.gz$wget -c http://cn2.php.net/distributions/php-5.6.19.tar.xz$wget -c https://curl.haxx.se/download/curl-7.48.0.tar.gz$wget -c https://codeload.github.com/smart-make/libjpeg/zip/master$wget -c http://iweb.dl.sourceforge.net/project/libpng/libpng16/1.6.21/libpng-1.6.21.tar.xz$wget -c http://ftp.yzu.edu.tw/nongnu//freetype/freetype-2.6.3.tar.gz$wget -c http://iweb.dl.sourceforge.net/project/mhash/mhash/0.9.9.9/mhash-0.9.9.9.tar.gz$wget -c http://heanet.dl.sourceforge.net/project/mcrypt/Libmcrypt/2.5.8/libmcrypt-2.5.8.tar.bz2$wget -c http://tenet.dl.sourceforge.net/project/mcrypt/MCrypt/2.6.8/mcrypt-2.6.8.tar.gz$wget -c ftp://ftp.gnu.org/gnu/gettext/gettext-0.19.tar.gz$wget -c http://heanet.dl.sourceforge.net/project/unixodbc/unixODBC/2.3.4/unixODBC-2.3.4.tar.gz$wget -c http://nginx.org/download/nginx-1.8.1.tar.gzowncloud-8.2.2.tgz5.2.3 交叉编译安装MySql注意，这里编译的是 mysql-5.1.72 其它更新的版本可能没有相应的configure文件。5.2.3.1 下载相关软件包$wget -c http://mirror.hust.edu.cn/gnu/ncurses/ncurses-5.6.tar.gz$wget -c http://cdn.mysql.com/archives/mysql-5.1/mysql-5.1.72.tar.gz5.2.3.2 编译PC板的MySql$tar -xzvf mysql-5.1.72.tar.gz $mv mysql-5.1.72/ mysql-5.1.72_pc$cd mysql-5.1.72_pc$./configure --prefix=/usr/local/develop/mysql-5.1.72$make目的是为交叉编译过程顺利进行，这里先生成一个特殊的只能在pc上运行的工具。5.2.3.3 交叉编译安装ncurses这个工具需要先编译，这样后面的MySql和php对gettext的交叉编译才不会出现问题。$tar -xzvf ncurses-5.6.tar.gz$cd ncurses-5.6/$./configure --host=arm-xiaomi-linux-uclibcgnueabi --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --enable-static CC=arm-xiaomi-linux-uclibcgnueabi-gcc$make $make install交叉编译的MySql首先修改configure文件，使之不会在交叉编译的时候运行测试软件$tar -xzvf mysql-5.1.72.tar.gz $cd mysql-5.1.72$vim configure因为交叉编译的程序无法在pc上运行，如果运行生成的测试软件，必然会由于无法运行而报错，导致后面步骤无法继续。找到类似如下代码：if test "$cross_compiling" = yes; then{ { $as_echo "$as_me:$LINENO: error: in \`$ac_pwd':" &gt;&amp;5$as_echo "$as_me: error: in \`$ac_pwd':" &gt;&amp;2;}{ { $as_echo "$as_me:$LINENO: error: cannot run test program while cross compilingSee \`config.log' for more details." &gt;&amp;5$as_echo "$as_me: error: cannot run test program while cross compilingSee \`config.log' for more details." &gt;&amp;2;}{ (exit 1); exit 1; }; }; }修改为：if test "$cross_compiling" = yes; thenecho "skip corss_compiling test";配置与编译$./configure --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --without-docs --without-man --without-debug --with-charset=utf8 --with-extra-charsets=gbk,gb2312,utf8,ascii --enable-local-infile --with-mysqld-user=root --host=arm-xiaomi-linux-uclibcgnueabi --with-named-curses-libs=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib/libncurses.a CC=arm-xiaomi-linux-uclibcgnueabi-gcc$make这里运行 make 编译时，会报类似如下错误：make[2]:正在离开目录 `/home/miracle/work/1_inbox/xiaomirouter/test/mysql-5.1.72/sql'./gen_lex_hash &gt; lex_hash.h-t/bin/bash: ./gen_lex_hash: 无法执行二进制文件make[1]: *** [lex_hash.h] 错误 126make[1]:正在离开目录 `/home/miracle/work/1_inbox/xiaomirouter/test/mysql-5.1.72/sql'拷贝前面pc版本MySql中的gen_lex_hash继续：$cp ../mysql-5.1.72_pc/sql/gen_lex_hash sqlmiracle@miracle-Zhaoyang-cd sql$touch sql/gen_lex_hash$cd ..$make仍然可能报告如下错误：sql_parse.cc:5741:21: error: 操作符‘&lt;’没有左操作数#if STACK_DIRECTION &lt; 0修改如下：$vim sql/sql_parse.cc将5739 #ifndef EMBEDDED_LIBRARY5740 5741 #if STACK_DIRECTION &lt; 0                                                                                                                         5742 #define used_stack(A,B) (long) (A - B)5743 #else5744 #define used_stack(A,B) (long) (B - A)5745 #endif修改为5739 #ifndef EMBEDDED_LIBRARY5740 #define STACK_DIRECTION 1                                                                                                                       5741 #if STACK_DIRECTION &lt; 05742 #define used_stack(A,B) (long) (A - B)5743 #else5744 #define used_stack(A,B) (long) (B - A)5745 #endif然后继续编译、安装如下$make$make install至此，交叉编译版本的MySql编译安装完毕。5.2.4 交叉编译安装PHP5.2.4.1 交叉编译安装libxml需要编译的版本是libxml2-2.7.8，更高的版本需要编译python。$tar -xzvf libxml2-2.7.8.tar.gz $cd libxml2-2.7.8/$./configure --host=arm-xiaomi-linux-uclibcgnueabi --enable-static --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop CC=arm-xiaomi-linux-uclibcgnueabi-gcc$make$make install5.2.4.2 交叉编译安装zlib$export CC=arm-xiaomi-linux-uclibcgnueabi-gcc$./configure  -static --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop $make $make install5.2.4.3 交叉编译安装pcre$export CC=$tar -xzvf pcre-8.38.tar.gz $cd pcre-8.38/$./configure --host=arm-xiaomi-linux-uclibcgnueabi --enable-static --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop CC=arm-xiaomi-linux-uclibcgnueabi-gcc$make$make install5.2.4.4 交叉编译安装openssl$tar -xzvf openssl-1.0.2g.tar.gz $cd openssl-1.0.2g/$./Configure shared no-asm --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop os/compiler:arm-xiaomi-linux-uclibcgnueabi-gcc$make$make install5.2.4.5 交叉编译安装libcurl$tar -xzvf curl-7.48.0.tar.gz $cd curl-7.48.0/$./configure --host=arm-xiaomi-linux-uclibcgnueabi --enable-static --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop CC=arm-xiaomi-linux-uclibcgnueabi-gcc$make$make install5.2.4.6 交叉编译安装libjpeg$unzip libjpeg-master.zip $cd libjpeg-master/$./configure --host=arm-xiaomi-linux-uclibcgnueabi --enable-static --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop CC=arm-xiaomi-linux-uclibcgnueabi-gcc$make$make install5.2.4.7 交叉编译安装libpng$tar -xJvf libpng-1.6.21.tar.xz $cd libpng-1.6.21$./configure --host=arm-xiaomi-linux-uclibcgnueabi --enable-static --with-zlib-prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop CC=arm-xiaomi-linux-uclibcgnueabi-gcc LDFLAGS=-L/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib CFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include CPPFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include$make$make install5.2.4.8 交叉编译安装libfreetype$tar -xzvf freetype-2.6.3.tar.gz$cd freetype-2.6.3$./configure --host=arm-xiaomi-linux-uclibcgnueabi --enable-static --with-zlib-prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop CC=arm-xiaomi-linux-uclibcgnueabi-gcc LDFLAGS=-L/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib CFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include CPPFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include LIBPNG_LIBS=-lpng$make$make install5.2.4.9 交叉编译安装libmhash$tar -xzvf mhash-0.9.9.9.tar.gz$cd mhash-0.9.9.9/$./configure --host=arm-xiaomi-linux-uclibcgnueabi --enable-static --with-zlib-prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop CC=arm-xiaomi-linux-uclibcgnueabi-gcc LDFLAGS=-L/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib CFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include CPPFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include至此，会报告 rpl_malloc 相关错误，需要修改如下：$vim include/mutils/mhash_config.h交叉编译時autotools认为工具链的libc中不包含 malloc 和 realloc ，然后擅自做主张替换成了 rpl_malloc 和 rpl_realloc 。把相关的几句话注释如下：257 //#define malloc rpl_malloc然后编译安装如下：$make$make install5.2.4.10 交叉编译安装libmcrypt-2.5.8$tar -xjvf libmcrypt-2.5.8.tar.bz2$cd libmcrypt-2.5.8还不能直接配置，需要如下修改：$vim ./config.sub添加对xiaomi路由器的支持：...287     arm-xiaomi-linux)288       os=-linux289       ;;290     *-*-*)                                                                                                                                        291         echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1&gt;&amp;2292         exit 1293         ;;...配置如下：$./configure --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --host=arm-xiaomi-linux CC=arm-xiaomi-linux-uclibcgnueabi-gcc编译之前需要如下修改：$vim config.h注释如下宏定义使得可以编译：174 /* Define to rpl_malloc if the replacement function should be used. */                                                                            175 //#define malloc rpl_malloc176 177 /* Define to rpl_realloc if the replacement function should be used. */178 //#define realloc rpl_realloc编译、安装如下：$make$make install5.2.4.11 交叉编译安装mcrypt这个貌似不用安装，但是保险起见还是把它安装上去。配置如下：$tar -xzvf mcrypt-2.6.8.tar.gz$cd mcrypt-2.6.8$./configure --with-gnu-ld --host=arm-xiaomi-linux-uclibcgnueabi --enable-static --with-zlib-prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop CC=arm-xiaomi-linux-uclibcgnueabi-gcc LDFLAGS=-L/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib CFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include CPPFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include交叉编译之前，需要将 Makefile 中对非交叉编译包含的路径 /usr/lib 的依赖去掉如下修改：$vim Makefile92 #CFLAGS = -I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include -I/usr/include -Wall                                            93 CFLAGS = -I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include -Wall$vim src/Makefile91 #CFLAGS = -I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include -I/usr/include -Wall92 CFLAGS = -I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include -Wall编译安装如下：$make$make install5.2.4.12 交叉编译安装gettext这个也貌似不需要安装，但是为保险起见也将其安装如下：$tar -xzvf gettext-0.19.tar.gz$cd gettext-0.19/$./configure --host=arm-xiaomi-linux-uclibcgnueabi --enable-static --with-libncurses-prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --with-named-curses-libs=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib/libncurses.a --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop CC=arm-xiaomi-linux-uclibcgnueabi-gcc$make$make install注意：此处可能导致后面 gettext 之时报错，如果报错，那么如下再进行一次 ncurses 编译：$cd ncurses-5.6/$./configure --host=arm-xiaomi-linux-uclibcgnueabi --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --with-shared CC=arm-xiaomi-linux-uclibcgnueabi-gcc$make $make install5.2.4.13 交叉编译安装libodbc似乎无用，保险起见，编译安装如下：$tar -xzvf unixODBC-2.3.4.tar.gz $cd unixODBC-2.3.4/$./configure --host=arm-xiaomi-linux-uclibcgnueabi --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --with-shared CC=arm-xiaomi-linux-uclibcgnueabi-gcc$make$make install5.2.4.14 交叉编译安装php这个部分是最关键，也最复杂。前面一切都是为了这个php做准备，有了php后面的nginx也才能够正常支持php的网站。本文采用php-5.6.19，下载地址如下：http://php.net/get/php-5.6.19.tar.gz/from/a/mirror如果需要最新地址，可到如下网址下载：http://php.net/downloads.php代码与依赖$tar -xzvf php-5.6.19.tar.gz拷贝交叉编译工具链中的 libc.so, libm.so 库。这步虽然可能不必要（小米路由器上已有运行库），但是编译时确实需要。$mkdir -p /home/miracle/work/1_inbox/xiaomirouter/test/usr/lib$cp /home/miracle/work/1_inbox/xiaomirouter/test/sdk_package/toolchain/arm-xiaomi-linux-uclibcgnueabi/sysroot/usr/lib/{libc.so,libm.so} $_配置前的修改使用configure脚本配置，会导致测试test的时候报错，错误原因类似mysql的配置，是因为交叉编译产生的测试程序不能直接运行，进而无法通过测试，修改configure脚本如下：$vim configure将如下脚本片段：if test "$cross_compiling" = yes; then :{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" &gt;&amp;5$as_echo "$as_me: error: in \`$ac_pwd':" &gt;&amp;2;}as_fn_error $? "cannot run test program while cross compilingSee \`config.log' for more details" "$LINENO" 5 ; }else修改为：if test "$cross_compiling" = yes; then :	echo "skip corss_compiling test"; # { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" &gt;&amp;5#$as_echo "$as_me: error: in \`$ac_pwd':" &gt;&amp;2;}#as_fn_error $? "cannot run test program while cross compiling#See \`config.log' for more details" "$LINENO" 5 ; }else配置1&#x2013;用于确认导出变量的配置经过如上修改之后， ./configure 脚本能够运行通过。但是，仅仅如此还是不够，这样配置后，即使后面的编译过程通过了，所得到的php也有许多的问题，这些问题只有在运行时才可能会被发现，那样我们有需要重新交叉编译、配置php了。过程比较麻烦，这里给出一些需要修改的地方，希望能够尽量避免日后重新配置安装。但是如果不得不重新配置安装的话，这里也为将来出现问题时如何解决给出了一个参考。我们编译php，首先做如下配置：$./configure --host=arm-xiaomi-linux-uclibcgnueabi --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --enable-fpm --with-fpm-user=www-data --with-fpm-group=www-data --with-mysql=mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-iconv-dir --with-freetype-dir --with-jpeg-dir=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --with-png-dir --with-zlib --with-libxml-dir=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --enable-xml --disable-rpath  --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --enable-mbregex --enable-mbstring --enable-ftp --with-gd --enable-gd-native-ttf --with-openssl=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --with-openssl-dir=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --with-mcrypt=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --with-mhash --with-unixODBC=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap  --enable-opcache=no --without-pear --disable-fileinfo CC=arm-xiaomi-linux-uclibcgnueabi-gcc --with-gettext=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop LDFLAGS=-L/home/miracle/work/1_inbox/xiaomirouter/test/usr/lib CFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include CPPFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include CFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include/freetype2 CPPFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include/freetype2确定需要额外修改的配置信息这里需要修改的内容比较复杂，不可能完全将修改的内容在这里给出。但是相信进行到这里的朋友肯定也对自己所做的事情很清楚了，不需要详细的描述，通过这里给出的方法，应当能够自己根据实际情况将configure修改成适合自己的样子。配置支持的函数开关上述配置完成之后，会生成一个 config.log, 其中包含了配置时的信息。对比在pc上配置、编译php后生成的 config.log 与该交叉配置、编译php的 config.log ，找到 ac_cv_func_xxx 变量的配置结果，会发现，有些pc版上为 yes ，而交叉编译版本时变成了 no 的变量，在交叉编译的configure中，根据自身路由器的情况，一般会将相应位置修改回 yes 。这里修改的变量内容很多，不一一列出，需要自行搜索。一般是在configure脚本中判断该变量之前的地方将其值修改。如果编译出错，一般是这样添加的变量对应的某些函数在当前交叉编译环境库中找不到，这时候，再在configure中将相应的函数定义相关变量的 yes 之处改回 no 即可。比如这里曾经修改过的： getloadavg, res_nsearch, strfmon.对应的函数就找不到，所以都又被 disable 了。例如如下就是修改过的代码片段：67029 ac_cv_func_fork=yes67030 ac_cv_func_waitpid=yes67031 ac_cv_func_sigaction=yes67032 67033 if test "$PHP_PCNTL" != "no"; then例子下面的例子，展示了我们为什么要添加这些函数变量。发现运行问题最初配置好php之后，适当修改 Makefile (修改方式参见后面)， 编译、安装完成之后，运行某个php脚本时，发现php提示找不到 glob 的错误。 对比php运行环境于是在pc和小米路由器上写了一个简单的php脚本，&lt;?php&gt;phpinfo()&lt;?&gt;然后搭建好webserver并在浏览器上显示该脚本的运行结果，发现，pc版本中支持的函数多了一个 glob, 这应当是在pc上没有错误，而在小米路由器上有错误的原因。修改源码包中相关内容该glob函数的定义，可以需要修改源代码，但是更根本的原因更可能是 configure 配置信息有问题，导致一些自动生成的源代码缺少了相关的函数定义。于是再对比pc版和交叉编译版的 config.log 发现确实对 glob 相关的定义有所不同，最终追踪到修改 configure 脚本如下：$vim configure...87993 ac_cv_func_glob=yes87994 for ac_func in getcwd getwd asinh acosh atanh log1p hypot glob strfmon nice fpclass isinf isnan mempcpy strpncpy87995 do :...同理，推测其它函数应当也有类似的问题，于是干脆直接对比 config.log, 将pc上激活，而在交叉编译版却被禁止的变量尽量都打开。配置其它选项参数参照类似前面的方式，对比pc版本和交叉编译版本 config.log 文件，找到其它看起来比较重要的、却在pc上打开，交叉编译版本关闭的一些选项参数，进行类似修改。比如：ac_cv_header_wchar_h=yesac_cv_lib_crypt_crypt=yesac_cv_header_time=yesac_cv_header_time_h=yesac_cv_crypt_md5=yesac_cv_crypt_sha256=yesac_cv_crypt_sha512=yes这些是我找到的一些看起来比较重要的变量，都依次在 configure 中将相应的变量直接硬编码成 yes 值了。配置2&#x2013;最终配置经过上述修改后，我们应该可以直接运行如下配置命令，生成Makefile了。$./configure --host=arm-xiaomi-linux-uclibcgnueabi --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --enable-fpm --with-fpm-user=www-data --with-fpm-group=www-data --with-mysql=mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-iconv-dir --with-freetype-dir --with-jpeg-dir=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --with-png-dir --with-zlib --with-libxml-dir=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --enable-xml --disable-rpath  --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --enable-mbregex --enable-mbstring --enable-ftp --with-gd --enable-gd-native-ttf --with-openssl=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --with-openssl-dir=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --with-mcrypt=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --with-mhash --with-unixODBC=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap  --enable-opcache=no --without-pear --disable-fileinfo CC=arm-xiaomi-linux-uclibcgnueabi-gcc --with-gettext=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop LDFLAGS=-L/home/miracle/work/1_inbox/xiaomirouter/test/usr/lib CFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include CPPFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include CFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include/freetype2 CPPFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include/freetype2Makefile修改$vim Makefile具体修改主要解决的是路径的问题，防止交叉编译的时候，链接到非交叉编译库的路径。修改的内容主要包括：去掉 CFLAGS_CLEAN, INCLUDES, ext/iconv/iconv.lo 中对 /usr/include 的包含。​去掉 EXTRA_LDFLAGS, EXTRA_LDFLAGS_PROGRAM, PHP_LDFLAGS 中对 /usr/lib 的搜索。代码修改经过前面对Makefile修改之后，还需对源代码进行一些修改，以避免出现编译错误。大致如下：修改1$vim include/../main/php_config.h修改片段：15 //#define uint unsigned int16 //#define ulong unsigned long  ...535 #define HAVE_CRYPT 1  ...2516 /* Define to `unsigned int ' if &lt;sys/types.h&gt; does not define. */2517 //#define uint unsigned int2518 2519 /* Define to `unsigned long ' if &lt;sys/types.h&gt; does not define. */2520 //#define ulong unsigned long该修改主要解决对uint和ulong重复定义的错误信息。修改2$vim php-5.6.19/ext/zip/lib/zip_add.c将如下片段：111 #if SIZEOF_OFF_T == 8                                                                                                                              112 #define ZIP_OFF_MAX ZIP_INT64_MAX113 #elif SIZEOF_OFF_T == 4114 #define ZIP_OFF_MAX ZIP_INT32_MAX115 #elif SIZEOF_OFF_T == 2116 #define ZIP_OFF_MAX ZIP_INT16_MAX117 #else118 #error unsupported size of off_t119 #endif改成：111 //#if SIZEOF_OFF_T == 8112 //#define ZIP_OFF_MAX ZIP_INT64_MAX113 //#elif SIZEOF_OFF_T == 4114 #define ZIP_OFF_MAX ZIP_INT32_MAX115 //#elif SIZEOF_OFF_T == 2116 //#define ZIP_OFF_MAX ZIP_INT16_MAX117 //#else118 //#error unsupported size of off_t119 //#endif该修改主要解决平台字节位相关错误，这些错误可能在运行时才能够体现出来比较难以定位，在这里修改小米路由器就是32字长的CPU，所以去掉无用的判断。修改3$vim ext/standard/basic_functions.c添加#if HAVE_CRYPT&#x2026;#endif 宏包含如下代码块：...1837 /* {{{ password.c */1838 #if HAVE_CRYPT1839 ZEND_BEGIN_ARG_INFO_EX(arginfo_password_hash, 0, 0, 2)1840     ZEND_ARG_INFO(0, password)1841     ZEND_ARG_INFO(0, algo)1842     ZEND_ARG_INFO(0, options)1843 ZEND_END_ARG_INFO()1844 ZEND_BEGIN_ARG_INFO_EX(arginfo_password_get_info, 0, 0, 1)1845     ZEND_ARG_INFO(0, hash)1846 ZEND_END_ARG_INFO()1847 ZEND_BEGIN_ARG_INFO_EX(arginfo_password_needs_rehash, 0, 0, 2)1848     ZEND_ARG_INFO(0, hash)1849     ZEND_ARG_INFO(0, algo)1850     ZEND_ARG_INFO(0, options)1851 ZEND_END_ARG_INFO()1852 ZEND_BEGIN_ARG_INFO_EX(arginfo_password_verify, 0, 0, 2)1853     ZEND_ARG_INFO(0, password)1854     ZEND_ARG_INFO(0, hash)1855 ZEND_END_ARG_INFO()1856 #endif1857 /* }}} */...2866 #if HAVE_CRYPT2867     PHP_FE(password_hash,                                                   arginfo_password_hash)2868     PHP_FE(password_get_info,                                               arginfo_password_get_info)2869     PHP_FE(password_needs_rehash,                                           arginfo_password_needs_rehash)2870     PHP_FE(password_verify,                                                 arginfo_password_verify)2871 #endif ...3628 #if HAVE_CRYPT3629     BASIC_MINIT_SUBMODULE(password)3630 #endif该修改主要解决如下类似错误：ext/standard/basic_functions.o: In function `zm_startup_basic':basic_functions.c:(.text+0x12d4): undefined reference to `zm_startup_password'ext/standard/basic_functions.o: In function `.LC795':basic_functions.c:(.rodata+0x9de8): undefined reference to `zif_password_hash'basic_functions.c:(.rodata+0x9dfc): undefined reference to `zif_password_get_info'basic_functions.c:(.rodata+0x9e10): undefined reference to `zif_password_needs_rehash'basic_functions.c:(.rodata+0x9e24): undefined reference to `zif_password_verify'collect2: error: ld returned 1 exit status交叉编译1-生成主要的二进制文件经过如上修改之后，即可以编译代码，如下：$make如上的编译并不能完全顺利进行下来，期间遇到如下问题：Generating phar.php/bin/bash: /home/miracle/work/1_inbox/xiaomirouter/test/php-5.6.19/sapi/cli/php: 无法执行二进制文件make: *** [ext/phar/phar.php] 错误 126原因是编译过程中需要在pc上运行 sapi/cli/php 生成一些必要的文件，但是由于编译过程是交叉编译，所以运行这个命令失败。需要借助pc版的php生成相应文件，大致过程见后面。交叉编译2-借助pc版本的php完成最终编译前面也提到了，前面出现的错误不需要修改什么，但是需要事先编译好一个pc版本的php。pc上php的编译在前面有所介绍。当交叉编译出现这个错误之后，将事先编译好的pc版的 php 程序替换交叉编译源码目录中的 php-5.6.19/sapi/cli/php ，然后继续 make 即可。 make 之后，不要忘记再替换回之前的备份。使用pc版本的 php 继续完成编译、安装$cd sapi/cli$mv php php.arm$cp /usr/local/develop/php-5.6.19/bin/php .（这里/usr/local/develop/php-5.6.19是pc上的php的路径）$cd ../../$make$make install用之前交叉编译版本的 php 替换回安装好的程序中的 php 程序$cd sapi/cli$cp php php.pc$cp php.arm php$cp php /home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/bin至此，Php的交叉编译过程完成。5.2.5 交叉编译安装nginx5.2.5.1 代码解压$tar -xzvf nginx-1.8.1.tar.gz$cd nginx-1.8.15.2.5.2 修改配置文件源代码中的 auto 目录修改会影响后面用 configure 生成的 objs/ngx_auto_config.h 的内容。如果没有修改相应的配置文件，则在后面编译之时修改该头文件中相应的定义也行。保险起见，最好从配置文件上进行修改。cpu位相关内容$vim auto/types/sizeof修改如下：15 ngx_size=4                                                                                                                                        ...&lt;中间的注释掉&gt;...18 case $ngx_size in因为目标机器（小米路由器）是32位，而这里测试程序是对编译主机检测的结果，如果该结果与目标机器不一致就会运行出错。例如我机器是64位，没有改这个，运行nginx读取配置文件的时候有如下错：nginx: [emerg] "worker_processes" directive invalid value in /userdisk/data/opt/usr/local/develop/conf/nginx.conf:2这类运行时才出现的错误，一般很难定位，所以在开始尽量能避免则避免。另外要注意 auto/endianness , 需要交叉编译这个文件定义的测试程序，然后放到小米路由器上运行一下，看其结果与ｐｃ上对比看是否一样，以决定NGX_HAVE_LITTLE_ENDIAN宏的定义。一些系统调用的支持配置$vim auto/os/linux注释修改类似如下87 # O_PATH and AT_EMPTY_PATH were introduced in 2.6.39, glibc 2.14                                                                                  88 89 #ngx_feature="O_PATH"90 #ngx_feature_name="NGX_HAVE_O_PATH"91 #ngx_feature_run=no92 #ngx_feature_incs="#include &lt;sys/types.h&gt;93 #                  #include &lt;sys/stat.h&gt;94 #                  #include &lt;fcntl.h&gt;"95 #ngx_feature_path=96 #ngx_feature_libs=97 #ngx_feature_test="int fd; struct stat sb;98 #                  fd = openat(AT_FDCWD, \".\", O_PATH|O_DIRECTORY|O_NOFOLLOW);99 #                  if (fstatat(fd, \"\", &amp;sb, AT_EMPTY_PATH) != 0) return 1"100 #. auto/feature...169 # crypt_r()170 171 #ngx_feature="crypt_r()"172 #ngx_feature_name="NGX_HAVE_GNU_CRYPT_R"173 #ngx_feature_run=no174 #ngx_feature_incs="#include &lt;crypt.h&gt;"175 #ngx_feature_path=176 #ngx_feature_libs=-lcrypt177 #ngx_feature_test="struct crypt_data  cd;178 #                  crypt_r(\"key\", \"salt\", &amp;cd);"179 #. auto/feature如果这里的内容没有修改的话，那么在后面编译之时的代码，应当如下修改$vim objs/ngx_auto_config.h修改片段：...38 //#ifndef NGX_HAVE_O_PATH39 //#define NGX_HAVE_O_PATH  140 //#endif                                                                                                                                          ...63 //#ifndef NGX_HAVE_GNU_CRYPT_R64 //#define NGX_HAVE_GNU_CRYPT_R  165 //#endif ...5.2.5.3 配置$./configure  --with-openssl=/home/miracle/work/1_inbox/xiaomirouter/test/openssl-1.0.2g --with-pcre=/home/miracle/work/1_inbox/xiaomirouter/test/openssl-1.0.2g --with-http_ssl_module --with-http_dav_module --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop5.2.5.4 修改Makefile$vim objs/Makefile修改1-交叉编译工具与选项#CC =	ccCC=arm-xiaomi-linux-uclibcgnueabi-gcc#CFLAGS =  -pipe  -O -W -Wall -Wpointer-arith -Wno-unused-parameter -Werror -g CFLAGS =  -pipe  -O -W -Wall -Wpointer-arith -Wno-unused-parameter CFLAGS+=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/includeCPP =	$(CC) -ECPPFLAGS+=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/includeLINK =	$(CC)LDFLAGS+=-L/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib修改2-头文件的包含ALL_INCS = -I src/core \-I src/event \-I src/event/modules \-I src/os/unix \-I /home/miracle/work/1_inbox/xiaomirouter/test/openssl-1.0.2g \-I /home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include \-I objs \-I src/http \-I src/http/modules \-I src/mail修改3-依赖模块头文件(openssl与pcre)CORE_DEPS = src/core/nginx.h \.../home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include/openssl/ssl.h \/home/miracle/work/1_inbox/xiaomirouter/test/pcre-8.38/pcre.h \objs/ngx_auto_config.h修改4-依赖模块安装路径包含(openssl与相应的交叉编译安装路径)CORE_INCS = -I src/core \-I src/event \-I src/event/modules \-I src/os/unix \-I /home/miracle/work/1_inbox/xiaomirouter/test/openssl-1.0.2g \-I /home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include \-I objs修改5-libpcre.a的链接objs/nginx:	objs/src/core/nginx.o \...objs/ngx_modules.o \/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib/libpcre.a修改6-链接 lz 的路径$(LINK) -o objs/nginx \...objs/ngx_modules.o \-lpthread -lcrypt /home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib/libpcre.a /home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib/libssl.a /home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib/libcrypto.a -ldl -L/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib -lz修改7-注释掉不需要的编译#/home/miracle/work/1_inbox/xiaomirouter/test/openssl-1.0.2g/pcre.h:	#/home/miracle/work/1_inbox/xiaomirouter/test/openssl-1.0.2g/Makefile#/home/miracle/work/1_inbox/xiaomirouter/test/openssl-1.0.2g/Makefile:	objs/Makefile#cd /home/miracle/work/1_inbox/xiaomirouter/test/openssl-1.0.2g \#&amp;&amp; if [ -f Makefile ]; then $(MAKE) distclean; fi \#&amp;&amp; CC="$(CC)" CFLAGS="-O2 -fomit-frame-pointer -pipe " \#./configure --disable-shared #/home/miracle/work/1_inbox/xiaomirouter/test/openssl-1.0.2g/.libs/libpcre.a:	#/home/miracle/work/1_inbox/xiaomirouter/test/openssl-1.0.2g/Makefile#cd /home/miracle/work/1_inbox/xiaomirouter/test/openssl-1.0.2g \#&amp;&amp; $(MAKE) libpcre.la#/home/miracle/work/1_inbox/xiaomirouter/test/openssl-1.0.2g/.openssl/include/openssl/ssl.h:	objs/Makefile#cd /home/miracle/work/1_inbox/xiaomirouter/test/openssl-1.0.2g \#&amp;&amp; if [ -f Makefile ]; then $(MAKE) clean; fi \#&amp;&amp; ./config --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/openssl-1.0.2g/.openssl no-shared  \#&amp;&amp; $(MAKE) \#&amp;&amp; $(MAKE) install LIBDIR=lib5.2.5.5 交叉编译、安装$make$make install至此，nginx交叉编译、安装完成。5.2.6 部署到小米路由器上的内容5.2.6.1 安装包部署每次升级路由器,都需要重新部署配置文件.$vim /etc/profile#customexport PATH=$PATH:/userdisk/data/opt/usr/local/develop/binexport PATH=$PATH:/userdisk/data/opt/usr/local/develop/sbinexport PATH=$PATH:/userdisk/data/opt/usr/local/develop/libexecexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/userdisk/data/opt/usr/local/develop/libexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/userdisk/data/opt/usr/local/develop/lib/mysql5.2.6.2 配置文件以及数据库的部署先给出一个脚本 install.sh, 用来集中描述对配置文件的部署：#!/bin/shPREFIX=/userdisk/data/opt/usr/local/develop[ -f /etc/my.cnf ] &amp;&amp; echo "/etc/my.cnf exists, skip." || cp ./my.cnf /etc[ -f $PREFIX/etc/php-fpm.conf ] &amp;&amp; echo "$PREFIX/etc/php-fpm.conf exists, skip."|| cp ./php-fpm.conf $PREFIX/etc[ -f $PREFIX/etc/php.ini ] &amp;&amp; echo "$PREFIX/etc/php.ini exists, skip."|| cp ./php.ini $PREFIX/etc[ -f $PREFIX/conf/nginx.conf ] &amp;&amp; echo "$PREFIX/conf/nginx.conf exists, skip."|| cp ./nginx.conf $PREFIX/confmkdir -p $PREFIX/datamkdir -p $PREFIX/tmpchmod 777 -R $PREFIX/tmpmysql_install_db --user=root --basedir=$PREFIX --datadir=$PREFIX/data对于以上脚本，我们需要了解如下：PREFIX=/userdisk/data/opt/usr/local/develop这句话指定了我们将要将交叉编译的内容部署到小米路由器上的哪个路径，路径用环境变量 PREFIX 来指定。[ -f /etc/my.cnf ] &amp;&amp; echo "/etc/my.cnf exists, skip." || cp ./my.cnf /etc这句话指定 MySql 的配置文件，这个文件拷贝自源码包下的 support-files/my-small.cnf, 将其修改后拷贝到小米路由器的 /etc 下，并重命名为 my.cnf 做为MySql的配置文件。对于该文件的修改主要如下片段：[mysqld]user = rootbasedir	= /userdisk/data/opt/usr/local/develop[ -f $PREFIX/etc/php-fpm.conf ] &amp;&amp; echo "$PREFIX/etc/php-fpm.conf exists, skip."|| cp ./php-fpm.conf $PREFIX/etc这句话给出 php-fpm 的配置，该文件拷贝自安装目录 $PREFIX/etc/php-fpm.conf 下的 php-fpm.conf.default 文件， 主要修改如下：[global]; Pid file; Note: the default prefix is /home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/var; Default Value: none;pid = run/php-fpm.pid; Error log file; If it's set to "syslog", log is sent to syslogd instead of being written; in a local file.; Note: the default prefix is /home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/var; Default Value: log/php-fpm.log;error_log = log/php-fpm.log...;   'port'                 - to listen on a TCP socket to all IPv4 addresses on a;                            specific port;;   '[::]:port'            - to listen on a TCP socket to all addresses;                            (IPv6 and IPv4-mapped) on a specific port;;   '/path/to/unix/socket' - to listen on a unix socket.; Note: This value is mandatory.listen = 127.0.0.1:9000...; Redirect worker stdout and stderr into main error log. If not set, stdout and; stderr will be redirected to /dev/null according to FastCGI specs.; Note: on highloaded environement, this can cause some delay in the page; process time (several ms).; Default Value: no;catch_workers_output = yes[ -f $PREFIX/etc/php.ini ] &amp;&amp; echo "$PREFIX/etc/php.ini exists, skip."|| cp ./php.ini $PREFIX/etc这个文件拷贝自源代码包中的 php.ini-development, 修改如下：...; Log errors to specified file. PHP's default behavior is to leave this value; empty.; http://php.net/error-log; Example:;error_log = php_errors.log; Log errors to syslog (Event Log on Windows).error_log = /userdisk/data/opt/usr/local/develop/var/log/php_errors.log...; Maximum size of POST data that PHP will accept.; Its value may be 0 to disable the limit. It is ignored if POST data reading; is disabled through enable_post_data_reading.; http://php.net/post-max-sizepost_max_size = 512M...; Directory in which the loadable extensions (modules) reside.; http://php.net/extension-dir; extension_dir = "./"; On windows:extension_dir = "/userdisk/data/opt/usr/local/develop/lib/php/extensions/no-debug-non-zts-20131226"...; Directory where the temporary files should be placed.; Defaults to the system default (see sys_get_temp_dir); sys_temp_dir = "/tmp"sys_temp_dir = "/userdisk/data/opt/usr/local/develop/tmp"...; Maximum allowed size for uploaded files.; http://php.net/upload-max-filesizeupload_max_filesize = 512M...; Default socket name for local MySQL connects.  If empty, uses the built-in; MySQL defaults.; http://php.net/pdo_mysql.default-socketpdo_mysql.default_socket= /tmp/mysql.sock...;;     session.save_path = "N;MODE;/path";; where MODE is the octal representation of the mode. Note that this; does not overwrite the process's umask.; http://php.net/session.save-path; session.save_path = "/tmp"session.save_path = "/userdisk/data/opt/usr/local/develop/tmp"...[ -f $PREFIX/conf/nginx.conf ] &amp;&amp; echo "$PREFIX/conf/nginx.conf exists, skip."|| cp ./nginx.conf $PREFIX/conf这个是nginx的配置文件，在 $PREFIX/conf/ 中有一个备份的文件 nginx.conf.default, (其他的nginx配置也是类似的备份方式)，对该文件的修改，和PC上基本一样。这里给出其完整配置如下：worker_processes  2;error_log  /userdisk/data/opt/usr/local/develop/logs/error.log;#error_log  /userdisk/data/opt/usr/local/develop/logs/error.log  notice;#error_log  /userdisk/data/opt/usr/local/develop/logs/error.log  info;#error_log  /userdisk/data/opt/usr/local/develop/logs/error.log  alert;pid        /var/run/nginx.pid;events {worker_connections  1024;}http {include       mime.types;default_type  application/octet-stream;log_format  main  '$remote_addr - $remote_user [$time_local] "$request" ''$status $body_bytes_sent "$http_referer" ''"$http_user_agent" "$http_x_forwarded_for"';access_log  /userdisk/data/opt/usr/local/develop/logs/access.log  main;sendfile        on;#tcp_nopush     on;#keepalive_timeout  0;keepalive_timeout  65;#gzip  on;###test phpserver {listen       18080;server_name 192.168.31.1;location / {#root   /userdisk/data/web/test;root   /userdisk/data/web/test;index  index.php index.html;}# pass the PHP scripts to FastCGI server listening on 192.168.31.1:19000#location ~ \.php$ {fastcgi_pass   127.0.0.1:19000;fastcgi_index  index.php;fastcgi_param  SCRIPT_FILENAME  /userdisk/data/web/test$fastcgi_script_name;include        fastcgi_params;}}###myown cloud with sslupstream php-handler {server 127.0.0.1:19000;#server unix:/var/run/php5-fpm.sock;}server {listen 18000;server_name 192.168.31.1;# enforce httpsreturn 301 https://$server_name$request_uri;}server {listen 443 ssl;server_name 192.168.31.1;ssl_certificate /userdisk/data/web/server.crt;ssl_certificate_key /userdisk/data/web/server.key;# Add headers to serve security related headersadd_header Strict-Transport-Security "max-age=15768000; includeSubDomains; preload;";add_header X-Content-Type-Options nosniff;add_header X-Frame-Options "SAMEORIGIN";add_header X-XSS-Protection "1; mode=block";add_header X-Robots-Tag none;add_header X-Download-Options noopen;add_header X-Permitted-Cross-Domain-Policies none;# Path to the root of your installationroot /userdisk/data/web;# set max upload sizelocation / {index index.html;}location /blog {alias /userdisk/data/web/blog;index index.html;}location /blog/quietheart {alias /userdisk/data/web/blog/quietheart;index index.html;}location /mycloud/owncloud {alias /userdisk/data/web/mycloud/owncloud;client_max_body_size 1G;fastcgi_buffers 64 4K;# Disable gzip to avoid the removal of the ETag headergzip off;# Uncomment if your server is build with the ngx_pagespeed module# This module is currently not supported.#pagespeed off;index index.php;error_page 403 /core/templates/403.php;error_page 404 /core/templates/404.php;rewrite ^/.well-known/carddav /remote.php/dav/ permanent;rewrite ^/.well-known/caldav /remote.php/dav/ permanent;# The following 2 rules are only needed for the user_webfinger app.# Uncomment it if you're planning to use this app.#rewrite ^/.well-known/host-meta /public.php?service=host-meta last;#rewrite ^/.well-known/host-meta.json /public.php?service=host-meta-json last;rewrite ^/remote/(.*) /remote.php last;rewrite ^(/core/doc/[^\/]+/)$ $1/index.html;try_files $uri $uri/ =404;}location = /robots.txt {allow all;log_not_found off;access_log off;}location ~ ^/(build|tests|config|lib|3rdparty|templates|data)/ {deny all;}location ~ ^/(?:\.|autotest|occ|issue|indie|db_|console) {deny all;}#		location / {#		rewrite ^/remote/(.*) /remote.php last;#		rewrite ^(/core/doc/[^\/]+/)$ $1/index.html;#			try_files $uri $uri/ =404;#		}location ~ \.php(?:$|/) {fastcgi_split_path_info ^(.+\.php)(/.+)$;include fastcgi_params;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;fastcgi_param PATH_INFO $fastcgi_path_info;fastcgi_param HTTPS on;fastcgi_param modHeadersAvailable true; #Avoid sending the security headers twice#fastcgi_pass   127.0.0.1:9000;fastcgi_pass   php-handler;fastcgi_intercept_errors on;}location ~* \.(?:css|js)$ {add_header Cache-Control "public, max-age=7200";# Add headers to serve security related headersadd_header Strict-Transport-Security "max-age=15768000; includeSubDomains; preload;";add_header X-Content-Type-Options nosniff;add_header X-Frame-Options "SAMEORIGIN";add_header X-XSS-Protection "1; mode=block";add_header X-Robots-Tag none;add_header X-Download-Options noopen;add_header X-Permitted-Cross-Domain-Policies none;# Optional: Don't log access to assetsaccess_log off;}# Optional: Don't log access to other assetslocation ~* \.(?:jpg|jpeg|gif|bmp|ico|png|swf)$ {access_log off;}}}创建程序运行时所需要的目录如下目录需要手动创建，运行时会向其中写入相关的文件：$mkdir -p $PREFIX/data$mkdir -p $PREFIX/tmp$chmod 777 -R $PREFIX/tmp安装数据库相关内容主要是数据库所在路径，配置之后即可启动MySql服务，如下：$mysql_install_db --user=root --basedir=$PREFIX --datadir=$PREFIX/data5.2.6.3 编写运行脚本启动脚本主要包括：MySql启动脚本、Php环境启动脚本、以及nginx启动脚本。后面会给出使用方式，这里先给出脚本内容分别如下：MySql启动脚本：mysql.server#!/bin/sh# Copyright Abandoned 1996 TCX DataKonsult AB &amp; Monty Program KB &amp; Detron HB# This file is public domain and comes with NO WARRANTY of any kind# MySQL daemon start/stop script.# Usually this is put in /etc/init.d (at least on machines SYSV R4 based# systems) and linked to /etc/rc3.d/S99mysql and /etc/rc0.d/K01mysql.# When this is done the mysql server will be started when the machine is# started and shut down when the systems goes down.# Comments to support chkconfig on RedHat Linux# chkconfig: 2345 64 36# description: A very fast and reliable SQL database engine.# Comments to support LSB init script conventions### BEGIN INIT INFO# Provides: mysql# Required-Start: $local_fs $network $remote_fs# Should-Start: ypbind nscd ldap ntpd xntpd# Required-Stop: $local_fs $network $remote_fs# Default-Start:  2 3 4 5# Default-Stop: 0 1 6# Short-Description: start and stop MySQL# Description: MySQL is a very fast and reliable SQL database engine.### END INIT INFO# If you install MySQL on some other places than /home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/mysql-5.1.72, then you# have to do one of the following things for this script to work:## - Run this script from within the MySQL installation directory# - Create a /etc/my.cnf file with the following information:#   [mysqld]#   basedir=&lt;path-to-mysql-installation-directory&gt;# - Add the above to any other configuration file (for example ~/.my.ini)#   and copy my_print_defaults to /usr/bin# - Add the path to the mysql-installation-directory to the basedir variable#   below.## If you want to affect other MySQL variables, you should make your changes# in the /etc/my.cnf, ~/.my.cnf or other MySQL configuration files.# If you change base dir, you must also change datadir. These may get# overwritten by settings in the MySQL configuration files.basedir=/userdisk/data/opt/usr/local/developdatadir=# Default value, in seconds, afterwhich the script should timeout waiting# for server start. # Value here is overriden by value in my.cnf. # 0 means don't wait at all# Negative numbers mean to wait indefinitelyservice_startup_timeout=900# The following variables are only set for letting mysql.server find things.# Set some defaultspid_file=server_pid_file=use_mysqld_safe=1user=rootif test -z "$basedir"thenbasedir=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/mysql-5.1.72bindir=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/mysql-5.1.72/binif test -z "$datadir"thendatadir=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/mysql-5.1.72/varfisbindir=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/mysql-5.1.72/sbinlibexecdir=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/mysql-5.1.72/libexecelsebindir="$basedir/bin"if test -z "$datadir"thendatadir="$basedir/data"fisbindir="$basedir/sbin"libexecdir="$basedir/libexec"fi# datadir_set is used to determine if datadir was set (and so should be# *not* set inside of the --basedir= handler.)datadir_set=## Use LSB init script functions for printing messages, if possible#lsb_functions="/lib/lsb/init-functions"if test -f $lsb_functions ; then. $lsb_functionselselog_success_msg(){echo " SUCCESS! $@"}log_failure_msg(){echo " ERROR! $@"}fiPATH=/sbin:/usr/sbin:/bin:/usr/bin:$basedir/binexport PATHmode=$1    # start or stopshiftother_args="$*"   # uncommon, but needed when called from an RPM upgrade action# Expected: "--skip-networking --skip-grant-tables"# They are not checked here, intentionally, as it is the resposibility# of the "spec" file author to give correct arguments only.case `echo "testing\c"`,`echo -n testing` in*c*,-n*) echo_n=   echo_c=     ;;*c*,*)   echo_n=-n echo_c=     ;;*)       echo_n=   echo_c='\c' ;;esacparse_server_arguments() {for arg docase "$arg" in--basedir=*)  basedir=`echo "$arg" | sed -e 's/^[^=]*=//'`bindir="$basedir/bin"if test -z "$datadir_set"; thendatadir="$basedir/data"fisbindir="$basedir/sbin"libexecdir="$basedir/libexec";;--datadir=*)  datadir=`echo "$arg" | sed -e 's/^[^=]*=//'`datadir_set=1;;--user=*)  user=`echo "$arg" | sed -e 's/^[^=]*=//'` ;;--pid-file=*) server_pid_file=`echo "$arg" | sed -e 's/^[^=]*=//'` ;;--service-startup-timeout=*) service_startup_timeout=`echo "$arg" | sed -e 's/^[^=]*=//'` ;;--use-mysqld_safe) use_mysqld_safe=1;;--use-manager)     use_mysqld_safe=0;;esacdone}parse_manager_arguments() {for arg docase "$arg" in--pid-file=*) pid_file=`echo "$arg" | sed -e 's/^[^=]*=//'` ;;--user=*)  user=`echo "$arg" | sed -e 's/^[^=]*=//'` ;;esacdone}wait_for_pid () {verb="$1"manager_pid="$2"  # process ID of the program operating on the pid-filei=0avoid_race_condition="by checking again"while test $i -ne $service_startup_timeout ; docase "$verb" in'created')# wait for a PID-file to pop into existence.test -s $pid_file &amp;&amp; i='' &amp;&amp; break;;'removed')# wait for this PID-file to disappeartest ! -s $pid_file &amp;&amp; i='' &amp;&amp; break;;*)echo "wait_for_pid () usage: wait_for_pid created|removed manager_pid"exit 1;;esac# if manager isn't running, then pid-file will never be updatedif test -n "$manager_pid"; thenif kill -0 "$manager_pid" 2&gt;/dev/null; then:  # the manager still runselse# The manager may have exited between the last pid-file check and now.  if test -n "$avoid_race_condition"; thenavoid_race_condition=""continue  # Check again.fi# there's nothing that will affect the file.log_failure_msg "Manager of pid-file quit without updating file."return 1  # not waiting any more.fifiecho $echo_n ".$echo_c"i=`expr $i + 1`sleep 1doneif test -z "$i" ; thenlog_success_msgreturn 0elselog_failure_msgreturn 1fi}# Get arguments from the my.cnf file,# the only group, which is read from now on is [mysqld]if test -x ./bin/my_print_defaultsthenprint_defaults="./bin/my_print_defaults"elif test -x $bindir/my_print_defaultsthenprint_defaults="$bindir/my_print_defaults"elif test -x $bindir/mysql_print_defaultsthenprint_defaults="$bindir/mysql_print_defaults"else# Try to find basedir in /etc/my.cnfconf=/etc/my.cnfprint_defaults=if test -r $confthensubpat='^[^=]*basedir[^=]*=\(.*\)$'dirs=`sed -e "/$subpat/!d" -e 's//\1/' $conf`for d in $dirsdod=`echo $d | sed -e 's/[     ]//g'`if test -x "$d/bin/my_print_defaults"thenprint_defaults="$d/bin/my_print_defaults"breakfiif test -x "$d/bin/mysql_print_defaults"thenprint_defaults="$d/bin/mysql_print_defaults"breakfidonefi# Hope it's in the PATH ... but I doubt ittest -z "$print_defaults" &amp;&amp; print_defaults="my_print_defaults"fi## Read defaults file from 'basedir'.   If there is no defaults file there# check if it's in the old (depricated) place (datadir) and read it from there#extra_args=""if test -r "$basedir/my.cnf"thenextra_args="-e $basedir/my.cnf"elseif test -r "$datadir/my.cnf"thenextra_args="-e $datadir/my.cnf"fifiparse_server_arguments `$print_defaults $extra_args mysqld server mysql_server mysql.server`# Look for the pidfile parse_manager_arguments `$print_defaults $extra_args manager`## Set pid file if not given#if test -z "$pid_file"thenpid_file=$datadir/mysqlmanager-`/bin/hostname`.pidelsecase "$pid_file" in/* ) ;;* )  pid_file="$datadir/$pid_file" ;;esacfiif test -z "$server_pid_file"thenserver_pid_file=$datadir/`/bin/hostname`.pidelsecase "$server_pid_file" in/* ) ;;* )  server_pid_file="$datadir/$server_pid_file" ;;esacficase "$mode" in'start')# Start daemon# Safeguard (relative paths, core dumps..)cd $basedirmanager=$bindir/mysqlmanagerif test -x $libexecdir/mysqlmanagerthenmanager=$libexecdir/mysqlmanagerelif test -x $sbindir/mysqlmanagerthenmanager=$sbindir/mysqlmanagerfiecho $echo_n "Starting MySQL"if test -x $manager -a "$use_mysqld_safe" = "0"thenif test -n "$other_args"thenlog_failure_msg "MySQL manager does not support options '$other_args'"exit 1fi# Give extra arguments to mysqld with the my.cnf file. This script may# be overwritten at next upgrade."$manager" \--mysqld-safe-compatible \--user="$user" \--pid-file="$pid_file" &gt;/dev/null 2&gt;&amp;1 &amp;wait_for_pid created $!; return_value=$?# Make lock for RedHat / SuSEif test -w /var/lock/subsysthentouch /var/lock/subsys/mysqlmanagerfiexit $return_valueelif test -x $bindir/mysqld_safethen# Give extra arguments to mysqld with the my.cnf file. This script# may be overwritten at next upgrade.pid_file=$server_pid_file$bindir/mysqld_safe --datadir=$datadir --pid-file=$server_pid_file $other_args &gt;/dev/null 2&gt;&amp;1 &amp;wait_for_pid created $!; return_value=$?# Make lock for RedHat / SuSEif test -w /var/lock/subsysthentouch /var/lock/subsys/mysqlfiexit $return_valueelselog_failure_msg "Couldn't find MySQL manager ($manager) or server ($bindir/mysqld_safe)"fi;;'stop')# Stop daemon. We use a signal here to avoid having to know the# root password.# The RedHat / SuSE lock directory to removelock_dir=/var/lock/subsys/mysqlmanager# If the manager pid_file doesn't exist, try the server'sif test ! -s "$pid_file"thenpid_file=$server_pid_filelock_dir=/var/lock/subsys/mysqlfiif test -s "$pid_file"thenmysqlmanager_pid=`cat $pid_file`if (kill -0 $mysqlmanager_pid 2&gt;/dev/null)thenecho $echo_n "Shutting down MySQL"kill $mysqlmanager_pid# mysqlmanager should remove the pid_file when it exits, so wait for it.wait_for_pid removed "$mysqlmanager_pid"; return_value=$?elselog_failure_msg "MySQL manager or server process #$mysqlmanager_pid is not running!"rm $pid_filefi# delete lock for RedHat / SuSEif test -f $lock_dirthenrm -f $lock_dirfiexit $return_valueelselog_failure_msg "MySQL manager or server PID file could not be found!"fi;;'restart')# Stop the service and regardless of whether it was# running or not, start it again.if $0 stop  $other_args; then$0 start $other_argselselog_failure_msg "Failed to stop running server, so refusing to try to start."exit 1fi;;'reload'|'force-reload')if test -s "$server_pid_file" ; thenread mysqld_pid &lt;  $server_pid_filekill -HUP $mysqld_pid &amp;&amp; log_success_msg "Reloading service MySQL"touch $server_pid_fileelselog_failure_msg "MySQL PID file could not be found!"exit 1fi;;'status')# First, check to see if pid file existsif test -s "$server_pid_file" ; then read mysqld_pid &lt; $server_pid_fileif kill -0 $mysqld_pid 2&gt;/dev/null ; then log_success_msg "MySQL running ($mysqld_pid)"exit 0elselog_failure_msg "MySQL is not running, but PID file exists"exit 1fielse# Try to find appropriate mysqld processmysqld_pid=`pidof $libexecdir/mysqld`# test if multiple pids existpid_count=`echo $mysqld_pid | wc -w`if test $pid_count -gt 1 ; thenlog_failure_msg "Multiple MySQL running but PID file could not be found ($mysqld_pid)"exit 5elif test -z $mysqld_pid ; then if test "$use_mysqld_safe" = "0" ; then lockfile=/var/lock/subsys/mysqlmanagerelselockfile=/var/lock/subsys/mysqlfi if test -f $lockfile ; then log_failure_msg "MySQL is not running, but lock exists"exit 2fi log_failure_msg "MySQL is not running"exit 3elselog_failure_msg "MySQL is running but PID file could not be found"exit 4fifi;;*)# usageecho "Usage: $0  {start|stop|restart|reload|force-reload|status}  [ MySQL server options ]"exit 1;;esacexit 0php环境运行脚本： php-fpm.sh#!/bin/sh#PHP_PATH=/userdisk/data/opt/usr/local/developDESC="php-fpm daemon"NAME=php-fpm# php-fpmDAEMON=$PHP_PATH/sbin/$NAMECONFIGFILE=$PHP_PATH/etc/php-fpm.confPIDFILE=/var/run/$NAME.pidrh_start() {$DAEMON -c $PHP_PATH/etc -y $CONFIGFILE || echo -n " already running"}rh_stop() {kill -QUIT `cat $PIDFILE` || echo -n " not running"}case "$1" instart)echo -n "Starting $DESC: $NAME"rh_startecho ".";;stop)echo -n "Stopping $DESC: $NAME"rh_stopecho ".";;restart)echo -n "Restarting $DESC: $NAME"rh_stopsleep 1rh_startecho ".";;*)echo "Usage: $SCRIPTNAME {start|stop|restart}" &gt;&amp;2exit 3;;esacexit 05.2.6.4 创建数据库根用户帐号与http帐号数据库帐号用于登录和操作数据库，http帐号是访问某些Owncloud安装目录子目录数据所需要的帐号。该过程只需执行一次，如下：$./mysql.server start$mysqladmin -u root password '&lt;根用户密码&gt;'$vim /etc/passwd...添加www-data用户类似如下...www-data:x:1024:1024:www-data:/root:/bin/ash$vim /etc/group...添加www-data组类似如下...www-data:x:1024:5.2.6.5 readme(one time)1. ./install.sh3. ./mysql.server start(one time)4. mysqladmin -u root password '&lt;6+&gt;'(one time)5. edit/etc/passwdwww-data:x:1024:1024:www-data:/root:/bin/ash/etc/groupwww-data:x:1024:6. ./php-fpm.sh start(one time every two year)7.opensslexport OPENSSL_CONF=/userdisk/data/opt/usr/local/develop/ssl/openssl.cnfopenssl genrsa -des3 -out server.key 1024openssl req -new -key server.key -out server.csrcp server.key server.key.orgopenssl rsa -in server.key.org -out server.keyopenssl x509 -req -days 730 -in server.csr -signkey server.key -out server.crt8. ./nginx.sh startmkdir /userdisk/data/web/mycloud/oc_datamkdir /userdisk/data/usr/local/develop/tmpchmod -R 777 /userdisk/data/usr/local/develop/tmp5.3 参考资料云存储相关：seafile:开源，部分收费（比如目录选择性同步、搜索、文件读写控制）,服务还不错，界面比较简陋。https://www.seafile.com/download/*own cloud：开源，免费，服务一般，有人反映卡，功能齐全，支持平台多。https://owncloud.org/SparkleShare（开源免费，不支持IOS，使用git做为引擎，中文支持差？）http://www.oschina.net/p/sparkleshare/similar_projects?lang=25&amp;sort=time云存储架构cloudstack vs openstackhttp://infosec.blog.51cto.com/226250/1565179介绍Linux下常见的开源云平台&amp;&amp;存储服务http://blog.csdn.net/gatieme/article/details/44977487对比sparkleshare、owncloud、seafilehttps://www.reddit.com/r/linux/comments/1efdnd/sparkleshare_owncloud_or_seafile/三大WEB服务器对比分析http://hai0378.iteye.com/blog/1860220openssl key的生成http://www.poluoluo.com/server/201401/261178.htmlnginx配置相关http://www.nginx.cn/591.html文件同步工具：http://alternativeto.net/software/goodsync/http://www.pc6.com/pc/wenjiantongburj/小米路由安装nginx：http://www.miui.com/thread-2592877-1-1.html小米路由器交叉编译php：http://bbs.xiaomi.cn/t-11228942小米开放平台http://www.miwifi.com/miwifi_open.html6 小米路由器上使用 git 版本控制系统6.1 下载 git 源码$wget --no-check-certificate -c https://codeload.github.com/git/git/tar.gz/v2.8.26.2 非交叉编译 git 过程先了解一下非交叉编译的过程，再进行交叉编译。生成配置脚本$tar -xzvf git-2.8.2.tar.gz$cd git-2.8.2$make configure$./configure --prefix=/usr/local/develop --without-tcltk执行完 configure 之后，会生成一个 config.mak.autogen 文件， Makefile 中会包含这个文件。手动配置编译模块根据 INSTALL 介绍，按需配置需要需掉的编译模块，修改 config.mak.autogen$vim config.mak.autogen...####CustomNO_PERL=YesPlease#NO_TCLTK=YesPlease$make allgit 有些功能还是需要外部依赖的，这里，将 perl 和 tcltk 相关内容去掉。会影响的功能，参见 INSTALL 介绍。实际执行完 make all 后，就可在当前目录中运行 ./git 进行测试了。6.3 交叉编译 git6.3.1 配置交叉编译环境路径参考：小米路由器交叉编译环境配置6.3.2 生成配置脚本$tar -xzvf git-2.8.2.tar.gz$cd git-2.8.2$make configure$./configure --host=arm-xiaomi-linux-uclibcgnueabi --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --with-curl=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib --without-tcltk CC=arm-xiaomi-linux-uclibcgnueabi-gcc LDFLAGS=-L/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib CFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include CPPFLAGS=-I/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include执行完 configure 之后，会生成一个 config.mak.autogen 文件， Makefile 中会包含这个文件。注意，运行 configure 之前，需要如下修改 configure 脚本，否则会出现无法运行测试文件相关的错误。修改如下：$vim configure...6250 if test "$cross_compiling" = yes; then :                                                                                                         6251     echo "skip corss_compiling test";6252 #  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" &gt;&amp;56253 #$as_echo "$as_me: error: in \`$ac_pwd':" &gt;&amp;2;}6254 #as_fn_error $? "cannot run test program while cross compiling6255 #See \`config.log' for more details" "$LINENO" 5; }...6300 if test "$cross_compiling" = yes; then :6301     echo "skip corss_compiling test";                                                                                                            6302 #  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" &gt;&amp;56303 #$as_echo "$as_me: error: in \`$ac_pwd':" &gt;&amp;2;}6304 #as_fn_error $? "cannot run test program while cross compiling6305 #See \`config.log' for more details" "$LINENO" 5; }6306 else...6.3.3 编译、安装$make all$make install至此， git 的交叉编译完成，部署到服务器添加环境变量后上即可运行。注意，编译之前需要修改 Makefile 使用交叉编译工具链$vim Makefile...439 CC = arm-xiaomi-linux-uclibcgnueabi-cc                                                                                                           440 AR = arm-xiaomi-linux-uclibcgnueabi-ar...6.3.4 部署与配置由于编译、安装时本地目录与部署的目录不同，运行的时候可能会出现各种问题。建议本地安装的目录和部署目录尽量一致。(考虑 chroot ?)假设编译时安装的路径为： /home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop部署的路径为： /userdisk/data/opt/usr/local/develop根据 man 手册，运行: git config --system xxx 会读写 /home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/etc 路径（小米路由器上不存在）运行: git config --global xxx 会读写 ~/.gitconfig (小米路由器只读)运行: git config xxx 会读写 .git/config, 对于第一次运行的来说，不存在这个路径。意图最初的配置文件在 /userdisk/data/opt/usr/local/develop/etc/gitconfig 读取，（因为无法操作 system 的以及 global 的配置）所以，有几个方法在第一次运行git时指定配置：配置 GIT_CONFIG$export GIT_CONFIG=/userdisk/data/opt/usr/local/develop/etc/gitconfig$git config init.templatedir /userdisk/data/opt/usr/local/develop/share/git-core/templates但是这样会修改已有的 local 的 config, 行为，使之在已有git repo中运行时，不会修改其 .git/config命令行中指定路径$git -C &lt;config path&gt; xxx但是这样默认会在路径中寻找 config 的文件，实践似乎不管用。命令行指定选项$git -c init.templatedir=/userdisk/data/opt/usr/local/develop/share/git-core/templates clone xxx开启标准路径文件写权限。执行下述命令即可：$mount -o remount -rw /参考：开启ssh后无法获得系统文件夹写入权限?注意了，第一次运行，一定要指定好 git config init.templatedir /userdisk/data/opt/usr/local/develop/share/git-core/templates最后，当已经有了一个仓库之时，直接用 git config 为相应的本地库设置好那些需要设置的选项，默认系统最好设置如下内容如：$git config --global init.templatedir /userdisk/data/opt/usr/local/develop/share/git-core/templates$git config --global http.sslVerify false$git config --global user.name "quietheart@xiaomi"$git config --global user.email "vaqeteart@qq.com"这些信息保存在 ~/.gitconfig 中。6.3.5 WAIT/FORWARD FAQ [%][/]State "WAIT/FORWARD" from              [2016-08-09 二 15:36]  wait for all done.6.3.5.1 DONE fatal: Unable to find remote helper for 'https'State "DONE"       from              [2016-07-27 三 09:24]添加路径: export PATH=$PATH:/userdisk/data/opt/usr/local/develop/libexec/git-core6.3.5.2 DONE warning: templates not found /home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/share/git-core/templatesState "DONE"       from              [2016-07-27 三 09:24]命令中指定templates： git -c init.templatedir=/userdisk/data/opt/usr/local/develop/share/git-core/templates clone https://vaqeteart@bitbucket.org/vaqeteart/quietheart.gitor in config file:[init]     templatedir = /userdisk/data/opt/usr/local/develop/share/git-core/templates6.3.5.3 DONE Protocol "https" not supported or disabled in libcurlState "DONE"       from              [2016-07-27 三 09:24]编译 libcurl 之时需要加入相关选项：./configure --host=arm-xiaomi-linux-uclibcgnueabi --enable-static --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --enable-http --with-ssl=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/ CC=arm-xiaomi-linux-uclibcgnueabi-gcc之后再编译 git注意，编译 libcurl 如果出现无法链接 libssl.a, 需要加入 -fPIC 重新编译 openssl, 编译完成之后，运行 curl --version 即可看到支持不支持 https 。6.3.5.4 xiaomi路由器上建立一个本地仓库后，最好用什么配置做为默认的本地仓库配置？如下：$git config init.templatedir /userdisk/data/opt/usr/local/develop/share/git-core/templates$git config http.sslVerify false$git config receive.denycurrentbranch ignore6.3.5.5 WAIT/FORWARD SSL certificate problem: unable to get local issuer certificateState "WAIT/FORWARD" from "NEXT"       [2016-08-09 二 15:34]  wair for more secury method.State "NEXT"       from              [2016-07-27 三 09:24]方法1：命令行中禁用 https 验证（不安全）$git -c init.templatedir=/userdisk/data/opt/usr/local/develop/share/git-core/templates -c http.sslVerify=false clone https://vaqeteart@bitbucket.org/vaqeteart/quietheart.git方法2：环境变量禁用 https 验证（不安全）$export GIT_SSL_NO_VERIFY=true$git -c init.templatedir=/userdisk/data/opt/usr/local/develop/share/git-core/templates clone https://github.com/vaqeteart/vaqeteart.github.io方法3：ssh-keygen??6.3.5.6 DONE 其他主机如何clone库？State "DONE"       from "NEXT"       [2016-08-09 二 15:35]State "NEXT"       from "DONE"       [2016-08-03 三 19:37]State "DONE"       from "DONE"       [2016-08-03 三 19:37]State "DONE"       from "NEXT"       [2016-07-28 四 17:04]State "NEXT"       from              [2016-07-28 四 17:02]如果开启了ssh功能，假设小米路由器上的git库路径为 /path/to/gitrepo, 账户为 user, 密码为 passwd, 那么其它主机只需要：$git clone user@ip:/path/to/gitrepo .....根据提示输入密码passwd....由于小米路由器上的ssh端口做了映射，所以clone之前，先将主机上的 .ssh/config 中加入类似如下：Host xiaomiHostName &lt;主机域名或者ip&gt;User userPort &lt;被映射的端口&gt;IdentityFile ~/.ssh/id_rsa之后只需如下进行：$git clond ssh://xiaomi:&lt;path&gt;6.3.5.7 DONE ash: git-upload-pack: not foundState "DONE"       from "NEXT"       [2016-08-09 二 15:35]State "NEXT"       from              [2016-08-03 三 19:37]主要是运行 git-upload-pack 的路径不对。命令行中指定$git clone --upload-pack "/userdisk/data/opt/usr/local/develop/bin/git-upload-pack" ssh://xxx或在服务器上，为 git-upload-pack 建立软链接，类似如下：$ln -s /userdisk/data/opt/usr/local/develop/bin/git-upload-pack /usr/bin参考:http://stackoverflow.com/questions/11128464/git-upload-pack-command-not-foundhttp://www.linuxidc.com/Linux/2012-07/66270.htm6.3.5.8 DONE error: cannot run pack-objects: No such file or directoryState "DONE"       from "NEXT"       [2016-08-09 二 15:35]State "NEXT"       from              [2016-08-08 一 14:17]类似前面，为全部git组件创建软链接的方式最简单（创建之前最好能检查一下已有的）：$ln -s /userdisk/data/opt/usr/local/develop/libexec/git-core/* /usr/bin6.3.5.9 DONE error: failed to push some refs to 'ssh://xiaomiState "DONE"       from "NEXT"       [2016-08-09 二 15:35]State "NEXT"       from              [2016-08-08 一 14:17]远程客户端运行 git push 之时出现，应当在服务端为当前git仓库打开允许 push 的选项，如下：$git config receive.denycurrentbranch ignore推送之后，到服务端上（xiaomi路由器上），可用 git log 查看到远端的修改，但是其工作目录中如果包含工作文件的话，推送的内容不会反映到工作目录中。这个时候，应当将工作目录中的内容备份，然后:$git reset --hard7 Misc7.1 小米路由器添加ddnsddns可以实现当ip地址不固定的时候，也能通过域名正确访问到相应的路由器。大致原理是需要有一个ddns服务提供商，然后路由器定时、及时地将ip地址变化信息及时更新给ddns服务商，ddns服务商将域名与最新的ip地址相对应。在路由器web管理界面上有相应的选项，建议用花生壳提供的动态路由。现在花生壳注册用户名和密码，获取到一个免费的域名，再将账户信息填写到路由器中ddns的相应位置即可。7.2 小米路由器修改ssh启动的欢迎语修改 /etc/banner 文件。8 WAIT/FORWARD FAQ [12/19] [63%]State "WAIT/FORWARD" from              [2016-04-07 四 18:52]  wait for all resolved.8.1 DONE 小米路由如何开启ssh?State "DONE"       from "WAIT/FORWARD" [2016-04-16 六 18:21]State "WAIT/FORWARD" from "DONE"       [2016-04-07 四 18:58]  等待整理。State "DONE"       from "INBOX"      [2016-03-14 一 17:12]Capture Time:[2016-03-02 三 14:56]开启ssh可以本地局域网登录的方法，参考：小米路由器ssh开启官网：http://www.miwifi.com/miwifi_open.html外网访问参考：http://jingyan.baidu.com/article/9113f81b3a5d982b3314c74a.html?st=3&amp;net_type=2&amp;bd_page_type=1&amp;os=0&amp;showimg=1&amp;rst=6如果实现公网访问，需要开启防火墙端口。8.1.1 下面内容仅参考暂不用小米路由器mini如何设置外网访问ssh关键是修改 /etc/config/firewall# port redirect of remapped ssh port (22001) on wanconfig redirect 'myssh'       option src              wan       option src_dport        22001       option dest             lan       option dest_port        22       option proto            tcp重启防火墙 /etc/init.d/firewall restart登录： ssh -p 10022 root@&lt;ip&gt;远程传输： scp -P 10022 &lt;file&gt; root@&lt;ip&gt;:&lt;path&gt;8.2 DONE 小米路由器防火墙如何配置?State "DONE"       from "WAIT/FORWARD" [2016-04-13 三 19:35]State "WAIT/FORWARD" from "INBOX"      [2016-03-28 一 11:27]  wait for more organize.State "INBOX"      from              [2016-03-15 二 09:38]参见：小米路由器防火墙配置8.3 DONE 小米路由如何添加域名访问？State "DONE"       from "INBOX"      [2016-04-13 三 19:42]Capture Time:[2016-03-02 三 14:56]首先申请dns域名，然后将之与ip关联，但是由于ip地址不固定，所以需要使用ddns服务。参见：小米路由器添加ddns8.4 DONE 小米路由器交叉编译环境配置State "DONE"       from "WAIT/FORWARD" [2016-08-08 一 17:23]State "WAIT/FORWARD" from "DONE"       [2016-08-08 一 11:42]  wait for arrange.State "DONE"       from              [2016-07-26 二 16:59]参考：小米路由器交叉编译环境配置8.5 DONE 如何使用软件管理工具管理小米路由上的软件?State "DONE"       from "INBOX"      [2016-04-16 六 18:19]Capture Time:[2016-03-04 五 18:28]小米路由器是openwrt的系统，可借助opkg工具，参考：使用opkg在小米路由器软件管理8.6 DONE 开启ssh后无法获得系统文件夹写入权限?State "DONE"       from "WAIT/FORWARD" [2016-08-08 一 17:25]State "WAIT/FORWARD" from              [2016-08-05 五 17:21]  wait for more.参考：访问文件系统权限8.7 DONE 在小米路由器上搭建基于LNMP的Owncloud云平台State "DONE"       from "WAIT/FORWARD" [2016-08-08 一 17:37]State "WAIT/FORWARD" from "DONE"       [2016-04-16 六 16:45]  wait for arrange.State "DONE"       from "INBOX"      [2016-04-16 六 16:45]Capture Time:[2016-03-04 五 19:55]注，Owncloud功能比较全面，但是也相对不是很稳定，而且感觉消耗资源。对于资源紧张的小米路由器，目前已经不考虑用其做为主要云服务器。暂时用git来满足分布访问的需求。直接考虑的方式，获取有更好的能替代Owncloud的方式。参考：在小米路由器上搭建基于LNMP的Owncloud云平台8.8 CANCEL MyowncloudState "CANCEL"     from "WAIT/FORWARD" [2016-08-08 一 17:33]  Owncloud不稳定，数据虽然不会丢失，但是有时也很麻烦，已经不采用，此处仅供参考。State "WAIT/FORWARD" from              [2016-08-08 一 17:32]  wait for arrange.注，Owncloud功能比较全面，但是也相对不是很稳定，而且感觉消耗资源。对于资源紧张的小米路由器，目前已经不考虑用其做为主要云服务器。暂时用git来满足分布访问的需求。直接考虑的方式，获取有更好的能替代Owncloud的方式。8.8.1 site: &lt;暂不可用&gt;8.8.2 step8.8.2.1 安装apache(pc)这里，安装apache之前需要安装组件：apr,apr-util,pcre，最后再安装httpd。这里，发现nginx更适合，所以不用apache了。下载$ wget -c http://apache.opencas.org//httpd/httpd-2.4.18.tar.bz2$ wget -c http://mirrors.cnnic.cn/apache//apr/apr-1.5.2.tar.bz2$ wget -c http://apache.opencas.org//apr/apr-util-1.5.4.tar.gz$ wget -c ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz安装$sudo ./configure --prefix=/usr/local/development/apr-1.5.2$sudo make$sudo make install$sudo ./configure --prefix=/usr/local/development/apr-util-1.5.4 --with-apr=/usr/local/development/apr-1.5.2$sudo make$sudo make install$sudo ./configure --prefix=/usr/local/development/pcre-8.38 --with-apr=/usr/local/development/apr-1.5.2 --with-apr-util=/usr/local/development/apr-util-1.5.4$sudo make$sudo make install$sudo ./configure --prefix=/usr/local/development/httpd-2.4.18 --enable-so --enable-mods-shared=all --with-apr=/usr/local/development/apr-1.5.2 --with-apr-util=/usr/local/development/apr-util-1.5.4 --with-pcre=/usr/local/development/pcre-8.38$sudo make$sudo make install$sudo ln -s /usr/local/development/httpd-2.4.18/bin/apachectl /etc/init.d启动$sudo /etc/init.d/apachectl start调试如果启动出现如下两个错误：miracle@miracle-Zhaoyang-E49:~/myinstalled/httpd-2.4.18$ sudo /etc/init.d/apachectl startAH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 127.0.1.1. Set the 'ServerName' directive globally to suppress this message(98)Address already in use: AH00072: make_sock: could not bind to address 0.0.0.0:80no listening sockets available, shutting downAH00015: Unable to open logs那么第一个问题：修改 /usr/local/development/httpd-2.4.18/conf/httpd.conf, 添加 ServerName localhost:80.第二个问题：应该是端口被占用，可能启动了其他apache，可以如下修改  /usr/local/development/httpd-2.4.18/conf/httpd.confListen 90ServerName localhost:90访问基于如上配置，打开浏览器，地址栏键入 localhost:90 看到 "It works!" 即表示成功。配置8.8.2.2 安装nginx(xiaomirouter)cd ~/xiaomirouter下载$wget -c http://bigota.miwifi.com/xiaoqiang/sdk/tools/package/sdk_package.zip$wget -c http://nginx.org/download/nginx-1.8.1.tar.gz$wget -c http://www.openssl.org/source/openssl-1.0.2g.tar.gz$wget -c http://mirrors.cnnic.cn/apache//apr/apr-1.5.2.tar.bz2$wget -c http://apache.opencas.org//apr/apr-util-1.5.4.tar.gz$wget -c ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz#$wget -c http://nchc.dl.sourceforge.net/project/libpng/zlib/1.2.8/zlib-1.2.8.tar.gz配置交叉编译工具环境$export PATH=~/xiaomirouter/test/sdk_package/toolchain/bin:$PATH$export CUSTOM_PREFIX=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop交叉编译openssl$tar -xzvf openssl-1.0.2g.tar.gz$export CROSS_COMPILE=arm-xiaomi-linux-uclibcgnueabi-$cd openssl-1.0.2g./config no-asm shared --prefix=$CUSTOM_PREFIX/openssl-1.0.2g$vim Makefile...#SHARED_LDFLAGS=-m64...#CC= gccCC= arm-xiaomi-linux-uclibcgnueabi-gcc#CFLAG= -fPIC -DOPENSSL_PIC -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -m64 -DL_ENDIAN -O3 -WallCFLAG= -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -DOPENSSL_NO_KRB5 -DL_ENDIAN -O3 -WallDEPFLAG= -DOPENSSL_NO_EC_NISTP_64_GCC_128 -DOPENSSL_NO_GMP -DOPENSSL_NO_JPAKE -DOPENSSL_NO_LIBUNBOUND -DOPENSSL_NO_MD2 -DOPENSSL_NO_RC5 -DOPENSSL_NO_RFC3779 -DOPENSSL_NO_SCTP -DOPENSSL_NO_SSL_TRACE -DOPENSSL_NO_SSL2 -DOPENSSL_NO_STORE -DOPENSSL_NO_UNIT_TEST -DOPENSSL_NO_WEAK_SSL_CIPHERSPEX_LIBS= EX_LIBS= -ldlEXE_EXT= ARFLAGS= #AR= ar $(ARFLAGS) rAR= arm-xiaomi-linux-uclibcgnueabi-ar $(ARFLAGS) r#RANLIB= /usr/bin/ranlibRANLIB= arm-xiaomi-linux-uclibcgnueabi-ranlib#NM= nmNM= arm-xiaomi-linux-uclibcgnueabi-nmPERL= /usr/bin/perlTAR= tarTARFLAGS= --no-recursionMAKEDEPPROG= gccLIBDIR=lib...$make depend$make$make installhttp://blog.csdn.net/zy799894671/article/details/22289039其他安装只指定安装路径，没有其他选项$sudo ./configure --prefix=/usr/local/development/nginx-1.8.1$sudo make$sudo make install加入 openssl 的编译：$./configure --prefix=/usr/local/development/nginx-1.8.1 --with-openssl=/home/miracle/myinstalled/openssl-1.0.2g --with-http_ssl_module$sudo make这里做 sudo make 的时候会自动编译ssl，如果手动编译ssl的话，那么大致如下：$sudo ./config --prefix=/usr/local/development/openssl-1.0.2g$sudo make depend$sudo make$sudo make install参考：http://www.cnblogs.com/skynet/p/4146083.html卸载只需要将 /usr/local/develop/nginx-1.8.1 删除即可。配置State "INBOX"      from              [2016-03-29 二 18:37]配置文件在 /usr/local/development/nginx-1.8.1/conf 下。启动直接运行 ./nginx修改配置后 ./nginx -s reload更多内容 ./nginx -h文档http://nginx.org/en/docs/Miscopenssl$sudo ./config --prefix=/usr/local/development/openssl-1.0.2g$sudo make depend$sudo make install8.8.2.3 安装php5.4这一步要放在安装完apache之后。$ sudo add-apt-repository ppa:ondrej/php5$ sudo apt-get update$ sudo apt-get install php5-cli php5-fpm php-pear php5-mysql libcurl4-openssl-dev#$ sudo pecl install pecl_http  # Update /etc/php5/fpm/php.ini and /etc/php5/cli/php.ini with http.so$ php -v8.8.2.4 源码安装phpopensslhttp://www.openssl.org/source/openssl-1.0.2g.tar.gz./config &#x2013;prefix=/usr/local/develop/openssl-1.0.2gsudo make dependsudo make sudo make installdepend librarysudo apt-get install libxml2sudo apt-get install libxml2-devsudo apt-get install libxml2-utilssudo apt-get install libcurl3sudo apt-get install libcurlsudo apt-get install libcurl4-gnutls-devphphttp://php.net/downloads.php./configure &#x2013;prefix=/usr/local/develop/php-5.6.19 &#x2013;with-config-file-path=/usr/local/develop/php-5.6.19/etc &#x2013;enable-fpm &#x2013;with-fpm-user=www-data &#x2013;with-fpm-group=www-data &#x2013;with-mysql=mysqlnd &#x2013;with-mysqli=mysqlnd &#x2013;with-pdo-mysql=mysqlnd &#x2013;with-iconv-dir &#x2013;with-freetype-dir &#x2013;with-jpeg-dir &#x2013;with-png-dir &#x2013;with-zlib &#x2013;with-libxml-dir=/usr &#x2013;enable-xml &#x2013;disable-rpath &#x2013;enable-magic-quotes &#x2013;enable-safe-mode &#x2013;enable-bcmath &#x2013;enable-shmop &#x2013;enable-sysvsem &#x2013;enable-inline-optimization &#x2013;with-curl &#x2013;with-curlwrappers &#x2013;enable-mbregex &#x2013;enable-mbstring &#x2013;with-mcrypt &#x2013;enable-ftp &#x2013;with-gd &#x2013;enable-gd-native-ttf &#x2013;with-openssl=/usr/local/develop/openssl-1.0.2g &#x2013;with-mhash &#x2013;enable-pcntl &#x2013;enable-sockets &#x2013;with-xmlrpc &#x2013;enable-zip &#x2013;enable-soap &#x2013;without-pear &#x2013;with-gettext &#x2013;disable-fileinfosudo makesudo make install8.8.3 referownCloud on OpenWrtubuntu 12.04 PHP5.4安装Ubuntu 12.04 下安装Apache 2.4.2Ubuntu10.04下编译安装apache-2.4.2版本8.9 CANCEL owncloud升级State "CANCEL"     from "WAIT/FORWARD" [2016-08-08 一 17:34]  Owncloud不稳定，数据虽然不会丢失，但是有时也很麻烦，已经不采用，此处仅供参考。State "WAIT/FORWARD" from "NEXT"       [2016-08-08 一 17:29]  wait for try.State "NEXT"       from              [2016-08-08 一 17:29]下载,注意将 https:// 改成 http://$wget -c http://download.owncloud.org/community/owncloud-9.0.2.tar.bz2停用所有第三方app.rsync --inplace -rtv owncloud_latest/owncloud/ owncloud/php -c userdisk/opt/usr/local/develop/etc occ maintenance:mimetype:update-dbphp -c userdisk/opt/usr/local/develop/etc occ maintenance:mimetype:update-jsphp -c userdisk/opt/usr/local/develop/etc occ upgrade参考:https://teddysun.com/211.htmlhttps://www.librehat.com/the-owncloud-upgrade-prolonged-stagnation-maintance-solution/8.10 CANCEL owncloud issueState "CANCEL"     from "NEXT"       [2016-08-08 一 17:34]  Owncloud不稳定，数据虽然不会丢失，但是有时也很麻烦，已经不采用，此处仅供参考。State "NEXT"       from "INBOX"      [2016-08-08 一 17:29]Capture Time:[2016-04-28 四 13:46]同步总是发生错误,其中之一是文件大小过大.无法上传大文件的错误:上传大文件的错误:Request Entity Too Largehttps://forum.owncloud.org/viewtopic.php?f=17&amp;t=7733无法上传文件的错误:上传文件出现类似如下错误:An exception occurred while executing 'INSERT INTO `oc_filecache` (`mimepart`,`mimetype`,`mtime`,`size`,`etag`,`storage_mtime`,`permissions`,`parent`,`path_hash`,`path`,`name`,`storage`) SELECT ?,?,?,?,?,?,?,?,?,?,?,? FROM `oc_filecache` WHERE `storage` = ? AND `path_hash` = ? HAVING COUNT(*) = 0' with params ["8", "18", 1461910752, 1250, "d73b2a5f54292c00fbe81872c61e9381", 1461910752, 27, "19", "04cf4abd8d26a455196d8cf88cab5fe0", "files\/Documents\/\u6587\u4ef6\u7ba1\u7406.md", "\u6587\u4ef6\u7ba1\u7406.md", "3", "3", "04cf4abd8d26a455196d8cf88cab5fe0"]: SQLSTATE[23000]: Integrity constraint violation: 1062 Duplicate entry '17101' for key 'PRIMARY'网上说是因为某些用户垃圾箱文件太多导致,清空垃圾箱即可,最好定时清空垃圾箱.?貌似还是不行? http://github.com/owncloud/core/issues/12591i've tracked the files down in this message, and it belongs to a user who has about 6500 files in his trashbin.Retention was at 30 days, I've lowered it to 7, to see if that helps, but it deletes only 1 file every 10 seconds or so, so that will take weeks...I had to restart the mysql server twice now to prevent bigger problems.https://github.com/owncloud/core/issues/178878.11 DONE 如何小米路由器上使用 git 版本控制系统?State "DONE"       from "WAIT/FORWARD" [2016-08-09 二 15:33]State "WAIT/FORWARD" from "INBOX"      [2016-07-26 二 17:05]  wait for refile.State "INBOX"      from              [2016-06-12 日 16:59]参考：小米路由器上使用 git 版本控制系统8.12 MAYBE/FUTURE 交叉编译mysql-5.7.11State "MAYBE/FUTURE" from "INBOX"      [2016-08-08 一 17:34]State "INBOX"      from              [2016-06-12 日 16:59]新版本的 mysql 不是用 GNU Auto tools 生成 Makefile 而是使用 CMake, 所以编译方法有所不同。8.12.1 try cmake$sudo apt-get install cmake$cd mysql-5.7.11$vim xx$cmake -DCMAKE_INSTALL_PREFIX=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop -DMYSQL_UNIX_ADDR=/var/run/mysql.sock -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_EXTRA_CHARSETS=utf8,gbk -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DENABLED_LOCAL_INFILE=1 -DMYSQL_DATADIR=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/data -DSTACK_DIRECTION=1 -DCURSES_LIBRARY=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib/libncurses.a -DCURSES_INCLUDE_PATH=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include -DWITH_MYISAM_STORAGE_ENGINE=1 -DDOWNLOAD_BOOST=1 -DWITH_BOOST=../boost.arm参考:http://www.th7.cn/db/mysql/201603/178674.shtmlhttp://dev.mysql.com/doc/internals/en/cmake.htmlhttp://www.cmake.org/Wiki/CMake_Cross_Compilinghttp://blog.chinaunix.net/uid-29570002-id-5112786.htmlPC版本的编译:mysql-5.7.11.pc$ cmake -DDOWNLOAD_BOOST=1 -DWITH_BOOST=../boost$cmake . -DWITH_BOOST=../boost/boost_1_59_0$makearm版本的编译:8.12.1.1 DONE 自带文档State "DONE"       from              [2016-08-17 三 12:04]INSTALL-SOURCETo list the configuration options, use one of the followingcommands:shell&gt; cmake . -L   # overviewshell&gt; cmake . -LH  # overview with help textshell&gt; cmake . -LAH # all params with help textshell&gt; ccmake .     # interactive display8.12.1.2 &lt;2016-08-15 一 16:29&gt;  how to manage cross compile?$sudo apt-get install cmake$cd usr/local/develop/include$ln -s ncurses/ncurses.h .$ln -s ncurses/curses.h .$cd mysql-5.7.11$vim Toolchain_xiaomi.cmake# this one is importantSET(CMAKE_SYSTEM_NAME Linux)#this one not so muchSET(CMAKE_SYSTEM_VERSION 1)# specify the cross compilerSET(CMAKE_C_COMPILER   /home/miracle/work/1_inbox/xiaomirouter/test/sdk_package/toolchain/bin/arm-xiaomi-linux-uclibcgnueabi-gcc)SET(CMAKE_CXX_COMPILER /home/miracle/work/1_inbox/xiaomirouter/test/sdk_package/toolchain/bin/arm-xiaomi-linux-uclibcgnueabi-g++)# where is the target environment SET(CMAKE_FIND_ROOT_PATH  /home/miracle/work/1_inbox/xiaomirouter/test/sdk_package/lib)# search for programs in the build host directoriesSET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)# for libraries and headers in the target directoriesSET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)#$cmake -DCMAKE_TOOLCHAIN_FILE=`pwd`/Toolchain_xiaomi.cmake -DCMAKE_INSTALL_PREFIX=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop -DMYSQL_UNIX_ADDR=/var/run/mysql.sock -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_EXTRA_CHARSETS=utf8,gbk -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DENABLED_LOCAL_INFILE=1 -DMYSQL_DATADIR=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/data -DSTACK_DIRECTION=1 -DCURSES_LIBRARY=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib/libncurses.a -DCURSES_INCLUDE_PATH=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include -DWITH_MYISAM_STORAGE_ENGINE=1 -DDOWNLOAD_BOOST=1 -DWITH_BOOST=../boost.arm .#$cmake -DCMAKE_INSTALL_PREFIX=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop -DWITH_DEBUG=0 -DDEFAULT_CHARSET=utf8 -DWITH_EXTRA_CHARSETS=all -DENABLED_LOCAL_INFILE=1 $cmake -DCMAKE_TOOLCHAIN_FILE=`pwd`/Toolchain_xiaomi.cmake -DCMAKE_INSTALL_PREFIX=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop -DMYSQL_UNIX_ADDR=/var/run/mysql.sock -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_EXTRA_CHARSETS=utf8,gbk -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DENABLED_LOCAL_INFILE=1 -DMYSQL_DATADIR=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/data -DSTACK_DIRECTION=1 -DCURSES_LIBRARY=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib/libncurses.a -DCURSES_INCLUDE_PATH=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_BOOST=`pwd`/../boost.arm .运行两次cmake?how to translate from auto tools?$./configure --prefix=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop --without-docs ??none??--without-man ??--without-debug --with-charset=utf8 --with-extra-charsets=gbk,gb2312,utf8,ascii --enable-local-infile --with-mysqld-user=root ???none???--host=arm-xiaomi-linux-uclibcgnueabi ???none???--with-named-curses-libs=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib/libncurses.a ???CC=arm-xiaomi-linux-uclibcgnueabi-gcc ???8.12.1.3 &lt;2016-08-17 三 12:03&gt;  how to manage boost error?in cmake/boost.cmake...  ## Did we get a path name to the directory of the .tar.gz or .zip file?  FIND_FILE(LOCAL_BOOST_ZIP            NAMES "${BOOST_PACKAGE_NAME}.tar.gz" "${BOOST_PACKAGE_NAME}.zip"            PATHS ${WITH_BOOST}            NO_DEFAULT_PATH           )  MESSAGE(STATUS "@@@@@@NAMES: ${BOOST_PACKAGE_NAME}.tar.gz")  MESSAGE(STATUS "@@@@@@PATHS(WITH_BOOST): ${WITH_BOOST}")  MESSAGE(STATUS "@@@@@@LOCAL_BOOST_ZIP: ${LOCAL_BOOST_ZIP}")  ## Did we get a path name to the directory of an unzipped version?  FIND_FILE(LOCAL_BOOST_DIR            NAMES "${BOOST_PACKAGE_NAME}"            PATHS ${WITH_BOOST}            NO_DEFAULT_PATH           )  MESSAGE(STATUS "@@@@@@NAMES: ${BOOST_PACKAGE_NAME}")  MESSAGE(STATUS "@@@@@@PATHS(WITH_BOOST): ${WITH_BOOST}")  MESSAGE(STATUS "@@@@@@LOCAL_BOOST_DIR: ${LOCAL_BOOST_DIR}")  ## Did we get a path name to an unzippped version?  FIND_PATH(LOCAL_BOOST_DIR            NAMES "boost/version.hpp"            PATHS ${WITH_BOOST}            NO_DEFAULT_PATH           )  MESSAGE(STATUS "@@@@@@NAMES: boost/version.hpp")  MESSAGE(STATUS "@@@@@@PATHS(WITH_BOOST): ${WITH_BOOST}")  MESSAGE(STATUS "@@@@@@LOCAL_BOOST_DIR: ${LOCAL_BOOST_DIR}")...output for cmakemiracle@miracle-Zhaoyang-E49:~/work/1_inbox/xiaomirouter/test/mysql-5.7.11$ cmake -DCMAKE_TOOLCHAIN_FILE=/home/miracle/work/1_inbox/xiaomirouter/test/mysql-5.7.11/Toolchain_xiaomi.cmake -DCMAKE_INSTALL_PREFIX=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop -DMYSQL_UNIX_ADDR=/var/run/mysql.sock -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_EXTRA_CHARSETS=utf8,gbk -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DENABLED_LOCAL_INFILE=1 -DMYSQL_DATADIR=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/data -DSTACK_DIRECTION=1 -DCURSES_LIBRARY=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib/libncurses.a -DCURSES_INCLUDE_PATH=/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/include -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_BOOST="/home/miracle/work/1_inbox/xiaomirouter/test/boost.arm" .-- Running cmake version 2.8.7-- Configuring with MAX_INDEXES = 64U-- SIZEOF_VOIDP 4-- MySQL 5.7.11-- Packaging as: mysql-5.7.11-Linux--- @@@@@@NAMES: boost_1_59_0.tar.gz-- @@@@@@PATHS(WITH_BOOST): /home/miracle/work/1_inbox/xiaomirouter/test/boost.arm-- @@@@@@LOCAL_BOOST_ZIP: LOCAL_BOOST_ZIP-NOTFOUND-- @@@@@@NAMES: boost_1_59_0-- @@@@@@PATHS(WITH_BOOST): /home/miracle/work/1_inbox/xiaomirouter/test/boost.arm-- @@@@@@LOCAL_BOOST_DIR: LOCAL_BOOST_DIR-NOTFOUND-- @@@@@@NAMES: boost/version.hpp-- @@@@@@PATHS(WITH_BOOST): /home/miracle/work/1_inbox/xiaomirouter/test/boost.arm-- @@@@@@LOCAL_BOOST_DIR: LOCAL_BOOST_DIR-NOTFOUND-- WITH_BOOST=/home/miracle/work/1_inbox/xiaomirouter/test/boost.arm-- BOOST_INCLUDE_DIR-- LOCAL_BOOST_DIR LOCAL_BOOST_DIR-NOTFOUND-- LOCAL_BOOST_ZIP LOCAL_BOOST_ZIP-NOTFOUND-- Could not find (the correct version of) boost.-- MySQL currently requires boost_1_59_0CMake Error at cmake/boost.cmake:81 (MESSAGE):  You can download it with -DDOWNLOAD_BOOST=1 -DWITH_BOOST=&lt;directory&gt;  This CMake script will look for boost in &lt;directory&gt;.  If it is not there,  it will download and unpack it (in that directory) for you.  If you are inside a firewall, you may need to use an http proxy:  export http_proxy=http://example.com:80Call Stack (most recent call first):cmake/boost.cmake:176 (COULD_NOT_FIND_BOOST)  CMakeLists.txt:443 (INCLUDE)-- Configuring incomplete, errors occurred!8.13 LATER 小米路由器搭建ftp服务State "LATER"      from "INBOX"      [2016-08-08 一 17:35]vsftp官方网址：https://security.appspot.com/vsftpd.htmlvsftpd.beasts.org8.13.1 交叉编译环境8.13.2 源代码下载：$wget https://security.appspot.com/downloads/vsftpd-3.0.3.tar.gz8.13.3 编译libcrypt8.13.4 修改Makefile/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/libCCCC = arm-xiaomi-linux-uclibcgnueabi-gccCFLAGSCFLAGS	=	-O2 -fPIE --param=ssp-buffer-size=4 \     -Wall -W -Wshadow -Werror -Wformat-security \     -D_FORTIFY_SOURCE=2 \     #-pedantic -WconversionLIBSLIBS	=	-L/home/miracle/work/1_inbox/xiaomirouter/test/usr/local/develop/lib -lcrypt8.13.5 编译8.13.6 开启防火墙config rule                                                   option name 'myftp'                                   option src 'wan'                                      option proto 'tcp'                                    option target 'ACCEPT'                                option name ''\''ftp wan accept tcp port 21'\'''             option dest_port '21'8.13.7 如何运行？查看代码后发现，是不是 vsftpd /userdisk/data/opt/usr/local/develop/etc/vsftpd.conf 参考：http://www.miui.com/thread-1843572-1-1.htmlhttp://www.cnblogs.com/JemBai/archive/2009/02/05/1384413.htmlhttp://www.cnblogs.com/hhuai/archive/2011/02/12/1952647.html8.13.8 8.14 MAYBE/FUTURE 交叉编译vimState "MAYBE/FUTURE" from "INBOX"      [2016-08-08 一 17:35]State "INBOX"      from              [2016-08-03 三 19:05]8.15 NEXT SeafileState "NEXT"       from "MAYBE/FUTURE" [2016-08-08 一 17:35]State "MAYBE/FUTURE" from "CANCEL"     [2016-07-29 五 12:05]State "CANCEL"     from              [2016-07-28 四 18:32]  虽然开源，但是从代码结构上来看，编译比较麻烦，取消。且对mysql的交叉编译环境暂时不待见。而且文件全都是加密过的，不能直接访问。额外的功能如搜索等，还需收费。8.15.1 DONE PC 上安装SeafileState "DONE"       from "NEXT"       [2016-07-26 二 15:35]State "NEXT"       from "INBOX"      [2016-07-26 二 15:35]Capture Time:[2016-07-25 一 19:01]下载：https://www.seafile.com/en/download/$wget -c /home/miracle/下载/seafile-server_5.1.4_x86-64.tar.gz$tar -xzvf seafile-server_5.1.4_x86-64.tar.gz$cd seafile-server_5.1.4_x86-64$sudo apt-get install python-mysqldb$./setup-seafile-mysql.sh...Press ENTER to continue-----------------------------------------------------------------[Enter]What is the name of the server? It will be displayed on the client.3 - 15 letters or digits[ server name ] my-seafile [Enter]What is the ip or domain of the server?For example: www.mycompany.com, 192.168.1.101[ This server's ip or domain ] 172.16.246.34 [Enter]Where do you want to put your seafile data?Please use a volume with enough free space[ default "/media/sda6/cloud/seafile/seafile-data" ] [Enter]Which port do you want to use for the seafile fileserver?[ default "8082" ] [Enter]-------------------------------------------------------Please choose a way to initialize seafile databases:-------------------------------------------------------[1] Create new ccnet/seafile/seahub databases[2] Use existing ccnet/seafile/seahub databases[ 1 or 2 ] 1[Enter]What is the host of mysql server?[ default "localhost" ] [Enter]What is the port of mysql server?[ default "3306" ] [Enter]What is the password of the mysql root user?[ root password ] xxxxxx[Enter]Enter the name for mysql user of seafile. It would be created if not exists.[ default "root" ] myseafile[Enter]Enter the password for mysql user "myseafile":[ password for myseafile ] xxxxxx[Enter]Enter the database name for ccnet-server:[ default "ccnet-db" ] [Enter]Enter the database name for seafile-server:[ default "seafile-db" ] [Enter]Enter the database name for seahub:[ default "seahub-db" ] [Enter]---------------------------------This is your configuration---------------------------------    server name:            my-seafile    server ip/domain:       172.16.246.34    seafile data dir:       /media/sda6/cloud/seafile/seafile-data    fileserver port:        8082    database:               create new    ccnet database:         ccnet-db    seafile database:       seafile-db    seahub database:        seahub-db    database user:          myseafile---------------------------------Press ENTER to continue, or Ctrl-C to abort---------------------------------[Enter]....-----------------------------------------------------------------Your seafile server configuration has been finished successfully.-----------------------------------------------------------------run seafile server:     ./seafile.sh { start | stop | restart }run seahub  server:     ./seahub.sh  { start &lt;port&gt; | stop | restart &lt;port&gt; }-----------------------------------------------------------------If you are behind a firewall, remember to allow input/output of these tcp ports:-----------------------------------------------------------------port of seafile fileserver:   8082port of seahub:               8000When problems occur, Refer to        https://github.com/haiwen/seafile/wikifor information.$./seafile.sh start$./seahub.sh start......What is the email for the admin account?[ admin email ] quiet_heart000@126.comWhat is the password for the admin account?[ admin password ] Enter the password again:[ admin password again ] ......访问之时，浏览器输入： 127.0.0.1:8000文档：http://manual.seafile.com/8.15.2 编译Seafile8.15.2.1 编译libsearpc$./autogen.sh$./configure --prefix=`pwd`/../prefixchecking for JANSSON... noconfigure: error: Package requirements (jansson &gt;= 2.2.1) were not met:No package 'jansson' found$wget -c http://www.digip.org/jansson/releases/jansson-2.7.tar.gz$./configure --prefix=`pwd`/../prefix$make$make install$./configure --prefix=`pwd`/../prefix LDFLAGS=-L`pwd`/../prefix/lib JANSSON_CFLAGS=-I`pwd`/../prefix/include JANSSON_LIBS="-L`pwd`/../prefix/lib -ljansson"gcc -DHAVE_CONFIG_H -I. -I..    -I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include -I../lib -g -O2 -MT searpc-demo-server.o -MD -MP -MF .deps/searpc-demo-server.Tpo -c -o searpc-demo-server.o searpc-demo-server.cIn file included from ../lib/searpc.h:7:0,                 from searpc-demo-server.c:10:../lib/searpc-server.h:6:21: 致命错误： jansson.h：没有那个文件或目录编译中断。添加 JANSSON_CFLAGS$vim demo/Makefile70 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \                                                                          71     $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) $(JANSSON_CFLAGS)$./configure --prefix=`pwd`/../prefix LDFLAGS=-L`pwd`/../prefix/lib JANSSON_CFLAGS=-I`pwd`/../prefix/include JANSSON_LIBS="-L`pwd`/../prefix/lib -ljansson"$make$make install8.15.2.2 编译ccnet下载依赖编译依赖编译 ccnet$cd ccnet-5.1.4-server$./autogen.sh./configure --prefix=`pwd`/../prefix --enable-serverchecking for uuid_generate in -luuid... noconfigure: error: *** Unable to find uuid libraryhttps://sourceforge.net/projects/libuuid/files/libuuid-1.0.3.tar.gz/download$cd libuuid-1.0.3/$./configure --prefix=`pwd`/../prefix$make$make install$cd ccnet-5.1.4-server$./configure --prefix=`pwd`/../prefix --enable-server LDFLAGS=-L`pwd`/../prefix/libfound library pthreadchecking for sqlite3_open in -lsqlite3... noconfigure: error: *** Unable to find sqlite3 library$wget -c http://www.sqlite.org/2016/sqlite-amalgamation-3140100.zip$cd sqlite-autoconf-3140100$./configure --prefix=`pwd`/../prefix$make$make install$cd ccnet-5.1.4-server$export PKG_CONFIG_PATH=`pwd`/../prefix/lib/pkgconfig$./configure --prefix=`pwd`/../prefix --enable-server LDFLAGS=-L`pwd`/../prefix/libconfigure: error: Package requirements (libevent &gt;= 2.0) were not met:No package 'libevent' found$wget -c https://github.com/libevent/libevent/releases/download/release-2.0.22-stable/libevent-2.0.22-stable.tar.gz$./configure --prefix=`pwd`/../prefix LDFLAGS=-L`pwd`/../prefix/lib$make$make install$./configure --prefix=`pwd`/../prefix --enable-server LDFLAGS=-L`pwd`/../prefix/lib...checking for ZDB... noconfigure: error: Package requirements (zdb &gt;= 2.10) were not met:No package 'zdb' found...$wget -c http://www.tildeslash.com/libzdb/dist/libzdb-3.1.tar.gz$./configure --prefix=`pwd`/../prefix --with-mysql LDFLAGS=-L`pwd`/../prefix/lib CFLAGS=-I`pwd`/../prefix/include$make$make install$./configure --prefix=`pwd`/../prefix --enable-server LDFLAGS=-L`pwd`/../prefix/lib$make...valac -C --pkg posix ccnetobj.vala/bin/bash: valac: 未找到命令make[2]: *** [ccnetobj.c] 错误 127...$sudo apt-get intall valac$make ...../common/rpc-service.c:40:30: 致命错误： searpc-signature.h：没有那个文件或目录编译中断。make[3]: *** [rpc-service.o] 错误 1make[3]:正在离开目录 `/home/miracle/下载/seafile/build/ccnet-5.1.4-server/net/daemon'make[2]: *** [all-recursive] 错误 1make[2]:正在离开目录 `/home/miracle/下载/seafile/build/ccnet-5.1.4-server/net'make[1]: *** [all-recursive] 错误 1make[1]:正在离开目录 `/home/miracle/下载/seafile/build/ccnet-5.1.4-server'make: *** [all] 错误 2...8.15.3 交叉编译Seafile8.15.4 参考资料官网：https://github.com/haiwen/seafile编译：http://manual.seafile.com/build_seafile/linux.html8.16 WAIT/FORWARD SparkleShareState "WAIT/FORWARD" from "CANCEL"     [2016-08-03 三 09:15]  is it available as a git client?考察是否能将其仅做为git户端使用，这样就不需要服务端有运行的了。服务端只需要有git即可。State "CANCEL"     from "NEXT"       [2016-07-28 四 18:30]  取消，因为依赖 git-lfs,而 git-lfs 是用 go 写的，并且可能依赖外部服务。State "NEXT"       from              [2016-07-27 三 09:29]这是一个基于git的类dropbox网盘。还需要基于图形环境。8.16.1 CANCEL PC上的编译安装State "CANCEL"     from "MAYBE/FUTURE" [2016-08-03 三 11:56]  没有必要在PC上源码安装，只需在使用的机器上有一个sparkleshare客户端即可，因为服务端就是git服务器。没有必要考虑交叉编译。State "MAYBE/FUTURE" from              [2016-08-03 三 09:38]8.16.1.1 依赖安装curl参考： 安装php所需依赖安装git参考： 小米路由器 git 源码交叉编译CANCEL 安装git-lfsState "CANCEL"     from "NEXT"       [2016-07-28 四 18:32]  取消，考虑git-annex.State "NEXT"       from              [2016-07-27 三 10:45]官网：https://github.com/github/git-lfs/releases下载：$wget -c https://github.com/github/git-lfs/archive/v1.2.0.tar.gzlibtool$sudo apt-get install libtoolmono8.16.1.2 下载：$wget -c https://github.com/hbons/SparkleShare/archive/1.5.0.tar.gz$./autogen.sh8.16.2 Ubuntu上直接安装8.16.2.1 安装因为服务端就是git服务器，只需在使用的机器上有一个sparkleshare客户端即可，没有必要在PC上源码安装，也没有必要考虑交叉编译。$sudo add-apt-repository ppa:warp10/sparkleshare$sudo apt-get update$sudo apt-get install sparkleshare libwebkit1.1-cil git-core可能还需要安装python-nautilus，防止某些系统打开之后软件崩溃：$sudo apt-get install python-nautilus8.16.2.2 运行$sparkleshare start8.16.2.3 添加已托管的git项目（位于ssh主机上）选择已有的一个git服务器下的git目录添加, 经常会出现无法同步文件的情况。如果机器是ssh登录的话，通过终端的log可看到，sparkle会自动登录远端服务器进行 git clone, 但是ssh密码却没有交互输入的地方。解决方法：需要将key文件上传到服务器中，实现免密ssh登录。sparkleshare目录中有key文件，.ssh中也有。上传用类似这个命令： ssh-copy-id quietheart@112.74.19.388.16.2.4 服务端的配置Sparkle shared其实就是一个 git 图形客户端。自动定期同步其管辖目录下的git文件。服务端的配置非常简单，只需要有一个git仓库即可。关于git的配置这里不做描述，需要的可参考git的相关使用文档： https://git-scm.com/book/zh/v2常见的用于sparkle的比较重要的git配置如下：允许push服务端git仓库需要配置成允许push, 修改配置文件修改其 receive.denyCurrentBranch 的值为 ignore ，或者在具有工作目录的仓库中运行 git config receive.denyCurrentBranch ignore .使用裸库替代有工作目录的git库如果服务端git仓库中包含一个工作目录，那么客户端的Sparkleshare 完成 push之后，服务端会看不到变化的文件。原因是服务端如果在被push的分支上，就无法在实时更新其工作目录结构，需要在服务端手动运行 git reset --hard 才行。最好的方法是，将服务端的git库设为裸库（或者镜像？）。8.16.3 参考网址：官方网址：https://www.sparkleshare.org/代码管理：https://www.github.com/hbons/SparkleShare源代码安装： https://github.com/hbons/SparkleShare/blob/master/SparkleShare/Linux/README.mdWiki： https://www.github.com/hbons/SparkleShare/wikigit-annex： http://git-annex.branchable.com/walkthrough/git-annex:  http://git-annex.branchable.com/8.17 MAYBE/FUTURE dvcs-autosyncState "MAYBE/FUTURE" from              [2016-07-28 四 19:53]8.18 CANCEL git annexState "CANCEL"     from "NEXT"       [2016-07-29 五 11:57]  语言太奇葩：Haskell.State "NEXT"       from "CANCEL"     [2016-07-29 五 11:36]State "CANCEL"     from "NEXT"       [2016-07-28 四 19:39]  使用麻烦，安装也不一定好弄State "NEXT"       from              [2016-07-28 四 18:32]开发语言比较奇葩git-annex is Free Software, written in Haskell. You can contribute!8.18.1 源代码git clone https://github.com/joeyh/git-annex.git8.18.2 参考资料官方网站：http://git-annex.branchable.com/学习的起点：https://writequit.org/articles/getting-started-with-git-annex.html使用举例：http://git-annex.branchable.com/walkthrough/#index10h2下载应用：https://downloads.kitenet.net/git-annex/android/current/源代码：https://github.com/joeyh/git-annex其他：http://hackage.haskell.org/package/git-annex8.19 MAYBE/FUTURE git lfsState "MAYBE/FUTURE" from "NEXT"       [2016-08-03 三 19:02]State "NEXT"       from              [2016-07-29 五 12:05]服务器？go语言？https://git-lfs.github.com/      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-04-07 四 18:52]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-04-07]<a href="/categories/study/linux/misc/xiaomi_router_tips.html"> 小米路由器DIY </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '关于linux中的时间和时区'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 基本概念1.1. 系统时钟和硬件时钟1.2. 硬件时间和系统时间的同步1.3. 时间和时区2. 常用命令3. 配置文件与环境变量4. 库函数5. 应用举例5.1. 在单一进程中修改时区的方法5.2. 时间同步校准6. 其它6.1. 参考这里主要讲述linux中时间和时区相关的原理。包括设置方法、配置、环境变量、以及库函数，及应用举例。1 基本概念1.1 系统时钟和硬件时钟Linux时钟分为系统时钟 （System Clock）和硬件（Real Time Clock，简称RTC）时钟。系统时钟是指当前Linux Kernel中的时钟，而硬件时钟则是主板上由电池供电的时钟，这个硬件时钟可以在BIOS中进行设置。当Linux启动时，硬件时钟会去读取系统时钟的设置，然后系统时钟就会独立于硬件运作。1.2 硬件时间和系统时间的同步重新启动系统，硬件时间会读取系统时间，实现同步，但是在不重新启动的时候，需要用hwclock或clock命令实现同步。1.3 时间和时区UTC：协调世界时，又称世界标准时间，简称UTC，从英文国际时间/法文协调时间”Universal Time/Temps Cordonné”而来。时区：反映与UTC的时差问题，中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与UTC的时差均为+8，也就是UTC+8。各个地区的时间都是UTC结合地区的时区信息得到的。整个地球分为二十四时区，每个时区都有自己的本地时间，他们的关系如下：UTC时间 与 GMT时间我们可以认为格林威治时间就是时间协调时间（GMT = UTC），格林威治时间和UTC时间都用秒数来计算的。UTC时间与本地时间UTC + 时区差 = 本地时间时区差东为正，西为负。UTC与Unix时间戳在计算机中看到的UTC时间都是从（1970年01月01日 0:00:00)开始计算秒数的。所看到的UTC时间那就是从1970年这个时间点起到具体时间共有多少秒。 这个秒数就是Unix时间戳。例如： 本地（北京）在东八区， 东八区时区差记为 +0800，则：本地（北京）时间 = UTC + (+0800)所以，不同地区， 其本地时间各不相同。再如， 对于中国和格林，这两个地区的时区不同，得到的时间也不同。分别如下：CST：中国标准时间（China Standard Time），与UTC时差为8,这个解释可能是针对RedHat Linux。GMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。2 常用命令下面给出的是常见的命令，不同系统可能有不同的命令。有关系统时间的命令: data,ntpupdate有关硬件时钟的命令: hwclock/clock时区相关命令: tzselect3 配置文件与环境变量时区信息一般首先从环境变量中去读，如果没有再从 /etc/TZ 等配置文件中去读。所涉及的配置文件和环境变量可能会根据系统有所不同，一般情况如下：时区的配置文件: etc/localtime (可以是/usr/share/zoneinfo&#x2026;的软链接), /etc/TZ, /etc/sysconfig/clock环境变量： TZ, 使用举例如下:bash中   export TZ="Europe/Moscow"        date -u -s "2011-10-29 21:55:00"cshell中 setenv TZ Europe/Moscow4 库函数这些为有关时间时区的常见系统库函数。time_t time(time_t *t)返回 time_t 类型，值为UTC时间从0时0分0秒算起到现在所经过的秒数。struct tm*gmtime(const time_t*timep)根据传入的 time_t 返回类型为 struct tm 结构，包含时、分、秒、日、周、月、年、日光节约时间标记等信息的时间表示，该时间为GMT时间，未经时区转换。struct tm *localtime(const time_t * timep)根据传入的 time_t 返回类型为 struct tm 结构，包含时、分、秒、日、周、月、年、日光节约时间标记等信息的时间表示，该时间为当地时间，已经时区转换。time_t mktime(struct tm * timeptr)将 struct tm 类型的时间转换为  time_t 类型，值为UTC时间从0时0分0秒算起到现在所经过的秒数。char *ctime(const time_t *timep)将传入的 time_t 类型时间转化为现实世界中的字符串表示形式，例如： Fri, 16 Oct 2015 23:12:18 +0800char * asctime(const struct tm * timeptr)将传入的 struct tm 结构类型时间转化为现实世界中的字符串表示形式，例如： Fri Oct 16 15:15:54 2015int gettimeofday ( struct timeval * tv , struct timezone * tz )返回当前时间信息， struct timeval *tv 存放秒和微秒信息， struct timezone *tz 存放时区信息。int settimeofday ( const struct timeval *tv,const struct timezone *tz)根据传入的时间信息 struct timeval *tv, 和时区信息 struct timezone *tz 设置当前时间。总之，time_t 是用秒数表示时间一般在系统时间戳中使用（一般就是UTC时间）；struct tm 使用结构体表示时间，在程序中使用（不同时区可能会有不同值）；而现实中使用字符串来表示时间，字符串格式可以定制。时区信息一般首先从环境变量中去读，如果没有再从 /etc/TZ 等配置文件中去读。5 应用举例5.1 在单一进程中修改时区的方法setenv("TZ","Europe/Moscow",1);tzset();5.2 时间同步校准假设安装完系统发现时间与现实时间相差8小时。一般是如下原因：安装系统时选择的时区是上海，而系统启动后把bios时间认为是utc时间，再根据上海所处时区，将时间+8小时给我们。这个时候的bios的时间和软件的时间便出现不一致的情况。一个代表 utc 一个代表我们设置的cst（+8时区）。可做如下调整（例如系统为center os 6）：修改配置文件，将默认环境变量更正为上海所在时区，不使用UTC时间$ vi /etc/sysconfig/clock  ZONE="Asia/Shanghai"UTC=false                          ARC=false这个文件影响系统启动后默认的时间相关环境变量值，这里主要是 UTC=false 这个选项，设置硬件时钟不是跟utc一致。将linux的时区设置为 上海$ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime加载配置时间环境变量的文件之前，需要指定好该文件的软链接位置，通过这个可在各个时区配置文件下通用的 /etc/localtime 软链接，可使系统能够找到刚刚设置的时区配置文件，并设置好相应的环境变量。对准时间ntp$ntpdate 192.43.244.18系统启动之后，系统时间通过 ntpdate 工具在网络上获取到。设置硬件时间和软件时间的一致并校准/sbin/hwclock -systohc通过这个命令，将系统时间同步至硬件始终上，这样我们的linux软件和计算机硬件都是cst时间了－－并且是我们设置的上海时区。6 其它6.1 参考man 3 tzset解决嵌入式Linux中的时区问题linux调整系统时间和时区的方法Linux下设置时区（通过shell设置和程序中设置）及程序中设置环境变量linux时区时间问题ntpLinux时间时区详解与常用时间函数linux修改系统时间和linux查看时区、修改时区的方法      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-02-18 四 15:45]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-02-18]<a href="/categories/study/linux/misc/linux_time_timezone.html"> 关于linux中的时间和时区 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '网文收集201602'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 网文列表1.1. &lt;2016-02-16 二 17:34&gt;  pkg-config的用法1.2. &lt;2016-02-17 三 15:00&gt;  Scientific Toolworks Understand for linux 的下载1.3. &lt;2016-03-02 三 20:00&gt;  Git Submodule 使用完整教程1.4. &lt;2016-05-24 二 14:11&gt;  Linux内存泄漏查询方法proc/status解释1.5. &lt;2016-08-12 五 16:11&gt;  CMake 入门实战1.6. &lt;2016-09-12 一 14:41&gt;  Android Native/Tombstone Crash Log 详细分析2. 其它2.1. maff存档格式2.2. 分类管理这里列出任何时候任何内容下收集的感觉有用的网文。1 网文列表1.1 &lt;2016-02-16 二 17:34&gt;  pkg-config的用法站内链接：pkg-config_usage.html存档：pkg-config_usage.html.maff1.2 &lt;2016-02-17 三 15:00&gt;  Scientific Toolworks Understand for linux 的下载站内链接: scitools_understand_for_linux.html存档: scitools_understand_for_linux.html.maff1.3 &lt;2016-03-02 三 20:00&gt;  Git Submodule 使用完整教程站内链接：Git_Submodule_tutor-HenryYan.html 存档：Git_Submodule_tutor-HenryYan.html.maff1.4 &lt;2016-05-24 二 14:11&gt;  Linux内存泄漏查询方法proc/status解释站内链接：Linux_memory_leak_proc_status存档：Linux_memory_leak_proc_status.shtml.maff注意：可使用 $ ulimit -s 设定栈限制。1.5 &lt;2016-08-12 五 16:11&gt;  CMake 入门实战站内链接：CMake_usage存档：CMake_usage.maff1.6 &lt;2016-09-12 一 14:41&gt;  Android Native/Tombstone Crash Log 详细分析站内链接：Android_Tombstone_Crash Log_analyzing存档：Android_Tombstone_Crash Log_analyzing.html.maff2 其它2.1 maff存档格式为基于zip格式的maff文档，maff类似微软的mht都是将当前网页保存成单一离线文件的格式.firefox下的MAFF Archive Format插件可以实现保存网页为maff，并且能直接查看对应文件格式.另外maff文件格式实质是zip压缩文件,可以将文件解压之后用普通浏览器打开其中的内容(与直接打开maff格式的区别是普通方式打开的网页缺少了源网址来源的信息提示),亦可将解压后的文件夹重新用zip压缩,重命名为xxx.maff用firefox的MAFF Archive Format插件浏览.当前存放外部引用网页的方式,可以采取maff方式保存(这要求我们只有使用firefox浏览网页),为便于随时浏览,可将保存的文件用zip解压. 需要时再用zip压缩\重命名为maff再打开.2.2 分类管理每个月或几个月整理一次，或者追加文章，将原来的文章整理至特定分类。      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-02-11 四 15:35]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-02-16]<a href="/categories/others/net_articles201602.html"> 网文收集201602 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '模板文件'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 介绍1.1. 子标题11.2. 子标题2：2. 内容13. 内容24. 其它5. WAIT/FORWARD FAQ [0/4]([0%])5.1. NEXT 问题1？5.2. NEXT 问题2？本文主要描述orgmode导出到jekyll文件的文章的常见格式。1 介绍文章可以以二级标题开始,便于将来父级追加,这一点不知道是否必要.1.1 子标题1子标题内容列表项目1。列表项目2。1.2 子标题2：子标题2的内容2 内容1规整好的内容13 内容2规整好的内容24 其它介绍没有明确规整的内容.5 WAIT/FORWARD FAQ [0/4]([0%])描述该文章中遗留的问题,有待将来解决.5.1 NEXT 问题1？State "NEXT"       from              [2016-02-01 一 15:39]5.2 NEXT 问题2？State "NEXT"       from "NEXT"       [2016-02-01 一 15:40]      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-02-11 四 15:35]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-02-11]<a href="/categories/others/template_file.html"> 模板文件 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '实用工具'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. WAIT/FORWARD FAQ [0/0]([100%])1.1. LATER encfs1.2. MAYBE/FUTURE ccache 增加编译速度1 WAIT/FORWARD FAQ [0/0]([100%])1.1 LATER encfsState "LATER"      from "INBOX"      [2016-02-09 二 10:05]Capture Time:[2016-01-25 一 18:08]加密文件系统，可以对特定的目录和目录中的文件进行加密。实现方式是通过encfs进行。安装sudo apt-get install encfs挂载加密目录encfs ~/crypt_dir ~/normal_dir卸载加密目录fusermount -u ~/normal_dir修改密码encfsctl参考：https://linux.cn/article-2234-1.html1.2 MAYBE/FUTURE ccache 增加编译速度State "MAYBE/FUTURE" from "INBOX"      [2016-02-09 二 10:15]Capture Time:[2016-01-26 二 11:43]      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-02-09 二 10:08]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-02-09]<a href="/categories/study/kits/useful_tools.html"> 实用工具 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Linux杂乱记录'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. Miscellaneous1.1. &#x2014;&#x2014; [2015-10-28 三 11:32]  Cscope 没有文件的错误------1.2. &#x2014;&#x2014; [2016-01-31 日 11:12]  top再H即可list by thread------1.3. &#x2014;&#x2014; [2016-01-31 日 14:42]  Linux进程状态机与ps关联------1 Miscellaneous1.1 &#x2014;&#x2014; [2015-10-28 三 11:32]  Cscope 没有文件的错误------From:/home/miracle/mydata/orgmode/gtd/next.org参考：http://www.21qa.net/questions/2699/2699Error detected while processing ~/.vimrc:cs_read_prompt EOF: No such file or directoryE609: Cscope error: cscope: cannot read trailer offset from file cscope.outc使用cscope查看程序代码遇到一个问题，就是在配置vim中默认打开cscope.out文件出现如上错误，经google后发现的问题是代码所放的文件夹命名中存在了“空格 ”，解决办法就是将文件夹重命名，用‘-’或英文等符号替代空格。1.2 &#x2014;&#x2014; [2016-01-31 日 11:12]  top再H即可list by thread------From:/home/miracle/mydata/orgmode/gtd/_next.org1.3 &#x2014;&#x2014; [2016-01-31 日 14:42]  Linux进程状态机与ps关联------From:/home/miracle/mydata/orgmode/gtd/_next.org参考：http://www.cnblogs.com/zhaoyl/archive/2012/09/04/2671156.html进程是通过fork系列的系统调用（fork、clone、vfork）来创建的，内核（或内核模块）也可以通过kernel_thread函数创建内核进程。这些创建子进程的函数本质上都完成了相同的功能——将调用进程复制一份，得到子进程。（可以通过选项参数来决定各种资源是共享、还是私有。）那么既然调用进程处于TASK_RUNNING状态（否则，它若不是正在运行，又怎么进行调用？），则子进程默认也处于TASK_RUNNING状态。另外，在系统调用clone和内核函数kernel_thread也接受CLONE_STOPPED选项，从而将子进程的初始状态置为 TASK_STOPPED。　　进程创建后，状态可能发生一系列的变化，直到进程退出。而尽管进程状态有好几种，但是进程状态的变迁却只有两个方向——从TASK_RUNNING状态变为非TASK_RUNNING状态、或者从非TASK_RUNNING状态变为TASK_RUNNING状态。总之，TASK_RUNNING是必经之路，不可能两个非RUN状态直接转换。也就是说，如果给一个TASK_INTERRUPTIBLE状态的进程发送SIGKILL信号，这个进程将先被唤醒（进入TASK_RUNNING状态），然后再响应SIGKILL信号而退出（变为TASK_DEAD状态）。并不会从TASK_INTERRUPTIBLE状态直接退出。　　进程从非TASK_RUNNING状态变为TASK_RUNNING状态，是由别的进程（也可能是中断处理程序）执行唤醒操作来实现的。执行唤醒的进程设置被唤醒进程的状态为TASK_RUNNING，然后将其task_struct结构加入到某个CPU的可执行队列中。于是被唤醒的进程将有机会被调度执行。　　而进程从TASK_RUNNING状态变为非TASK_RUNNING状态，则有两种途径：　　1、响应信号而进入TASK_STOPED状态、或TASK_DEAD状态；　　2、执行系统调用主动进入TASK_INTERRUPTIBLE状态（如nanosleep系统调用）、或TASK_DEAD状态（如exit系统调用）；或由于执行系统调用需要的资源得不到满　　　　 足，而进入TASK_INTERRUPTIBLE状态或TASK_UNINTERRUPTIBLE状态（如select系统调用）。　　显然，这两种情况都只能发生在进程正在CPU上执行的情况下。通过ps命令我们能够查看到系统中存在的进程，以及它们的状态：R(TASK_RUNNING)，可执行状态。只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。只要可执行队列不为空，其对应的CPU就不能偷懒，就要执行其中某个进程。一般称此时的CPU“忙碌”。对应的，CPU“空闲”就是指其对应的可执行队列为空，以致于CPU无事可做。有人问，为什么死循环程序会导致CPU占用高呢？因为死循环程序基本上总是处于TASK_RUNNING状态（进程处于可执行队列中）。除非一些非常极端情况（比如系统内存严重紧缺，导致进程的某些需要使用的页面被换出，并且在页面需要换入时又无法分配到内存……），否则这个进程不会睡眠。所以CPU的可执行队列总是不为空（至少有这么个进程存在），CPU也就不会“空闲”。很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。S(TASK_INTERRUPTIBLE)，可中断的睡眠状态。处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。D(TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态。与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么ps命令看到的进程几乎不会出现TASK_UNINTERRUPTIBLE状态，而总是TASK_INTERRUPTIBLE状态。而TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了（参见《linux异步信号handle浅析》）。在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。（比如read系统调用触发了一次磁盘到用户空间的内存的DMA，如果DMA进行过程中，进程由于响应信号而退出了，那么DMA正在访问的内存可能就要被释放了。）这种情况下的TASK_UNINTERRUPTIBLE状态总是非常短暂的，通过ps命令基本上不可能捕捉到。linux系统中也存在容易捕捉的TASK_UNINTERRUPTIBLE状态。执行vfork系统调用后，父进程将进入TASK_UNINTERRUPTIBLE状态，直到子进程调用exit或exec。通过下面的代码就能得到处于TASK_UNINTERRUPTIBLE状态的进程：#include &lt;unistd.h&gt;void main() {if (!vfork()) sleep(100);}编译运行，然后ps一下：kouu@kouu-one:~/test$ ps -ax | grep a\.out4371 pts/0 D+ 0:00 ./a.out4372 pts/0 S+ 0:00 ./a.out4374 pts/1 S+ 0:00 grep a.out然后我们可以试验一下TASK_UNINTERRUPTIBLE状态的威力。不管kill还是kill -9，这个TASK_UNINTERRUPTIBLE状态的父进程依然屹立不倒。T(TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态。向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。（SIGSTOP与SIGKILL信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）向进程发送一个SIGCONT信号，可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态。当进程正在被跟踪时，它处于TASK_TRACED这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于TASK_TRACED状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。对于进程本身来说，TASK_STOPPED和TASK_TRACED状态很类似，都是表示进程暂停下来。而TASK_TRACED状态相当于在TASK_STOPPED之上多了一层保护，处于TASK_TRACED状态的进程不能响应SIGCONT信号而被唤醒。只能等到调试进程通过ptrace系统调用执行PTRACE_CONT、PTRACE_DETACH等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复TASK_RUNNING状态。Z(TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程。进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在shell中，$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。当然，内核也可以将这些信息保存在别的地方，而将task_struct结构释放掉，以节省一些空间。但是使用task_struct结构更为方便，因为在内核中已经建立了从pid到task_struct查找关系，还有进程间的父子关系。释放掉task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。这个信号默认是SIGCHLD，但是在通过clone系统调用创建子进程时，可以设置这个信号。通过下面的代码能够制造一个EXIT_ZOMBIE状态的进程：#include &lt;unistd.h&gt;void main() {if (fork())while(1) sleep(100);}编译运行，然后ps一下：kouu@kouu-one:~/test$ ps -ax | grep a\.out10410 pts/0 S+ 0:00 ./a.out10411 pts/0 Z+ 0:00 [a.out] &lt;defunct&gt;10413 pts/1 S+ 0:00 grep a.out只要父进程不退出，这个僵尸状态的子进程就一直存在。那么如果父进程退出了呢，谁又来给子进程“收尸”？当进程退出的时候，会将它的所有子进程都托管给别的进程（使之成为别的进程的子进程）。托管给谁呢？可能是退出进程所在进程组的下一个进程（如果存在的话），或者是1号进程。所以每个进程、每时每刻都有父进程存在。除非它是1号进程。1号进程，pid为1的进程，又称init进程。linux系统启动后，第一个被创建的用户态进程就是init进程。它有两项使命：1、执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）；2、在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作；init进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于TASK_INTERRUPTIBLE状态，“收尸”过程中则处于TASK_RUNNING状态。X(TASK_DEAD - EXIT_DEAD)，退出状态，进程即将被销毁。而进程在退出过程中也可能不会保留它的task_struct。比如这个进程是多线程程序中被detach过的进程（进程？线程？参见《linux线程浅析》）。或者父进程通过设置SIGCHLD信号的handler为SIG_IGN，显式的忽略了SIGCHLD信号。（这是posix的规定，尽管子进程的退出信号可以被设置为SIGCHLD以外的其他信号。）此时，进程将被置于EXIT_DEAD退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-02-09 二 10:35]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-02-09]<a href="/categories/study/linux/misc/linux_misc_notes.html"> Linux杂乱记录 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Linux命令学习记录'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. Misc1.1. MAYBE/FUTURE enca1.2. LATER shasum1.3. MAYBE/FUTURE ifttt1.4. MAYBE/FUTURE tref可查看windows邮件中的dat文件1.5. MAYBE/FUTURE jfbterm &amp; fbterm1.6. MAYBE/FUTURE complete1.7. update-alternatives1.7.1. java配置举例1.7.2. 添加举例：1.8. ps1.9. sudo1 Misc主要收集各类linux下的命令，内容没有整理，或者正在整理，整理好后会移出去到特定的文档中。1.1 MAYBE/FUTURE encaState "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 16:18]Time:[2015-10-14 三 11:33]编码转换更好的傻瓜型命令行工具enca，它不但能智能的识别文件的编码，而且还支持成批转换。  　　1.安装  　　$sudo apt-get install enca  　　2.查看当前文件编码  　　enca -L zh_CN ip.txt     Simplified Chinese National Standard; GB2312     Surrounded by/intermixed with non-text data  　　3.转换  　　命令格式如下  　　$enca -L 当前语言 -x 目标编码 文件名  　　例如要把当前目录下的所有文件都转成utf-8  　　enca -L zh_CN -x utf-8 *     检查文件的编码　enca -L zh_CN file   　　 将文件编码转换为"UTF-8"编码　 enca -L zh_CN -x UTF-8 file如果不想覆盖原文件可以这样         enca -L zh_CN -x UTF-8 &lt; file1 &gt; file2 参考：http://blog.csdn.net/jnbbwyth/article/details/6991425/1.2 LATER shasumState "LATER"      from "INBOX"      [2015-10-14 三 10:17]Time:[2015-10-13 二 14:21]类似 md5sum的一个命令。1.3 MAYBE/FUTURE iftttState "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 16:18]Capture Time:[2015-10-30 五 14:59]1.4 MAYBE/FUTURE tref可查看windows邮件中的dat文件State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 16:18]State "INBOX"      from              [2015-11-05 四 12:06]1.5 MAYBE/FUTURE jfbterm &amp; fbtermState "MAYBE/FUTURE" from "INBOX"      [2015-12-18 五 13:36]Capture Time:[2015-12-14 一 15:45]可以显示中文的纯字符终端，类似zhcon.参考：http://zhidao.baidu.com/link?url=ImeEdpu_besndXYBaeQohsiyHWognPFRRcBJm4XGcL1CxWYKGA54bwRIPqaPlP_67YBKAgaayDhTN9ZhB9V5Jq可以尝试使用fbterm安装命令：sudo apt-get install fbterm xfonts-wqyctrl+alt+f1进入的纯字符界面后，先运行fbterm。退出fbterm，可以输入exit命令。如果不起作用，先把当前用户加入video组：sudo usermod -g video [用户名]1.6 MAYBE/FUTURE completeState "MAYBE/FUTURE" from "LATER"      [2015-12-18 五 13:40]State "LATER"      from "INBOX"      [2015-12-18 五 13:39]Capture Time:[2015-12-16 三 16:51]参考:http://www.gnu.org/software/global/globaldoc_toc.html$ complete -F funcs global$ global kmem_&lt;TAB&gt;&lt;TAB&gt;kmem_alloc           kmem_alloc_wait      kmem_initkmem_alloc_nofault   kmem_free            kmem_mallockmem_alloc_pageable  kmem_free_wakeup     kmem_suballoc1.7 update-alternatives当ubuntu中某个软件有多个版本共存与系统之中时，默认采用哪个软件，可以通过 update-alternatives 进行管理。1.7.1 java配置举例设置默认java环境输入 sudo update-alternatives --display java 可查看信息默认的jdk信息。如果只有一个java环境如下设置即可$sudo update-alternatives --install /usr/bin/java java  /usr/lib/jvm/jdk1.8.0_65/bin/java 300$sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk1.8.0_65/bin/javac 300若有多个版本，需要修改默认的，则再输入$sudo update-alternatives --config java$sudo update-alternatives --config javac将会提示：要维持当前值[*]请安回车键或者输入选择的编号,输入自己设置的优先级(300)对应的编号，按回车就可以了，再输入display查看，确定默认版本信息。会更新 /etc/alternatives 中的内容。参考:http://blog.csdn.net/gobitan/article/details/24322561 http://www.linuxidc.com/Linux/2014-11/109216.htm 1.7.2 添加举例：假设源代码安装php在 /usr/local/develop/php-5.6.19, 那么sudo update-alternatives --install /usr/bin/php5.6.19 php5.6.19 /usr/local/develop/php-5.6.19/bin/php 49会导致： /usr/bin/php5.6.19 链接被创建，指向 /etc/alternatives/php5.6.19, 而 /etc/alternatives/php5.6.19 指向 /usr/local/develop/php-5.6.19/bin/php.http://blog.csdn.net/baggio1006/article/details/6338623http://persevere.iteye.com/blog/14795241.8 ps支持三种类型的选项：Unix风格: 选项可能会被分组，但是必须以 - 开始BSD风格: 选项可能会被分组，不以 - 开始GUN长选项风格: 选项以 =&#x2013;=开始ps -a列出所有与terminal有关的进程，不包含session leader.ps a列出所有与terminal有关的进程ps -A 同 ps -e, 列出所有的进程。ps x列出所有你拥有的进程ps ax列出所有进程没有 -x 。ps -u &lt;userlist&gt; 同 ps --user &lt;userlist&gt;列出 EUID为 =&lt;userlist&gt; 对应的名称或者ID的进程。 &lt;userlist&gt; 可以为空格分割的字符串，或者逗号分割。 ps -p "1 2" -p 3,4.ps u以用户为主显示，结果第一列是用户ID。USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND1032      9392  0.0  0.0  10484  1732 pts/11   S+   11:59   0:00 man psps -U &lt;userlist&gt;列出 RUID为 &lt;userlist&gt; 对应的名称或者ID的进程。 &lt;userlist&gt; 可以为空格分割的字符串，或者逗号分割。 ps -p "1 2" -p 3,4.ps U &lt;userlist&gt; 同 ps --user &lt;userlist&gt;列出 EUID为 &lt;userlist&gt; 对应的名称或者ID的进程。 &lt;userlist&gt; 可以为空格分割的字符串，或者逗号分割。 ps -p "1 2" -p 3,4.1.9 sudo以 user 用户而非 root 运行 xxx ， sudo -u user xxx      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-02-11 四 17:05]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-02-02]<a href="/categories/study/linux/command/linux_command_tips.html"> Linux命令学习记录 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Linux进程和线程的调度与优先级'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 总述1.1. 概念：1.2. 方法：1.3. 原理：2. 进程优先级概念3. 进程优先级与变动影响因素与原理4. 查看与设置优先级与进程线程信息等的方法5. WAIT/FORWARD FAQ [0/4]([0%])5.1. NEXT 线程优先级是否继承父线程优先级？是否继承父进程优先级？5.2. NEXT chrt 修改进程优先级，那么该进程的子线程优先级是否改变？5.3. NEXT chrt, ps, top, pthread_attr_setschedpolicy(), sched_setscheduler() 中的优先级值和含义有什么关系？5.4. NEXT 考虑将引文中的链接下载到本地本文主要概述Linux下进程与线程的调度算法和优先级相关内容。1 总述为便于快速了解和复习，本节先给出结论性的大致概述，后面再详细介绍相关内容。关于进程优先级和调度策略的大致信息如下。1.1 概念：进程优先级值越小，优先级越大。进程优先级是PRI值不是Nice值，但是Nice值会影响优先级。三类调度策略：RR调度和FIFO调度的进程属于实时进程，以分时调度(OTHER)的进程是非实时进程实时进程优先级高于普通进程，实时进程使用静态优先级调度、非实时进程使用动态优先级调度，非实时进程动态优先级通过nice调整、可能受bonus影响。1.2 方法：命令行/脚本中可以通过 ps, top, chrt 来查看和修改调度和优先级属性。通过 sched_setscheduler() 设置进程调度和优先级属性。通过 pthread_attr_setschedpolicy() 设置线程调度和优先级属性。1.3 原理：一般子进程会继承父进程的调度策略，在Linux  2.6.32之后，可以使用 SCHED_RESET_ON_FORK 按位与参数的方式调用 sched_setscheduler(), 使用之后效果是：如果调用进程使用 SCHED_FIFO 或 SCHED_RR 调度策略，使用 SCHED_RESET_ON_FORK 后fork创建的子进程创建时将会自动重置为 SCHED_OTHER 调度策略；如果调用进程使用负值nice，那么使用  SCHED_RESET_ON_FORK 后fork创建的子进程创建时将会自动将其nice重置为0。 这个标记激活时只有当进程具有 CAP_SYS_NICE 标记时才能被重置，而这个 CAP_SYS_NICE 标记在使用fork()创建子进程后，在子进程中被禁止。2 进程优先级概念进程优先级值越小，优先级越大。linux下的进程调度优先级是从-20到19，一共40个级别，数字越大，表示进程的优先级越低。默认时候，进程的优先级是0。如果不是root权限,则侄只能降调度优先级而不能提高，即使是自己用户的进程，自己把它调高了后，优先级也不能再被调会原来的值了，除非使用root用户来调回去。系统重启后，对进程优先级的调整全部失效，所有进程的调度回到默认的初始级别。参考：Linux进程优先级的调整方法进程优先级是PRI值不是Nice值，但是Nice值会影响优先级PRI也还是比较好理解的，即进程的优先级，或者通俗点说就是程序被CPU执行的先后顺序，此值越小进程的优先级别越高。那NI呢？就是我们所要说的nice值了，其表示进程可被执行的优先级的修正数值。如前面所说，PRI值越小越快被执行，那么加入nice值后，将会使得PRI变为：PRI(new)=PRI(old)+nice。到目前为止，更需要强调一点的是，进程的nice值不是进程的优先级，他们不是一个概念，但是进程nice值会影响到进程的优先级变化。通过调整nice值，更改进程优先级，nice调整范围是 -20~19。参考：linux进程优先级、进程nice值3 进程优先级与变动影响因素与原理调度策略：RR调度和FIFO调度的进程属于实时进程，以分时调度(OTHER)的进程是非实时进程。FIFO（先进先出）和RR（时间片轮转）用于实时进程，OTHER（分时调度）用于非实时进程；实时进程会抢占普通进程;FIFO会导致同优先级实时进程始终占用CPU，RR会保证同优先级实时进程按时间片轮流执行。参考：SCHED_OTHER,SCHED_FIFO,SCHED_RR实时进程优先级高于普通进程，实时进程使用静态优先级调度、非实时进程使用动态优先级调度，非实时进程动态优先级通过nice调整、可能受bonus影响。Linux进程有两种优先级：普通进程优先级（使用SCHED_NORMAL调度策略），以及实时进程优先级（使用SCHED_FIFO或SCHED_RR调度策略）不同调度策略的实时进程只有在相同优先级时才有可比性，任何时候，实时进程的优先级都高于普通进程Linux对实时进程使用静态优先级调度，对普通的进程（非实时进程），根据动态优先级进行调度。实时进程，只有静态优先级(在0~MAX_RT_PRIO-1间，默认MAX_RT_PRIO为100）, 内核不会再根据休眠等因素对其静态优先级做调整； 实时进程0-99号优先级每一个优先级对应一个优先级队列（链表），先执行数值高的对应的链表（0号最低），可由后面所述的 chrt 以及 相应函数修改该优先级；非实时进程静态优先级可通过nice值（-20~19）调整：static_prio=MAX_RT_PRIO + nice + 20。nice只影响非实时进程(静态优先级在100~139之间)，nice越大静态优先级值越大，优先级越低。非实时进程动态优先级根据静态优先级和bonus计算:dynamic_prio = max (100, min (static_prio - bonus + 5, 139))bonus反映进程平均睡眠时间（范围0~10），睡眠时间越多越可能是交互进程，每次轮到它运行时它就越可能不会使用完时间片再释放cpu。参考：Linux进程调度原理 以及 给进程设置实时优先级4 查看与设置优先级与进程线程信息等的方法通过 ps 查看进程信息ps -el 可查看进程优先级和nice值,命令执行结果：NI列显示的每个进程的nice值（主要针对非实时进程），PRI是进程的优先级（如果是实时进程就是静态优先级，如果是非实时进程，就是动态优先级）。参考：Linux进程调度原理通过 top 查看进程信息其中的优先级和ps的pri不一样，ps中一般为0的进程，在top中为20，这个优先级应该对应于前面所说的实时进程优先级，实时进程只使用1-99号优先级队列，序号越大优先级越高，0号留给普通进程使用。chrt -p &lt;pid&gt; 查看进程属性通过 chrt 查看和修改进程调度和优先级属性，它一般也是调用后面的 sched_setscheduler() 实现的。  注意： char -o pri command 设置为SCHED_OTHER调度方式优先级别值只能是0表示比任何实时优先级都低，非实时进程不使用该值决定调度行为，普通进程使用自己的调度策略。参考： man chrt 通过 sched_setscheduler() 设置进程调度和优先级属性效果类似 chrt, 关于priority的注意：这里参数中的pri不是ps的nice也不是priority,而是代码中的sched_priority，用于表示一系列可执行进程列表。实时进程中该值范围为1-99越大表示优先级越高, 非实时只能是0表示始终比实时进程低，并且非实时进程的优先级不由此值确定而是由其内部动态优先级确定。chrt中的pri应该也类似含义，例如： chrt -f -p 10 pid 则ps中pri为-11， chrt -f -p 1 pid 则ps中pri为-2）为0，进程命令为command，其它可以根据选项参数设置。关于prioriti的注意：一般子进程会继承父进程的调度策略，在Linux  2.6.32之后，可以使用 SCHED_RESET_ON_FORK 按位与参数的方式调用 sched_setscheduler(), 使用之后效果是：如果调用进程使用 SCHED_FIFO 或 SCHED_RR 调度策略，使用 SCHED_RESET_ON_FORK 后fork创建的子进程创建时将会自动重置为 SCHED_OTHER 调度策略；如果调用进程使用负值nice，那么使用  SCHED_RESET_ON_FORK 后fork创建的子进程创建时将会自动将其nice重置为0。 这个标记激活时只有当进程具有 CAP_SYS_NICE 标记时才能被重置，而这个 CAP_SYS_NICE 标记在使用fork()创建子进程后，在子进程中被禁止。参考： man sched_setscheduler 和 线程优先级设置通过 pthread_attr_setschedpolicy() 设置线程调度和优先级属性效果类似 sched_setscheduler(), 但是用于线程而非进程。参考： man pthread_attr_setschedpolicy5 WAIT/FORWARD FAQ [0/4]([0%])5.1 NEXT 线程优先级是否继承父线程优先级？是否继承父进程优先级？State "NEXT"       from              [2016-02-01 一 15:39]5.2 NEXT chrt 修改进程优先级，那么该进程的子线程优先级是否改变？State "NEXT"       from "NEXT"       [2016-02-01 一 15:40]5.3 NEXT chrt, ps, top, pthread_attr_setschedpolicy(), sched_setscheduler() 中的优先级值和含义有什么关系？State "NEXT"       from              [2016-02-01 一 15:40]5.4 NEXT 考虑将引文中的链接下载到本地State "NEXT"       from              [2016-02-01 一 15:50]      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2016-02-01 一 15:35]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2016-02-01]<a href="/categories/study/os/linux_schedule_priority.html"> Linux进程和线程的调度与优先级 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '测试orgmode文章导出'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. FAQ [3/8]([37%])1.1. INBOX 如何设置style文件链接使之在所有文件中可以公用？1.2. DONE 如何设置文内引用链接保持在文件路径变化时文件内容不变？1.2.1. 链接引用文件存放地1.2.2. org文件中引用链接到jekyll导出文件链接的转换1.2.3. 转换实现1.3. DONE 如何设置图片链接在文件路径变化时保持不变？1.4. NEXT 如何设置文件中的签名信息？1.5. DONE 如何设置文件中jekyll文章的引用位置？1.6. NEXT 如何为每次更新文章追加设置记录时间戳？1.7. NEXT 如何放置引用文章链接在文章路径改变时的失效情况发生？1.8. NEXT 如何为本地orgmode导出文件设置导出引用链接？1 FAQ [3/8]([37%])1.1 INBOX 如何设置style文件链接使之在所有文件中可以公用？1.2 DONE 如何设置文内引用链接保持在文件路径变化时文件内容不变？State "DONE"       from "WAIT/FORWARD" [2016-01-11 一 17:08]State "WAIT/FORWARD" from "NEXT"       [2016-01-08 五 17:41]  等待整理State "NEXT"       from              [2015-12-17 四 17:42]1.2.1 链接引用文件存放地文章引用的文件，存放在jekyll中data目录的，名为对应文章所在文件扩展名替换为 .files 的目录中。假设引用的是一个图片文件， 引用的文章文件名称是 2015-12-17-testexport.org, 导出到jekyll系统中的名称是 2015-12-17-testexport.html, 那么其文章所有被引用的文件都存放在 data/2015-12-17-testexport.files 。1.2.2 org文件中引用链接到jekyll导出文件链接的转换org文件中的引用链接，在导出到jekyll的html需要进行转换才能正确显示，转换方式如下1.2.2.1 org文章使用链接的方式org文章中引用本地外部文件和普通orgmode语法一样，如下[[file:~/mygitrepo/quietheart/mydoc/prepub/orgmode/data/2015-12-17-testexport.files/2015-12-17-editor_study_line.jpg][image file]]1.2.2.2 导出的html链接导出结果到jekyll对应的html文件后，对应链接变成&lt;a href="file:///home/miracle/mygitrepo/quietheart/mydoc/prepub/orgmode/data/2015-12-17-testexport.files/2015-12-17-editor_study_line.jpg"&gt;image file&lt;/a&gt;1.2.2.3 对导出的html链接进行转换这样的结果在jekyll中是无法直接正确显示链接的，需要在导出为html之后，再对相应html文件中相应的链接处进行处理，处理成jekyll可以显示的方式，这里为：&lt;a href="/data/2015-12-17-testexport.files/2015-12-17-editor_study_line.jpg"&gt;image file&lt;/a&gt;处理成功的效果：image file1.2.3 转换实现这里实现上述转换的方法是定义一个替换链接的函数，把它做为hook添加到 org-publish-after-publishing-hook 中。大致如下：(defun my-update-jekyll-html-link (htmlfile);;replace the local file link to site relative link in jekyll.;;open    (setq htmlbuffer (find-file-existing htmlfile));;search    (goto-char (point-min));;TODO the xxx.files, xxx is better to be replaced by the html file name.    (while (re-search-forward "\\(&lt;a href=.*?\\)\\(file:.*?quietheart/mydoc/prepub/jekyll\\)\\(/data/[0-9]\\{4\\}-[0-1][0-9]-[0-3][0-9]-.*?\.files\\)" nil t)         (replace-match "\\1\\3" nil nil));;save and close    (save-buffer)    (kill-buffer htmlbuffer)))(defun my_after_pub_html_hook (orgfile htmlfile)     (my-update-jekyll-html-link htmlfile))(add-hook 'org-publish-after-publishing-hook 'my_after_pub_html_hook)))1.3 DONE 如何设置图片链接在文件路径变化时保持不变？State "DONE"       from "NEXT"       [2016-01-11 一 17:55]State "NEXT"       from              [2016-01-11 一 17:40]类似文件链接的转换，如何设置文内引用链接保持在文件路径变化时文件内容不变？关键添加如下：;;image reference link convert.;;TODO the xxx.files, xxx is better to be replaced by the html file name.(while (re-search-forward "\\(&lt;img .*?src=.*?\\)\\(file:.*?quietheart/mydoc/prepub/orgmode\\)\\(/data/[0-9]\\{4\\}-[0-1][0-9]-[0-3][0-9]-.*?\.files\\)" nil t) (replace-match "\\1\\3" nil nil))效果：1.4 NEXT 如何设置文件中的签名信息？State "NEXT"       from              [2015-12-17 四 17:42]1.5 DONE 如何设置文件中jekyll文章的引用位置？State "DONE"       from "NEXT"       [2016-01-11 一 17:39]State "NEXT"       from              [2015-12-17 四 17:42]类似上面导出文件链接的转换，如何设置文内引用链接保持在文件路径变化时文件内容不变？关键如下：(while (re-search-forward "\\(&lt;a href=.*?\\)\\(file:.*?quietheart/mydoc/prepub/orgmode\\)\\(/.*?\\)\\(_posts/[0-9]\\{4\\}-[0-1][0-9]-[0-3][0-9]-\\)\\(.*?\.html\\)" nil t) (replace-match "\\1\\3\\5" nil nil))效果gtd method1.6 NEXT 如何为每次更新文章追加设置记录时间戳？State "NEXT"       from              [2015-12-17 四 17:42]1.7 NEXT 如何放置引用文章链接在文章路径改变时的失效情况发生？State "NEXT"       from              [2016-01-11 一 18:00]1.8 NEXT 如何为本地orgmode导出文件设置导出引用链接？State "NEXT"       from              [2016-01-18 一 18:28]这个和发布不同，日常orgmode管理之时，一般都会将相关文章放到一个目录中，引用的文件也属于该目录的子目录。这种情况下，使用 elisp: 链接的方式来自定义链接的引用。imagefile;; custom link function for export.(defun my-link-org-file (file_path)  (setq org-file-prefix org-directory)  (find-file (concat org-file-prefix file_path)))(defun my-link-org-img (imgfile_path)  (setq org-file-prefix org-directory)  (find-file (concat org-file-prefix imgfile_path)))[[elisp:(my-link-org-file%20"data/image/2010-04-02-editor_study_line.jpg")][normalfile]][[elisp:(my-link-org-img%20"data/image/2010-04-02-editor_study_line.jpg")][imagefile]]&lt;a href="(my-link-org-file%20"data/image/2010-04-02-editor_study_line.jpg")"&gt;normalfile&lt;/a&gt;&lt;a href="(my-link-org-img%20"data/image/2010-04-02-editor_study_line.jpg")"&gt;imagefile&lt;/a&gt;      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2015-12-25 五 15:00]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-12-17]<a href="/categories/others/testexport.html"> 测试orgmode文章导出 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '测试orgmode链接'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. image links2. audio links1 image links2015-12-01-test_image.jpg2 audio linksmsgcrskysongForEver.mp3      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2015-12-01 二 14:30]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-12-01]<a href="/categories/others/test_orglink.html"> 测试orgmode链接 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '使用orgmode进行GTD管理'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 任务状态2. 划分文件3. 管理方式:3.1. 大致思路：3.2. 回顾3.2.1. 回顾种类3.2.2. 回顾内容：4. 实现方式4.1. 实现基本Orgmode任务管理4.1.1. TODO标题表示任务4.1.2. 按照实现策略进行配置4.1.3. 常用操作4.2. 交叉引用4.3. 设置优先级别4.3.1. 可采用四象限法则，将事情按照重要和紧急两个不同的程度进行划分，分为四个“象限”。4.3.2. 设置优先级4.3.3. 切换优先级4.4. Capture-Refile-Archive4.4.1. 概念4.4.2. 配置4.4.3. 操作4.5. 归档4.5.1. 配置归档位置和归档后附带信息4.5.2. 归档命令4.5.3. 举例4.6. 便于整理周报的记录技巧4.7. orgmode与mobile org整合4.7.1. 配置4.7.2. 原理4.7.3. 同步操作4.7.4. 使用举例4.7.5. 其它5. WAIT/FORWARD FAQ [8/11]([72%])5.1. DONE 如何划分任务状态以及存放的文件？5.2. DONE 如何实现任务管理的基本管理？5.3. DONE 如何设置交叉引用?5.4. DONE 如何设置优先级别?5.5. DONE 如何迅速捕获临时产生的任务，以及将各个任务标题在状态文件中进行转移？5.6. DONE 如何设置归档?5.7. DONE 便于整理周回顾?5.8. DONE 如何将PC与移动端的orgmode整合?5.9. LATER 杂乱问题5.10. NEXT 改善归档与done/cancel策略5.11. NEXT 改善refile的配置方式这里给出采用orgmode进行gtd管理的策略。注：orgmode工作目录说明文件(orgmode/gtd/readme.org)即此文的副本,此文定期更新同步到orgmode工作目录的说明文件。1 任务状态状态含义同一般GTD系统，这里先不做深入介绍。主要设置如下任务状态：INBOX任何未经处理的任务。NEXT正在处理的任务。LATER被暂缓延迟的任务。WAIT/FORWARD等待能够继续处理的条件。MAYBE/FUTURE可能会处理，可能不处理的任务。CANCEL被取消的任务。DONE已完成的任务。2 划分文件主要设置如下目录和文件来存放数据：inbox.org整个体系的输入，产生的任何任务、灵感、想法都会通过快速捕捉命令（例如 C-c c ）默认收集到这里。单个文件，因为进入其中的任务迟早会被清空，不会积累。这里的内容是最原始的、迅速捕捉到的内容，待处理，甚至都没有任务状态关键字。每次回顾后，这里的内容要么被移动到相应位置，要么被直接处理，要么归档。next.org这里内容主要存放当前处理的任务。单个文件，因为进入其中的任务迟早会被清空，不会积累。处理任务之时，集中在next.org中进行处理，处理之时相应的任务可能会被切换成各种状态，每次经过定期回顾处理后，这个文件其它状态的内容被移动到合适的位置，导致仅包含 NEXT 状态的任务。later.org这里的内容存放 LATER 状态的任务。单个文件，因为进入其中的任务迟早会被清空，不会积累。每次回顾之后，可能会有一些新的任务切换成 LATER 状态并进入这个文件；也可能有一些任务被切换至其它状态并移出到对应文件。wait_forward.org这里的内容存放 WAIT/FORWARD 状态的任务。单个文件，因为进入其中的任务迟早会被清空，不会积累。每次回顾之后，可能会有一些新的任务切换成 WAIT/FORWARD 状态并进入其中；也可能有一些任务被切换至其它状态并移出这里到对应目录。maybe_future.org这里的内容存放 MAYBE/FUTURE 状态的任务。建议为目录，因为其中内容可能会积累。每次回顾之后，可能会有一些新的任务被切换成 MAYBE/FUTURE 状态并进入其中；也可能有一些任务被切换至其它状态并移出这里到对应目录。cancel.org这里的内容存放 CANCEL 状态的任务。建议为目录，其中内容可能会积累。每次回顾之后，可能会有一些新的任务切换成 CANCEL 状态并进入其中；也可能有一些任务被切换至其它状态并移出这里到对应目录。done.org这里的内容存放 DONE 状态的任务。建议为目录，其中内容可能会积累。每次回顾之后，可能会有一些新的任务切换成 DONE 状态并进入其中；也可能有一些任务被移至其他回顾目录、归档目录、或者加入特定关联信息等。output将处理好的任务转化为文档的地方。建议为目录，其中内容可能会积累。主要存放将要整理成笔记的内容，整理好的内容存放到这里，在合适的时候（如回顾之时）会被转移至其它笔记系统；另外为了借助orgmode环境方便集中访问和refile，有些草稿性质的文档，也可为之做成一个软链接，将软链接放在这里，源文档仍在其初始目录。_review存放与任务关联的项目。建议为目录，其中内容可能会积累。主要存放之前整理过的、或者不活跃的回顾项目。项目其实是对任务的一种“分类”，每个项目包含多个任务，由gtd系统管理，回顾之时会将相关联的任务组织整理，将其概要信息归结为一条项目，存放在这里。_active存放与任务关联的当前活跃项目。建议为目录，其中内容可能会积累。主要存放当前正在整理或者进行的、或者活跃的回顾项目。项目条目的含义同上，是多个相关联的任务的概要索引，便于日后查找参考等，也使得整个gtd中被处理的任务更为有序。_archive归档已完成任务。建议为目录，其中内容可能会积累。主要将一些任务归档，减少Agenda视图的冗余，以及备份，具体依实际情况待定。3 管理方式:3.1 大致思路：两种划分状态的方式任务的状态既通过其所在的 状态文件名 表示，也通过 TODO关键字标记 表示。两种“划分”得到的状态含义大致相同，并且一一对应。回顾阶段与处理阶段为方便信息检索，以及避免信息重复，采用“分阶段”（处理阶段和回顾阶段）方式管理。虽然我们划分任务状态的采用的文件名和TODO状态标记两种方式，通过如下方式对处理阶段划分，并不会造成混乱。处理阶段在任务处理时进行，将任务切换至合适的TODO关键字标记。回顾阶段在系统回顾时进行，将相关TODO关键字标记的任务转移到对应的状态文件中集中存放。3.2 回顾3.2.1 回顾种类短期回顾比较频繁的，例如“日”回顾，主要用来清理inbox中的内容，以及切换状态。对于inbox状态文件，将其中的任务和内容切换到合适状态并refile；对于其它文件的任务，只需切换其状态即可；为简化频繁的文件操作，操作可在orgmode的agenda view下进行。中期回顾根据项目情况定期的，例如“周”回顾，主要用来梳理当前任务的状态和关系。主要涉及对任务的refile，以及文档生成等。长期回顾便于总结复习整理的，例如“月”、“年”回顾，主要用来梳理任务状态、复习曾经整理的内容、归档等等。3.2.2 回顾内容：3.2.2.1 短期回顾在"短期回顾"中，定期处理inbox中的内容使得收集状态的内容及时被处理。根据情况，可能有如下类型：立即处理一般处理过程仅需1-2分钟，直接处理完，让其归结为done状态。做为任务处理转移到对应的gtd任务状态中开始对其进行gtd管理，如果任务复杂，可考虑为其创建项目（回顾）来管理相关任务。不需要处理直接删除。归档与笔记从gtd输出（例如到out目录），或直接转移到对应的笔记系统。对其他状态任务的处理，只需切换相应任务状态，直接在orgmode中的AgendaView中进行可以避免频繁的文件切换。3.2.2.2 中期回顾在"周"回顾中，梳理各种任务状态中的内容，将相关的内容关联起来，将相应的状态内容移动到对应的文件等等。处理方式类似对于inbox的处理，可能有如下类型：立即处理将已完成的任务梳理，并且从其它文件中移动到"done"，需要添加项目回顾关联的，则添加相应的关联信息。做为任务处理没有完成的任务，视情况将其放置到合适的状态和位置，必要时可能会追加更详细的任务属性（如优先级、截止日期、重复间隔等等）。不需要处理将不需要继续进行的任务，放置到cancel状态中，将其取消。归档与笔记将一些有必要归档的内容归档（减少agenda的负担），以及将特定内容移动到特定的笔记系统（内容管理）。4 实现方式下面给出实现上述管理主要需要注意的几个部分。4.1 实现基本Orgmode任务管理4.1.1 TODO标题表示任务TODO标题是一种包含状态的特殊标题在标题标记后面加上相应状态名，便成为TODO项目。状态默认为TODO和DONE，可以自行配置。* TODO 这是一个TODO项目** TODO 这是TODO的子项目带有统计子项目的TODO项目在一个待办标题中添加子待办标题，然后在待办标题中添加 [%] 或者 [%] 。 每当子标题更新时，父标题上面的相应比例会自动统计变化，如果强制刷新，则在父标题相应的比例标记上输入 C-c C-c 。* TODO 这是一个统计子项的TODO项目 [0/2]** TODO 这是TODO的子项目1** TODO 这是TODO的子项目2当然这样也行：* TODO 这是一个统计子项的TODO项目 [0/2] ([0%])** TODO 这是TODO的子项目1** TODO 这是TODO的子项目24.1.2 按照实现策略进行配置增加TODO状态在配置文件中加入类似如下代码：;;set status for TODO.(setq org-todo-keywords     '((sequence "INBOX" "NEXT" "LATER" "WAIT/FORWARD" "MAYBE/FUTURE" "|" "CANCEL" "DONE")))配置状态颜色通过org-todo-keyword-faces的设置实现，添加内容如下;; color for todo keywords(setq org-todo-keyword-faces '(("INBOX" . (:foreground "blue" :weight bold)) ("NEXT" . org-warning)("LATER" . "yellow")("WAIT/FORWARD" . "blue")("MAYBE/FUTURE" . "purple")("DONE" . "green")("CANCEL" . "grey")))配置状态快捷切换键通过定义状态时将快捷按键放在状态后面，用‘（）’括起来，添加内容如下：;;set status for TODO.(setq org-todo-keywords '((sequence                          "INBOX"                         "NEXT(n)"                         "LATER(l)"                         "WAIT/FORWARD(w)"                         "MAYBE/FUTURE(m)"                         "|" "CANCEL(c)" "DONE(d)"                         )) )配置状态切换的跟踪时间戳当TODO列表切换到结束状态时，会自动为其添加一个结束时候的时间戳（转变为非结束状态时会将其移除）。;;add timestamp when todo change to done.(setq org-log-done 'time)4.1.3 常用操作TODO项目相关操作：M-S-Ret 当前位置插入TODO项目，默认状态和上一条统计TODO状态一样C-S-Ret 当前级别子树后面插入TODO项目C-c C-t 当前所在TODO项目状态切换(不一定要在TODO标题上面)默认状态下，循环切换次序是TODO-&gt;Done-&gt;普通标题（只有*）。S-RIGHT/S-LEFT 当前所处TODO标题上进行状态切换，默认状态下，循环切换次序是：TODO-&gt;DONE-&gt;普通标题C-c , 修改优先级（包括A,B,C三个级别，不一定在TODO标题上面）S-UP/S-DOWN 切换优先级，默认次序是A-&gt;B-&gt;C-&gt;无。C-u C-c C-t 快捷切换状态，输入后会提示你要输入的状态，可以支持Tab补全，可以用快捷按键替代。光标停留在 [%] 或者 [%] 之上，输入 C-c C-c4.2 交叉引用因任务可能会在不同的文件与标题间迁移，所以需要为每一条目采用与文件与位置无关的id，即采用全局唯一id链接的方式实现交叉引用。首先配置全局链接类似如下：;;Settings for global id link.(require 'org-id)(setq org-id-link-to-org-use-id t)为被引用标题创建全局链接id保存链接内容的同时也创建了相应的链接。当然，这需要事先配置好保存链接快捷键(global-set-key "\C-cl" 'org-store-link)输入 C-c l 之后便创建好了相应的全局链接，类似如下：* 子树标题   :PROPERTIES: :ID:       60b13787-86e8-43a3-9a33-73d3eb7e6f58 :END:引用链接像正常插入链接一样，输入 C-c C-l 即可，默认插入最近一次保存的链接。引用的格式举例 [[id:60b13787-86e8-43a3-9a33-73d3eb7e6f58][子树标题]]4.3 设置优先级别4.3.1 可采用四象限法则，将事情按照重要和紧急两个不同的程度进行划分，分为四个“象限”。第一象限重要但不紧急的事。法则重点，这才是最需要做的事。需要制定计划，按时完成。可以让你进入良性循环的做法！第二象限重要并紧急的事。需要优先解决，这也是没有计划的做法，无休止地一直在“瞎忙”。第三象限不重要但紧急的事。会让我们产生“这事很重要”的错觉。实际上就算重要也是对别人而言。我们花很多时间在这个里面打转。自以为是在第一象限，其实不过是在满足 别人的期望与标准。第四象限不紧急也不重要的事。浪费时间，或者完全对自己完全无意义的事。如果有可能，交给别人去做。我们把事项进行一些梳理，就会清楚自己的时间和精力主要应该用在什么地方了。4.3.2 设置优先级通过如下方式：;;set priority(setq org-highest-priority ?A)(setq org-lowest-priority ?D)(setq org-default-priority ?A)(setq org-priority-faces '(                           (?A . org-warning)                           (?B . (:background "DodgerBlue" :foreground "black" :weight bold))                            (?C . (:foreground "SkyBlue" :weight bold))                           (?D . (:foreground "DodgerBlue" :weight bold))                            ))4.3.3 切换优先级在标题上输入 S-&lt;up&gt;/&lt;down&gt; 5w1h分析4.4 Capture-Refile-Archive4.4.1 概念Capture用来迅速收集一些临时产生的想法，尽可能少的打断当前的工作状态。通过指定好快捷方式和相应的Capture目标位置后，在任意时间运行捕获命令会将这些临时的记录存放在一个指定的位置，空闲之时再做进一步整理。Refile以特定的命令，用来将之前Capture的内容直接转移到特定的地方，避免了手动剪切（复制）和粘帖。4.4.2 配置4.4.2.1 Capture的配置不同的管理方式可能会导致不同的配置，但是一般都包含两个方面：首先设置好一个启动Capture的快捷方式，再配置用于存储Capture信息的目的地。这里以gtd管理为例给出一个配置例子：;;Setting for gtd captures;;Directory for capture files.(setq org-directory "~/mydata/orgmode/");;Default capture files.(setq org-default-notes-file (concat org-directory "gtd/inbox.org"));;Capture template(setq org-capture-templates '(			      ("t" "Tasks" entry (file+headline "gtd/inbox.org" "Tasks") "* INBOX %?\nTime:%T\nFrom:%F\n")			      ("p" "Projects" entry (file+headline "gtd/inbox.org" "Projects")  "* %?\nTime:%U\nFrom:%F\n")			      ("i" "Item notes" item (file+headline "gtd/inbox.org" "Items")  "+ %?\n  Time:%U\n  From:%F\n")			      ("m" "Misc notes" plain (file+headline "misc.org" "Notes")  "-----------------------------------------------------\nTime:%U\n %?")			     )) ;;set tags;;where?(h/o/w),what?(c/l/s),when?(gtd|immeiately,wait,action),who?(my gtd,others),why?how?(delete/archieve/schedule)(setq org-tag-alist '(                    (:startgroup . nil)                         ("home" . ?r) ("office" . ?o) ("way" . ?w)                    (:endgroup . nil)                    ("职业" . ?c)                    ("生活" . ?l)                     ("学习" . ?s)                    ))4.4.2.2 Refile的配置主要配置两个方面的内容：Refile的目标（org-refile-targets），以及Refile时选择目标的策略(org-refile-use-outline-path会自动补全文件名以及标题，目标的格式类似文件路径的格式，包含文件和标题)。org-refile-targets对应的可以是路径可以是列表，具体参考其中的文档，需要注意的是：如果是列表该变量中的文件路径需要是全路径；文件中需要有一个标题才能在做 C-c C-w 补全的时候显示出来，空文件不行。如果是一个文件路径如果org-refile-targets是一个文件，则：这个文件可以是一个文件列表，使用这个列表的文件做为refile目标; 每个文件项占一行（不要有""），文件项可以是对于org-directory的相对路径; 这样文件内容变化之后，不用重新载入配置也能在 C-c C-w 中显示出新增的文件; 如果有一项是文件目录，那么不要再次包含该目录下的文件，因为这样会在agenda view中导致重复显示。;;targets for refile(setq org-refile-targets (quote (                                 (nil :maxlevel . 9)                                 (org-agenda-files :maxlevel . 9)                                )                         ));;outline path for refile(setq org-refile-use-outline-path 'full-file-path);;org-outline-path-complete-in-steps(setq org-outline-path-complete-in-steps t);;create new parents while refile(setq org-refile-allow-creating-parent-nodes 'confirm)4.4.3 操作基于以上配置，我们可以操作如下：启动Capture输入 C-c c输入之后会提示选择捕获何种类型的信息，提示信息和选择命令取决于之前设置的配置变量 org-capture-templates 。选择将待捕获的信息存于"Tasks"标题之下输入 t具体如何输入取决之前的配置如何，这里输入之后会打开一个Capture Buffer，用于输入将要被记录的信息，其中按照预先配置好的模板，已经预先插入了一些基本信息（如时间、捕获信息时所处位置等等）。完成Capture输入 C-c C-c输入之后，会将buffer中相应的信息插入到之前配置好的位置（例如某个文件中的某个标题之下），然后回到之前被中断的工作状态。取消Capture输入 C-c C-k取消捕获的动作，回到之前被中断的工作状态。访问存放Capture的文件Buffer输入 C-u C-c c输入之后，会提示和 C-c c 一样的信息，选择相应的捕获类型后，会直接打开相关的文件，具体是何文件，取决于事先设置的信息。访问上次捕获所处的文件Buffer输入 C-u C-u C-c c类似前面，捕获访问的是记录上次捕获的文件Buffer，并自动定位到其中上次捕获的信息之上。以剪切方式Refile输入 C-c C-w输入之后，会提示Refile的目标位置（在org-agenda-files中列出），支持Tab补全，选择好相应的文件之后，可以继续将文件内的标题也类似路径的方式输入（也支持TAB补全），选择好之后，回车会将相应的内容移动到对应的目标位置。注意：移动的内容可以是用Mark方式选择的区域，或者当前光标所在的子树，在执行 C-c C-w 之后有提示。以复制方式Refile输入 C-c M-w输入之后，会提示Refile的目标位置（在org-agenda-files中列出），支持Tab补全，选择好相应的文件之后，可以继续将文件内的标题也类似路径的方式输入（也支持TAB补全），选择好之后，回车会将相应的内容复制到对应的目标位置。注意：复制的内容可以是用Mark方式选择的区域，或者当前光标所在的子树，在执行 C-c C-w 之后有提示。访问Refile的目标对应Buffer输入 C-u C-c C-w输入之后，会提示和 C-c C-w 一样的信息，选择相应的位置后，会直接打开相关的文件。访问上次Refile所处的文件Buffer输入 C-u C-u C-c C-w类似前面，访问的是记录上次Refile的文件Buffer，并自动定位到上次Refile目标的信息之上。4.5 归档具体配置方式可以参见： C-h v org-archive-default-command, C-h v org-archive-location, C-h v org-archive-save-context-info4.5.1 配置归档位置和归档后附带信息将内容根据“年-月-日-包含文件名的标题-被归档的标题”的层次，归档在指定的_archive/session&lt;年月&gt;_archive.org文件中，归档之后，被归档节点属性包含：时间、文件、标签、todo状态、分类、节点在归档前的路径等信息。;;location for archive(setq org-archive-location (concat org-directory "gtd/_archive/" (format-time-string "%Y%m") "_archive.org::datetree/* Archive from %s"));;information added to property when a subtree is moved(setq org-archive-save-context-info '(time file ltags itags todo category olpath))注意，以上归档文件名为类似 session201511_archive.org ，这里的时间应该是启动Emacs会话的时间并非归档操作的时间。4.5.2 归档命令输入 C-c C-x C-s4.5.3 举例如上配置之后，例如*Title1**DONE sub title1 CLOSED: [2015-11-27 五 14:17]- State "DONE"       from              [2015-11-27 五 14:17]***subsub title1****DONE subsubsub title1CLOSED: [2015-11-27 五 14:18]- State "DONE"       from              [2015-11-27 五 14:18]****subsubsub title2****subsubsub title3***subsub title2**sub title2注意以上格式中，标题前面应该和'*' 之间有一个空格。执行 C-c C-x C-s 之后，会在相应路径生成一个201510_archive.org文件，追加了如下内容：*2015**2015-11 十一月***2015-11-27 星期五****Archive from orgmodetest.org*****DONE subsubsub title1CLOSED: [2015-11-27 五 14:18]:PROPERTIES::ARCHIVE_TIME: 2015-11-27 五 14:23:ARCHIVE_FILE: ~/test/emacs/orgmodetest.org:ARCHIVE_TODO: DONE:ARCHIVE_CATEGORY: orgmodetest:ARCHIVE_OLPATH: Title1/sub title1/subsub title1:END:- State "DONE"       from              [2015-11-27 五 14:18]4.6 便于整理周报的记录技巧按照时间列出处理情况为便于整理工作周报，可以将每天的记录工作首先按日期时间在每个TODO项目上创建子标题。每个子标题下记录详细工作日记日志。例如：*[2015-10-30 五 09:43] xxxxxx如果需要在agenda中列出时间，那么使用激活的时间戳即可。标题尽量简单叙述当前的工作情况。写周报的时候只看这个地方就行了。另外，每个TODO任务中如果设置了状态切换的日志，这样可能会和处理进度的子标题有些意义冲突，目前对此不做过多考虑，不会在状态切换日志中记录过多信息，并且状态切换日志仅在wait和cancel中记录。经过以上方式之后，做周报时，大致可以按照每个TODO项的日期时间标题来进行搜集。4.7 orgmode与mobile org整合MobileOrg是Mobile端的一个应用程序，运行在Android（也有IOS的MobileOrg）;Org是PC端Emacs的一个插件应用，对应其Orgmode模式。对其具体操作方式在orgmode的文档中有专门的介绍，并且不断更新，这里讲述相对固定的管理方式方面的内容。描述如何用Org创建可以通过MobileOrg显示的文档格式，以及如何将Mobile端的MobileOrg中修改和捕获的笔记，集成到PC端的“主” Org mode系统中（即Org与MobileOrg的同步），不涉及Agenda相关的操作。4.7.1 配置为了在MobileOrg中能够修改tags和TODO状态，你应该在PC端设置好自定义变量： org-todo-keywords 和 org-tag-alist ，使它们包含所有需要修改的重要的tags和TODO keywords，哪怕每个文件只使用其中的部分内容。MobileOrg也能通过in-buffer settings来为你提供TODO和tags设置，但是它只能读懂这些变量中的那些设置好的TODO状态集合以及tags。假设我们想要使PC上的Org与移动设备上的MobileOrg保持内容同步（底层通过git机制，也可以是云存储、ssh、ftp等机制）。这里给出为实现这个目的，在PC需要做的配置工作(移动端的MobileOrg做为辅助工具，其配置和操作非常简单，在适当的时候会提及)。4.7.1.1 在PC上添加使用MobileOrg的emacs配置主要包括对Emacs中org-mode模块的加载以及与MobileOrg同步的路径。例如:;;Sync with mobileorg(require 'org-mobile);;mobile stage(setq org-mobile-directory "/home/miracle/mygitrepo/pocket/MobileOrg")另外，可以通过 org-mobile-encryption-password 设置加密方面的内容。在后面我们可知，在PC上的orgmode中有特定的命令将相关内容推送到这个目录中。4.7.1.2 在PC上添加同步orgmode和MobileOrg的emacs配置主要包括PC端和MobileOrg端状态与标记的设置，PC上被推送orgmode内容的源文件路径，以及PC上接收MobileOrg修改的缓存路径设置。为被推送文件定义只属于该文件的状态和标记被推送的文件可使用文件选项定义相关的状态和标签（实践发现不用定义文件的状态和标签也行），定义内容最好和PC上的相关状态变量(即 setq org-todo-keywords )一致，或者是其子集。如果使用文件定义状态，那么可以将用于push到MobileOrg的文件中的状态设置选项如下：#+TODO: INBOX(i!) NEXT(n!) LATER(l!) WAIT/FORWARD(w@/!) MAYBE/FUTURE(m!) | CANCEL(c!) DONE(d!)标记的设置类似。设置状态关键字和被推送至MobileOrg的文件列表路径如下;;set status for TODO.(setq org-todo-keywords '((sequence "INBOX(i!)""NEXT(n!)""LATER(l!)""WAIT/FORWARD(w@/!)""MAYBE/FUTURE(m!)""|" "CANCEL(c!)" "DONE(d!)")))   ;;mobile push(setq org-mobile-files (list (concat org-directory "gtd/mobile_org")))设置接收来自MobileOrg内容的“缓存”目标文件路径如下;;mobile pull(setq org-mobile-inbox-for-pull (concat org-directory "gtd/from_mobile.org"))4.7.2 原理4.7.2.1 Mobile端的Mobile Org与PC端的Org同步当我们在MobileOrg中与PC端的Org同步时，需要知道它不仅仅是从PC端获取（mobile端的pull）相应org文件用于浏览，同时也会追加(mobile端的push)被captured的entries，并且指向被标记和修改的entries，这些内容被汇总在同步目录( org-mobile-directory )中的 mobileorg.org 文件里。4.7.2.2 PC端的Org与Mobile端的MobileOrg同步PC端的Pull获取MobileOrg修改内容(PC端的pull)的时候，会将这些信息从 mobileorg.org 先转移到到 org-mobile-inbox-for-pull 对应的文件中，并对指向的被标记的内容进行进一步操作，进而将能够自动处理内容同步到对应的文件中。Pull的过程大致过程如下:Org将会将 mobileorg.org 中的所有entries移动到 org-mobile-inbox-for-pull 所指向的文件（假设为mobileinbox），每个被捕获的entry和编辑事件都会被做为这个mobileinbox中的顶级entry而存在。（进行操作之后， mobileorg.org 将会被清空）当将entries移动到 org-mobile-inbox-for-pull 指向的文件之后，Org将会开始执行在MobileOrg进行的修改。有些修改直接就会被应用了不需要额外的用户交互（例如修改tag、TODO状态、标题、正文文本可以被简单的应用）。而需要额外动作的entries会接收到一个:FLAGGED:的tag，这样它们才会很容易地被找到。当应用修改或者寻找一个entry之时出现了问题，目标entry将会保持在 org-mobile-inbox-for-pull 中，并且被标记一个错误信息，我们需要之后手动解决这些问题，并将对应内容(entry)转移到期望的位置。(不熟悉)Org之后会生成一个包含所有flagged的entries的agenda view，用户可以遍历这些entries来做一些必要的动作。如果在对MobileOrg中的entry进行标记的时候一个note已经存储了，那么这个note会在光标处于对应agenda line的时候在回显区域显示出来。关于 ?在哪个特定的agenda中按下 ? 将会在另外一个windows中显示整个被标记的笔记(flagging note)，也会将它push到kill ring中。所以，你可以在这个entry中使用 ?z C-y C-c C-c 保存哪个标记笔记为普通笔记。连续键入 ? 两次将会体同将 :FLAGGED:标签联通记录的标记笔记（flagging note）（在一个属性中被保存）一起被移走。这样，你可以用此来表示这个 flagged entry的处理已经完成。如果你不能够直接处理所有的flagged entries，你可以通过 C-c a 回到这个agenda view。PC端的Push推送内容到MobileOrg端(PC端的push)的时候，会推送PC上设置的 org-mobile-files 对应的文件，该变量对应的文件路径是相对 org-directory 的路径，默认使用 org-agenda-files ,被退送的目标是 org-mobile-directory 设定的位置。Push的过程大致如下：拷贝 org-mobile-files 中的内容到同步目录 org-mobile-directory 中，文档中提到，如果待推送的文件是一个链接文件，那么链接文件名称需要和源名称一致。创建特定的agendas.org文件，这些文件可以是用户自定义的agenda view，由 org-mobile-agendas 来设定。最后，orgmode会写一个 index.org 文件，这个文件包含所有到其他文件的链接，Mobile首先在Server中读取这个文件，然后把这个文件中列出的所有agendas文件和org文件下载下来，为了加速下载过程，MobileOrg只读取checksums3被改变的文件。4.7.2.3 Org与MobileOrg的同步目录我们需要注意，在前面的讲述中所涉及到的同步，其实暗含了两种同步：Mobile端的MobileOrg与PC端的Org之间的同步（通过设定一个同步目录做为中转）这个前面也讲到，主要是Mobile端的Sync（包含Push/Pull）操作，以及PC端的Push/Pull操作。同步目录在云端与PC/Mobile端的同步前面MobileOrg和Org同步之时，需要经过它们之间的一个共通的“同步目录”。这个目录在Mobile端和PC端的内容和结构需要首先保持一致，才能保证后续MobileOrg和Org之间数据的同步一致。所以，我们在同步PC端的Org与Mobile端的MobileOrg之前，先将PC端和Mobile端的目录通过某种方式进行同步。这里同步目录的方式使用用git进行，PC端和Mobile端之间的同步目录用某个git托管服务器进行管理（例如github、bitbucket、或者自己的服务器），任意端的同步目录中数据发生变化后都要推送到托管服务器中，而任意端要读取最新数据都需要从托管服务器中拉取数据，同步目录中的数据更新之后，再进行后续MobileOrg和Org的数据更新。我们也可使用其它方式管理同步目录，比如云存储（百度云、DropBox等）、或者ftp、webdav、ssh等。另外，Mobile端的git可以使用pocketgit工具。4.7.3 同步操作4.7.3.1 PC端的Org推送（Pull）命令如下：M-x org-mobile-push 推送之后，会在同步目录（即 org-mobile-directory 对应的路径）中建立 org-mobile-files 对应文件列表的路径结构，并拷贝相应文件到其中。4.7.3.2 PC端的Org拉取（Push）命令如下：M-x org-mobile-pull 运行之后，其对应的 org-mobile-files 便包含了和MobileOrg同步的内容。4.7.3.3 Mobile端的MobileOrg同步（Sync）这里使用Android版本的MobileOrg，大致如下：首先设置好同步目录，然后选择软件界面中的"Sync"按钮，即可完成同步（包含Pull和Push）。4.7.4 使用举例PC上配置好相关变量和目录手机上安装好MobileOrg也设置好同步目录将PC和手机上的同步目录用github/bitbucket管理PC上同步目录更新： git/pullPC上记录之前运行： org-mobile-pull 可以看到手机上修改的内容。PC上记录，记录之后运行： org-mobile-pushPC上的git同步目录上传修改： git add/commit/push手机上的git同步目录下载更新： git pull手机上的MobileOrg同步(点击Sync)手机上看到PC修改的内容手机上修改并同步（点击Sync）手机上更新同步目录： git add/commit/push回到步骤4。4.7.5 其它目前发现，该功能列表中的段落，无法识别断行？对复杂的管理不是非常实用，相对而言，mobile org中Capture功能相对实用一些，可以将片段捕捉下来，同步到电脑上(但是同步的过程也比较繁琐)。参考相关文档：MobileOrg4.7.5.1 改进已经将状态文件冠以 _ 前缀，便于在Agenda View中集中浏览，例如: _inbox.org, _next.org &#x2026;。每一步处理中，处理子项的步骤可以按照层次冠以 ---- 前缀， n层子处理步骤冠以n个 =-&#x2014;=前缀。例如：**NEXT test1***----&lt;2015-12-21 一 16:17&gt; xxx1***----&lt;2015-12-21 一 16:17&gt; xxx2****--------&lt;2015-12-21 一 16:17&gt;xxx2.1****--------&lt;2015-12-21 一 16:17&gt;xxx2.2这样显示便于在Agenda中一目了然哪些是子待办事项，以4个为单位因为4个字符比较容易输入。回顾的细化：短期回顾简单处理时，会将特定状态关键字的任务从状态文件间迁移，稍复杂的处理会将任务直接迁移至特定文档中（在该文档中做为属于该文档的任务）；中期处理之时，除了对应状态关键字和状态文件，也对状态关键字的任务必要时迁出状态文件进入特定文档中。5 WAIT/FORWARD FAQ [8/11]([72%])State "WAIT/FORWARD" from "NEXT"       [2015-11-27 五 15:07]  Wait for all done.State "NEXT"       from              [2015-11-27 五 15:07]5.1 DONE 如何划分任务状态以及存放的文件？State "DONE"       from "NEXT"       [2015-10-08 四 10:23]参见: 任务状态 和 划分文件5.2 DONE 如何实现任务管理的基本管理？State "DONE"       from "WAIT/FORWARD" [2015-11-27 五 16:13]State "WAIT/FORWARD" from "LATER"      [2015-11-27 五 16:13]  wait for moreState "LATER"      from "NEXT"       [2015-11-27 五 16:13]State "NEXT"       from "INBOX"      [2015-11-27 五 16:13]参见:实现Orgmode任务管理的基本管理5.3 DONE 如何设置交叉引用?State "DONE"       from "NEXT"       [2015-11-26 四 17:51]参考：交叉引用5.4 DONE 如何设置优先级别?State "DONE"       from              [2015-11-26 四 18:00]参考：设置优先级别5.5 DONE 如何迅速捕获临时产生的任务，以及将各个任务标题在状态文件中进行转移？State "DONE"       from              [2015-11-30 一 10:38]参见：Capture-Refile-Archive5.6 DONE 如何设置归档?State "DONE"       from "NEXT"       [2015-11-27 五 14:54]参见：归档5.7 DONE 便于整理周回顾?State "DONE"       from              [2015-11-27 五 10:35]参见：便于整理周报的记录技巧5.8 DONE 如何将PC与移动端的orgmode整合?State "DONE"       from              [2015-11-27 五 11:02]参见：orgmode与mobile org整合5.9 LATER 杂乱问题State "LATER"      from "NEXT"       [2015-11-27 五 16:13]State "NEXT"       from              [2015-11-27 五 15:29]这里描述一些无法分类是杂乱问题。进入 inbox.org的 INBOX 的任务，在回顾的时候，首先切换其状态，然后再refile到对应的状态文件？目前是对于到状态文件的任务，是先切换，再refile；对应其它特殊文档内部的TODO任务，refile与切换次序随意。每个状态，工作日志记录到有状态切换的日志中，还是也可能根据自己情况记录工作日志？不用都加note，也可每个状态切换都加详细的note。折衷起见，主要处理信息还是列在后面。状态切换的列表中，可以添加每次关键的一些步骤。比如NEXT状态中，又获取到一些新的信息，可以切换状态增加NEXT-&gt;NEXT的时间戳，然后附上一个简短笔记“xxx发生了”。5.10 NEXT 改善归档与done/cancel策略State "NEXT"       from              [2016-02-03 三 09:43]之前都是将done和cancel状态的内容放置目录中，按照月份存放相应状态内容，原因是相应状态的内容是属于不断积累增多的，不可能只放在一个文件中。考虑到归档的功能，其实将done/cancel内容放置在一个文件也可，只需要定期进行归档即可，积累的内容会不断地移动到归档中，而归档又可根据日期来进行划分。而wait/forward中的内容，需要再考虑如何进行，目前暂不设定归档， 设置的方式也仍然采用目录的方式，以便学习时能够知道目录目标的设置方式。5.11 NEXT 改善refile的配置方式State "NEXT"       from              [2016-02-03 三 09:46]将refile目标放置到一个文件中，有时候会出现问题，目前不再使用这个方法。直接将refile的目标配置到配置文件中，这样更为保险。;;set agenda files(setq org-agenda-files (list                         (concat org-directory "gtd/_next.org")                         (concat org-directory "gtd/_later.org")                         (concat org-directory "gtd/_wait_forward.org")                         (concat org-directory "gtd/_maybe_future/")                         (concat org-directory "gtd/_cancel.org")                        (concat org-directory "gtd/_done.org")                         (concat org-directory "gtd/mobile_org/_mobile_inbox.org")                         (concat org-directory "gtd/_active")                         (concat org-directory "gtd/_review")                         (concat org-directory "gtd/output/")                       ))      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2015-11-27 五]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-11-27]<a href="/categories/note/gtd_with_orgmode.html"> 使用orgmode进行GTD管理 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'GTD管理方式'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 前言2. 概述2.1. 执行平台2.2. 良好GTD系统应该具备的特性2.3. 主要内容3. 任务和项目3.1. 项目3.2. 任务3.3. 举例说明4. 管理思路4.1. 任务管理4.2. 项目管理5. 执行方式5.1. 任务状态5.1.1. 支持的任务状态5.1.2. 任务状态与生命周期5.2. 项目与回顾5.2.1. 项目状态5.2.2. 项目生命周期6. 建议6.1. 原则6.1.1. 不要将任务状态设置太多6.1.2. 任务不一定全部要处理完毕6.1.3. 任务从“收集”中拿出后，不应该再放回去6.1.4. 进行的任务要先移动至“下一步”状态，再进行处理。6.1.5. 处于“下一步”状态的任务不宜过多6.1.6. 处于“稍后”状态的任务，要么会回到“下一步”，要么会被放置其它状态6.1.7. 大多数GTD管理不需要过于复杂的特性6.1.8. 多操作多整理多回顾有助获得正能量6.1.9. 在特定环境下可借助特定工具扩展GTD来提高效率6.2. 推荐6.2.1. Orgmode6.2.2. DGT GTD6.2.3. 任意一个带有分类功能的便签7. 其他7.1. 使用GTD思想进行内容管理7.1.1. “任务管理”方面7.1.2. “内容管理”方面7.2. 将GTD管理中产生的数据进行内容管理7.2.1. 管理思路7.2.2. 举例7.3. 使用GTD标签管理信息7.3.1. GTD标签7.3.2. 实现方式7.3.3. 扩展7.3.4. 关键7.4. 使用GTD方式管理邮件7.4.1. 实现思路7.4.2. 实现举例7.5. 使用GTD方式管理工作文件7.5.1. 思路7.5.2. 实现举例7.6. 杂乱7.6.1. 任务状态7.6.2. 任务属性7.6.3. 任务性质7.6.4. 优先级划分7.6.5. 劳逸结合7.6.6. 回顾的解释7.6.7. 管理回顾的经验7.6.8. 关于参考7.6.9. 如何处理“项目分类”与“状态分类”实现的冲突7.6.10. 自我管理的演化过程7.7. 参考资料8. WAIT/FORWARD FAQ [%] [/]8.1. NEXT 如何通过orgMobile进行管理？8.2. INBOX 回顾的内容，没有完成的可以用链接的方式将任务与回顾相互引用，任务完成之后，可以考虑将其直接集成到回顾中，不用链接，防止过于分散。1 前言这篇文章并不是以教程目的存在，其实是在本人实践GTD方式半年多的时间里，总结的文档。其中肯定有不确切或者错误之处，但是理解的方式因人而异，希望此文能够为学习GTD以及想高效组织和管理自身生活的朋友们带来一些提示。文中全部基于文本方式实现并无配图，配图可能会让理解更为直观，但是目前看来更多只能做为点缀，细读本文的读者应该不用借助配图便能获取其中的思想，配图可能会在将来更新之时给出。文本原始格式是Orgmode文本，如果看到网页本版或者其它更多格式的本文，应该都是基于该语法导出的文章。采用git方式进行版本管理，所以可能会在完善更新过程中不断发布新的版本。2 概述GTD是一种思路和方法，它可以渗透在我们生活的方方面面，而不仅仅做为任务管理的手段而存在。这里给出的只是是众多GTD管理方式的一种，是基于个人目前应用与实践情况而采用的GTD管理方式；GTD管理并不依赖特定工具，它可以在个人实践过程中，根据情况逐渐完善与改进；不同场景和环境下可能会借助不同的方式或工具来使用GTD，但是这些方式或者工具等都具有一种共性，这个共性就是GTD的思想。2.1 执行平台本文中叙述的GTD方法是基于一些常见的可分类、可贴标签、具有内部引用链接等功能的笔记进行，如为知笔记；但是讲述的方法会尽量避免依赖外部环境的特性（比如标签和引用的功能不一定在所有的工具中都有，Windows下的记事本就只能支持文本编辑）而强调方法的通用。2.2 良好GTD系统应该具备的特性添加对特定环境的特性依赖能使得在该环境下的GTD管理更有效率，但是对于一个良好的GTD方式，个人认为应该具有如下特性：在现有环境中，应该能够方便地添加适合当前环境的特性依赖以提高GTD系统的效率。更换环境之时，原有的GTD系统应该能方便地迁移到新的环境下继续运行。切换到新环境之后，应该能方便地去掉对原有环境特性的依赖。其实，这几点分别是对GTD系统扩展性、通用型、灵活性方面的要求，具有这些特性，有助于增强其健壮与稳定。任何系统在完善之前，首先要保证它有足够强的生存能力，最简单情况下，可以只凭借分类的文件系统、或纸质笔记、甚至只凭借自身的记忆（如果能够保证不会遗忘的话），实现GTD的管理。^_^2.3 主要内容任务和项目管理思路执行方式建议其他3 任务和项目3.1 项目这里的项目，是一个需要处理的事情、计划、或过程。它是日常生活、工作、学习中，我们所有要处理的、一系列相关的事务的统称，不同的项目代表不同类的事务。项目使得我们日常凌乱的处理事务，有了一个明确的归类。3.2 任务这里的任务不像项目那样笼统，而一定是可以明确执行的一个步骤，它可能属于某个项目。确定的任务可以让我们平时行动之时，目标明确，精力集中，无需被更多琐碎的处理判断归纳分类等而分心。3.3 举例说明例如：“学习英语”，这就不是一个任务，它是包含许多步骤的过程，对应这里所讲述的项目；  而“背诵5个单词”，就是一个具体的任务，它属于“学习英语”这个项目的一个子步骤；  我们每完成“学习英语”中的一个任务，就距离“学习英语”这个项目的目标更近一步了。  我们在真正学习英语的时候，每一个时刻其实都是在集中精力做其中的一个任务，期间不可能还做其它的事情；比如“背诵5个单词”的时候，我们不应该还要分出心来思考：“学习英语需要先背诵一定的单词，然后尝试阅读，学习祈使句语法……”；我们只需要背诵完这5个单词，别的事情是规划的问题，会在完成当前“背诵5个单词”的任务之后，来专门集中决策一下下一步需要做的事情。总之，项目是需要规划的，任务是需要执行的，而规划是确定任务的。在一个项目中，将规划和执行分开，可能会提高完成的效率，而能够高效的完成所有的项目，会提高我们的生活质量。另外，并不是所有的项目都一定要完成，GTD只是让完成的效率尽量高，尽量减少压力，而非一定要将其中的项目完成。4 管理思路这里的GTD系统，实际重点在于管理任务的方式，项目在GTD中主要是用来反映将其中相互关联的任务集中起来便于回顾，对于复杂项目的管理方式，可能需要额外考虑。目前大致采用如下方式管理项目和任务，今后有好的方式会逐渐改善。4.1 任务管理每条任务使用单独一条笔记来表示，所有的任务都有自己的状态，状态通过目录来管理，具体见后面。使用本方式管理任务，目前比较弱势的方面是缺乏时间提和醒方面的内容(也许是为了增强其简洁并且可移植，而导致的缺陷)，无法让任务随时间而迁移状态，无法合适的指明任务的时间属性，以及无法合适的在恰当的时间进行提醒。所以日常经常进行的、并且对时间提醒方面依赖不大的任务可集中在这里进行（例如工作日志）。而需要依赖其他特性(如提醒)的任务内容，可考虑借助工具辅助完成，如DGT GTD、中华万年历、等等。4.2 项目管理每一个项目用一条回顾来表示，而每条回顾用一条笔记来表示，而所有项目类似任务，通过项目的状态目录来管理，具体见后面。使用本方式管理项目，目前比较弱势的方面是暂时还无其它合适的方式管理，因为项目也是随时间动态变化的，随着时间的推移我们会遇到的新的项目和计划，所以用目录或标签来表示项目也不太合适（经常建立新标签或者目录会使得系统越来越复杂），这里暂时用回顾表示一个总体的项目，每个回顾用一条笔记表示，期间的产生的各个行动步骤变成特定状态的GTD任务进行管理。执行任务时的一些关键的步骤会纳入到这个回顾系统中，回顾作为总体索引，也用来表示一个计划，期间会引用到本GTD系统内的任意一个其它的任务或者回顾等，也有助于保持整个GTD系统的有序。5 执行方式5.1 任务状态每种任务同一时间只可处于一种状态，所以可以考虑用目录方式实现任务状态。  5.1.1 支持的任务状态“收集”当遇到一个需要处理的任务之时，我们需要首先迅速把它记录下来，可以只简单给出一个标题以便提示等等，之后在空闲时会对其进行进一步处理。这个最初出现的任务，可以没有经过任何整理，此时它处于“收集”状态。它是任务出现的初始状态，是所有内容流入GTD系统的入口。“下一步”同一时段我们一般只能处理有限的任务，根据实际情况，我们可能会从所有任务中选出一部分进行处理，这些已经开始进行处理的的任务，便存在这里，处于“下一步”状态。它是推动GTD系统运作的动力，使我们更集中精力于应该做的事情上来，而不被其它还没有开始的任务扰乱心神。“稍后”这里的任务也是应该做的，但是由于日程或者其它原因，需要将一些相对不重要的任务暂停，推迟一段时间再做，这时任务便处于“稍后”状态，它在GTD中起到缓冲紧张度的作用。“等待委派”有些任务在自己这里已经没有什么可以做的了，需要等待其它方的处理之后才能继续确认下一步的进行状态，或者转交给其他人处理，这可以将任务转给别人，这样的任务就处于“等待委派”状态，它可减轻GTD系统的负担。“将来也许”类似推迟，不过这里的内容表示没有一个期限的“推迟”，这里的任务相对推迟的任务来说也更显得“不重要”一些，这些“以后用空再做”的任务都放在这里，处于“将来也许”的状态。这个分类可以允许我们大胆的将想做的列出，并且可以不用对列出的事情“负责”，想做就做，不做也不会消失，它能大大减少GTD系统的拥塞程度。“已完成”一个任务完成之后，可能以后也会引用，也可能不会，这些已经处理完毕的任务，便成为“已完成”状态，它是GTD系统的历史。“取消”有些任务开始可能在“下一步”，过后又变成“推迟”了，再过后又“将来也许”，再过后，可能都没有必要执行它了，不删除它们，是因为可能它们将来还会有用，这些任务便处于“取消”的状态，相当于GTD系统的回收站。5.1.2 任务状态与生命周期在上述状态下，我们给出一个描述任务生命周期的例子。a.阅读英文文档时，忽然发现需要背诵一些特定的英语单词，于是向“收集”状态目录中，添加一条“背诵英语单词”，然后继续工作。b.空闲时，对“收集”状态的任务处理，这时发现“背诵英语单词”这条任务比较重要，于是把它纳入到“下一步”，准备之后就进行。c.开始处理任务时，首先看“下一步”是否有任务，发现“背诵英语单词”这条任务， 于是开始进行学习，学习过程中不断的对该任务对应的笔记进行记录总结汇总更新等。d.学习一定时间后单词还没有背完，但是在"下一步"又有其它的任务更为重要需要处理，于是开始处理其它的任务。e.在处理“下一步”状态中的任务时，不断的有其它更多的重要任务需要处理，学习英语单词暂时还不能继续，于是把它从“下一步”移动到“稍后”状态，待处理完手头的任务之后再继续处理此任务。f.处理“下一步”状态的任务时，不断的有新的比背诵英语单词更重要的任务，由于有重要的任务在先，被移动到“稍后”状态。g.待“下一步”的任务处理完成后，再看"稍后"状态的任务，找到其中重要的任务，将它重新迁移到“下一步”中，准备进行处理。h.处理完“下一步”的任务，再次从“稍后”状态的任务中， 选出重点的进行处理，这时发现“背诵英语单词”这条任务优先级很低，可能短期内不会再进行了，于是将它移动到“将来也许”中。i.某日实在清闲，在“将来也许”中随便拿出一个叫做“背诵英语单词”的任务，放到“下一步”之前，发现它没有必要了，于是放到“取消”中，表示这个任务不执行了。j.很久以后，浏览“取消”的任务，发现“背诵英语单词”，感觉最近要做，于是放到“下一步”。k.到“下一步”中，取出一条“背诵英语单词”的任务，开始进行，直至完成后，将其移至“已完成”中。至此，“背诵英语单词”这条任务结束。5.2 项目与回顾项目回顾是对GTD系统中任务的有机组织，每条回顾都包含相关的其它子项目或者计划、以及诸多任务处理状况的汇总。它可以使GTD系统更为有序，也便于将来跟踪相关的任务和情况。  由于项目是一系列相关任务的组合，所以每个项目借助一条回顾来表示；而我们遇到的项目的分类和数目经常随时间变化，所以用每条笔记而非目录表示一个回顾，进而表示一个新的项目。同时，类似于任务的管理，由于状态是所有项目相对通用和固定的属性，所以我们用不同的目录来表示项目状态，存放所有项目，为便于区分，表示项目的目录以“#”作为前缀。5.2.1 项目状态这里用来存放项目回顾的主要状态目录有：  “#活跃”有些任务，如学习计划等可能需要反复执行，或者有些项目正处于活跃处理过程中，从中会不断衍生出新的任务到相应的任务状态。这样的项目便处于"#活跃中"状态，当项目进行到一定程度不再特别活跃的时候，可能会进入“#项目回顾”状态。“#回顾”是对相对不活跃的项目汇总，包含已经完成或者基本明朗的项目。在进行任务时，并不是所有任务都要建立回顾。当发现一些任务需要梳理其关系和追踪的时候，为这些相关的任务建立一个回顾，可起索引汇总的作用，在日后回顾这些复杂的任务之间相关的过程之时也可参考。实际上有些项目，开始是做为任务进入到“收集”状态的，执行一段时间之后，知道了它可以做为一个项目回顾后，便将其放置到相应的项目回顾目录中。从这点上来讲也可看出，其实收集既是项目的初始状态，也是任务的初始状态，是任务进入整个GTD系统的入口。5.2.2 项目生命周期项目的生命周期一般是：收集、活跃、回顾；而需要重复执行的项目，其回顾放在"#活跃"目录中。6 建议6.1 原则建议在实现GTD时，能遵循如下的原则：  6.1.1 不要将任务状态设置太多过多的状态会导致GTD系统的复杂，处理任务时反而会因此分散精力。6.1.2 任务不一定全部要处理完毕GTD不是为了完成任务，而是为了减轻压力，使用GTD还能辅助记忆和梳理，减轻大脑记忆的负担。6.1.3 任务从“收集”中拿出后，不应该再放回去收集箱是暂存新流入和产生的任务，它是GTD内容的主要来源，而非为状态迁移而存在。6.1.4 进行的任务要先移动至“下一步”状态，再进行处理。这样能保证正在进行的任务集中在“下一步”状态，将精力只集中在“下一步”中的任务，而无需分散精力在其它状态中寻找需要处理的任务。6.1.5 处于“下一步”状态的任务不宜过多“下一步”是当前真正正在处理的任务，能够同时处理的任务是有限的，这里的任务不宜逗留过久，迟早会被处理成其它状态。过多的“下一步”任务，会为大脑和心里造成很大压力，同时。6.1.6 处于“稍后”状态的任务，要么会回到“下一步”，要么会被放置其它状态一些相对比较重要但是还来不及处理的任务，不放在“下一步”而是放在“稍后”中，可以起到缓冲压力的作用。这里的内容实质是被推迟的任务，如果不会被推迟很久，迟早会回到“下一步”状态；如果它可能会被推迟很久，那干脆将它放置“将来也许”甚至“取消”中。6.1.7 大多数GTD管理不需要过于复杂的特性执行GTD不应当过度依赖工具，只要可以创建内容（表示任务），并且能将内容归类（表示状态），完全可以手动完成绝大多数GTD管理。6.1.8 多操作多整理多回顾有助获得正能量经常回顾和整理自己的GTD系统，可以保持系统有序，还能给自己反馈正能量。GTD中表示待办任务，处理任务时便有一种做事情，也看到了效果的感觉。有一种说法是，这些“成就”会被大脑做为努力一段时间的“奖赏”，在手动处理GTD的同时会不断地有一种亲身获得“奖赏”的感觉。直观一点说，执行任务之前，会在心里不自觉地讨厌列在表上的任务条目，当完成任务之后，手动管理会亲身体会到将讨厌的那一条任务删除的成就感，尽管每次的成就很少，但是众多这样的反馈不断的激励着大脑，却能给自己带来意想不到的力量。6.1.9 在特定环境下可借助特定工具扩展GTD来提高效率除了基本的GTD功能，对于特定工作环境，一些高级属性借助工具扩展，可能会有助提升效率。如今日待办、或者提醒，场景或任务跟踪等等，在一些工具中有特定的表示和组织方式，设置好相关属性后，任务会自动迁移、或者提醒等等，避免了手动设置。尽管几乎不用进行手动设置了，但是想要保持自己GTD的有序和获取更多的执行动力，还是要经常回顾。可以借助相关的GTD管理工具，这里介绍几个：6.1.9.1 DGT GTD：是安卓系统下非常全面的GTD工具，操作便捷，记录迅速，自定制功能丰富，支持备份，自定义同步等，只是刚开始需要稍微熟悉一下其操作的方式。简单说，两个特点：“丑”（不是很丑）、“好用”（非常好用）。6.1.9.2 Doit.im：支持多平台，云同步，界面简洁便于初学者使用和理解GTD的工作流程，但是有些功能需要收费才能实现。6.1.9.3 Omnifocus：没有亲自用过，根据许多文章中的介绍，可以知道这是一款重量级的华丽版的IOS下的GTD管理工具，入门门槛高，但是功能极其强大。6.1.9.4 2Do：也是一款IOS下好用的GTD管理工具，功能强大，入门相对简单。6.1.9.5 Wunderlist(奇妙清单)：简洁的界面，不过在国内同步功能比较慢。6.1.9.6 toodledoIOS下一个比较流行的GTD工具。6.1.9.7 Orgmode：这个其实是基于文本的标记语言，是Emacs的一款著名的编辑模式插件，但是功能非常强大，目前已经在许多地方支持（如vim、github、IOS、Android应用上等）。它的初衷是项目管理相关的目的，其中就包括能够实现GTD管理的相关内容，但是功能不仅限此，它也可以用来记录笔记，记录的笔记基于大纲模式，有一定的所见即所得功能，但是更强大的是“所想即所得”的特性，是word远不能及的。这个工具/语言不限于平台，只需遵循orgmode语法即可，配合Emacs进行使用会使得效率极高、扩展性几近无限。Orgmode能够完成的功能也会随掌握程度的提升而丰富：如果简单掌握，那么Orgmode属于轻量级标记语言中的一种；但是如果需要更多的功能（如导出发布为各种格式），则需要进一步的学习。关键的是，Orgmode文件是纯文本格式，只需纯文本格式的内容便能实现它的全部功能。6.2 推荐这里算是给本文以及实际中习惯的工具做一个“广告”吧。具体如何理解和接受，还要看各位读者的喜好。结合实际经验，这里给出用于GTD管理的工具或方法选取的建议。如果一个工具或方法它存放数据的形式越原始，越开放，记录越便捷，其适用度越高，也越容易被人接受（我想相对于直观的文本格式内容，哪些数据库格式、或压缩格式、或版本控制数据格式、以及更多其他特定格式的数据文件，更容易让人接收应当是文本格式的内容吧）。毕竟数据是自己的，工具只是外壳；访问数据的便捷可能需要借助特定的工具或方法，但是如果脱离了特定的工具方法，数据仍然不受影响才是多数人关心的。对于GTD管理的工具和方法，做如下推荐：6.2.1 Orgmode它其实已经超出了工具的范围，它实际属于一种语言或者规则、方法，功能比较全面，不仅可以GTD管理，还能做项目管理、内容管理等等。Orgmode可以让我们记录的数据以最原始的方式（直观的文本方式）来展示出来，而访问数据的方式一方面可以通过Emacs的orgmode高效进行，另一方面也可脱离相关工具，只要掌握Orgmode的一些约定语法我们仍可以用最原始的方式（如记事本）访问我们的数据，更能结合使用各种版本控制工具来管理我们的数据等。另外，我们还能将Orgmode的数据导出为当前流行的各种格式（如Html、pdf等），当然，越复杂的功能，就越需要更长时间的学习，如果我们没有足够的时间，Orgmode的简单功能也是够用的。因为期间会涉及到Emacs的使用以及Orgmode的配置等，篇幅关系会有专门的文档对Orgmode进行介绍，这里不详细说了。6.2.2 DGT GTD在安卓系统上，它也将其工具的特性发挥到了极致。几乎支持所有你能想得到的GTD管理信息，也支持数据导出、共享、备份等等，最重要的是，记录非常方便，非常适合记录一些瞬间涌现的灵感等等，当然，为避免日后可能会迁移数据引起的问题，重要的数据还是尽早导出到一种通用的存储方式组织好（例如OrgMode）。6.2.3 任意一个带有分类功能的便签毕竟不是所有人都使用Android系统，如果找不到或者没有或者不想学像DGT GTD那样的工具，可能会有些不方便，即便如此我们仍然可以进行GTD管理。我们各自的系统中一般也都能找到一个类似“便签”、“记事本”的工具，如果没有，一般也都能够找到对应系统的一款相关软件。最后一个方法，也就是：结合本文中介绍的方法以及你当前系统上已有的某个相对便捷的、带有“分类”特性的记事软件，也能实现基础的GTD管理。方法很简单，就是将本文中提到的几个GTD状态做为分类，每一篇的笔记内容做为GTD任务（例如，可以使用比较常用的云笔记、中华万年历、为知笔记、evernote、甚至系统自带便签来进行）。如果以上提到的环境都不具备，也并不代表不能进行GTD的管理了。毕竟GTD只是一种方法，如何使用它，还是要看使用这个方法的人。正如前面已经提到的，每个人都有自己的方法来实现GTD，只有一个纸和一支笔，甚至只有一个好的记忆方式，也一样能实现GTD的管理。因为实现GTD最本质的东西只需两个条件：记录和分类。7 其他本文介绍的只是一个实现GTD的核心思想，但是并不包括全部。还有许多基于此的应用场景、和变通的方法（如邮件管理、内容管理、工作项目等等），本文不做过多介绍，会在日后相应的机会下可能有所介绍。使用GTD后一段时间的感受：好的工具能够提高你的效率，但是世界上没有最好的工具，因为总会有新的思想来创造出更好的工具，摆脱工具控的限制，用知识来充实自己的思想。这里给出几个利用GTD思想进行管理的实例：7.1 使用GTD思想进行内容管理这里所说的内容管理是对知识体系的一种组织形式，是日常存放积累知识的体系，实现完整的内容管理和GTD管理类似，也需要一些特定的方法（比如通过云存储、云笔记、版本控制、文件管理等等）。这里不对内容管理的方面做过多介绍，虽然内容管理与任务管理是两个方面的内容，但是它们之间也并非没有联系，这里着重讲述如何将GTD思想应用到内容管理上。在没有一个比较系统的方式管理我们积累的内容之前，这些内容可能会显得杂乱、无章，虽然也经常会进行定期的清理和组织（比如，对分类系统的重构、重新定义，将某些分类中的内容进行修改、或迁移等等），但是整理的过程比较耗时耗力，并且不同时刻整理之时采用的思路和策略（很多都是临时想到的方法）也可能有所不同，尤其是对于“非专业”的内容管理，每次整理后，之前整理的策略也很快会忘记，新的内容又会导致内容系统逐渐重新归于混乱，甚至整个知识体系的结构都会发生翻天覆地的变化。随着时间的推移，和越来越多的内容“堆积”，很容易让人产生疲劳和沮丧。其实我们可以将这些问题归结为两点：需要不断地完善更新这些内容的组织方式需要一个好的方法来完善更新相应的内容组织方式前者属于知识本身的结构化（成长）问题，它可能会随时间、以及我们每个人知识系统的不断扩充而变化，管理策略可以采用内容管理方面涉及的各类方法和手段；而后者属于任务管理的方面，对应的任务便是对内容的管理。内容管理和任务管理之间没有明确界限，其中又有许多相互交叉的方面，所以我们可以将任务管理和内容管理结合起来（任务管理为辅，内容管理为主）管理我们的内容。随着我们知识内容结构的变化，可能不同阶段会需要不同的方法来管理内容，所以可以考虑选择一种相对固定的、不变的方法或思路进行“任务管理”，管理的任务便是“内容”，而管理的方式采用不同阶段涉及到的“内容管理”相关技术。这样，无论内容结构如何变化如何需要调整，由于更新内容所采用的“任务管理”手段相对固定，便能在已有体系基础上让一切有序的进行了。随着对管理技术的深入实践理解，采用的管理策略也会更趋向合理。这里抛砖引玉，给出目前我采用的一种方式^_^：如果GTD管理体系本身就做为内容管理体系的一部分存于其中，例如为知笔记用来管理内容，GTD与其中内容管理共存，此时可将用于GTD的内容 分类冠以"GTD_xxx"，所有GTD相关操作都在该分类中进行。关键是要将内容管理和GTD管理区分开来，分类的作用也可以是区分功能，不再局限于内容属性（这里是普通分类名称上加上特殊前缀等等，用以该分类用于功能属性）。7.1.1 “任务管理”方面使用GTD方法将“内容管理”做为任务进行管理:收集如果日常生活中，遇见有些内容值得记录至内容系统，那么及时迅速地将这些内容记录在某些固定的位置，先不用做更多处理。 记录的位置可以是事先设置好的一个内容管理默认分类，或者GTD中的收集箱，总之这样的地方根据自身情况只有几个，例如：手机中的便签、笔记中的“默认分类”或者“未分类”目录、收藏网页网址的工具、甚至是手动人为创建的“收集”目录等等，只要能方便、快速地将相关内容进行分享记录（例如通过手机中的“分享”菜单，电脑中的鼠标右键）即可。整理闲暇之时（如公交车上、排队等待等空余场合），到之前“收集”对应的那些地方，将曾经收集到的来不及整理的东西一一整理到对应的合适位置上去。具体整理的策略可能根据内容管理的方式而有所变化，但是既然采用GTD方式进行整理，那么整理过程中也必然会在每个整理的子任务中包含“收集”、“下一步”、“稍后”、“将来也许”、“等待委派”、“取消”、“完成”这些类似的状态，将每个整理任务都走完这样的状态，便能有条不紊地让内容越来越趋于有序。具体方式需要在内容管理中才能解释的更清晰，这里不做过多介绍。7.1.2 “内容管理”方面采用多种方式结合，内容保证集中存放、便于访问、灵活通用、可移植，有一个或者两个主要的知识系统，其它做为分支和辅助。内容管理应该属于和GTD时间管理“并行”的另一方面管理内容，比如“云笔记”（如为知笔记，麦库记事，有道，evernote，onenote，mynoteskeeper等）、“云存储”（如百度云，微云，Megalink等）、“本地存储”（存放一些私有数据资料）、“分布式版本控制”（如git本地存放私有内容，）、“版本控制系统托管服务”（github，bitbucket托管不敏感内容的git库）、“发布系统”（博客、Jekyll建站、Orgmode或Markdown便于分享的内容等）、以及其它（如便签、笔记、记事本、Pocket网页收集）等等。这里不过多介绍。7.2 将GTD管理中产生的数据进行内容管理这里介绍的是基于本文中提到的GTD方法，如何将其中的数据与内容管理系统衔接。7.2.1 管理思路在使用GTD方式处理日常任务时，一些的“已处理”状态中的任务，有些值得记录至自己的知识体系系统中，那么可以尝试一下这个方式：如果该任务没有对应的回顾引用到它那么直接将它从GTD系统中移动（或复制）到知识管理体系当中，根据自己的情况选择移动还是复制。如果该任务有对应的回顾引用到它那么不是将该任务内容简单移动或复制到相应笔记位置，而是将其复制到相应笔记处并添加一些引用信息，这样可以防止破坏原有GTD中回顾项目的链接。另外，最好也在GTD中记录一下复制到了哪里，下次更新之时，可以同时更新跟踪；同时内容记录之处，保留到回顾项目的反向引用链接。操作的时候，最好不要让GTD系统的回顾引用到GTD以外的内容。7.2.2 举例例如GTD中，有一条已经完成的任务（单词任务），该任务有对应的项目回顾（单词任务），并且这条任务已经整理到内容管理系统中的某个位置，则可采用类似如下方式处理（实际只需在相应的“已处理”任务中添加整理至何处的信息）。7.2.2.1 GTD系统项目回顾中对应的条目路径回顾条目路径为： 我的任务/GTD/#回顾/英语学习回顾  内容：回顾条目内容如下:xxxxxxx阅读任务单词任务语法积累任务xxxxxxx注意：列出的任务可以是链接，但是显示的名字要与对应的任务名一致，便于在不支持链接的笔记系统中查找7.2.2.2 GTD系统“已处理”状态中对应的任务：路径：任务条目路径为： 我的任务/GTD/已处理/单词任务内容：任务条目内容如下：已整理至：学习/英语/单词任务英语学习回顾XXXXXX注意：被整理至内容管理系统中的任务，整理之时，也在任务顶部追加“已整理至xxxx位置”之类的字样，最好名字也和实际笔记的名字一致，便于日后查找。7.2.2.3 内容管理系统中对应的内容：路径：笔记路径为： 学习/英语/单词任务内容：笔记内容如下：英语学习回顾XXXXXX注意：在内容管理系统中，保留回顾链接，可以链接至GTD系统中的对应回顾条目。7.3 使用GTD标签管理信息对于有标签功能的系统、软件、工具，其中的信息可以通过这个方式来整理，整理只能使相应的信息趋于有序，而每次的整理不会受上次整理的影响也不会对下次整理产生影响，简而言之，如果想用这个方式整理，那么内容会更有序，如果过段时间不用这个方式了，整理了一部分的内容，也不会因为半途而废而导致信息更混乱。7.3.1 GTD标签首先理解这个概念，GTD标签，可以用来辅助整理信息，如果某条信息没贴GTD标签则表示没有被整理过，也即“收集”状态，贴标签的的表示内容已由GTD标签辅助处理过，状态就是标签对应指示的状态。  采用这个方法，需要信息所处环境支持标签功能，并且将信息所处的环境的标签看做有两类:GTD标签,以及普通标签。普通标签就是平时我们使用的标签;而GTD标签是从普通标签中预留一些特殊标签（如标题前加GTD_），用做该方法的GTD整理。只有普通标签不代表已由GTD法处理过，并且不能同时贴两个同一体系的GTD标签，只有GTD标签表示暂不关注整理的分类。7.3.2 实现方式这种方法的原则是：采用此法整理过的内容，一定存在GTD标签，没有GTD标签的，视为没整理过（即收集状态）。即没贴GTD标签的，就是没整理的，整理好后，若不用借助GTD标签可保持有序，则可以不再贴GTD标签，过段时间又乱了可以重拾GTD标签辅助整理。  GTD标签举例gtd_下一步gtd_稍后gtd_将来也许gtd_取消gtd_已处理当信息已处理后（例如借助GTD整理好分类），可以只有已处理，或者同时有GTD标签和普通标签。这种方式适合无分类的信息管理，或者分类及标签混乱，但是还没应用GTD标签，借助GTD标签来管理内容。（例如pocket）7.3.3 扩展若分类大变，或者再次细化整理，则换一套管理思路，管理方式仍旧采用gtd方式管理.例如丢弃之前的gtd标签，采用新的gtd标签：gtd方式2_下一步gtd方式2_稍后gtd方式2_将来也许gtd方式2_取消gtd方式2_已处理这样扩展之后，就算之前应用过GTD标签，如果想换一条整理思路，那么重新换一套标签就行了，之前的标签忽略即可。建议软件能显示所有未贴标签的内容。建议能修改标签名。建议能批量加标签。标签和分类的区别是先有文章后有标签，但先有分类后有文章7.3.4 关键使用该方式，最好相应的环境能支持如下功能：能显示所有未贴标签的内容。能过滤显示出没贴特定标签的内容（如没贴GTD标签，却贴了普通标签的分类）。能修改标签名。能批量增、删改标签。7.4 使用GTD方式管理邮件如果是采取GTD方式管理自己的工作方式，其中邮件中的内容处理之后，可过滤到GTD系统中。而对邮件，也可采用GTD类似的方式来进行过滤，这样自己的GTD管理系统像是分层的一样，但是不宜过于复杂。7.4.1 实现思路大多数邮件客户端都有标签显示的功能，基于此，我们可以先定下如下规则：未贴标签的邮件，就是杂乱的不重要的邮件，而贴了标签的邮件，是需要关注的。7.4.2 实现举例设置如下类似GTD的系统标签：未读邮件类似GTD中的收集，这个状态在一般邮件客户端中都默认存在，所以并不对应什么标签名称，需要特别注意的是，收集是未读状态的无GTD标签邮件，而非无GTD标签邮件，这样保证收集的邮件不至于堆积。下一步该标签表示还来不及读取，只是通过标题等能确认是重点邮件，读取之后会变成后面的对应分类。类似GTD的“下一步”，需要过后进一步处理的邮件，这个分类的内容在整体中应该不多，处理后去掉标签或迁移到其它标签中，或重要邮件放到合适的位置、或者标签已办事项中。稍后相对下一步，可以稍后延缓处理的邮件。该标签邮件的处理方式类似前面，对应于GTD的“稍后”状态。将来也许不确定是否会用到，看起来像是重点，先堆积到这里。该标签邮件处理方式类似前面，对应于GTD中的“将来也许”状态。等待委派委派给别人处理或等待回复。该标签邮件处理方式类似前面，对应于GTD中的“等待委派”状态。已经处理的相关标签已处理邮件，不用贴上“已处理”标签，将其相应的GTD状态标签去掉即可，一般是已读的、未贴GTD标签的邮件，如果邮件比较重要，则建立一些根据自己情况的分类来重点存放。例如开发注意本项目发布，开发过程中的一些注意事项。该标签邮件处理方式类似前面，对应于GTD中的“将来也许”状态。项目文档项目开发、管理、会议、讨论等中发布的一些文档开发技巧日常开发的一些小技巧、说明等。通用技术一些比较通用的，不仅限于当前项目的技术内容，可以日后进一步学习或者有长远的作用的内容。公司事务一些公司事务信息，如人力资源相关、薪资、一些注意事项说明、出差、报销、福利等。重要信息暂时没有办法分类，但是感觉需要终点关注的邮件，比如阶段性的进展或者计划等。另外，有些系统中可用添加星标的方式标注邮件，这时候，一些临时性有期限的阶段重点可以用星标标注（比如上次release到了哪个版本，这次应该从上次的开始，那么每次release的时候为其添加星标，下次的时候就不会为了一个上次版本号，海量搜索所有邮件了），便于近期跟踪，相对重要信息，这类邮件的生命周期较短。这样处理邮件后，处理好的内容（转移至其它系统如GTD系统中继续也表示邮件处理完了）‍，要么就是添加上合适的标签，要么就是去掉标签表示不用关注。但是如前所述，如果感觉处理后还是很重要，那就加上星标。或者放到一个“重要邮件”的标签中。不同的客户端可能显示标签的方式不同，例如对于outlook，为了便于分类显示邮件，我们可以建立一个基于标签的搜索目录；而对于thunderbird，我们可以直接通过将标签添加到快速访问栏过滤显示；等等。其实添加标签后，标签基本上就可以预示分类了，但是如果标签感觉不是十分牢靠（可能一不小心点一下，就没有标签了）所以一些重要的没有过时的东西，可以按照意愿自建目录，转移到特定目录中。7.5 使用GTD方式管理工作文件有时候我们处理问题不一定全部在某一个GTD系统中进行，期间可能会涉及到访问电脑文件系统的相关操作。对文件系统采用GTD的方式管理，能避免文件系统的内容因文件杂乱导致的混乱。7.5.1 思路类似前面讲述的GTD标签的方式，我们可以创建一些GTD分类，将需要处理的资料流经这些分类最终归并到其他的合适的普通分类中。比如，查看邮件时，发现一个待处理的问题。这封邮件中包含一些附件，比如处理问题时参考的文档、处理时的日志、以及测试报告、测试程序；处理问题之时，又可能会查阅其它地方，将其它相关参考资料整理至本地（比如上网下载一个处理该问题的软件或者数据文件）；甚至会自己写一些文档记录当前处理的内容，比如设计文档、流程图、设计图等等。这些内容如果很多，那么可能会将自己的文件系统搞的乱七八糟。显然目前似乎也很难将这些内容的管理集成到现有的GTD系统中，或者也可以集成，但是需要再为现有的GTD系统添加一些额外的处理方式（这个方式可以因人而异，这里也不做介绍，可能将来会给出一套方案来解决这个问题）。如果我们不愿意花费精力将自己的这个GTD系统弄得很庞大复杂，为简便起见，我们可以给出一个折衷方案，自己习惯的方式，直接将相关的内容在本地文件系统中进行操作，但是操作之时，对文件系统采用GTD的思路划分。7.5.2 实现举例比如，我们给自己的文件系统划分为如下GTD分类目录：$ls -p1_inbox/  3_later/  5_maybe_future/  7_cancel/ 2_next/   4_wait/   6_done/  readme  ...目录内容如下：1_inbox/用于将所有处理问题过程中临时下载、获取的资料集中在这里存放，内容不能堆积要及时整理到其他目录。2_next/在整理文件系统时，将正在进行工作所需的资料汇集至此，不同内容可处于不同子目录中。3_later/在整理文件系统时，需要被推迟的事情所涉及的资料汇集至此，不同内容可处于不同子目录中。4_wait/在整理文件系统时，由于等待而被阻塞的事情汇集至此，不同内容可处于不同子目录中。5_maybe_future/在整理文件时，将不重要的以后可能会用到的资料堆积在这里，不同内容可处于不同子目录中。6_done/在整理文件系统时，已完成工作相关资料暂积于此，这里包含各种完成任务所涉及资料，将来可能进一步整理。7_cancel/在整理文件系统时，将取消的任务涉及的资料都汇集到这里，将来可能会被清理。readme对当前处理的目录结构的进一步说明。其它目录任何自己定义的目录。与以上GTD分类不冲突，GTD分类做为过滤，采用GTD方法，经过前面几个GTD分类的过滤（状态切换后）后，最终整理好的资料可以汇集于其他自己习惯的目录中。7.6 杂乱任何经验知识等叙述到一定程度，总有一些无法具体归类的杂项内容，哪怕是某方面知识体系中的一小部分，也很难一下子把所知以及真正的内容全部完美的表达出来。本文也是如此，所以在这里列出暂时堆积一些无法放置的，可能有待进一步整理也可能不会再整理的内容。7.6.1 任务状态GTD系统不是一成不变的，但是大多数GTD系统，应当具有如下几个类似的状态：收集、下一步、将来也许、已完成。收集箱用于快速存放所有临时想到的任务，有时间再将其进一步整理，细化任务属性，但是其中内容不要堆积。下一步便于集中精力，只存放当前处理的任务，其中内容不要过多。将来也许任务堆积的地方，可能做可能不做又不想遗忘的、没处理的任务，都可以先堆积在这里。已完成已完成的任务，做为备份或归档，可能将来回顾或进一步组织整理。7.6.2 任务属性除了前面的任务状态，根据所处环境、工具与方法的不同，GTD任务还可能具有的属性也有所不同。比较基本的有任务所属的“任务名称”、“项目分类”；有时候根据情况还需要其他扩展的属性如：“场景”、“开始/结束时间”、“是否重复”、“提醒”、“备注”、“优先级”等等。不同属性具有不同用途，实现方式也不同。比如：“项目分类”和“场景”可能用分类目录或者标签的方式来实现，如果采用分类目录，需要注意此时与状态分类并不冲突，因为分类不仅是对内容状态、属性的分类，也是对任务场景的分类。任务的“项目分类”一般在回顾的时候会经常用到；任务的“情景”一般在处于不同场合的时候用到（如@家里、@办公室、@外出等）；这些一般都可根据个人习惯进行设置，只要便于快速过滤到适合该情况下需要关注的任务即可。又如：“开始/结束时间”、“是否重复”、“提醒”……这类时间相关的信息，可能根据软件场合的不同也有不同的实现。比如Orgmode可以用时间戳和SCHEDULE属性等来标记这些信息等等。而有些工具在特定的时候，又可能会根据时间信息，对任务进行自动的处理，比如将任务贴上标签，设置好起始结束日后，过期或者特定时间，自动将任务移动到特定的状态或项目等分类中（有许多GTD管理工具中都有一项”今日待办“之类的分类就类似如此)，或者反复提醒。对于简单的GTD管理，如记事本方式，可能就很难直接实现这类根据时间有所动作的任务管理。7.6.3 任务性质如果对任务，需要时间方面的属性进行辅助管理，这里给出一些经验性的建议：提醒不用什么都设提醒，必须在指定时间做的事情，或重要的事情才值得提醒；提醒的功能可以任找类似闹钟功能的方便软件辅助即可（如中华万年历），不用必须集成到GTD中实现。日程有些任务虽然不需提醒，但是也对时间比较敏感，比如今日待办，明日待办，指定日期代办，将来待办等，虽然有些并不一定是要执行，但是都有一个期限，有些工具在日历中会将其标记出来。待办对时间不敏感的任务。有些任务对时间信息不是很敏感，或无法指定究竟什么时候需要做、需要完成，但是能确定的是它应该被做，这类任务可以称为待办。前面所述的，是对任务性质方面的划分，并不是必须的分类方式，这里真正做了划分的，我们在GTD中看到的各个任务的状态，大多状态的任务都具有以上之一的性质。对任务性质进行这样的划分之后，一些比较让人迷惑的概念应该比较容易澄清了。例如：日历、提醒、备忘、日程、待办……这几个概念经常在叙述的时候出现，如果不对其专门规定和提取，有时候连自己都会对其比较迷惑。经过上面的性质划分之后，我们可以这样理解：“日程”就是有时间安排的任务，它可以在“日历”中被标记出来。“备忘”有些是需要提醒的，有些不用“提醒”只要做为“待办”即可。7.6.4 优先级划分任务都有一个优先级的问题，有一个为任务优先级分类的方式：四象限法则。该方法不具体介绍，大致是将任务按照“紧急度”与“重要度”划分为四个象限：第一象限重要不紧急需要制定计划，按时完成的内容，是最重要的事情，它可以帮助我们进入良性循环。建议占用约65%-80%的精力。第二象限重要且紧急需要优先解决，这也是没有经过适当计划的内容，可能因为之前的安排不合理，导致一些任务从第一象限随着时间的推移被迁移到第二象限，可能导致我们无休止地一直在“瞎忙”。建议占用约20%-25%的精力。第三象限紧急不重要会让我们产生“这事很重要”的错觉的事件，实际上其实事件只是对别人而言很重要。建议占用约15%的精力。第四象限不重要不紧急浪费时间的事情，如果可能，交给别人去做。建议占用&lt;1%的精力。7.6.5 劳逸结合划分任务状态很大一部分也是为了集中我们的精力，将处理任务时精力集中在下一步，回顾时精力集中在任务的划分等等。而真正在处理任务之时，精力不一定能保证一直集中；集中过久又可能会导致之后的处理效率低下。所以可以考虑番茄工作法来改善这样的状况。番茄工作法是一种相对于GTD更微观的时间管理方法。大致如下：将每次做事情，比喻成番茄，休息和番茄交替进行。大致如下原则：一个番茄时间（25分钟）不可分割，不存在半个或一个半番茄时间。一个番茄时间内如果做与任务无关的事情，则该番茄时间作废。永远不要在非工作时间内使用《番茄工作法》。（例如：用3个番茄时间陪儿子下的棋、用5个番茄时间钓鱼，等等。）不要拿自己的番茄数据与他人的番茄数据比较。番茄的数量不可能决定任务最终的成败。必须有一份适合自己的作息时间表。通用的方式是：每个番茄25分钟，休息5分钟，但是也可根据自身情况而定。工作时准备好一个定时器，每次过一个番茄，一定休息，休息完毕，就下一个番茄，每次休息和番茄之间，通过定时器来提醒，防止“越界”。7.6.6 回顾的解释如果某项任务比较复杂，处理完毕后，最好能有一个汇总的文档，整理期间处理的情况，类似索引。便于以后参考引用，以及追加索引处理更新情况，也可能没有用处，这就是一条回顾，也是项目。回顾最初可能是以任务的形式出现的，将任务处理到一定程度后，发现其中可以划分为许多子部分，而最初的“任务”可以用来做为一个回顾索引，来引用到处理任务时涉及的的各个子部分。这个时候，“任务”就变成了“回顾”，将新建立的回顾放在相应的“回顾”分类中（如“活跃的回顾”、“普通的回顾”等），之后的处理全在“回顾”以及其引用的相应的任务中记录和复习，并不是说进入到“回顾”中了，就相应的条目就不能更新了，回顾是对项目的划分，这里存在的是项目而非任务，回顾并非任务的终结状态，它是一系列相关任务的处理情况记录和索引，便于今后理解和参考。7.6.7 管理回顾的经验这里有些，可以借鉴，不是必须的：回顾可能没有结尾，但是一定条理清晰，便于追加编辑，和索引。每条回顾中可能包含多条对任务的索引，索引内容不能太多，更多相关的内容可以在该索引对应的链接内容中体现。每条回顾对应一个项目，不同的回顾代表不同项目，每个项目是对相关任务的汇集。并不是所有的任务都需要回顾和汇总，一些单一简单的任务，其本身处理完放入到已处理中，本身就可当作回顾。回顾中索引引用的任务或者内容，最好和相应的任务或内容对应的笔记的题目一致，以便于在无支持链接的情况下移植。回顾和所引用的任务之间最好能够交叉引用。创建相关任务的时候，首先将回顾的链接附上。等待任务处理到一定程度之时，可以重新命名一个好的标题，然后再将任务链接贴在回顾中。理想情况下，回顾中只包含相关的任务标题链接，有时候实在需要进一步说明，也可在回顾相应的索引链接处中给出一些提示性的内容表征任务的大致情况。如果回顾对应的项目仍需继续，那么就不要将相关的所有任务清除为已处理，以免丢失对任务的跟踪。也就是说，没有完成，或达到一定阶段的项目，要保持其中有一项未完成状态的任务(例如长时间不做了，可以将其设置为推迟、将来也许、甚至不了了之的任务确认后放入取消)。活跃的回顾是指当前进行的项目，随着项目的进行可能会在其中不断衍生出新的任务，例如一些重复性的任务，如“周报”，一般每周都要写，短期内不会终止，所以它可被看作一个活跃的项目。回顾所引用的一般是处于各个状态的任务，不一定只有任务，也可能是其他的回顾，但是一定是GTD系统中的内容。回顾的内容与回顾所引用的内容应该能相互引用，便于参考时的跳转。7.6.8 关于参考参考既不是任务，也不是回顾，但是它又处于GTD系统当中。它主要是在回顾，或者处理时不是中间任务性质的半参考文档性质的内容。例如导致接收任务的邮件片段、期间的交互证据、网址文献等等。按理说应该有相关的时间、地点（可以是email地址）、人物、事件（起因/经过/结果）。在目前看来，参考在本文所述的GTD中可以被去掉，归并到已处理分类中，但是也可根据个人需要与喜好单独列出来一个分类用来管理这些内容。如何处理“回顾”、“任务”、“参考”的关系？任务是可以执行事情的分割单位，其中包含处理该任务是的一些总结性质的东西，是深入处理相关任务时做的杂乱记录。回顾是对一系列相关任务的汇集整理，本事就是一个项目，整理任务处理期间的关系以及处理的大致情况和索引，便于今后跟踪和参考。参考可能是回顾会引用的，或者是任务中会引用到的一些资料，例如导致接收任务的邮件、期间的交互证据，网址文献等等。7.6.9 如何处理“项目分类”与“状态分类”实现的冲突先给出问题，在列出思考实现的过程，最后给出采用当前的方案的原因。正常收集过来的任务直接放在收集箱，进行进一步处理之后放在相应的项目分类中，随着时间的推移再进入到下一步状态，但是该任务仍然属于之前所设置的项目分类。也就是说，任务的项目分类是不变的，状态却可能随着处理改变成其它状态（如下一步）。任务的状态是以目录形式存在，所以对于项目分类的管理方式如果也以目录的方式管理可能就导致目录混乱。考虑到项目分类是随时间动态增长的，而目录分类不宜过多；相对的，标签是文章之后动态创建的，将项目用标签表示可能更灵活好用一些；或者在每一个状态目录中建立子目录表示项目，或者使用标签来实现对任务即可用状态的角度来分类，又可用项目角度来分类……然而，这些方式都会到至笔记的分类复杂，并且并不是所有的工具都支持标签。前面的局限在于，认为分类只能是对同一角度内容的分类，所以将项目和状态同时用分类来表示的时候，会混淆。当前采用的方式将状态和项目全都用分类来表示，但是分类不是在一个角度上进行分类，可以是管理状态的分类，或者管理项目的分类……不同方面，有各自的分类方式，可以用分类名前缀，或者自己的习惯来理解不同的分类方式就行。这样，将“分类”进行分类之后，不同方面的分类可以存在于同一个笔记系统中，就不会引起混乱。它是，对于项目这类变化比较大的（基本是只增不减）内容，采用分类又有些不妥，所以项目干脆用笔记来表示，每个项目分类只是一个笔记，然后将所有项目归结到项目状态中。7.6.10 自我管理的演化过程随着时间的过去，我们从学校进入到职场，从个人变成了组建的家庭，所处理和面对的事务也变得越来越复杂。如果不做合理规划，工作、生活、学习各个方面会变得越来越糟糕。希望能有一个高效的生活方式的我们，可能会经历如下的管理过程阶段，希望能给大家一个参考。7.6.10.1 记事本阶段(笔记本子，或者Windows上的记事本，博客等)将平时涉及的一切写到一个记事本中，可以是电子版的，或者纸质的，也有时候为分享和方便记录到博客等网络平台中。在随后的讲述中我们会发现，这些内容渐渐变得越来越复杂分散，简单的记录已不再适应。7.6.10.2 待办清单与文档（任何设备、系统上自带的工具）记事本，可能包含了能够记录的一切，但是其中记录的内容各不相同，而且数据量越来越大，我们真正所需的，其实是在适当的时候将其提取出来，总结起来发现大致有两类事情：一类是平时记录的技巧、经验、资料、文档等等另一类是影响自己行动的计划、待办事项、约会、提醒等等。于是产生了两种方式的记录：待办清单和文档。待办清单其实是行动管理的雏形。罗列了需要处理的事情，需要进行某些事情的时候，浏览一下这个清单，处理完将其划掉，日常的生活在清单不断地增减中度过。文档其实是内容管理的雏形。那些经验、技巧、文档类的内容，被整理至某个笔记系统或目录结构中，为不同的内容建立相应的分类，分门别类存放，需要之时直接到对应地方查阅即可。在任何我们手中的系统和设备中（比如手机的Android和IOS、PC的Window和Linux等等），总有一款待办清单方面的工具，以及笔记记录方面的工具，供我们这时所需。7.6.10.3 丰富的待办清单与文档系统(中华万年历与为知笔记)随着时间迁移，在待办清单和文档，终于有一个像样的名称，内容管理和行动管理。行动管理方面待办清单变得越来越长，往往想确定下一步做什么的时候，需要先浏览一遍长长的清单，然后找到需要的内容，于是产生了对待办清单改善的需要：需要一些新的工具，或者在原来的待办清单上改善和扩展。一是添加提醒，一些事情到特定时间后自动通过闹钟或者其他方式提醒我们去看，手机、电脑上有许多类似的工具；二是划分优先级，那些待办事项中，总有一些是重要的、一些是不重要的、一些是过时的等等，四象限法则就是一个划分优先级的好方法，在我所用过的工具里，中华万年历是这个时候不错的选择，它还附带了一个简单的云笔记功能。内容管理方面总是觉得之前的分类变得越来越复杂，文件系统越来越乱，内容越来越多，并且分散在各处（手机、电脑等），都有不不同的文档系统，而且有时候想要记录的时候，东西不在身边，当有现成的环境之时，却又想不起该记录什么了。这需要对内容管理方式有一个改善，改善分类的方式，让分类简单；增加记录与访问的便携与集中性，比如各类云笔记（麦库、有道、为知、evernote）等等可以随时记录访问，也可根据需要的内容，搜索检索相应的笔记，根据我的经验，为知笔记在这个方面做的非常不错。7.6.10.4 轻重结合(轻量级的系统便签或笔记工具、与为知、中华万年历)在管理内容和行动方面的信息的同时，不断寻求新的更强大的工具，最终会感觉到，自己的手机、电脑、越来越慢，访问所需的等待时间往往超过了我们的忍耐限度，为了临时记录一点东西，我们可能会花费1、2分钟的时间启动我们的系统和软件，启动的时间内，我们往往可能已经能够把相应的事务处理完毕了。这要求我们对所管理的信息有一种便捷的访问方式。各类系统平台上一般都会有那么几款轻量级别的记录工具，记事便签、记事本等等，再添加上分类的功能使之不要过于弱。重量级和轻量级工具同时使用，我们经常访问的信息就存于轻量级别的工具中，空闲之时在重量级工具与轻量级工具之间同步数据。7.6.10.5 需有体系的信息管理组织方式（GTD与Git）便携性意味着功能的减弱，功能强则会减弱便携性。两者综合起来应用，又会涉及到同步和数据移植行的问题。这时候管理信息已经不是工具方面的问题了，而是方法和存储。采用的方式：行动管理方面方法是GTD方法，为所有任务定义好状态。工具则任意款便携、可移植的工具即可。内容管理方面原生文本格式方式增强数据移植性；Git分布式管理增强便携安全与版本控制；用现有大型网站托管资料（如github、bitbucket等等）增强集中与同步性。数据格式、访问、存储与管理方式工具可以尽量简单，方法选择适合自己的方法，而数据的格式也是一个问题。如果做过软件开发的人，可能会觉得，这有点类似软件中的MVC方法问题（M是数据模型、V是数据访问视图、C是数据控制方式）。数据格式-Orgmode为了便于将来环境的切换，数据存储的格式是一个比较重要的内容。文本格式实践发现，最通用的数据格式不是.doc、音视频、图片、pdf、或者各类笔记专有数据格式等等，而是文本，文本格式也便于版本控制管理。标记语言对于文本格式，xml、html就是文本标记语言，latex也是，但是通用性强了、可阅读性也必不可少，这些文本格式对于非专业人员，几乎是天书般的存在。轻量级标记语言各类轻量级的标记语言如markdown、orgmode等等，可以做为数据存储的格式，学习成本也低、而且文本的数据格式也便于直接阅读。Markdown与Orgmode学习成本太低，便意味着功能的有限，反之亦然。markdown的学习成本很低，相对orgmode更流行，但是若用它写复杂的文档，还是有些勉强只能写一些简单的博客性文章；orgmode是这里极力推荐的方式，它可以变得很轻量级，但是如果你多学习，它又能变得非常强大，既能内容管理，又能行动管理，还能导出为其他各种格式远不止于此。访问方式-工具控总结起来，这个阶段，工具不是重点，Emacs、Vim、记事本、任意一款可以编辑的工具都可做为数据访问的方式。如果只考虑工具，又不想自己主动耗费精力思考方法，降低学习成本，这个阶段有两个工具建议可用：行动管理采用dgt gtd，安卓下的工具，可以导出数据，并且便携记录。内容管理仍然采用为知笔记。做为辅助对访问速度要求高时，可以用系统上的任意便签工具做为中转。管理方式-GTD与分布式版本控制方法才是核心，管理方法往往说起来很简单：GTD管理任务，Git分布式管理内容并版本控制，当然肯定也会有其它的方法或者分布式管理。总结总之，如果用最直接的方式来描述一个特定的管理方式，目前而言，我采用的方式是：emacs的扩展性满足了工具控的需要，可以当作任何想到的工具访问数据；markdown和orgmode这类文本标记语言相结合，表示数据，使之符合人阅读的原生文本格式，orgmode还能方便转换为各种其它格式；任意款分布式版本控制工具（比较流行的是git）可以当作云存储与管理内容的方式;gtd方法做为灵魂，做为管理行动的方式（管理数据的组织方式也是诸多行动的一种），其它一切都是浮云。7.6.10.6 其它前面的过程，其实总结起来，可能是这个样子的：杂乱的信息-任务管理/内容管理。当管理达到一定阶段，满足现状的时候，还可能会发生其他的事情，比如，数据、工具、方法都有了，我们要做什么？也许，下一步就是目标管理了吧？因为我也听说过SWOT方法、5w1h方法等等，又或许，还需更好的方式在组织这些。7.7 参考资料一些值得参考的一些文章：褪墨・时间管理http://blog.sina.com.cn/s/blog_6495e9c90101evo7.htmlhttp://www.mifengtd.cn/articles/gtd-grab-the-destiny.html8 WAIT/FORWARD FAQ [%] [/]State "WAIT/FORWARD" from              [2016-06-12 日 17:16]  wait for all done.8.1 NEXT 如何通过orgMobile进行管理？State "NEXT"       from "INBOX"      [2015-12-30 三 09:40]8.2 INBOX 回顾的内容，没有完成的可以用链接的方式将任务与回顾相互引用，任务完成之后，可以考虑将其直接集成到回顾中，不用链接，防止过于分散。Capture Time:[2016-05-25 三 10:30]如果过大过复杂的内容，或者没有办法很好的组织的内容，可以用链接的方式对其进行关联。否则就尽量不要使用链接，使用链接的内容，都是没有弄完的内容，弄完之后把链接去掉。      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2015-11-30 一]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-11-03]<a href="/categories/note/GTD_Manage_Method.html"> GTD管理方式 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Emacs Orgmode学习笔记'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 标题与大纲1.1. 语法1.2. 配置1.2.1. 调整大纲缩进显示1.3. 操作2. TODO项目2.1. 语法2.2. 配置2.3. 操作3. 格式3.1. 段落3.2. 字体3.3. 硬换行4. 列表4.1. 语法4.2. 操作5. 表格5.1. 语法5.2. 操作6. 块标记6.1. 语法6.2. 操作7. 链接7.1. 语法7.2. 配置7.3. 操作8. 时间戳8.1. NEXT 语法8.2. 操作9. 标签9.1. 语法9.2. 配置9.3. 操作10. Capture-Refile-Archive10.1. 概念10.2. 配置10.2.1. Capture的配置10.2.2. Refile的配置10.3. 操作11. Agenda11.1. 操作11.1.1. 交互操作11.1.2. 交互命令：12. 导出12.1. 操作13. 其它13.1. 建议13.1.1. 列表与标题13.1.2. 列表与换行13.2. 感想13.3. 注意13.4. orgmode与mobile org整合13.4.1. 配置13.4.2. 原理13.4.3. 同步操作13.4.4. 使用举例13.4.5. 其它13.5. orgmode与jekyll的结合13.5.1. 部署13.5.2. 配置13.5.3. 被导出文件与jekyll的集成13.5.4. 为待发布文章添加兼容jekyll显示的信息13.5.5. 发布命令13.5.6. 其他13.6. Misc collection13.6.1. &#x2014;&#x2014; [2015-12-03 四 14:55]  Agenda view------14. WAIT/FORWARD FAQ [35/111]([31%])14.1. MAYBE/FUTURE 如何隐藏"标题星星"？14.2. LATER 搜索子树相关14.3. DONE 各个级别标题列表如何缩进？14.4. DONE 各个级别列表标题中的内容段落如何缩进？14.5. LATER 如何显示图片14.6. DONE 如何删除标题或者项目以及子树下的内容？14.7. DONE 如何链接文件和位置之类的？14.8. DONE 如何行内转义引用?14.9. DONE 如何设置启动时的自动折叠？14.10. MAYBE/FUTURE 如何预览效果？14.11. DONE 标签的预定义14.12. MAYBE/FUTURE 如何自动对齐ORGMODE文件的格式？14.13. DONE 如何在标题间跳转？14.14. DONE 如何缩进列表段落？14.15. LATER 貌似自动刷新功能还是没有完全实现14.16. DONE 如何增加状态？14.17. DONE 如何定制状态的各种属性？14.18. DONE 如何设置和进行TODO的状态快捷切换？14.19. DONE 如何按状态搜索TODO项目？14.20. LATER 如何实现代码原样引用？14.21. DONE 配置折叠状态编辑的动作14.22. LATER 按照TAG进行搜索14.23. LATER 导出与发布14.24. DONE 如何调整大纲缩进显示14.25. DONE 如何写行内引用的文字，类似markdown中的``。14.26. DONE 如何确保硬换行14.27. DONE 如何保存一个与文件位置无关的链接？ C-c l 相关参数？14.28. DONE 如何简化列表标题等文档复杂度14.29. CANCEL 如何定制插入的时间戳格式？14.30. LATER 如何在Refile的时候新建一个标题？org-refile-allow-creating-parent-nodes?14.31. DONE 恢复到默认的大纲内容模式还不太好用14.32. WAIT/FORWARD 是否可以org-agenda-files只使用一个文件，对应文件中列出所有agenda文件？14.33. WAIT/FORWARD 如何设置问题Open的时间？14.34. WAIT/FORWARD 确认一下agenda的配置文件是否可以配置目录？14.35. LATER 考虑使用F1-n设置自己日常使用的自定义快捷方式，并且保证不要与其它冲突。14.36. LATER 标题如何添加序号？14.37. LATER 如何直接插入一个子标题？14.38. DONE 参考并整理结构编辑的相关操作：14.39. DONE 如何对一个子树进行导出？14.40. MAYBE/FUTURE 注意，断行要用'\\'，要么就空白一行。14.41. WAIT/FORWARD 如何解决输入下划线的时候，自动转换为下标？（想要不转换）14.42. LATER orgmode refile如何创建新的文件和条目，如何定位设置之外的路径14.43. DONE orgmode如何只对一个指定的子标题生成html等导出文件？14.44. DONE 如何在capture模板中将时间戳设置为非活跃时间戳，以减少Agenda的显示负担？14.45. DONE orgmode如何插入带有时间（而不仅仅是日期）的时间戳？14.46. LATER 整理一下emacs_orgmodeusage的文档格式14.47. MAYBE/FUTURE 如何在活跃与非活跃时间戳之间进行切换？14.48. NEXT 如何打开链接的时候不新开一个窗口？14.49. WAIT/FORWARD orgmode 的BEGIN_SRC总是导出错误，提示输入的语言参数，如何确定有哪些语言参数？14.50. LATER 如果Agenda对应TODO状态发生变化，如何刷新Agenda view?14.51. DONE orgmode有没有离线帮助手册在emacs中直接使用？14.52. LATER 如何自由切换orgmode的活跃和非活跃时间戳？14.53. LATER 如何在orgmode中调整已有列表条目的缩进级别？14.54. MAYBE/FUTURE Orgmode表格格式如何自动添加分割横线？为何导出时没有列分割？14.55. MAYBE/FUTURE Agenda view不折行？14.56. MAYBE/FUTURE 如何格式化块？如删除块？14.57. LATER 如何自动触发状态变化？14.58. DONE orgmode与mobile org整合14.59. MAYBE/FUTURE Orgmode refile如何到特定的标题上而非仅仅追加或者插入？14.60. CANCEL orgmode attachment的内容需要看一下14.61. NEXT 如何在orgmode中打开链接的时候不会自动新开窗口而是使用已有窗口？14.62. LATER orgmode 如何修改时间戳？直接编辑？14.63. MAYBE/FUTURE agenda如何不扫描有些状态，如done、cancel、maybe/future14.64. MAYBE/FUTURE orgmode的块是否可以嵌套？比如quote块内是否可以quote？14.65. LATER orgmode如何在导出子树的时候自动以标题命名？14.66. LATER orgmode如何指定导出的路径和文件名称？14.67. LATER orgmode光标如何定位到下一个链接？14.68. LATER orgmode如何实现任务自动触发定时切换以及refile14.69. WAIT/FORWARD 列表与换行14.70. WAIT/FORWARD orgmode建议14.71. LATER Orgmode中checkbox和header也可以结合使用14.72. LATER 确认一下orgmode中的引用块相关细节，例如begin example和begin quote之间的区别14.73. CANCEL 考虑orgmode中，是否应该每一个状态添加!，将处理信息和状态信息集成。14.74. LATER orgmode 如何递归折叠光标所在节点？14.75. WAIT/FORWARD emacs markdown 导出14.76. DONE orgmode与jekyll的结合14.77. LATER orgmode如何输入成块的原样文字而不解释、缩进之类的？14.78. LATER 为什么orgmode定义好的refile如果是单个文件，那么这个文件内容会自动变化？14.79. LATER Jekyll与orgmode结合的问题14.80. NEXT 如何为orgmode导出添加作者信息？14.81. LATER emacs如何导出的时候不缓存上次修改差异而直接强制导出？14.82. DONE 是否应该为取消的项目在切换到取消之前添加备注，类似wait/forward，指明为什么取消？14.83. MAYBE/FUTURE orgmode多文件文档14.84. LATER orgmode中导出时的include关键字所基于的路径能否配置？14.85. LATER 如何在orgmode中时间戳中选择特定的时间插入？需要知道相关的指令和按键，而非手动修改。14.86. NEXT orgmode导出utf8问题14.87. CANCEL orgmode sub task and summary.14.88. DONE 切换和设置优先级14.89. WAIT/FORWARD archive14.89.1. 配置14.89.2. 操作14.89.3. 举例14.90. NEXT orgmode中为何example块中的标题还遵从orgmode的格式？14.91. NEXT orgmode导出为utf8报告错误14.92. LATER orgmode在引用块中缩进的标题问题14.93. MAYBE/FUTURE orgmode导出markdown有太多的引用标记，如何尽可能原样展示而非很多的'style'类似的东西？14.94. LATER orgmode 番茄钟、时间记录14.95. MAYBE/FUTURE orgmode为什么refile 目标会跟踪软链接到其他目录中？14.96. LATER 属性14.96.1. 操作14.97. WAIT/FORWARD ormode项目管理14.98. DONE orgmode考虑是否应该将状态文件以'_' 做为前缀，便于angenda中一目了然不和其他文件混淆？14.99. NEXT orgmode应用聚合有哪些场景？ [2/7]14.100. LATER orgmode记时功能可以提高集中力14.101. NEXT Orgmode如何官方发问？14.101.1. 订阅邮件列表14.101.2. 参考14.102. MAYBE/FUTURE Ascii art14.103. MAYBE/FUTURE artist mode in emacs14.104. MAYBE/FUTURE Emacs中的plantuml配置如何与ascii art格式图形结合？14.105. LATER orgmode画图14.106. LATER pdflatex for orgmode14.107. NEXT mobileorg的加密功能，可以防止隐私的泄漏；orgmode的加密功能既能管理工作又能防止工作隐私泄漏。14.108. WAIT/FORWARD orgmode中图片链接导出之时如何不是文字链接而直接图片？14.109. LATER orgmode表格导出之后，文本或者html没有竖线只有横线14.110. NEXT orgmode导出文章pdf问题14.111. LATER orgmode中搜索相关命令的整理15. 参考资料：这里是学习Emacs Orgmode过程记录的笔记，可供日后查阅以及参考。1 标题与大纲1.1 语法一级标题用"* "，二级标题用"** "，以此类推，最多10级，注意'*'后面的空格。1.2 配置配置默认启动的折叠方式如果对全局起作用，需要设置org-startup-folded变量，设置值可参见 C-h v org-startup-folded ，在emacs启动配置中添加如下类似值：;;set initial folded state.(setq org-startup-folded 'content)如果仅对一个文件起作用，则为文件添加如下类似元数据：#+STARTUP: overview#+STARTUP: content#+STARTUP: showall#+STARTUP: showeverything配置折叠状态下的编辑动作实践发现，在折叠的时候删除或者追加，有些影响可能会在展开的时候才能看见。比如删除一个字符等等，所以不知道的情况下建议不要在折叠的时候删除字符。但是我们可以添加配置来修改这时的行为。配置变量是org-catch-invisible-edits，可以通过查看 C-h v org-catch-invisible-edit 来查看设置的值含义。;;set action when edit invisible content(setq org-catch-invisible-edits 'show-and-error)1.2.1 调整大纲缩进显示默认显示缩进好的大纲内容加入如下配置(setq org-startup-indented t)或者加入如下选项到文件使得只在当前文件生效：#+STARTUP: indent1.3 操作展开、折叠所有章节输入 S+Tab对光标所在章节进行展开、折叠输入 Tab对当前子树标题使用大纲方式显示输入 C-c C-k切换到初始的浏览状态，也就是org-startup-folded设定的状态。输入 C-u C-u TAB显示全部，包括Drawers。输入 C-u C-u C-u TAB跳转至上级标题输入 C-c C-u跳转至上一个/下一个标题（无视级别）输入 C-c C-p/n跳转至上一个/下一个标题（同级别）输入 C-c C-f/b当前标题升级/降级，不包括子树输入 M-LEFT/RIGHT当前标题以及子树升级/降级输入 M-S-LEFT/RIGHT当前标题上移下移??输入 M-UP/DOWN当前子树上移下移??输入 M-S-UP/DOWN在光标处插入当前级别标题输入 M-Ret光标在文本中，则将内容一分为二，换行后插入同级别标题;在空白则在之下插入当前所在级别标题。在当前标题子树后插入同级别标题输入 C-Ret 切换到大纲浏览状态输入 C-c C-j 进入大纲浏览状态之后，状态栏有提示，右侧也会新开一个buffer提示有特殊的大纲浏览状态帮助命令。例如：切换上一条/下一条标题输入 Up/Down直接进入相应标题并退出大纲浏览状态输入 Ret搜索输入 /在某标题上循环切换视图输入 Tab退出大纲浏览视图输入 C-g另外直接输入文字也可进行搜索。切换标题和正文状态输入 C-c *输入之后，会进行标题切换，将文本、区域、或条目转换成相应位置下的子标题，或反之。选择当前Entry输入 M-h输入之后，会高亮显示当前光标所在entry的内容。例如光标在标题上，则高亮标题以及子树内容，持续按 M-h 会继续以同级别下entry为单位，扩展选择范围，这里的entry可以是段落、标题、列表项等等，取决于光标所停留的位置。选择当前光标所处标题以及子树输入 C-c @输入之后，会高亮显示当前光标所在子树的内容，不论光标是否停留在标题上。删除当前所在标题及子树输入 C-c C-x C-w输入之后，无论光标是否在标题上，都会将其所在标题连同子树删除（剪切）。复制当前所在标题及子树输入 C-c C-x M-w输入之后，无论光标是否在标题上，都会将其所在标题连同子树复制。2 TODO项目2.1 语法TODO是一种包含状态的特殊标题在标题标记后面加上相应状态名，便成为TODO项目。状态默认为TODO和DONE，可以自行配置。* TODO 这是一个TODO项目** TODO 这是TODO的子项目带有统计子项目的TODO项目在一个待办标题中添加子待办标题，然后在待办标题中添加 [%] 或者 [%] 。 每当子标题更新时，父标题上面的相应比例会自动统计变化，如果强制刷新，则在父标题相应的比例标记上输入 C-c C-c 。* TODO 这是一个统计子项的TODO项目 [0/2]** TODO 这是TODO的子项目1** TODO 这是TODO的子项目2当然这样也行：* TODO 这是一个统计子项的TODO项目 [0/2] ([0%])** TODO 这是TODO的子项目1** TODO 这是TODO的子项目22.2 配置增加TODO状态在配置文件中加入类似如下代码：;;set status for TODO.(setq org-todo-keywords     '((sequence "INBOX" "NEXT" "LATER" "WAIT/FORWARD" "MAYBE/FUTURE" "|" "CANCEL" "DONE")))配置状态颜色通过org-todo-keyword-faces的设置实现，添加内容如下;; color for todo keywords(setq org-todo-keyword-faces '(("INBOX" . (:foreground "blue" :weight bold)) ("NEXT" . org-warning)("LATER" . "yellow")("WAIT/FORWARD" . "blue")("MAYBE/FUTURE" . "purple")("DONE" . "green")("CANCEL" . "grey")))配置状态快捷切换键通过定义状态时将快捷按键放在状态后面，用‘（）’括起来，添加内容如下：;;set status for TODO.(setq org-todo-keywords '((sequence                          "INBOX"                         "NEXT(n)"                         "LATER(l)"                         "WAIT/FORWARD(w)"                         "MAYBE/FUTURE(m)"                         "|" "CANCEL(c)" "DONE(d)"                         )) )配置状态切换的跟踪时间戳当TODO列表切换到结束状态时，会自动为其添加一个结束时候的时间戳（转变为非结束状态时会将其移除）。;;add timestamp when todo change to done.(setq org-log-done 'time)配置优先级颜色和内容设置如下：;;set priority(setq org-highest-priority ?A)(setq org-lowest-priority ?D)(setq org-default-priority ?A)(setq org-priority-faces '(                           (?A . org-warning)                           (?B . (:background "DodgerBlue" :foreground "black" :weight bold))                            (?C . (:foreground "SkyBlue" :weight bold))                           (?D . (:foreground "DodgerBlue" :weight bold))                            ))2.3 操作TODO项目相关操作：M-S-Ret当前位置插入TODO项目，默认状态和上一条统计TODO状态一样C-S-Ret   当前级别子树后面插入TODO项目C-c C-t 当前所在TODO项目状态切换(不一定要在TODO标题上面)默认状态下，循环切换次序是TODO-&gt;Done-&gt;普通标题（只有*）。S-RIGHT/S-LEFT 当前所处TODO标题上进行状态切换默认状态下，循环切换次序是：TODO-&gt;DONE-&gt;普通标题C-c 修改优先级（包括A,B,C三个级别，不一定在TODO标题上面）S-UP/S-DOWN 切换优先级默认次序是A-&gt;B-&gt;C-&gt;无。C-u C-c C-t 快捷切换状态，输入后会提示你要输入的状态，可以支持Tab补全，可以用快捷按键替代。刷新子项目完成情况统计光标停留在 [%] 或者 [%] 之上，输入 C-c C-c3 格式3.1 段落一个独立段落需要段落之上有一个空行。如果没有空行则上一段的换行符号自动变成空格。如果强制换行而不用空行则在行尾输入 \\ 。3.2 字体字体格式一般会采用特定标记来实现，标记界限周围要和其他字符隔开，不能紧邻其他字符。*粗体*+删除线+_下划线_=等宽= 或 ~等宽~ /斜体/注意，等宽字体可以做为行内代码引用使用。例如： input3.3 硬换行注意，列表内或者其他部分，非段落的硬换行需要将相应行尾插入 \\ ，否则就需要用空行来另起一段落。直接换行会在输出特定格式的时候直接变成一个空白。4 列表4.1 语法Org 能够识别有序列表、无序列表和描述列表。无序列表项以‘-’、‘+’或者‘*‘开头。有序列表项以‘1.’或者‘1)’开头。描述列表用‘::’将项和描述分开。有序列表和无序列表都以缩进表示层级。只要对齐缩进，不管是换行还是分块都认为是处于当前列表项。同一列表中的项的第一行必须缩进相同程度。当下一行的缩进与列表项的的开头的符号或者数字相同或者更小时，这一项就结束了。当所有的项都关上时，或者后面有两个空行时，列表就结束了。例如：+ 列表如何处理缩进  这样处理  - 子列表    子列表缩进    * 子子列表      子子列表缩进内容，一般而言，尽量不用'*'做为列表的项目    子列表内容  列表内容总之，列表项下的内容，如果属于该列表项，那么就将其缩进成大于该列表项首行的标号再输入相应文字。另外，某一列表可以带有checkbox成为任务列表，实际就是在列表项开始加入一对中间有空格的方括号[ ]。任务列表可以有子任务，如果想要显示任务的完成情况计算总进度，只需要在总任务后面添加一对方括号，里面加上%或/ 如[%],[/]。4.2 操作M-RET 插入同级列表项C-RET 当前子树尾部插入同级别列表项M-S-RET 插入有 checkbox的同级列表项C-c C-c 改变 checkbox状态C-c - 更换列表标记，如果当前项不是列表，会被转化成列表。S-LEFT/RIGHT 更换列表标记，类似 C-c - 。M-left/right 改变列表项层级关系，不包括子项M-S-left/right 改变列表项层级关系，包括子项构成的子树M-up/dowm 上下移动列表项=TAB（新的空的列表条目中） 调整缩进级别如果新的条目中还没有文字，TAB 会调整到合适的级别。比如，我们在一个列表下新开一空行，然后TAB，这样之后敲入的内容将在相应的缩进之中（实践发现，如果Tab之前敲入内容了，那么Tab不会缩进）。如果列表项下事先已经有了未缩进的内容（即缩进级别和列表项目标号一样），那么该内容应该不属于相应列表项之内，如果逻辑上让其属于列表项，需要将其缩进。缩进的方法不是直接在相应位置或者行敲 TAB ，有两种方法将这部分内容调整缩进使之属于列表项：在内容前插入一空行，然后空行内敲入 TAB ，然后空行尾 DEL 或 C-k 将空行下的内容自动‘拉上来’实现缩进。2）在相应内容上插入一个 SPC ，然后再键入 =TAB=。注意，以上缩进方式缩进的级别自动和上一行缩进成同样级别。5 表格5.1 语法5.2 操作输入表格需要输入表头如 |Name|Pone|Age 之后，按C-c RET,就可以生成整个表格的结构(也可输入Tab调整)。输入表格分割线输入 |- 之后，按C-c RET,就可以生成整个表格的结构(也可输入Tab调整)。创建表格输入 C-c | ，会提示生成指定行列的表格。在下一行创建表格分割线在当前表格中输入 C-c - 。跳转下一项输入 TAB 可以自动调整表格对齐并且跳转到下一栏，如果是一行末则新开一行并跳入新行第一栏。输入之后，产生类似如下表格：te&#xa0;在单元格内换行输入 M-Ret将区域转换成表格输入 C-c |这里，对一片区域，每行用空格或者TAB分割开，选中该区域后，输入这个命令，便会将相应的内容转换成表格。移动光标到当前所在单元格首部输入 M-a移动光标到当前所在单元格尾部输入 M-e将当前光标所在表格项设置为空输入 C-c &lt;SPC&gt;删除当前光标所在列输入 M-S-&lt;Left&gt;在当前光标所在列左插入一列输入 M-S-&lt;Right&gt;这里注意，如果光标在表格最后一列的右面，运行这个命令就是在表格最右侧追加一列。左/右移动当前光标所在列输入 M-&lt;left&gt;/&lt;right&gt;6 块标记6.1 语法单行的例子内容以": "开头，注意后面的空格。6.2 操作加入"#+BEGIN_SRC和#+END_SRC"配对：行首输入`&lt;s Tab`加入"#+BEGIN_EXAMPLE和#+END_EXAMPLE"配对：行首输入`&lt;e Tab`加入"#+BEGIN_HTML和#+END_HTML"配对：行首输入`&lt;h Tab`输入 M-TAB例如:#+BEGIN_SRC eli#+END_SRC键入 eli 后输入 M-TAB, 即可补全出选项，例如：#+BEGIN_SRC elisp#+END_SRC对代码块进行求职在代码块上输入 C-c C-v C-e7 链接7.1 语法脚注用 [fn:1] 的方式插入脚注，要求脚注定义放在第0列，不能有缩进而在相应的解释部分插入类似如下：[fn:1]本文参考自xxx。其中 [fn:1] 部分是可以点击相互切换的。例如：The Org homepage[fn:1] now looks a lot better than it used to....[fn:1] The link is: http://orgmode.org外部链接链接的格式是：[[链接地址][链接内容]]如：[[http://orgmode.org/orgguide.pdf][grgguid.pdf]][[file:/home/maple/图片/test.jpg][a picture]]如果去掉标签，则能直接显示图片：[[file:/home/maple/图片/test.jpg]]这里，为了便于展示源代码， 我加上了转义，用于对单行例子的引用，如果没有": "转移字符，那么直接会在orgmode显示解析后的结果。7.2 配置保存链接的配置：(global-set-key "\C-cl" 'org-store-link)配置之后，每次输入 C-c l 之后会将当前位置所在的条目链接保存起来，之后输入 C-c C-l 的时候，会提示选择已保存的链接，默认选择最近一次保存的条目链接。启用全局唯一id链接配置如果启用了 org-id.el 以及设置了 org-id-link-to-org-use-id 那么运行 C-c C-l 会保存两个链接：一个是用户可读的链接（包含文件名和标题，当标题的文件和位置变化可能会导致原引用该处的链接不可用）；一个是具有全局唯一id的链接（在相应标题子树被转移到其它位置的时候，这个链接仍然不变）。其实保存链接内容的同时也创建了相应的链接，为创建全局唯一id的链接，运行之后，会导致相应子树标题下追加了如下属性：* 子树标题    :PROPERTIES:  :ID:       60aaa787-86e8-43a3-9a33-73d3eb7e6f58  :END:引用的格式举例 [[id:60aaa787-86e8-43a3-9a33-73d3eb7e6f58][子树标题]]下面给出一个配置的例子：;;Settings for global id link.(require 'org-id)(setq org-id-link-to-org-use-id t)7.3 操作保存链接输入 C-c l这项功能需要事先配置好 org-store-link 按键映射，配置好后这个动作会将当前位置所在条目的链接保存起来，供之后插入链接等使用。插入链接输入: C-c C-l这样会列出已经保存的链接供选择，也会在底部回显区会提示你输入链接网址和描述文字（支持事先保存的链接补全），输入或选择完成后，链接插入完毕。另外，在已有链接上输入该命令，可以在已有链接上进行修改。如果选择了具有全局唯一id的链接形式，不会因相应子树所处的文件等信息的改变而失效。内部链接引用和定义下面是内部链接引用和定义的例子[[inner][内部链接引用]]#&lt;&lt;inner&gt;&gt;记录内部链接地址输入 C-c %跳转到已记录的内部链接地址输入 C-c &amp;不断地输入会不断地跳转到已经记录和定义的内部链接，可以跨buffer。新建脚注输入： C-c C-x f输入之后，如果当前光标已有脚注，那么会在定义和第一个引用之处跳转，否则新建一个脚注。新建的脚注会在文档底部，有一个新开的标题"Footnotes"，新建的脚注编辑好定义之后，再输入 C-c &amp; 可以跳回刚才插入脚注的位置。8 时间戳8.1 NEXT 语法时间戳是一个具有特定格式的日期（可能带有时间和时间段）说明， 时间戳可以出现在树条目的标题和正文的任何地方，它能使条目只在特定的日期才出现在议程列表中。主要有如下一些类型：普通时间戳；可用于事件、约会简单地给一个条目加上时间和日期，指明事件或约会发生的时间：* Meet Peter at the movies &lt;2006-11-01 Wed 19:15&gt;* Discussion on climate change &lt;2006-11-02 Thu 20:00-22:00&gt;具有时间间隔的时间戳：可用于周期重复的内容时间戳可以包含一个时间间隔，表示事件不只在指定的时间发生，还在每隔一个特定的时间如 N 天（d）、周（w）、月（m）或者年（y）之后重复发生。如以下表示从2007-05-15开始每周2发生的会议事件* Pick up Sam at school &lt;2007-05-16 Wed 12:30 +1w&gt;日记样式的 sexp 条目Orgmode 为支持更复杂的时间，支持的Emacs 日历/日记包（calendar/diary package）中的日记条目* The nerd meeting on every 2nd Thursday of the month&lt;%%(diary-float t 4 2)&gt;时间/日期段两个时间戳用‘–’连接起来就定义了一个时间段.** Meeting in Amsterdam&lt;2004-08-23 Mon&gt;--&lt;2004-08-26 Thu&gt;非激活的时间戳在方括号而不是尖括号中的时间戳，是未激活的，只是一个时间戳记录信息，它不会让一个条目显示在议程中。* Gillian comes late for the fifth time [2006-11-01 Wed]时间戳前面可以加一些关键字来协助计划安排。例如表示任务应该完成的日期的截止期限（DEADLINE）,用于指定任务开始日期的日程安排（SCHEDULE）。参考:http://www.cnblogs.com/Open_Source/archive/2011/07/17/2108747.html#sec-8 http://members.optusnet.com.au/~charles57/GTD/org_dates/index.html进行提取8.2 操作插入一个时间戳输入 C-c .输入之后，会进入一个交互模式，默认是当前时间，可以通过 S-LEFT/RIGHT/UP/DOWN 选择一个指定的时间戳，插入之后的时间戳是激活的，会以'&lt;&gt;'括起来，只有日期信息没有时间，可以在日程视图中显示。Calendar Navigation	Shift-RIGHT	Go forward a dayShift-LEFT	Go backward a dayShift-UP	Go to previous weekShift-DOWN	Go to next week&lt;	Scroll calendar back 1 month&gt;	Scroll calendar forward 1 month.	Go to Today插入一个非激活的时间戳输入 C-c !命令类似 C-c . 不过这条命令插入的时间戳是非激活状态的，不会在Agenda中显示。插入一个包含日期和时间的时间戳输入 C-u C-c .输入这个命令也会插入时间戳，与 C-c . 不同的是它插入的时间戳不仅包含日期信息，还包含时间信息。插入一个包含日期和时间的非激活时间戳输入 C-u C-c !命令类似 C-u C-c . 只是插入的时间戳是非激活的。修改插入的时间戳光标停在待修改的项目上(年/月/日/时/分/秒)输入 S-UP / S-DOWN , 如果 S-LEFT / S-RIGHT 则是修改日期。插入设置为SCHEDULE的时间戳输入 C-c C-s会在当前标题下面插入一个带有"SCHEDULE"的时间戳，同样可以通过 S-LEFT/RIGHT/UP/DOWN 选择一个指定的时间。插入设置为DEADLINE的时间戳输入 C-c C-d会在当前标题下面插入一个带有"DEADLINE"的时间戳，同样可以通过 S-LEFT/RIGHT/UP/DOWN 选择一个指定的时间。插入一个非激活的时间戳输入 C-c !输入之后，类似上面，通过 S-LEFT/RIGHT/UP/DOWN 选择日期插入。插入的时间戳不是激活的，会以'[]'括起来，不在日程视图中显示。打开Emacs Clendar输入 C-c &gt;插入Emacs Calendar光标所在的日期到光标所在处输入 C-c &lt; 计算光标所在time range之间的天数输入 C-c C-y记录工作时间在任务开始、结束、中断的时候可以使用Org在相应的任务标题下添加一个时间日志，动态记录时间信息。相关指令如下：C-c C-x C-i	开始当前条目的计时（clock-in）。这会插入一个 CLOCK 关键字和一个时间戳。加上 C-u 前缀，从当前已经计时的任务中选择任务。C-c C-x C-o	停止计时（clock-out）。这会在开始计时的地方插入另一个时间戳。它会直接计算使用时间并插入到时间段的后面如 “=&gt; HH:MM”。C-c C-x C-e	为当前的计时任务更新进度。C-c C-x C-x	取消当前的计时。当你误操作打开一个计时时，或者转而去做其他事情时，这个命令就很有用。C-c C-x C-j	跳转到包含当前正在运行的计时的任务条目。用 C-uf前缀从当前计时的任务中选择。C-c C-x C-r	在当前文件插入一个包含像 Org 表格一样的计时报告的动态块。当光标正处于一个存在的块上时，更新它。C-c C-c	在一个已经存在的计时表格之上时，更新它。 更新动态块。光标需要置于动态块 #+BEGIN 这行。9 标签9.1 语法标签以":"做为开头和结尾，可以连续定义多个。例如：:boss:notes:9.2 配置标签是动态增加的，也可预定义，预定义的方式如下：使用#+TAGS元数据进行标记，仅对当前文件有效：#+TAGS: { 桌面(d) 服务器(s) }  编辑器(e) 浏览器(f) 多媒体(m) 压缩(z)修改.emaxcs配置;;set tags(setq org-tag-alist '(                    (:startgroup . nil)                         ("room" . ?r) ("outside" . ?o)                    (:endgroup . nil)                    ("工作" . ?w)                    ("生活" . ?l)                     ("学习" . ?s)                    ))9.3 操作键入 : 后， M-Tab 自动提供标签的补齐。更方便的做法是在正文部分用 C-c C-q 或直接在标题上用 C-c C-c 创建标签，这种方式可以列出所有预定义的标签以便选取。10 Capture-Refile-Archive10.1 概念Capture用来迅速收集一些临时产生的想法，尽可能少的打断当前的工作状态。通过指定好快捷方式和相应的Capture目标位置后，在任意时间运行捕获命令会将这些临时的记录存放在一个指定的位置，空闲之时再做进一步整理。Refile以特定的命令，用来将之前Capture的内容直接转移到特定的地方，避免了手动剪切（复制）和粘帖。10.2 配置10.2.1 Capture的配置不同的管理方式可能会导致不同的配置，但是一般都包含两个方面：首先设置好一个启动Capture的快捷方式，再配置用于存储Capture信息的目的地。这里以gtd管理为例给出一个配置例子：;;Setting for gtd captures;;Directory for capture files.(setq org-directory "~/mydata/orgmode/");;Default capture files.(setq org-default-notes-file (concat org-directory "gtd/inbox.org"));;Capture template(setq org-capture-templates '(			      ("t" "Tasks" entry (file+headline "gtd/inbox.org" "Tasks") "* INBOX %?\nTime:%T\nFrom:%F\n")			      ("p" "Projects" entry (file+headline "gtd/inbox.org" "Projects")  "* %?\nTime:%U\nFrom:%F\n")			      ("i" "Item notes" item (file+headline "gtd/inbox.org" "Items")  "+ %?\n  Time:%U\n  From:%F\n")			      ("m" "Misc notes" plain (file+headline "misc.org" "Notes")  "-----------------------------------------------------\nTime:%U\n %?")			     )) ;;set tags;;where?(h/o/w),what?(c/l/s),when?(gtd|immeiately,wait,action),who?(my gtd,others),why?how?(delete/archieve/schedule)(setq org-tag-alist '(                    (:startgroup . nil)                         ("home" . ?r) ("office" . ?o) ("way" . ?w)                    (:endgroup . nil)                    ("职业" . ?c)                    ("生活" . ?l)                     ("学习" . ?s)                    ))10.2.2 Refile的配置主要配置两个方面的内容：Refile的目标（org-refile-targets），以及Refile时选择目标的策略(org-refile-use-outline-path会自动补全文件名以及标题，目标的格式类似文件路径的格式，包含文件和标题)。org-refile-targets对应的可以是路径可以是列表，具体参考其中的文档，需要注意的是：如果是列表该变量中的文件路径需要是全路径；文件中需要有一个标题才能在做 C-c C-w 补全的时候显示出来，空文件不行。如果是一个文件路径如果org-refile-targets是一个文件，则：这个文件可以是一个文件列表，使用这个列表的文件做为refile目标; 每个文件项占一行（不要有""），文件项可以是对于org-directory的相对路径; 这样文件内容变化之后，不用重新载入配置也能在 C-c C-w 中显示出新增的文件; 如果有一项是文件目录，那么不要再次包含该目录下的文件，因为这样会在agenda view中导致重复显示。;;targets for refile(setq org-refile-targets (quote (                                 (nil :maxlevel . 9)                                 (org-agenda-files :maxlevel . 9)                                )                         ));;outline path for refile(setq org-refile-use-outline-path 'full-file-path);;org-outline-path-complete-in-steps(setq org-outline-path-complete-in-steps t);;create new parents while refile(setq org-refile-allow-creating-parent-nodes 'confirm)10.3 操作基于以上配置，我们可以操作如下：启动Capture输入 C-c c输入之后会提示选择捕获何种类型的信息，提示信息和选择命令取决于之前设置的配置变量 org-capture-templates 。选择将待捕获的信息存于"Tasks"标题之下输入 t具体如何输入取决之前的配置如何，这里输入之后会打开一个Capture Buffer，用于输入将要被记录的信息，其中按照预先配置好的模板，已经预先插入了一些基本信息（如时间、捕获信息时所处位置等等）。完成Capture输入 C-c C-c输入之后，会将buffer中相应的信息插入到之前配置好的位置（例如某个文件中的某个标题之下），然后回到之前被中断的工作状态。取消Capture输入 C-c C-k取消捕获的动作，回到之前被中断的工作状态。访问存放Capture的文件Buffer输入 C-u C-c c输入之后，会提示和 C-c c 一样的信息，选择相应的捕获类型后，会直接打开相关的文件，具体是何文件，取决于事先设置的信息。访问上次捕获所处的文件Buffer输入 C-u C-u C-c c类似前面，捕获访问的是记录上次捕获的文件Buffer，并自动定位到其中上次捕获的信息之上。以剪切方式Refile输入 C-c C-w输入之后，会提示Refile的目标位置（在org-agenda-files中列出），支持Tab补全，选择好相应的文件之后，可以继续将文件内的标题也类似路径的方式输入（也支持TAB补全），选择好之后，回车会将相应的内容移动到对应的目标位置。注意：移动的内容可以是用Mark方式选择的区域，或者当前光标所在的子树，在执行 C-c C-w 之后有提示。以复制方式Refile输入 C-c M-w输入之后，会提示Refile的目标位置（在org-agenda-files中列出），支持Tab补全，选择好相应的文件之后，可以继续将文件内的标题也类似路径的方式输入（也支持TAB补全），选择好之后，回车会将相应的内容复制到对应的目标位置。注意：复制的内容可以是用Mark方式选择的区域，或者当前光标所在的子树，在执行 C-c C-w 之后有提示。访问Refile的目标对应Buffer输入 C-u C-c C-w输入之后，会提示和 C-c C-w 一样的信息，选择相应的位置后，会直接打开相关的文件。访问上次Refile所处的文件Buffer输入 C-u C-u C-c C-w类似前面，访问的是记录上次Refile的文件Buffer，并自动定位到上次Refile目标的信息之上。11 Agenda11.1 操作调出Agenda显示交互界面输入 C-c a输入之后，根据提示选择想要显示的视图种类。11.1.1 交互操作调出Agenda交互界面之后，可以进行如下交互操作（注意：操作作用范围是相应的agenda文件）。限定Agenda显示内容的范围输入 &lt;输入之后，会切换Agenda视图的搜索范围，依次为“没有限定”、“限定当前buffer”、"限定当前子树"。取消对Agenda view的范围限定输入 &gt;列出所有TODO项目输入 t列出特定状态的TODO项目输入 T输入之后，需要进一步输入需要列出的状态关键字，以完成显示。搜索包含指定字符串的标题输入 s输入之后，再输入待搜索字符串即可列出所有包含该字符串的标题（字符串可能在内容中）搜索TODO项目字符串输入 S同上，不同之处是，搜索的是TODO标题项目，而不是普通标题。搜索字符串输入 /输入之后，再输入待搜索字符串将会列出所有包含该字符串的地方。11.1.2 交互命令：进入Agenda中后，会有如下提示：Global list of TODO items of type: ALLAvailable with `N r': (0)[ALL] (1)INBOX (2)NEXT (3)LATER (4)WAIT/FORWARD (5)MAYBE/FUTURE (6)CANCEL (7)DONE只显示某一项，如只显示NEXT的内容输入 2 r重新刷新当前 Agenda输入 r切换是否显示当前行所在buffer内容输入 &lt;12 导出12.1 操作导出为特定格式输入 C-c C-e 输入之后，会默认将当前Buffer导出为特定格式，期间需要输入交互信息指定导出为html还是pdf；如果需要其它的导出选项，比如将当前子标题导出为特定格式，需要根据交互命令来做（比如C-s是切换导出范围）。13 其它搜索sparse tree输入 C-c / 输入之后，会提示你搜索对应的内容，输入你想搜索的内容后可以看到相关内容以及相关的tree。导出输入 C-c C-e输入之后，进入交互命令，可以选择各种需要导出的格式。13.1 建议13.1.1 列表与标题建议少用列表，多用标题。列表中的段落尽可能少，层次尽可能浅；多用标题也方便定位和缩进(标题过多，会导致目录复杂?)。建议少用断行，多用段落。13.1.2 列表与换行[2015-10-19 一 07:52]想到一个方法解决列表内多段落的问题。换行杜绝硬换行的习惯, 尽量使用空行表示换行。硬换行用“\\”，但是输入不便且有些情况不支持（如MobileOrg），所以想要换行，就新起一段落，那么新行前多一个空行。这是一个新行，也是新段落。一个段落，实际就是一行。逻辑关系有标点表示。列表内换行用描述列表有时为美观，列表第一换行若用一空行则显得与列表项标题相距有点远，并且第一行内容一般也很少，一般都是总体描述性文字。所以，建议第一行是简短描述时用描述列表，第一行在描述的“::”后，之后的段落也用空行。若直接第一行就很长不是描述，那么不用描述列表，并且宁可与列表项标题多空一行，也不用断行符。13.2 感想学习orgmode主要分为如下几个阶段：基本标记语法阶段 可以在简单场合写作简短的评论、文章使用，需要关注的内容可以是：标题、格式、列表、链接、表格、块标记日程管理阶段 对基本标记语法掌握之后，进一步掌握日程管理并利用其中的功能，需要关注的内容可以是：发布阶段 对已有内容整理、组织、发布成公开格式13.3 注意如果Checkbox，则最好一行，如果是多行的Checkbox, 那么导出的效果将会把 + [ ] 放到第一行，其它的全在新行开始。13.4 orgmode与mobile org整合参考相关文档：MobileOrg学习本文之前，需要首先了解Orgmode相关知识，至少应该知道：Orgmode可用于轻量级文档标记、项目管理、以及内容发布。MobileOrg是一个使用Org mode的移动端应用程序。目前支持IOS和Android系统。MobileOrg提供离线浏览(Viewing)和捕获(Capture)在真实计算机上的Org mode系统内容。它允许你为已有的entries记录修改。本文中：MobileOrg是Mobile端的一个应用程序，运行在Android（也有IOS的MobileOrg）;Org是PC端Emacs的一个插件应用，对应其Orgmode模式。文档中描述如何用Org创建可以通过MobileOrg显示的文档格式，以及如何将Mobile端的MobileOrg中修改和捕获的笔记，集成到PC端的“主” Org mode系统中（即Org与MobileOrg的同步），不涉及Agenda相关的操作。13.4.1 配置为了在MobileOrg中能够修改tags和TODO状态，你应该在PC端设置好自定义变量： org-todo-keywords 和 org-tag-alist ，使它们包含所有需要修改的重要的tags和TODO keywords，哪怕每个文件只使用其中的部分内容。MobileOrg也能通过in-buffer settings来为你提供TODO和tags设置，但是它只能读懂这些变量中的那些设置好的TODO状态集合以及tags。假设我们想要使PC上的Org与移动设备上的MobileOrg保持内容同步（底层通过git机制，也可以是云存储、ssh、ftp等机制）。这里给出为实现这个目的，在PC需要做的配置工作(移动端的MobileOrg做为辅助工具，其配置和操作非常简单，在适当的时候会提及)。13.4.1.1 在PC上添加使用MobileOrg的emacs配置主要包括对Emacs中org-mode模块的加载以及与MobileOrg同步的路径。例如:;;Sync with mobileorg(require 'org-mobile);;mobile stage(setq org-mobile-directory "/home/miracle/mygitrepo/pocket/MobileOrg")另外，可以通过 org-mobile-encryption-password 设置加密方面的内容。在后面我们可知，在PC上的orgmode中有特定的命令将相关内容推送到这个目录中。13.4.1.2 在PC上添加同步orgmode和MobileOrg的emacs配置主要包括PC端和MobileOrg端状态与标记的设置，PC上被推送orgmode内容的源文件路径，以及PC上接收MobileOrg修改的缓存路径设置。为被推送文件定义只属于该文件的状态和标记被推送的文件可使用文件选项定义相关的状态和标签（实践发现不用定义文件的状态和标签也行），定义内容最好和PC上的相关状态变量(即 setq org-todo-keywords )一致，或者是其子集。如果使用文件定义状态，那么可以将用于push到MobileOrg的文件中的状态设置选项如下：#+TODO: INBOX(i!) NEXT(n!) LATER(l!) WAIT/FORWARD(w@/!) MAYBE/FUTURE(m!) | CANCEL(c!) DONE(d!)标记的设置类似。设置状态关键字和被推送至MobileOrg的文件列表路径如下;;set status for TODO.(setq org-todo-keywords '((sequence "INBOX(i!)""NEXT(n!)""LATER(l!)""WAIT/FORWARD(w@/!)""MAYBE/FUTURE(m!)""|" "CANCEL(c!)" "DONE(d!)")))   ;;mobile push(setq org-mobile-files (list (concat org-directory "gtd/mobile_org")))设置接收来自MobileOrg内容的“缓存”目标文件路径如下;;mobile pull(setq org-mobile-inbox-for-pull (concat org-directory "gtd/from_mobile.org"))13.4.2 原理13.4.2.1 Mobile端的Mobile Org与PC端的Org同步当我们在MobileOrg中与PC端的Org同步时，需要知道它不仅仅是从PC端获取（mobile端的pull）相应org文件用于浏览，同时也会追加(mobile端的push)被captured的entries(之后captured的内容会消失)，并且指向被标记和修改的entries，这些内容被汇总在同步目录( org-mobile-directory )中的 mobileorg.org 文件里。13.4.2.2 PC端的Org与Mobile端的MobileOrg同步PC端的Pull获取MobileOrg修改内容(PC端的pull)的时候，会将这些信息从 mobileorg.org 先转移到到 org-mobile-inbox-for-pull 对应的文件中，并对指向的被标记的内容进行进一步操作，进而将能够自动处理内容同步到对应的文件中。Pull的过程大致过程如下:Org将会将 mobileorg.org 中的所有entries移动到 org-mobile-inbox-for-pull 所指向的文件（假设为mobileinbox），每个被捕获的entry和编辑事件都会被做为这个mobileinbox中的顶级entry而存在。（进行操作之后， mobileorg.org 将会被清空）当将entries移动到 org-mobile-inbox-for-pull 指向的文件之后，Org将会开始执行在MobileOrg进行的修改。有些修改直接就会被应用了不需要额外的用户交互（例如修改tag、TODO状态、标题、正文文本可以被简单的应用）。而需要额外动作的entries会接收到一个:FLAGGED:的tag，这样它们才会很容易地被找到。当应用修改或者寻找一个entry之时出现了问题，目标entry将会保持在 org-mobile-inbox-for-pull 中，并且被标记一个错误信息，我们需要之后手动解决这些问题，并将对应内容(entry)转移到期望的位置。(不熟悉)Org之后会生成一个包含所有flagged的entries的agenda view，用户可以遍历这些entries来做一些必要的动作。如果在对MobileOrg中的entry进行标记的时候一个note已经存储了，那么这个note会在光标处于对应agenda line的时候在回显区域显示出来。关于 ?在哪个特定的agenda中按下 ? 将会在另外一个windows中显示整个被标记的笔记(flagging note)，也会将它push到kill ring中。所以，你可以在这个entry中使用 ?z C-y C-c C-c 保存哪个标记笔记为普通笔记。连续键入 ? 两次将会体同将 :FLAGGED:标签联通记录的标记笔记（flagging note）（在一个属性中被保存）一起被移走。这样，你可以用此来表示这个 flagged entry的处理已经完成。如果你不能够直接处理所有的flagged entries，你可以通过 C-c a 回到这个agenda view。PC端的Push推送内容到MobileOrg端(PC端的push)的时候，会推送PC上设置的 org-mobile-files 对应的文件，该变量对应的文件路径是相对 org-directory 的路径，默认使用 org-agenda-files ,被退送的目标是 org-mobile-directory 设定的位置。Push的过程大致如下：拷贝 org-mobile-files 中的内容到同步目录 org-mobile-directory 中，文档中提到，如果待推送的文件是一个链接文件，那么链接文件名称需要和源名称一致。创建特定的agendas.org文件，这些文件可以是用户自定义的agenda view，由 org-mobile-agendas 来设定。最后，orgmode会写一个 index.org 文件，这个文件包含所有到其他文件的链接，Mobile首先在Server中读取这个文件，然后把这个文件中列出的所有agendas文件和org文件下载下来，为了加速下载过程，MobileOrg只读取checksums3被改变的文件。13.4.2.3 Org与MobileOrg的同步目录我们需要注意，在前面的讲述中所涉及到的同步，其实暗含了两种同步：Mobile端的MobileOrg与PC端的Org之间的同步（通过设定一个同步目录做为中转）这个前面也讲到，主要是Mobile端的Sync（包含Push/Pull）操作，以及PC端的Push/Pull操作。同步目录在云端与PC/Mobile端的同步前面MobileOrg和Org同步之时，需要经过它们之间的一个共通的“同步目录”。这个目录在Mobile端和PC端的内容和结构需要首先保持一致，才能保证后续MobileOrg和Org之间数据的同步一致。所以，我们在同步PC端的Org与Mobile端的MobileOrg之前，先将PC端和Mobile端的目录通过某种方式进行同步。这里同步目录的方式使用用git进行，PC端和Mobile端之间的同步目录用某个git托管服务器进行管理（例如github、bitbucket、或者自己的服务器），任意端的同步目录中数据发生变化后都要推送到托管服务器中，而任意端要读取最新数据都需要从托管服务器中拉取数据，同步目录中的数据更新之后，再进行后续MobileOrg和Org的数据更新。我们也可使用其它方式管理同步目录，比如云存储（百度云、DropBox等）、或者ftp、webdav、ssh等。另外，Mobile端的git可以使用pocketgit工具。13.4.3 同步操作13.4.3.1 PC端的Org推送（Pull）命令如下：M-x org-mobile-push 推送之后，会在同步目录（即 org-mobile-directory 对应的路径）中建立 org-mobile-files 对应文件列表的路径结构，并拷贝相应文件到其中。13.4.3.2 PC端的Org拉取（Push）命令如下：M-x org-mobile-pull 运行之后，其对应的 org-mobile-files 便包含了和MobileOrg同步的内容。13.4.3.3 Mobile端的MobileOrg同步（Sync）这里使用Android版本的MobileOrg，大致如下：首先设置好同步目录，然后选择软件界面中的"Sync"按钮，即可完成同步（包含Pull和Push）。13.4.4 使用举例PC上配置好相关变量和目录手机上安装好MobileOrg也设置好同步目录将PC和手机上的同步目录用github/bitbucket管理PC上同步目录更新： git/pullPC上记录之前运行： org-mobile-pull 可以看到手机上修改的内容。PC上记录，记录之后运行： org-mobile-pushPC上的git同步目录上传修改： git add/commit/push手机上的git同步目录下载更新： git pull手机上的MobileOrg同步(点击Sync)手机上看到PC修改的内容手机上修改并同步（点击Sync）手机上更新同步目录： git add/commit/push回到步骤4。缺点：列表中的段落，无法识别断行？13.4.5 其它13.4.5.1 关于Agenda在手机端的Mobileorg上，看到的agenda内容是在 org-mobile-files 范围内的内容。13.4.5.2 MobileOrg的实用之处-CaptureMobileOrg的特长目前看来非编辑和阅读，因为编辑和阅读所支持的格式不全，并且一般都在pc上进行编辑。MobileOrg存在的一个亮点是Capture。在MobileOrg上直接捕获(Capture)， 不设置父标题（即新建笔记到Capture下），在PC端运行 org-mobile-pull 的时候，直接将其抓取到 inbox-from-mobile 中，同步后MobileOrg上的相应Capture也会消失。这样，手机中随手记下简短的内容，再汇集到PC上整理。13.5 orgmode与jekyll的结合主要介绍使用orgmode的发布功能生成html文件，然后将orgmode的发布功能与jekyll结合。13.5.1 部署13.5.1.1 jekyll环境路径为 ~/mygitrepo/quietheart/mydoc/prepub/jekyll/13.5.1.2 orgmode文档环境路径为 ~/mygitrepo/quietheart/mydoc/prepub/orgmode/13.5.1.3 关键文件结构包含各自说明目录的作用~/mygitrepo/quietheart/mydoc/prepub/jekyll/readme~/mygitrepo/quietheart/mydoc/prepub/orgmode/readmeorgmode文档路径中待发布到jekyll的内容在如下路径：~/mygitrepo/quietheart/mydoc/prepub/orgmode/_posts/~/mygitrepo/quietheart/mydoc/prepub/orgmode/data对应的目录内的结构应该是jekyll的镜像子集。其它路径其他路径作用会根据需要确定。如 ~/mygitrepo/quietheart/mydoc/prepub/orgmode/categories/ 当前暂时在_posts中写文，完成的文章可能会转移至categories。又如 ~/mygitrepo/quietheart/mydoc/prepub/orgmode/_includes 这个里面包含为兼容jekyll显示，定义的样式，是html代码片段。13.5.2 配置做如下配置，使得orgmode导出的文件直接被导出到jekyll中：;;;;Publish;;;;;;(require 'org-publish);;old;;(require 'org-html);;old;;(require htmlize);;??(require 'ox-publish)(require 'ox-html)(setq org-publish-project-alist '(    ("org-docs"    :base-directory "~/mygitrepo/quietheart/mydoc/prepub/orgmode/_posts/"    :base-extension "org"    :publishing-directory "~/mygitrepo/quietheart/mydoc/prepub/jekyll/_posts/"    :recursive t    :publishing-function org-html-publish-to-html    :headline-levels 4             ; Just the default for this project.    :language zh-CN    :html-extension "html"    :body-only t ;; Only export section between &lt;body&gt; &lt;/body&gt;        ;;:auto-preamble t    ;;:section-numbers nil     :with-toc nil    :with-smart-quotes t        ;;:with-fixed-width nil    ;;:with-tables t    ;;:with-tasks t    ;;:with-todo-keywords t    ;;:with-timestamps t    ;;:with-footnotes t    ;;:author QuietHeart    ;;:email quiet_heart000@126.com    ;;:with-email t    )    ("org-data"    :base-directory "~/mygitrepo/quietheart/mydoc/prepub/orgmode/data/"    :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf\\|tgz\\|gz\\|tar\\|zip\\|rar\\|7z"    :publishing-directory "~/mygitrepo/quietheart/mydoc/prepub/jekyll/data/"    :recursive t    :publishing-function org-publish-attachment    )    ("org" :components ("org-docs" "org-data")) ))13.5.3 被导出文件与jekyll的集成被导出文件按照类似jekyll的方式命名，即 日期-文章名.org ，再经过上述配置，orgmode导出的文件是只包含 body 部分的相同文件名但是扩展名为 .html 的文件。这个时候，生成的文件已经能够直接被jekyll应用，集成到jekyll框架内生成的站点中，但是生成的文件格式还是可能有些错乱，而且没有包含jekyll所需的头信息（ YAML Front Matter 信息）。13.5.4 为待发布文章添加兼容jekyll显示的信息为使得发布的文章能够更好的兼容jekyll信息，需要对待发布的 *.org 文章， 从最开始，依次添加如下额外信息。13.5.4.1 orgmode html选项首先添加文档选项信息，这些信息不直接体现在文章内容上。可以先输入 C-c C-e # html 以便插入html模板，插入的信息类似如下：#+OPTIONS: html-link-use-abs-url:nil html-postamble:auto#+OPTIONS: html-preamble:t html-scripts:t html-style:t#+OPTIONS: html5-fancy:nil tex:t#+HTML_DOCTYPE: xhtml-strict#+HTML_CONTAINER: div#+DESCRIPTION:#+KEYWORDS:#+HTML_LINK_HOME:#+HTML_LINK_UP:#+HTML_MATHJAX:#+HTML_HEAD:#+HTML_HEAD_EXTRA:#+SUBTITLE:#+INFOJS_OPT:#+CREATOR: &lt;a href="http://www.gnu.org/software/emacs/"&gt;Emacs&lt;/a&gt; 23.3.1 (&lt;a href="http://orgmode.org"&gt;Org&lt;/a&gt; mode 8.3.1)#+LATEX_HEADER:不同版本，可能产生的内容有所不同，根据个人需要对此进行修改，如果不需要，那么就不加这个步骤。这里给出一个实例：#+TITLE:GTD管理方式#+AUTHOR:QuietHeart#+DATE:[2015-11-03 二 12:16]13.5.4.2 jekyll所需的 YAML Front Matter之后再添加用于jekyll识别的 YAML Front Matter 信息，信息位于 #+BEGIN_HTML...#+END_HTML 之间，必须将信息包含在两对 --- 行内，这样生成的导出文件，最开始便是相应的 YAML Front Matter 信息了。具体参见jekyll相关文档。这里给出一个例子：#+BEGIN_HTML---layout: poststitle: GTD管理方式categories: [categories, note]comments: true---#+END_HTML13.5.4.3 包含兼容jekyll显示的css样式信息再后添加导出html样式信息，该信息是html代码片段而非css文件的包含。由默认 C-c C-e hh 导出的单html文件样式修改而来，修改之时结合jekyll的CSS配置，将这个配置插入到导出的html中，便可使导出的文件样式更好地兼容整个jekyll环境中所定义的样式。如前面所述，这里会将该代码片段存成文件 jekyll_orgmode_style.ext ，部署到 orgmode/_includes/ 中，并被包含的待发布的文章中，如下：#+INCLUDE: "../_includes/jekyll_orgmode_style.ext"关于样式代码片段内容，根据个人的jekyll样式定义，以及orgmode导出的html样式各有不同，需要自行修改，这里给出一个例子：#+BEGIN_HTML&lt;style type="text/css"&gt;.title  { text-align: center;           margin-bottom: .2em; }.subtitle { text-align: center;            font-size: medium;            font-weight: bold;            margin-top:0; }.todo   { font-family: monospace; color: red; }.done   { font-family: monospace; color: green; }.priority { font-family: monospace; color: orange; }.tag    { background-color: #eee; font-family: monospace;          padding: 2px; font-size: 80%; font-weight: normal; }.timestamp { color: #bebebe; }.timestamp-kwd { color: #5f9ea0; }.org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }.org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }.org-center { margin-left: auto; margin-right: auto; text-align: center; }.underline { text-decoration: underline; }#postamble p, #preamble p { font-size: 90%; margin: .2em; }p.verse { margin-left: 3%; }pre {  border: 1px solid #0c0;  box-shadow: 1px 1px 1px #0e0;  padding: 8pt;  font-family: italic monospace;  color: #C7EDCC;  background-color: #111111;  overflow: auto;  margin: 1.2em;}pre.src {  position: relative;  overflow: visible;  padding-top: 1.2em;}pre.src:before {  display: none;  position: absolute;  background-color: white;  top: -10px;  right: 10px;  padding: 3px;  border: 1px solid black;}pre.src:hover:before { display: inline;}pre.src-sh:before    { content: 'sh'; }pre.src-bash:before  { content: 'sh'; }pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }pre.src-R:before     { content: 'R'; }pre.src-perl:before  { content: 'Perl'; }pre.src-java:before  { content: 'Java'; }pre.src-sql:before   { content: 'SQL'; }table { border-collapse:collapse; }caption.t-above { caption-side: top; }caption.t-bottom { caption-side: bottom; }td, th { vertical-align:top;  }th.org-right  { text-align: center;  }th.org-left   { text-align: center;   }th.org-center { text-align: center; }td.org-right  { text-align: right;  }td.org-left   { text-align: left;   }td.org-center { text-align: center; }dt { font-weight: bold; }.footpara { display: inline; }.footdef  { margin-bottom: 1em; }.figure { padding: 1em; }.figure p { text-align: center; }.inlinetask {  padding: 10px;  border: 2px solid gray;  margin: 10px;  background: #ffffcc;}#org-div-home-and-up { text-align: right; font-size: 70%; white-space: nowrap; }.linenr { font-size: smaller }.code-highlighted { background-color: #ffff00; }.org-info-js_info-navigation { border-style: none; }#org-info-js_console-label  { font-size: 10px; font-weight: bold; white-space: nowrap; }.org-info-js_search-highlight{ background-color: #ffff00; color: #000000; font-weight: bold; }  &lt;/style&gt;#+END_HTML13.5.4.4 添加文章内容目录索引为保证用于jekyll的 YAML Front Matter 位于文件最前，前面的 :with-toc nil 配置可以确保orgmode不会自动将目录插入到文件开始，但是如果需要为文章加入目录信息，可以手动通过 #+TOC: headlines 3 在需要之处插入目录。实例如下：#+TOC: headlines 313.5.4.5 需要添加信息的汇总这里为清晰起见，做一个汇总，经过前面添加的过程，最终我们在所要发布的 *.org 文章里添加的信息举例如下：#+TITLE:GTD管理方式#+AUTHOR:QuietHeart#+DATE:[2015-11-03 二 12:16]#+BEGIN_HTML---layout: poststitle: GTD管理方式categories: [categories, note]comments: true---#+END_HTML#+INCLUDE: "../_includes/jekyll_orgmode_style.ext" #+TOC: headlines 3注意，文章内容中的链接全部用相对于orgmode配置的发布源路径的相对链接。13.5.5 发布命令配置好信息之后，直接运行orgmode的发布命令即可将相应orgmode文件转换为html文件：M-x org-publish-project RET org RET或者输入 C-c C-e P x注意，因为缓存的关系，如果没有被修改的文件，有时候可能不会被重新发布，可以只发布当前文件： C-c C-e P f13.5.6 其他参考资料：http://orgmode.org/worg/org-tutorials/org-jekyll.htmlhttp://higrid.net/c-art-orgmode_jeklly_github.htmhttp://orgmode.org/worg/org-tutorials/org-publish-html-tutorial.html自行配置的时候，可能在执行的时候发布命令会报错，Publishing file /home/miracle/mygitrepo/quietheart/mydoc/prepub/orgmode/_posts/2015-11-03-GTD_Manage_Method.org using `org-publish-org-to-html'find-buffer-visiting: Wrong type argument: stringp, (:base-directory "~/mygitrepo/quietheart/mydoc/prepub/orgmode/_posts/" :base-extension "org" :publishing-directory "~/mygitrepo/quietheart/mydoc/prepub/jekyll/_posts/" :recursive t :publishing-function org-publish-org-to-html ...)这时候可以参考如下信息：http://www.cnblogs.com/banjia/archive/2012/09/29/2708966.htmlhttp://comments.gmane.org/gmane.emacs.orgmode/76412http://orgmode.org/worg/org-8.0.html13.6 Misc collection杂乱无章的收集的文档，暂时无法分类可能待整理?13.6.1 &#x2014;&#x2014; [2015-12-03 四 14:55]  Agenda view------From:/home/miracle/mydata/orgmode/gtd/inbox.org把当前buffer加入到agenda files中C-c [把当前buffer从agenda files中移除C-c ]14 WAIT/FORWARD FAQ [35/111]([31%])State "WAIT/FORWARD" from              [2015-11-27 五 15:10]  wait for all finishied.14.1 MAYBE/FUTURE 如何隐藏"标题星星"？State "MAYBE/FUTURE" from "INBOX"      [2015-11-23 一 17:53]参考下面的资料：啊，十分感谢，果然也可以隐藏星星，而且没有INDENT所带来的问题，虽然在某级别下行输入普通文本不会自动缩进，不过已经很好了。  另，开启这个变量的方式是在.EMACS文件中加入(SETQ ORG-HIDE-LEADING-STARS T)【 在 UNKNOWNZERX 的大作中提到: 】: 话说有个ORG-HIDE-LEADING-STARS变量14.2 LATER 搜索子树相关State "LATER"      from "INBOX"      [2015-12-03 四 15:33]C-c / d 建立一个包含所有deadline的TODO项目的sparse treeC-c / b 建立一个包含deadline在指定日期前的TODO项目的sparse treeC-c / a 建立一个包含deadline在指定日期后的TODO项目的sparse tree 14.3 DONE 各个级别标题列表如何缩进？用调整的级别的命令即可。例如参考：标题大纲操作 和 列表操作 相关命令。14.4 DONE 各个级别列表标题中的内容段落如何缩进？可以参考列表操作 相关命令。14.5 LATER 如何显示图片State "LATER"      from "INBOX"      [2015-12-03 四 15:33]14.6 DONE 如何删除标题或者项目以及子树下的内容？State "DONE"       from "LATER"      [2015-11-20 五 12:14]目前可以在大纲状态下标记某部分成活动区域，然后删除便会连同子树一并删除。输入 C-c C-x C-w ，具体参考 标题大纲操作14.7 DONE 如何链接文件和位置之类的？参考 链接14.8 DONE 如何行内转义引用?参考格式部分的内容14.9 DONE 如何设置启动时的自动折叠？可以参考标题大纲配置14.10 MAYBE/FUTURE 如何预览效果？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:33]14.11 DONE 标签的预定义参考 标签配置14.12 MAYBE/FUTURE 如何自动对齐ORGMODE文件的格式？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:33]14.13 DONE 如何在标题间跳转？参考 标题大纲操作14.14 DONE 如何缩进列表段落？可以参考列表操作 相关命令。14.15 LATER 貌似自动刷新功能还是没有完全实现State "LATER"      from "NEXT"       [2015-10-10 六 16:32]在refile的时候会体现出来，还需要 C-x C-v 手动进行。14.16 DONE 如何增加状态？参考 TODO配置14.17 DONE 如何定制状态的各种属性？配置属性参考： TODO配置14.18 DONE 如何设置和进行TODO的状态快捷切换？快捷切换参考:TODO操作 14.19 DONE 如何按状态搜索TODO项目？State "DONE"       from "NEXT"       [2015-10-10 六 16:21]输入 C-c a T具体参见Agenda操作14.20 LATER 如何实现代码原样引用？对于:#+BEGIN_SRC  emacs-lisp:#+END_SRC:#+BEGIN_EXAMPLE:#+END_EXAMPLE这样的代码块，最好在相关的引用块中缩进一下。14.21 DONE 配置折叠状态编辑的动作参考：标题大纲配置14.22 LATER 按照TAG进行搜索State "LATER"      from "NEXT"       [2015-10-10 六 16:32]14.23 LATER 导出与发布14.24 DONE 如何调整大纲缩进显示需要设置org=startup-indented，或者indent选项，参考标题大纲配置14.25 DONE 如何写行内引用的文字，类似markdown中的``。等宽字体即可，参考：格式14.26 DONE 如何确保硬换行列表或其他行尾插入 \\具体参考：硬换行14.27 DONE 如何保存一个与文件位置无关的链接？ C-c l 相关参数？配置全局链接。参考:链接配置14.28 DONE 如何简化列表标题等文档复杂度简化结构。参考：建议14.29 CANCEL 如何定制插入的时间戳格式？State "CANCEL"     from "LATER"      [2015-11-20 五 12:15]State "LATER"      from "NEXT"       [2015-10-22 四 09:54]14.30 LATER 如何在Refile的时候新建一个标题？org-refile-allow-creating-parent-nodes?State "LATER"      from "NEXT"       [2015-10-09 五 15:29]14.31 DONE 恢复到默认的大纲内容模式还不太好用使用 C-u C-u TAB 参考：大纲操作。14.32 WAIT/FORWARD 是否可以org-agenda-files只使用一个文件，对应文件中列出所有agenda文件？State "WAIT/FORWARD" from "NEXT"       [2015-10-09 五 15:33]  wait for move to appropriate place.State "NEXT"       from "INBOX"      [2015-10-09 五 15:29]可以参考如下设置：(setq org-agenda-files (concat org-directory "gtd/agendafiles"))对应的文件类似如下：gtd/gtd/next.orggtd/later.orggtd/maybe_future/gtd/cancel/gtd/done/gtd/_active/gtd/_review/gtd/output/14.33 WAIT/FORWARD 如何设置问题Open的时间？State "WAIT/FORWARD" from "NEXT"       [2015-10-10 六 16:22]  没有完全解决，需要将有用信息转移的合适位置，没有解决的部分视情况切换状态。直接方式目前来说，如果直接插入一个TODO项目就暂时没有相应的时间戳，只能间接实现，如后面所述。间接方式设置如下参数：(setq org-todo-keywords '((sequence                            "INBOX(i!)"                           "NEXT(n!)"                           "LATER(l!)"                           "WAIT/FORWARD(w@/!)"                           "MAYBE/FUTURE(m!)"                           "|" "CANCEL(c!)" "DONE(d!)"                           )))注意其中的'!'表示添加时间戳信息。这样插入一个普通项目之后，可以通过切换成INBOX状态达到自动插入时间戳的目的。这样设置之后，也会导致任何的状态切换会自动在相应的TODO项目标题下添加一个时间戳和状态切换信息。14.34 WAIT/FORWARD 确认一下agenda的配置文件是否可以配置目录？State "WAIT/FORWARD" from "NEXT"       [2015-10-10 六 16:29]  等待整理至合适位置将org-agenda-files变量设置成单文件后，将采用这个文件内容列出的文件列表做为agenda的备选文件，目前实践看来可以将这个文件中某项文件列表写成目录路径。14.35 LATER 考虑使用F1-n设置自己日常使用的自定义快捷方式，并且保证不要与其它冲突。State "LATER"      from "NEXT"       [2015-10-10 六 16:32]14.36 LATER 标题如何添加序号？State "LATER"      from "INBOX"      [2015-12-03 四 15:33]14.37 LATER 如何直接插入一个子标题？State "LATER"      from "INBOX"      [2015-10-09 五 15:18]State "INBOX"      from              [2015-10-09 五 15:16]目前的方法是先用 C-Ret 插入一个同级标题，然后没有移动光标的情况下直接用 TAB 缩进到合适级别，或者用特定的标题操作缩进。14.38 DONE 参考并整理结构编辑的相关操作：State "DONE"       from "NEXT"       [2015-11-20 五 12:15]参考网址为：http://orgmode.org/manual/Structure-editing.html#Structure-editingo整理至：大纲操作14.39 DONE 如何对一个子树进行导出？State "DONE"       from "INBOX"      [2015-11-17 二 16:38]输入 C-c C-e 之后，再输入 C-s 选择导出范围。14.40 MAYBE/FUTURE 注意，断行要用'\\'，要么就空白一行。State "MAYBE/FUTURE" from "INBOX"      [2015-11-17 二 16:39]14.41 WAIT/FORWARD 如何解决输入下划线的时候，自动转换为下标？（想要不转换）State "WAIT/FORWARD" from "NEXT"       [2015-10-19 一 12:02]  等待整理至合适位置State "NEXT"       from "INBOX"      [2015-10-12 一 09:36]State "INBOX"      from              [2015-10-08 四 14:48对于上下标引导(_和^)字符，只解释后面'{}'括起来的文字为上下标，其余不解释。设置如下：;;don't interpret"-" and "^" for display(interpret with "{}").(setq org-use-sub-superscripts '{})(setq org-export-with-sub-superscripts '{})变量 org-use-sub-superscripts 用来控制是否显示之时解释 - 引导的下标，还是 ^ 引导的上标；如果解释值为t，则始终对引导的内容解释成上下标；如果不解释，则值为nil；如果只在将文字用'{}'括起来的时候才解释，则设置为'{}； 变量 org-export-with-sub-superscripts 类似，不过解释的时机为导出之时解释，而非显示。8.0这两个变量互相为对方的别名，后来不是了。对于导出html格式，如果设置 org-use-sub-superscripts 不管用，设置 org-export-with-sub-superscripts 才管用。效果：正常文字_正常文字正常文字_{下标}正常文字^正常文字正常文字^{上标}normal_normalnormal_{sub}normal^normalnormal^{sup}14.42 LATER orgmode refile如何创建新的文件和条目，如何定位设置之外的路径State "LATER"      from "INBOX"      [2015-12-03 四 15:33]Time:&lt;2015-10-02 五 14:10&gt;14.43 DONE orgmode如何只对一个指定的子标题生成html等导出文件？State "DONE"       from "INBOX"      [2015-11-17 二 16:41]Time:&lt;2015-10-07 三 11:12&gt;参考：导出操作14.44 DONE 如何在capture模板中将时间戳设置为非活跃时间戳，以减少Agenda的显示负担？State "DONE"       from "INBOX"      [2015-10-09 五 15:26]在模板中使用 %u/%U 来替代 %t/%T ，例如：;;Capture template(setq org-capture-templates '(;;                            ("t" "Tasks" entry (file+headline "gtd/inbox.org" "Tasks") "* INBOX %?\nTime:%T\n")                              ("t" "Tasks" entry (file+headline "gtd/inbox.org" "Tasks") "* INBOX %?\nTime:%U\n")                              ("p" "Projects" entry (file+headline "gtd/inbox.org" "Projects")  "* %?\nTime:%U\n")                              ("i" "Item notes" item (file+headline "gtd/inbox.org" "Items")  "+ %?\n  Time:%U\n  From:%F\n")                              ("m" "Misc notes" entry (file+headline "gtd/inbox.org" "Notes")  "* ------Time:%U------\nFrom:%F\n%?")                             ))14.45 DONE orgmode如何插入带有时间（而不仅仅是日期）的时间戳？State "DONE"       from "NEXT"       [2015-10-22 四 09:55]State "NEXT"       from "DONE"       [2015-10-09 五 15:26]State "DONE"       from "NEXT"       [2015-10-09 五 14:26]State "NEXT"       from "INBOX"      [2015-10-09 五 09:41]Time:[2015-10-09 五 09:37]具体参考：时间戳操作使用 C-u C-c !14.46 LATER 整理一下emacs_orgmodeusage的文档格式State "LATER"      from "INBOX"      [2015-11-17 二 16:41]Time:&lt;2015-10-09 五 09:36&gt;14.47 MAYBE/FUTURE 如何在活跃与非活跃时间戳之间进行切换？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:33]State "INBOX"      from              [2015-10-09 五 15:26]14.48 NEXT 如何打开链接的时候不新开一个窗口？State "NEXT"       from "INBOX"      [2015-11-17 二 16:41]State "INBOX"      from              [2015-10-09 五 15:09]14.49 WAIT/FORWARD orgmode 的BEGIN_SRC总是导出错误，提示输入的语言参数，如何确定有哪些语言参数？State "WAIT/FORWARD" from "DONE"       [2015-10-10 六 16:15]  need move to right place.State "DONE"       from "INBOX"      [2015-10-10 六 16:14]Time:[2015-10-09 五 14:26]参考：orgmode相关文档网址目前大致支持如下格式：LanguageIdentifierAwkawkC++C++CSScssditaaditaaEmacs CalccalcFortranfortranHaskellhaskellJavascriptjsLedgerledgerLilypondlilypondMscgenmscgenOctaveoctaveOzozPlantumlplantumlPythonpythonRubyrubySchemeschemeSedsedSQLsqlSQLitesqliteAsymptoteasymptoteCCClojureclojureDdGraphvizdotEmacs Lispemacs-lispgnuplotgnuplotJavajavaLaTeXlatexLisplispMATLABmatlabObjective CamlocamlOrg modeorgPerlperlProcessing.jsprocessingRRSasssassGNU Screenscreenshellsh例如，如果使用Emacs Lisp的格式那么这样：#+BEGIN_SRC emacs-lispxxx#+END_SRC14.50 LATER 如果Agenda对应TODO状态发生变化，如何刷新Agenda view?State "LATER"      from "INBOX"      [2015-10-10 六 16:26]Time:[2015-10-10 六 16:21]在Agenda的TODO筛选界面（如 C-c a T ）上按照提示操作 (如 r )。14.51 DONE orgmode有没有离线帮助手册在emacs中直接使用？State "DONE"       from "INBOX"      [2015-11-17 二 16:41]Time:[2015-10-09 五 14:27]输入 M-x info ， 之后能够看到orgmode相关的文档。14.52 LATER 如何自由切换orgmode的活跃和非活跃时间戳？State "LATER"      from "INBOX"      [2015-12-03 四 15:34]Time:[2015-10-09 五 15:46]14.53 LATER 如何在orgmode中调整已有列表条目的缩进级别？State "LATER"      from "INBOX"      [2015-12-03 四 15:35]Time:[2015-10-09 五 16:11]14.54 MAYBE/FUTURE Orgmode表格格式如何自动添加分割横线？为何导出时没有列分割？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:34]Time:[2015-10-10 六 12:05]14.55 MAYBE/FUTURE Agenda view不折行？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:34]Time:[2015-10-10 六 16:36]例如 C-c a T14.56 MAYBE/FUTURE 如何格式化块？如删除块？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:35]14.57 LATER 如何自动触发状态变化？State "LATER"      from "INBOX"      [2015-12-03 四 15:35]例如自动触发状态切换，自动触发refile之类的？14.58 DONE orgmode与mobile org整合State "DONE"       from "WAIT/FORWARD" [2015-11-27 五 10:49]目前感觉不是非常好用，mobile org中Capture功能相对实用一些，可以将片段捕捉下来，同步到电脑上。具体参见：orgmode与mobile org整合14.59 MAYBE/FUTURE Orgmode refile如何到特定的标题上而非仅仅追加或者插入？State "MAYBE/FUTURE" from "LATER"      [2015-12-03 四 17:21]State "LATER"      from "INBOX"      [2015-12-03 四 15:35]Time:[2015-10-19 一 09:54]另外，如何新建文件？新建标题之类的？关于refile之时不将被refile的标题做为子标题，参见如下回答：If you specify org-refile-use-outline-path to be 'file it is possible to just use the path of the file as the refile target and the node will be entered at the top-level.(setq org-refile-use-outline-path 'file)(setq org-refile-targets '((org-agenda-files :level . 1)))You can see the full documentation of org-refile-use-outline-path with C-h v org-refile-use-outline-path RET.网址：http://stackoverflow.com/questions/21334817/emacs-org-mode-refile-to-main-tree-and-not-as-a-subtree14.60 CANCEL orgmode attachment的内容需要看一下State "CANCEL"     from "WAIT/FORWARD" [2015-11-20 五 12:18]State "WAIT/FORWARD" from "CANCEL"     [2015-11-20 五 12:18]State "CANCEL"     from "CANCEL"     [2015-11-20 五 12:18]State "CANCEL"     from "CANCEL"     [2015-11-20 五 12:18]State "CANCEL"     from "NEXT"       [2015-11-20 五 12:17]State "NEXT"       from "INBOX"      [2015-10-14 三 10:17]Time:[2015-10-13 二 08:45]attachment功能感觉不是很适用于当前自己的内容管理体系，故取消。设置当前标签的附件目录输入 C-c C-a s, 然后输入附件的目录,之后会增加一个 ATTACH_DIR 属性,指向你设置的目录路径.附件操作输入 C-c C-a, 然后有相应的子命令,进行操作,具体参见帮助.添加附件输入 a, 会视 org-attach-method 的值, 将相应的附件复制/拷贝/链接到 ATTACH_DIR 对应目录中,并追加一项 Attachments 属性.14.61 NEXT 如何在orgmode中打开链接的时候不会自动新开窗口而是使用已有窗口？State "NEXT"       from "WAIT/FORWARD" [2015-11-09 一 10:26]State "WAIT/FORWARD" from "LATER"      [2015-11-05 四 11:12]  等待整理至合适的位置。State "LATER"      from "INBOX"      [2015-10-21 三 15:10]Time:[2015-10-19 一 11:11]配置帮助等新开弹出窗口为上下方式分割后，这个问题消失了，跟踪链接会自动使用当前窗口而非新开了。配置如下：;; perfer split 'pop' window vertically(whole-&gt;up+lower).(setq split-height-threshold 0)(setq split-width-threshold nil)后来有出现了，跟踪链接的时候都会新开一个窗口。14.62 LATER orgmode 如何修改时间戳？直接编辑？State "LATER"      from "INBOX"      [2015-12-03 四 15:35]Capture Time:[2015-10-23 五 11:36]14.63 MAYBE/FUTURE agenda如何不扫描有些状态，如done、cancel、maybe/futureState "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:35]Capture Time:[2015-10-23 五 09:15]14.64 MAYBE/FUTURE orgmode的块是否可以嵌套？比如quote块内是否可以quote？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:35]Capture Time:[2015-10-23 五 09:48]14.65 LATER orgmode如何在导出子树的时候自动以标题命名？State "LATER"      from "INBOX"      [2015-10-12 一 10:01]Time:[2015-10-12 一 09:50]14.66 LATER orgmode如何指定导出的路径和文件名称？State "LATER"      from "INBOX"      [2015-10-12 一 10:02]Time:[2015-10-12 一 09:54]14.67 LATER orgmode光标如何定位到下一个链接？State "LATER"      from "INBOX"      [2015-10-12 一 10:02]Time:[2015-10-12 一 09:58]14.68 LATER orgmode如何实现任务自动触发定时切换以及refileState "LATER"      from "NEXT"       [2015-10-12 一 10:07]State "NEXT"       from "INBOX"      [2015-10-12 一 10:07]Time:[2015-10-12 一 10:03]14.69 WAIT/FORWARD 列表与换行State "WAIT/FORWARD" from "INBOX"      [2015-10-26 一 09:48]  等待移动至合适的位置[2015-10-19 一 07:52]想到一个方法解决列表内多段落的问题。换行 :: 杜绝硬换行的习惯硬换行用“\\”，但是输入不便且有些情况不支持（如MobileOrg），所以想要换行，就新起一段落，那么新行前多一个空行。这是一个新行，也是新段落。一个段落，实际就是一行。逻辑关系有标点表示。列表内换行 :: 用描述列表有时为美观，列表第一换行若用一空行则显得与列表项标题相距有点远，并且第一行内容一般也很少，一般都是总体描述性文字。所以，建议第一行是简短描述时用描述列表，第一行在描述的“::”后，之后的段落也用空行。若直接第一行就很长不是描述，那么不用描述列表，并且宁可与列表项标题多空一行，也不用断行符。14.70 WAIT/FORWARD orgmode建议State "WAIT/FORWARD" from "INBOX"      [2015-10-26 一 09:49]  等待移动至合适的位置[2015-10-20 二 07:44]建议标题以2级开始（题目视作一级）14.71 LATER Orgmode中checkbox和header也可以结合使用State "LATER"      from "INBOX"      [2015-10-27 二 14:26]Capture Time:[2015-10-26 一 11:01]例子如下：TODO list [0%]+ [ ] Read previous resource manage files.+ [ ] Read current header file.+ [ ] Read current document.+ [ ] Design work.14.72 LATER 确认一下orgmode中的引用块相关细节，例如begin example和begin quote之间的区别State "LATER"      from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-10-26 一 11:02]14.73 CANCEL 考虑orgmode中，是否应该每一个状态添加!，将处理信息和状态信息集成。State "CANCEL"     from "NEXT"       [2015-11-30 一 18:03]  当前没有必要State "NEXT"       from "INBOX"      [2015-10-27 二 14:27]Capture Time:[2015-10-26 一 14:09]14.74 LATER orgmode 如何递归折叠光标所在节点？State "LATER"      from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-10-28 三 13:54]14.75 WAIT/FORWARD emacs markdown 导出State "WAIT/FORWARD" from "INBOX"      [2015-10-30 五 10:27]  等待转移至合适位置Capture Time:[2015-10-30 五 10:25]可以参考一下这个网址：http://stackoverflow.com/questions/22988092/emacs-org-mode-export-markdown使用官方提供的 C-c C-e 后没有导出markdown的m选项。I have some weird behavior, I don't actually know if it's a bug or something else. When I do C-c C-e the option to convert to markdown doesn't appear. Nonetheless I can type the option M-x org-md-export-as-markdown and after I do that, the option export to markdown appears in the C-c C-e menu.Any Ideas?解决方案是If you are using Org-mode version 8.0 or later (check with M-x org-version), the export framework is broken up into several libraries that are not necessarily loaded by default.Something like this in your Emacs configuration can load the Markdown exporter automatically with Org-mode:(eval-after-load "org"  '(require 'ox-md nil t))shareimprove this answer14.76 DONE orgmode与jekyll的结合State "DONE"       from "WAIT/FORWARD" [2015-12-18 五 14:12]State "WAIT/FORWARD" from "NEXT"       [2015-11-04 三 15:27]  待转移至合适位置State "NEXT"       from "INBOX"      [2015-11-03 二 15:30]State "INBOX"      from              [2015-11-03 二 15:28]大致思路是：建立一个与jekyll目录结构类似的orgmode路径，org文件存于其中，发布导出路径是jekyll。具体参见：orgmode与jekyll的结合14.77 LATER orgmode如何输入成块的原样文字而不解释、缩进之类的？State "LATER"      from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-10-30 五 11:17]14.78 LATER 为什么orgmode定义好的refile如果是单个文件，那么这个文件内容会自动变化？State "LATER"      from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-11-05 四 10:27]14.79 LATER Jekyll与orgmode结合的问题State "LATER"      from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-11-16 一 09:18]添加postamble包含文件的“绝对”相对路径如何实现？使用orgmode结合jekyll的策略和功能的分开。策略在jekyll的readme里，功能在orgmode文档中。14.80 NEXT 如何为orgmode导出添加作者信息？State "NEXT"       from "INBOX"      [2015-11-16 一 10:31]Capture Time:[2015-11-11 三 16:54]14.81 LATER emacs如何导出的时候不缓存上次修改差异而直接强制导出？State "LATER"      from "INBOX"      [2015-11-16 一 10:31]Capture Time:[2015-11-13 五 11:16]14.82 DONE 是否应该为取消的项目在切换到取消之前添加备注，类似wait/forward，指明为什么取消？State "DONE"       from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-11-16 一 10:35]14.83 MAYBE/FUTURE orgmode多文件文档State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-11-18 三 10:33]各个分片文档组成整体文档14.84 LATER orgmode中导出时的include关键字所基于的路径能否配置？State "LATER"      from "INBOX"      [2015-12-03 四 15:36]Capture Time:[2015-11-18 三 17:37]14.85 LATER 如何在orgmode中时间戳中选择特定的时间插入？需要知道相关的指令和按键，而非手动修改。State "LATER"      from "INBOX"      [2015-12-03 四 15:37]Capture Time:[2015-11-23 一 10:41]14.86 NEXT orgmode导出utf8问题State "NEXT"       from "LATER"      [2015-12-03 四 15:37]State "LATER"      from "INBOX"      [2015-12-03 四 15:37]Capture Time:[2015-11-23 一 14:09]14.87 CANCEL orgmode sub task and summary.State "CANCEL"     from "INBOX"      [2015-11-24 二 11:54]  no need , it is described in TODO operation.Capture Time:[2015-11-24 二 11:06]14.88 DONE 切换和设置优先级State "DONE"       from "WAIT/FORWARD" [2015-11-27 五 11:44]State "WAIT/FORWARD" from "LATER"      [2015-11-27 五 11:39]State "LATER"      from "NEXT"       [2015-11-27 五 11:39]State "NEXT"       from "INBOX"      [2015-11-27 五 11:39]State "INBOX"      from              [2015-11-27 五 11:39]参考: TODO项目 相关配置和操作。大致如下：配置;;set priority(setq org-highest-priority ?A)(setq org-lowest-priority ?D)(setq org-default-priority ?A)(setq org-priority-faces '(                           (?A . org-warning)                           (?B . (:background "DodgerBlue" :foreground "black" :weight bold))                            (?C . (:foreground "SkyBlue" :weight bold))                           (?D . (:foreground "DodgerBlue" :weight bold))                            ))操作切换优先级输入 S-UP/S-DOWN14.89 WAIT/FORWARD archiveState "WAIT/FORWARD" from "INBOX"      [2015-11-27 五 14:36]  wait for move.State "INBOX"      from              [2015-11-27 五 11:57]14.89.1 配置具体内容可以参见： C-h v org-archive-default-command, C-h v org-archive-location, C-h v org-archive-save-context-info14.89.1.1 配置归档位置将内容根据“年-月-日-包含文件名的标题-被归档的标题”的层次，归档在指定路径的文档中，如下(setq org-archive-location (concat org-directory "gtd/_archive/201511_archive.org::datetree/* Archive from %s"));;(setq org-archive-location (concat org-directory "gtd/_archive/session" (format-time-string "%Y%m") "_archive.org::datetree/* Archive from %s"))14.89.1.2 配置归档包含的信息归档之后，被归档节点属性包含：时间、文件、标签、todo状态、分类、节点在归档前的路径等信息：(setq org-archive-save-context-info '(time file ltags itags todo category olpath))14.89.2 操作采用默认的方式归档输入 C-c C-x C-a 这会默认将当前标题归档为同名，但是后缀为 .org_archieve 的归档文件(无论状态是不是done)。这个命令具体会怎么执行，会根据 org-archive-default=command 的设置而定， 默认值为： org-archive-subtree(no term)归档命令C-c C-x C-s 或者 C-c $执行 org-archive-subtree ， 将所选内容归档至指定文件指定标题，具体可通过 org-archive-location 指定。C-u C-c C-x C-s类似前面，但是归档之前会检测被归档的标题子标题是否有open的todo项目，如果没有就移动，否则提示。如果光标不再标题，则对所有顶级标题开始依次遍历并检测归档。C-u C-u C-c C-x C-s类似前面，但是检测之时，检测的是过期的时间戳，而非todo项目。以上命令中，第一个经常用到，后面两个不怎么用，如果保存被归档内容的更多信息，需要配置 org-archive-save-context-info , 归档之后，标题中的链接和引用仍然有效。14.89.3 举例如上配置之后，例如*Title1**DONE sub title1 CLOSED: [2015-11-27 五 14:17]- State "DONE"       from              [2015-11-27 五 14:17]***subsub title1****DONE subsubsub title1CLOSED: [2015-11-27 五 14:18]- State "DONE"       from              [2015-11-27 五 14:18]****subsubsub title2****subsubsub title3***subsub title2**sub title2注意以上格式中，标题前面应该和'*' 之间有一个空格。执行 C-c C-x C-a 之后，会在相应路径生成一个201510_archive.org文件，追加了如下内容：*2015**2015-11 十一月***2015-11-27 星期五****Archive from orgmodetest.org*****DONE subsubsub title1CLOSED: [2015-11-27 五 14:18]:PROPERTIES::ARCHIVE_TIME: 2015-11-27 五 14:23:ARCHIVE_FILE: ~/test/emacs/orgmodetest.org:ARCHIVE_TODO: DONE:ARCHIVE_CATEGORY: orgmodetest:ARCHIVE_OLPATH: Title1/sub title1/subsub title1:END:- State "DONE"       from              [2015-11-27 五 14:18]14.90 NEXT orgmode中为何example块中的标题还遵从orgmode的格式？State "NEXT"       from "INBOX"      [2015-12-03 四 15:37]Capture Time:[2015-11-27 五 15:05]14.91 NEXT orgmode导出为utf8报告错误State "NEXT"       from "INBOX"      [2015-12-04 五 15:37]Capture Time:[2015-12-04 五 10:31]错误信息如下org-export-numbered-headline-p: Wrong type argument: number-or-marker-p, nil目前看来是在一个标题下添加了对其他内容的引用（通过id）之后出现这个问题，例如:** DONE wk1548CLOSED: [2015-12-04 五 10:09]:PROPERTIES::ID:       b287eddd-9629-49d9-9949-6042f71b8047:END:- State "DONE"       from "NEXT"       [2015-12-04 五 10:09]参考:[[id:3f6910c4-e8ea-4cf7-8dad-c13ab7127074][周报回顾]]14.92 LATER orgmode在引用块中缩进的标题问题State "LATER"      from "INBOX"      [2015-12-04 五 15:37]Capture Time:[2015-12-04 五 10:36]参见：http://comments.gmane.org/gmane.emacs.orgmode/10325814.93 MAYBE/FUTURE orgmode导出markdown有太多的引用标记，如何尽可能原样展示而非很多的'style'类似的东西？State "MAYBE/FUTURE" from "LATER"      [2015-12-04 五 15:37]State "LATER"      from "INBOX"      [2015-12-04 五 15:37]Capture Time:[2015-12-04 五 10:40]14.94 LATER orgmode 番茄钟、时间记录State "LATER"      from "INBOX"      [2015-12-10 四 10:36]Capture Time:[2015-12-07 一 09:53]14.95 MAYBE/FUTURE orgmode为什么refile 目标会跟踪软链接到其他目录中？State "MAYBE/FUTURE" from "INBOX"      [2015-12-11 五 17:39]Capture Time:[2015-12-10 四 11:27]14.96 LATER 属性State "LATER"      from              [2015-12-16 三 08:56]14.96.1 操作在当前所在标题插入属性输入 C-c C-x p, 输入之后,按照提示输入属性名和属性值. * 测试属性 :PROPERTIES::test:     name:what:     no:END:移除一个属性在相应的属性区域输入 C-c C-c d, 输入之后,按照提示输入待删除的属性名.14.97 WAIT/FORWARD ormode项目管理State "WAIT/FORWARD" from "INBOX"      [2015-12-10 四 11:25]  等待整理至合适位置Capture Time:[2015-12-10 四 10:33]子项目的管理：如果子项目中有未完成的项目，理论上说，这些子项中的最高优先级别状态，就是父项目的状态。项目优先级为：NEXT&gt;LATER&gt;WAIT&gt;INBOX&gt;DONE=CANCEL14.98 DONE orgmode考虑是否应该将状态文件以'_' 做为前缀，便于angenda中一目了然不和其他文件混淆？State "DONE"       from "INBOX"      [2015-12-18 五 13:37]Capture Time:[2015-12-15 二 10:57]已经将状态文件冠以 _ 前缀，便于在Agenda View中集中浏览。14.99 NEXT orgmode应用聚合有哪些场景？ [2/7]State "NEXT"       from "LATER"      [2015-12-18 五 14:03]State "LATER"      from "INBOX"      [2015-12-18 五 13:39]Capture Time:[2015-12-16 三 11:25][X] 与MobileOrg的结合参见 orgmode与mobile org整合[&#xa0;] (no term)基本语法[&#xa0;] (no term)如何安装?[&#xa0;] (no term)如何管理文档?[X] 如何与jekyll结合参见 orgmode与jekyll的结合[&#xa0;] 如何管理gtd?参见[&#xa0;] (no term)学习之路？基本语法-&gt;capture+refile-&gt;export+publish 开始就写文档，并且记录 FAQ等等.14.100 LATER orgmode记时功能可以提高集中力State "LATER"      from "INBOX"      [2015-12-18 五 13:38]Capture Time:[2015-12-17 四 09:51]14.101 NEXT Orgmode如何官方发问？State "NEXT"       from "INBOX"      [2015-12-21 一 15:57]Capture Time:[2015-12-18 五 16:55]14.101.1 订阅邮件列表首先订阅相关邮件列表，定位参见：Emacs-orgmode &#x2013; General discussions about Org-mode.14.101.2 参考http://www.catb.org/esr/faqs/smart-questions.htmlMailing list and IRC channel14.102 MAYBE/FUTURE Ascii artState "MAYBE/FUTURE" from "INBOX"      [2016-01-05 二 15:38]Capture Time:[2015-12-31 四 14:20]14.103 MAYBE/FUTURE artist mode in emacsState "MAYBE/FUTURE" from "INBOX"      [2016-01-05 二 15:38]Capture Time:[2015-12-31 四 14:31]http://www.emacswiki.org/emacs/ArtistMode14.104 MAYBE/FUTURE Emacs中的plantuml配置如何与ascii art格式图形结合？State "MAYBE/FUTURE" from "INBOX"      [2016-01-05 二 15:38]Capture Time:[2015-12-31 四 16:35]14.105 LATER orgmode画图State "LATER"      from "INBOX"      [2016-01-05 二 15:38]Capture Time:[2015-12-30 三 13:42]14.106 LATER pdflatex for orgmodeState "LATER"      from "INBOX"      [2016-01-05 二 15:38]Capture Time:[2015-12-31 四 11:56]sudo apt-get install latex-beamer14.107 NEXT mobileorg的加密功能，可以防止隐私的泄漏；orgmode的加密功能既能管理工作又能防止工作隐私泄漏。State "NEXT"       from "INBOX"      [2016-01-05 二 15:38]Capture Time:[2015-12-30 三 10:00]14.108 WAIT/FORWARD orgmode中图片链接导出之时如何不是文字链接而直接图片？State "WAIT/FORWARD" from "INBOX"      [2016-01-11 一 16:46]  有待整理Capture Time:[2016-01-11 一 16:43]根据文档，当图片链接有描述文字之时，会在html导出之时显示该图片的描述性文字链接。如果想要直接显示图片可以：添加链接的时候，不给出链接描述文字；当图片链接的描述为图片的路径之时（可以为另外一个图片做为其缩略图），导出的时候显示的便不是图片的链接文字，而直接是图片。如下：[[/home/miracle/mydata/orgmode/data/image/2010-04-02-editor_study_line.jpg]][[/home/miracle/mydata/orgmode/data/image/2010-04-02-editor_study_line.jpg][/home/miracle/mydata/orgmode/data/image/2010-04-02-editor_study_line.jpg]]问题：实践发现，应该是没有描述的比较实用，描述为图片的有时候似乎不好用？14.109 LATER orgmode表格导出之后，文本或者html没有竖线只有横线State "LATER"      from "INBOX"      [2016-01-13 三 16:36]Capture Time:[2016-01-11 一 16:22]14.110 NEXT orgmode导出文章pdf问题State "NEXT"       from "INBOX"      [2016-01-13 三 16:37]Capture Time:[2016-01-11 一 11:20]14.111 LATER orgmode中搜索相关命令的整理State "LATER"      from "INBOX"      [2016-01-13 三 16:39]Capture Time:[2016-01-11 一 10:38]15 参考资料：http://www.fuzihao.org/blog/2015/02/19/org-mode%E6%95%99%E7%A8%8B/http://orgmode.org/worg/doc.htmlhttp://orgmode.org/manual/比较不错的参考资料：http://www.cnblogs.com/bamanzi/archive/2010/04/04/emacs-indent.htmlhttp://orgmode.org/worg/org-faq.html#outline-container-shortcuts-for-entering-source-blocks      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2015-09-11 五 14:08]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-09-11]<a href="/categories/study/emacs/emacs_orgmode_tips.html"> Emacs Orgmode学习笔记 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '测试自动分类'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '将文章放到当前/xxx1/xxx2/_posts/下会自动指定其分类为[xxx1,xxx2]categories/others';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-09-09]<a href="/categories/others/test_categories.html"> 测试自动分类 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Emacs学习笔记'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 文件操作2. 文件管理2.1. 目录显示2.2. 文件操作2.3. 标记操作2.3.1. 删除标记2.3.2. 普通标记2.3.3. 正则表达式标记2.3.4. 结合标记能使用的操作：2.3.5. 其它3. 编辑3.1. 插入3.2. 撤销与重复3.3. 标记3.4. 删除、移除、复制、粘帖3.5. 杂乱编辑4. 窗口操作5. 跳转操作5.1. 搜索5.2. 基本跳转5.3. 书签6. Buffer操作7. 基本配置8. 编程相关9. 帮助10. 原理10.1. 关于递归编辑10.2. 关于mark/region/active region/transient-mark-mode/Text Selection10.3. 关于自动临时保存和备份10.3.1. 临时文件10.3.2. 自动备份10.3.3. 其他10.4. Emacs撤销、重做和重复10.4.1. 插件10.4.2. 标准操作10.4.3. 比较详细的解释10.4.4. 官方文档10.4.5. 总结10.5. 关于Narrow11. 其他11.1. 意外操作12. WAIT/FORWARD FAQ [27/114]([23%])12.1. NEXT 前进后退？12.1.1. 插件12.1.2. 链接的后退12.1.3. 查找的后退12.1.4. 输入 C-u C-@12.2. DONE TAB标签栏?12.2.1. 下载地址12.2.2. 关键配置12.3. DONE 如何删除一行12.4. MAYBE/FUTURE 如何移动一行？12.5. DONE 如何删除至行首？12.6. DONE 如何save all?12.7. DONE 只读切换?12.8. DONE 如何删除备份文件，或者不使用自动备份？12.9. DONE 跳转到当前buffer工作目录？12.10. WAIT/FORWARD Emacs当前工作目录？12.11. LATER 如何重做？12.12. LATER 如何成块缩进?12.13. LATER 如何创建空文件12.14. NEXT 如何跳转至上次编辑内容？12.15. DONE 如何save all？12.16. DONE emacs如何加载插件？12.17. LATER TAB标签显示？12.18. LATER 跳至上次编辑的位置？12.19. WAIT/FORWARD 插件在哪配置12.20. DONE kill buffer?12.21. DONE 直接执行lisp函数？12.22. LATER 如何实现自动缩进？12.23. WAIT/FORWARD 如何插入确定的缩进TAB？12.24. NEXT 如何输入上次输入的内容或者重做？12.25. DONE 交换行12.26. WAIT/FORWARD 动态加载配置立即生效？12.27. DONE 如何执行命令时在回显区快速输入和删除？12.28. DONE 如何查看某一配置变量的值？12.29. MAYBE/FUTURE 如何恢复默认配置？12.30. WAIT/FORWARD 如何文件刷新？12.31. DONE 如何显示匹配括号？12.32. NEXT 关于Tab缩进12.32.1. &#x2014;&#x2014;Time:[2015-09-30 三 15:19]------12.33. LATER 如何显示空白字符？12.34. LATER 如何复制一行？12.35. LATER 缩进提示线？12.36. DONE 重命名当前文件？12.37. MAYBE/FUTURE 如何表示当前文件名？12.38. WAIT/FORWARD 宏录制12.39. WAIT/FORWARD 如何块缩进？12.40. WAIT/FORWARD C-/是Undo12.41. DONE 如何操作目录12.42. CANCEL 如何管理配置目录12.43. LATER 如何定位光标下路径的文件？12.44. LATER 如何按项目组织目录12.45. WAIT/FORWARD 如何让Emacs在光标到达当前Buffer最后一行尾部不自动recenter?12.46. LATER 考虑一下用el-get插件管理插件12.47. MAYBE/FUTURE eshell如何操作？12.48. WAIT/FORWARD 如何配置自动新开“弹出”窗口的分割方向？12.49. LATER Emacs如何控制Pop分割窗口的大小？12.50. WAIT/FORWARD emacs如何进行会话保存？12.51. DONE Emacs背景配色设置？12.51.1. 下载地址：12.51.2. 配置默认主题12.52. WAIT/FORWARD emacs的光标滚动如何让其不在屏幕尾部自动滚屏到中间？12.53. WAIT/FORWARD 如何控制鼠标滚轮滚动的行数12.54. LATER emacs如何清除所有buffer?12.55. LATER 配置调试12.56. NEXT 不喜欢emacs新开"提示窗口"是垂直方向12.57. DONE Emacs如何定制颜色？12.58. LATER 如何设置撤销的次数？目前貌似撤销只有有限的几次12.59. LATER 重复最近的命令12.60. WAIT/FORWARD elisp library12.60.1. 关于 load-file, load, require, autoload12.60.2. 关于 Library, Package, Feature12.61. WAIT/FORWARD Emacs自定义配置12.62. LATER 默认启动xemacs的窗口大小12.63. NEXT emacs-desktop的会话存储默认位置12.64. NEXT 如何高亮？12.65. NEXT Emacs如何进行特定模式下的按键绑定映射？12.66. LATER 如何为当前的Emacs编辑器升级？12.67. DONE Emacs撤销、重做和重复12.68. NEXT Emacs 如何远程访问？12.69. LATER 将emacs custom config变成手动的config12.70. WAIT/FORWARD 恢复文件12.71. LATER 无需远端安装emacs，用本地emacs直接访问远端，可否？12.72. MAYBE/FUTURE Emacs 任务管理？12.73. LATER 崩溃后下次启动自动提示回复文件的方式？12.74. LATER Emacs如何粘帖复制文本到X剪切板中？12.75. LATER Emacs中如何在require后卸载插件？12.76. LATER 拼音输入法12.77. NEXT Emacs为什么有时候缩进无法删除？12.78. NEXT Emacs如何搜索光标下的内容12.79. LATER Emacs如何格式化全部代码？12.80. NEXT 为什么Emacs有时候无法删除缩进？12.81. DONE Emacs如何反撤销重做？12.82. WAIT/FORWARD emacs剪切板和x剪切板共享12.83. DONE 完善自己的开发环境，代码跳转、扫描、定位等，不用每次都要手动配置12.84. LATER Emacs 括号跳转12.85. DONE 关于Narrow12.86. LATER emacs如何搜索光标所在字符的内容12.87. LATER C-x =12.88. MAYBE/FUTURE 定义自己的Emacs环境12.89. MAYBE/FUTURE 将emacs插件分层整理一下，最好能尝试一下新版本的emacs12.90. NEXT Emacs如何撤销以及反撤销？12.91. WAIT/FORWARD &#x2014;&#x2014; [2015-12-02 三 15:06]  Emacs标签跳转------12.92. LATER &#x2014;&#x2014; [2015-12-02 三 16:58]  Emacs mark ring------12.93. MAYBE/FUTURE 意外发现 ESC-` 在minibuf打开菜单栏12.94. NEXT 学习资源12.95. LATER Emacs如何自定义按键映射不冲突12.96. NEXT Emacs高级搜索12.97. WAIT/FORWARD Emacs如何显示括号匹配？如何显示行号？12.98. LATER 设置输入法12.99. DONE 使用Emacs阅读代码12.100. LATER emacs自动保存间隔12.101. NEXT emacs如何替换文本?12.102. LATER Emacs如何设置多重功能的按键?12.103. NEXT Emacs如何切换最近buffer,而非只有一个最近buffer?12.104. WAIT/FORWARD Emacs如何高亮多个单词?12.104.1. 利用emacs自带的 hi-lock-mode12.104.2. 利用插件12.105. DONE 如何在Emacs直接预览markdown效果？12.106. MAYBE/FUTURE 如何执行脚本12.107. NEXT Emacs崩溃后的恢复策略12.108. NEXT emacs如何跳转到匹配的括号？12.109. NEXT 一些基本操作12.110. NEXT emacs如何返回上次编辑的位置12.111. NEXT Emacs如何定期自动保存文件?12.112. DONE emacs打开文件等，如何实现部分匹配文件或者命令而非精确开头匹配12.112.1. ido12.112.2. smex12.113. LATER 意外发现的 M-* 和 M-. 是做什么的？12.114. NEXT Emacs代码折叠这里是学习Emacs过程记录的笔记，可供日后查阅以及参考。简单的emacs操作提示，不做过多解释。心中的疑问放在后面。M可以是&lt;ALT&gt;或者&lt;ESC&gt;。&lt;Delback&gt;=&lt;Backspace&gt;=1 文件操作启动emacs输入如下内容：$emacs  $emacs -nw另外，启动之后，在键盘上键入 q 跳过系统欢迎的信息.打开目录 输入 C-x d 之后可输入具体路径，如果直接回车则默认打开当前buffer文件所在目录。新建目录输入 M-x make-directory 然后输入路径，回车。新建文件输入 C-x C-f 然后输入路径，写文件(这样不创建新文件)。载入一个文件输入 C-x C-f 之后输入路径，回车。其实打开的是对应文件的一个buffer，每个文件对应一个buffer，buffer名一般就是文件名去掉后缀。查看当前buffer所在的路径M-x pwd重新载入当前buffer对应文件输入 C-x C-v 保存文件输入 C-x C-s 输入之后，再输入路径，回车。全部保存输入 C-x s 输入之后，会依次询问每个文件的是否保存，输入 y 表示保存相应文件； n 表示不保存； ! 保存所有; . 保存当前buffer并退出询问; q 直接退出询问；更多的信息可以用 C-h 来查阅。关闭文件输入 C-x k 输入之后，会进入一个交互命令，输入想要关闭的buffer名字，即可关闭对应的文件再回车，如果什么都不输入直接回车，则默认退出当前buffer关闭对应的文件。退出编辑器输入 C-x C-c2 文件管理Emacs自带一个文件管理器，为dired模式。进入目录浏览输入 C-x d输入之后，可键入要进入的目录，如果不选择直接 Ret 那么会直接进入当前buffer所在目录。进入目录后，可以输入 h 查看帮助信息，查看回显区简洁帮助输入 ? 进入dired模式之后，可以通过下面命令管理文件，此时Emacs可以做为一个文件管理器来使用。2.1 目录显示上一层目录输入 ^上下移动光标选择不同文件项输入 n / p上下移动至下一个目录子项输入 &lt; / &gt;上下移动至被标记项输入 M-{ / M-}退出目录缓冲输入 q刷新目录缓冲输入 g切换名称日期排序输入 =s=使用View模式查看文件输入 v ， 会以只读方式显示文件内容另一个窗口查看文件输入 o查看文件类型输入 y跳转文件输入 j ,输入之后，会提示选择将要打开的文件路径复制文件名输入 w2.2 文件操作对应位置创建目录输入 +删除对应文件对应行输入 D , 会提示是否删除拷贝对应文件对应行输入 C ， 会提示目标路径创建硬链接对应行输入 H ， 会提示目标路径创建软链接绝对路径对应行输入 S ，相对路径对应行输入 Y ， 会提示目标路径重命名文件对应行输入 R , 会提示重命名的名称修改文件权限对应行输入 M , 会提示修改成什么权限，比如 777修改属组对应行输入 G修改属主对应行输入 O压缩解压缩对应行输入 z执行文件对应行输入 X新建文件输入 C-x C-f2.3 标记操作2.3.1 删除标记标记删除对应行输入 d将所有备份文件标记为删除输入 ~将存盘文件标记为删除输入 #对标记删除的文件执行删除对应行输入 x2.3.2 普通标记普通标记对应行输入 m普通标记所有可执行文件输入 **普通标记所有目录项输入 */普通标记所有符号链接输入 *@2.3.3 正则表达式标记正则表达式标记匹配名称的文件输入 % m , 输入之后，会提示输入满足正则表达式待标记文件名称正则表达式标记匹配内容的文件输入 % g , 输入之后，会提示输入待标记文件包含的满足正则表达式的内容正则表达式标记依次拷贝文件输入 % C , 输入之后提示输入被拷贝文件满足的正则表达式例如:\(.+\).cpp之后再输入目标例如在前面匹配的基础上输入： =\1.h2.3.4 结合标记能使用的操作：以下操作可以结合上述描述的普通标记和某些正则来使用，达到批量处理的目的。删除文件DcopyC重命名或移动R改变用户O改变群组G改变权限M符号链接S硬链接H压缩Z复制文件名w 删除行，刷新后可恢复k2.3.5 其它取消标记删除对应行输入 u取消所有标记输入 U将文件列表读写切换输入 C-x C-q读写切换之后，底部会提示为 [(Editable Dired)] ，可以修改对应文件名等。更多命令参见 h 给出的帮助信息。参考：Emacs文件管理3 编辑3.1 插入插入其他文件输入 C-x i3.2 撤销与重复这里列出最基本的，具体可以参考：Emacs撤销、重做和重复撤销输入 C-x u 或输入 C-/重复操作输入 C-u &lt;数字&gt; &lt;操作&gt; 或输入 C-&lt;数字&gt; &lt;操作&gt; 这两种方法，通过 C-u &lt;数字&gt; 或 C-&lt;数字&gt; 指定好重复次数之后，输入你想进行的操作，就可以重复相应的次数了。3.3 标记标记整个buffer输入 C-x h标记块标记块开始定位到待移除的首部，输入 C-@ (或 C-&lt;SPC&gt; ，如果不冲突)，标记完成。此时底部有指示是标记状态。移除相应块移动光标，这时候光标经过的地方会高亮，也就是被标记。3.4 删除、移除、复制、粘帖注意：这里的移除类似剪切可再次粘帖回来 、删除的内容不可粘帖回来。移除当前行输入 C-S-DEL, 这里的 DEL 就是 Backspace 。移除至行尾，可粘帖回来输入 C-k, 再次 C-k 会将换行符号移除。删除至行首，可粘帖回来输入 C-0 C-k 或输入 M-- C-k 或 C-u 0 C-k删除光标前面字符输入 &lt;Backspace&gt;, 删除之后，不可通过 C-y 来“粘帖”回来。删除光标后面字符输入 C-d 删除之后，不可通过 C-y 来“粘帖”回来。移除光标前至面第一个单词首输入 M-&lt;Backspace&gt; 会移除光标前面的内容至单词首部（单词和数字字符，没有标点和其他字符，如"&lt;"，"&gt;"）。移除光标后至第一个单词尾输入 M-d会移除光标后面的内容至单词尾部（单词和数字字符，没有标点和其他字符，如"&lt;"，"&gt;"）。删除到指定字符输入 M-z &lt;char&gt;输入 M-z 之后再输入字符 &lt;char&gt; ，会删除光标到 &lt;char&gt; 之间的内容。块移除标记块后，输入 C-w 。块复制标记块后，输入 M-w 。粘帖最近一次移除或复制的内容输入 C-y, 输入之后，可以粘帖最近一次被移除的内容。粘帖最近某次移除的内容输入 M-y不断的 M-y 会不断的变换遍历之前移除的内容（不是复制），直至选择到待粘帖的内容便可结束。3.5 杂乱编辑交换当前行与上一行的位置输入 C-x C-t输入之后，会将当前行与前一行交换，并且将当前光标移动到两行的后面。4 窗口操作关掉当前窗口输入 C-x 0关掉其他窗口输入 C-x 1水平创建窗口输入 C-x 2垂直创建窗口输入 C-x 3切换窗口输入 C-x o, 在各个窗口之间循环切换。5 跳转操作5.1 搜索正向搜索C-s连续正向搜索C-s C-s ...逆向搜索C-r5.2 基本跳转向前翻页C-v向后翻页M-v跳至指定行输入 M-g g &lt;line number&gt;, 再输入待跳转的行号。跳至缓冲区文件首输入 M-&lt;跳至缓冲区文件尾输入 M-&gt;跳转到同一层次下一个括号结束位置输入 C-M-n跳转到同一层次上一个括号开始位置输入 C-M-p5.3 书签创建"书签"输入 C-x r &lt;SPC&gt;, 然后随便按一个键，做为书签名比如'a'跳转到"书签"输入 C-x r j, 输入刚才创建的书签"a"，就会跳到你刚在的书签所在的那个光标处。6 Buffer操作查看所有buffer列表输入 C-x C-b切换至指定buffer输入 C-x b 输入之后，进入一个交互模式，输入指定buffer名称即可。如果直接回车，会在上次buffer与本次buffer之间切换。关闭buffer输入 C-x k 会提示想要关闭的buffer，默认关闭当前buffer。关闭3天内未使用的buffer输入 M-x clean-buffer-list依次询问式关闭指定（是否保存）的buffer输入 M-x kill-some-buffers7 基本配置这里给出Emacs基本使用时可能需要配置的一些内容，不涉及复杂插件的相关内容。这里配置文件大致做如下布局：~/.emacs是emacs配置文件的入口，一般保存整体配置信息，~/.emacs.d存放插件等具体配置子脚本。8 编程相关9 帮助查看帮助信息的帮助输入 = C-h C-h =, 这样可以显示如何查询其他帮助信息。查看某个按键序列帮助输入 C-h k xxx输入 C-h k 后会有一个交互，让你输入按键序列，输入 xxx 之后，会显示相应的按键绑定以及帮助信息。自定义绑定一个按键之前通过这条命令，可以确认是否被绑定的按键会发生冲突，亦可通过这个命令，在已有的基础上，添加自己扩展的绑定功能。查看某个elisp函数的作用输入 C-h f使用自定制的功能，带来的问题至少有：通用性降低，依赖性增强，与其他功能冲突可能性增加。所以之前使用vim，基本不会用太多的插件以及按键映射，大多数操作使用其默认的配置。但是对于一个通过自定制扩展而闻名的emacs来说，我觉得这一点可以有所改变。通用性降低这方面，我们可以通过将相关配置进行合理组织，然后通过版本控制或者其他方式备份，便于在其他机器上使用；依赖性增强，一方面通过对配置和插件备份可以解决，一方面经常总结文档，以及对相关内容的熟练程度也会让这个问题不了了之；与其他功能的冲突，我们可以通过帮助查看已有按键绑定以及被占用的功能，使用未被使用的做为扩展，由此避免冲突。使用原生功能，以及使用自定制功能，是两种不同的理念。前者通用、简单，后者可扩展、高效，还有其他不同，但是各有所长，关键在于根据实际情况，使用最适合的方式来解决问题，方式因人而异，没有绝对的，我个人的倾向是：在vim倾向前者，在emacs倾向后者，但是emacs使用之时，尽量保持原有的功能而不改变成其它的，如果实在不行，可以扩展原有功能。查看按键绑定输入 C-h b根据正则表达式模糊查找输入 C-h a xxx, 这样会列出所有匹配 xxx 的帮助信息。查看某前缀按键集合的帮助输入 C-c C-h, 会查看C-c为前缀的按键绑定帮助，查看某命令前缀的按键绑定帮助输入 &lt;命令前缀&gt; C-h, 例如 C-c C-x C-h 会查看 C-c C-x 为前缀的按键绑定帮助。查看info输入 M-x info, 或者输入 C-h i输入之后，会显示info手册，和linux的一样，不过在emacs中阅读更方便。查看当前模式信息C-h m退出帮助信息输入 qEmacs FAQ输入 C-h C-f10 原理10.1 关于递归编辑所谓的“递归编辑”是指递归编辑状态，由位于状态栏的方括号所指示，其中包含了用小括号来指明的模式名称。比如说，你有时可能会看到[(Fundamental)]，而不是 (Fundamental)。（比如在用 M-% 进行交互式替换的时候你又用了 C-s 进行搜索，这时替换模式并没有结束，但你又进入了搜索模式，这就是所谓的递归编辑。）10.2 关于mark/region/active region/transient-mark-mode/Text Selection内容主要参考 Emacs: What's Region, Active Region, transient-mark-mode? 大致如下：mark一个用户可以设置的位置，用来进行文本选择。通过调用 set-mark-command （即 C-@ ）设置mark，在list代码中你可以调用 push-mark或者set-mark设置标记。region最后一次mark的位置知道当前光标所在位置，这一段的区域。用户一旦在buffer中设置了mark，region就存在了。可以通过函数 region-beginning , region-end 来获取region的位置。active region当变量 mark-active 为true的时候，region就是active状态。transient-mark-modetransient-mark-mode也是emacs的一种minor mode，当emacs的 transient-mark-mode 为on的时候，active region将被高亮， 当变量 transient-mark-mode 为true的时候，该模式就是on的状态，默认该模式是on的状态。因为默认为on，并且Buffer中始终有一个region，所以前面对active region需要用 mark-active 进行控制，防止文本中的region始终高亮。什么时候region被active?当 set-mark-command 被调用的时候，region就会变成active(高亮状态)，当执行了一个命令后，一般region的状态就会被设置成inactive。总之，你用鼠标或者键盘设置mark之后，被选择的文本就会被高亮，你执行一些操作之后，文本高亮就被取消。什么是Text Selection？Text Selection就是被选择的文本，一般与active region同义。Text Selection就是非空的active region，可以通过 use-region-p 检测Text Selection， 这个函数其实检测的是三个内容：a. trasient-mark-mode 是否为on；b. mark-active 是否为true；c.通过 =use-empty-active-region来检测region非空。10.3 关于自动临时保存和备份10.3.1 临时文件一般是在Emacs中编辑时,在编辑文件的同一个目录内生成一个以#file-name#这样的文件，这个文件会在我们保存文件之后被emacs删除。这个文件的作用是为了防止在进行编辑的时候异常退出造成的损失。临时文件存在大致过程如下：1. 在Emacs内使用[C-x,C-f]打开要编辑的文件(test-file.txt)2. 在打开的buffer中编辑内容3. Emacs自动侦测buffer是否更改，如果更改会自动Auto-Save4. 此时我们能够在编辑的文件同一目录下看到临时文件为:    #test-file.txt#5. 使用[C-x,C-s]保存当前buffer6. 当前buffer中的内容被写入文件,#test-file.txt#消失——被Emacs自动删除崩溃时恢复的方式1. 打开要恢复的文件，如：test.txt2. [M-x]3. 输入:recover-file 回车4. 确认恢复关闭自动保存临时文件功能，在你启动的.emacs文件内添加下面这行(setq auto-save-default nil) ;; default is t, close with nil10.3.2 自动备份第一次保存的时候，如果保存的文件已经存在，Emacs会自动将保存前的文件重命名作为备份文件，而备份文件使用的是一个“～”作为后缀(如：file-name~)。备份文件默认仅会发生在Emacs第一次写入的时候，即，开启Emacs之后，第一次打开文件并保存的时候，编辑期间多次保存并不能产生多次备份动作。然而，下次重新打开Emacs，再次执行同样的动作的时候，同样在第一次保存时，Emacs是会将上次的备份文件覆盖的（如果有）。大概的流程如下：1. 打开文件,如:MitchellChu.txt2. 编辑...（这涉及到临时文件的问题，忽略）3. 在emacs内发出保存指令4. emacs先将MitchellChu.txt保存为：MitchellChu.txt~5. 保存完成后，Emacs将当前buffer的内容写入MitchellChu.txt注意：此时的MitchellChu.txt已经不再是原来的那个文件，但所有连接到原来那个文件的，现在被这个新文件接管。取消该功能设置如下(setq make-backup-files nil)更多设置，比如拷贝、路径、多个备份版本等，可参考：backup-by-copying version-control backup-directory-alist 等。10.3.3 其他参考：http://blog.useasp.net/archive/2014/07/18/emacs-temporary-files-and-backup-files-for-edited-file.aspxhttp://blog.csdn.net/flytomysky/article/details/709656110.4 Emacs撤销、重做和重复简单说来，撤销是取消上次的操作，重做是对撤销的撤销，重复是对上次命令进行重做。下面重点对撤销和重做进行叙述。“Emacs中只有撤销，没有重做” 或许是初学者的迷惑，也或许让Emacs蒙受了"很烂的编辑器，怪不得很多人不愿意用"的评价。其实，真正的答案很简单： 撤销是取消上次的操作，重做是对撤销的撤销 对这简单的两句话若能真正理解，你或许便能知晓真正的答案。当知晓真正的答案之时，你或许会感觉到，Emacs如峰回路转般，让你不得不收回对它以前的无知评论，重新对它产生新的认识。不光是这个小小的功能，其实在整个Emacs的前进过程中，如果能坚持下去，你会遇到很多类似的境况，也许，这也是为什么Emacs的学习曲线不同于其它，是“螺旋”的吧。这里给出众多Emacs学修中的一员，在经历众多Emacs道路中的困难之一，对其现象做一个简单的重现，希望能让没有使用过Emacs的朋友，能体会到一点使用它的感觉。10.4.1 插件通过undo-tree插件选择需要恢复的操作C-x u 进入 undo-tree-visualizer-mode , p n 上下移动，在分支之前 b f 左右切换，t 显示时间戳，选定需要的状态后， q 退出。这是主要的操作，其它的自己摸索好了……参考：http://www.dr-qubit.org/undo-tree/undo-tree.el 和 emacs 新手必看: undo-tree10.4.2 标准操作对撤销的撤销便是重做（或者向前撤销）第一，执行 C-x u 向后撤销第二，执行 C-g 然后 C-x u 就是向前撤销了。参考：Emacs中的撤销10.4.3 比较详细的解释10.4.3.1 Emacs中所有命令均可undo所有命令均可undo, 包括undo本身，所有命令emacs都一视同仁，所以：undo+undo=redoemacs 把相同类型的操作，合并为一个事件。比如说往缓冲区里打字，也就是 self-insert-command，如果每次 undo ，只是撤消掉一个字符，那就太僵硬了，所以 self-insert-command 的操作，每20次合并为一个事件，一次 undo ，撤消掉20个字符。而 undo 的猥琐之处在于，只要连续的 undo ，无论多少个，都是一个事件……当然，这也是必需的，不然你 undo 了20次之后，又突然开始 redo ……而恰巧这时又是夜深人静的话……10.4.3.2 Emacs中撤销操作序列的表示方式undo 之后想要 redo ，就要进行一个其它类型的操作，随便输入一个字符或者移动一下光标都可以，不过标准答案是 C-g 。s1--s2--s3--s4              )    s3  u3--u4   / | (  |   \ s5--s6--s7--s8--s9  |    \                  )  |     u5--u6--u7--u8--u9   \     s10----sn假设 u3 表示 undo s3 。从 s9 开始 undo，顺着 emacs 的“undo蛇”往回走，到了 u3 的时候，就是 undo undo s3，也就是 s3 了，而这一串 undo，也成了“undo贪吃蛇”的一部分。虽然 emacs 保留了全部的操作状态，但是从 s10 返回 s1 却要将近20步，而普通的编辑器只要两步。这个必需得动手实验后才能有一个直观的印象，按以下步骤操作: (g C-g) (u undo)1g2g3g4guu5g6g7g8g9guuuuuu10(可以把end-of-line绑到空格代替C-g)10.4.3.3 引入插件undo-tree来"改变"Emacs中的undo模式：其实这种“undo蛇”完全可以表示成 undo tree。s10 到 s1 ，两步;再到 s4，四步(有一步是切换分支)……          s10----sn         /s1--s2--s3--s4         \          s5--s6--s7--s8--s9不知道 emacs 为什么没有使用这种方式，可能是因为选择分支之类的操作很难描述吧。好了，不提这么伤感的事，现在有一个扩展叫作 undo-tree ，基本解决了这个问题。 undo-tree 安装使用都很简单:;放到load-path中，配置文件中添加(require 'undo-tree)(global-undo-tree-mode)由于篇幅所限，就不截图了C-x u 进入 undo-tree-visualizer-mode , p n 上下移动，在分支之前 b f 左右切换，t 显示时间戳，选定需要的状态后， q 退出。这是主要的操作，其它的自己摸索好了……参考：emacs 新手必看: undo-tree10.4.4 官方文档查阅Emacs C-h i 信息中有关Undo的内容，如下：Any command other than an undo command breaks the sequence of undo commands. Starting from that moment, the entire sequence of undo commands that you have just performed are themselves placed into the undo record, as a single set of changes. Therefore, to re-apply changes you have undone, type C-f or any other command that harmlessly breaks the sequence of undoing; then type C-/ to undo the undo command.亦可参考：http://www.cnblogs.com/wendellyi/archive/2013/08/29/3290366.html10.4.5 总结其实redo就是对undo的undo，undo会将本身当作被redo的对象，但是连续的undo之间不会被打断，（当然其中的每次undo仍然会视为一个change)，通过 C-g 打断连续的Undo操作，再 C-/ 就实现了对上次的undo 进行 undo，其实感觉上，Emacs将一切操作线性化，即简化了设计，又符合人的思维次序，而通过undo-tree却将这个undo变成了树状结果，便于理解，但是实践上未必更实用。目前暂时不用相关的插件。10.5 关于NarrowNarrowing的意思是将焦点集中到buffer的指定区域上, 有助于集中精力到特定的段落上，而将无关信息屏蔽掉。Narrow后，你能看到的内容就是被Narrow的部分，但是并非删除了其他的内容，而是将相应的内容隐藏了。Narrow后，其他内容好像不存在了一样，正常的跳转/搜索操作也被限制在Narrow范围内。Narrow后，能够看见的区域被称作可访问区域，当取消narrow的时候，其他不可见的区域也变回可见了。主要命令：将Narrow范围设定在光标与Mark范围之间输入 C-x n n ，其实一般也就是被选区域。取消Narrow输入 C-x n w将Narrow范围设定为当前页输入 C-x n p将Narrow范围设定为当前函数输入 C-x n d具体可以参考 C-x n C-h 或 http://www.gnu.org/software/emacs/manual/html_node/emacs/Narrowing.html11 其他切换模式输入 M-x &lt;mode name&gt; 这里&lt;mode name&gt;是模式名称，自己输入，可以&lt;Tab&gt;补全。只读切换输入 C-x C-q输入之后，当前buffer会在只读以及可读写之间切换。终止现在正在执行的命令输入 C-g这个命令只能终止本层编辑正在执行的指令，当你处于 recursive edit level 的时候，你就不能够利用 C-g 来取消命令了，那么你需要利用 &lt;Esc&gt;&lt;Esc&gt;&lt;Esc&gt; （或者更多次）来取消。交互执行lisp命令并插入结果输入如下命令序列:M-x lisp-interaction-mode&lt;lisp expressions&gt;C-j切换 lisp-interaction-mode 模式之后，输入lisp表达式， C-j 计算并插入结果。千万注意 C-j 的光标位置。交互执行lisp命令不插入结果输入如下命令序列：M-x lisp-interaction-mode&lt;lisp expressions&gt;C-x C-e切换 lisp-interaction-mode 模式之后，输入lisp表达式， C-x C-e 计算并将结果显示在底部mini buffer中。千万注意 C-x C-e 的光标位置。查看所有安装的包输入 M-x list-packages插入原样字符输入 C-q &lt;待输入字符&gt;输入之后将会插入相应字符（包括控制字符），而不是执行字符对应的按键绑定命令。进入elisp交互解释界面输入 eilm11.1 意外操作这里列出平时意外操作发现的一些功能，可能会整理至合适位置。快速文本块选择输入 C-S-n/p/a/e 或者可以表达为 C-N/P/A/E 好像可以进行块选择，按其它的按键会导致退出“选择模式”。新开一行输入 C-o, 默认输入这个命令可以可以在当前位置上面新开一行。当前位置内容帮助在光标单词处输入 C-h xxx 直接回车默认会解释光标下的帮助内容。选择标记整个buffer输入 C-x h将选择的数据块按照上行缩进（上一行缩进几个空格，则此处也缩进几个空格，而不是tab?）选择后输入 =C-M-\=，如果上行没有缩进则自动缩进一个tabstop。其实选择块之后，直接Tab也会缩进。12 WAIT/FORWARD FAQ [27/114]([23%])State "WAIT/FORWARD" from              [2015-11-27 五 15:07]  wait for all done12.1 NEXT 前进后退？State "NEXT"       from "WAIT/FORWARD" [2015-12-17 四 15:30]State "WAIT/FORWARD" from "LATER"      [2015-12-03 四 13:52]  前进后退的插件已经基本阅读完毕，使用自定义markring不会影响已有的系统markring；可行，其他前进后退的更多文档可能需要借助系统的mark以及使用的经验。State "LATER"      from "NEXT"       [2015-11-02 一 11:41]12.1.1 插件使用recent-jump插件。12.1.1.1 配置举例;; set recent-jump(setq recent-jump-threshold 4)(setq recent-jump-ring-length 10)(global-set-key (kbd "C-o") 'recent-jump-jump-backward)(global-set-key (kbd "M-o") 'recent-jump-jump-forward)(require 'recent-jump)12.1.1.2 常用操作前进C-o后退M-o12.1.1.3 其他对该插件可以自行修改其源代码，以定制什么情况下针对什么命令、多大举例进行跳转。具体参见插件的源码和文档。;;; Commentary:;; ;; sometimes, we start a big jump, e.g. go to the beginning of buffer, search,;; page down etc, it is handy that you can go back to where you start. For;; example, when we writing program source code, we ofter search for some;; reference and go back to where you start and continue writing. But how can we;; define "Big Jump". I can not find a proper hook for the big jump, so at last;; I choose the pre-command-hook. Now what my defination for "Big Jump" is :;; ;; 1. you issued some special command, it can be defined by;; recent-jump-hook-commands ;;;; 2. you jumped really much. that is you move more than `recent-jump-threshold';; lines.参考: http://blog.waterlin.org/articles/%E5%9C%A8emacs%E4%B8%AD%E5%BF%AB%E9%80%9F%E5%9C%B0%E8%B7%B3%E8%BD%AC%EF%BC%9Arecent-jumpel.html12.1.2 链接的后退跳转一次链接后，会记录上次链接。使用 C-c &amp; 可以后退。具体需要仔细确认。12.1.3 查找的后退查找一个字符串，回车后，会记录开始查找时的位置。使用 C-u C-@ 可以退回查找前的位置。12.1.4 输入 C-u C-@12.2 DONE TAB标签栏?State "DONE"       from "MAYBE/FUTURE" [2016-03-03 四 11:02]State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:38]使用 tabbar 插件。具体参考相关文档。12.2.1 下载地址wget https://www.emacswiki.org/emacs/download/tabbar.el12.2.2 关键配置;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;tabbar;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(require 'tabbar)(tabbar-mode t)12.3 DONE 如何删除一行State "DONE"       from "NEXT"       [2015-11-02 一 11:43]删除一行输入 C-S &lt;BS&gt;12.4 MAYBE/FUTURE 如何移动一行？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 15:39]State "INBOX"      from              [2015-11-02 一 11:43]12.5 DONE 如何删除至行首？State "DONE"       from "NEXT"       [2015-11-02 一 11:53]输入 C-0 C-kn或输入 M-- C-k或 C-u 0 C-k12.6 DONE 如何save all?State "DONE"       from "WAIT/FORWARD" [2016-02-10 三 11:08]State "WAIT/FORWARD" from "NEXT"       [2015-10-10 六 16:46]  待整理至合适的位置。输入 C-x s参考: 文件操作12.7 DONE 只读切换?State "DONE"       from "WAIT/FORWARD" [2016-02-10 三 11:11]State "WAIT/FORWARD" from "DONE"       [2015-10-10 六 16:45]  需要转移到合适的位置。State "DONE"       from "NEXT"       [2015-10-10 六 16:45]输入 C-x C-q参见 其他12.8 DONE 如何删除备份文件，或者不使用自动备份？State "DONE"       from "NEXT"       [2015-11-02 一 11:55]具体参考：关于自动临时保存和备份;;disable auto backup file("xxx~") when save(default t).(setq make-backup-files nil);; all backups goto ~/.backups instead in the current directory;;(setq backup-directory-alist (quote (("." . "~/.backups"))));;disable recovery file("#xxx#") when modify(default t);;(setq auto-save-default nil)12.9 DONE 跳转到当前buffer工作目录？State "DONE"       from "WAIT/FORWARD" [2016-02-10 三 11:14]State "WAIT/FORWARD" from "NEXT"       [2015-10-12 一 09:23]  待整理到合适位置State "NEXT"       from "INBOX"      [2015-10-12 一 08:50]输入 C-x d参考： 文件管理另外，不知道在哪里看到的文章上讲 C-x C-j 可以用 dired mode 打开正在编辑的文件的所在目录，但是我的版本的 Emacs 居然没有这个快键，而且这个键没有绑定任何命令。 于是加了一段代码实现这个功能。;; C-x C-j open the directory of current buffer(global-set-key (kbd "C-x C-j")(lambda ()(interactive)(if (buffer-file-name)(dired default-directory))))12.10 WAIT/FORWARD Emacs当前工作目录？State "WAIT/FORWARD" from "NEXT"       [2015-10-20 二 17:02]  等待整理到合适的位置。参考： 文件管理当前buffer的目录， 输入 C-x d 。 设置默认工作目录可以如下：(setq default-directory "/home/quieheart")但是=default-directory= 是buffer-local,参考：http://zhidao.baidu.com/link?url=ZDHfOcxIDLzxiCRDi2yEWusjiqu9NRag0IFU7J3KGYFMiibAGC_MVL5Tm-aFWaekODyF0uhXf0aDLVtyalqk74eKy6H_CoJWfNp1_mWD3Ci&gt;&gt; windows下的emacs怎么改按c-x c-f出现的路径。C-x C-f 使用的目录是 default-directory 的值。default-directory 是 buffer-local variable, 用 setq 写在 .emacs 里面没什么用。在没有与文件关联的buffer中default-directory 的值是启动emacs时的当前目录。所以你可以修改启动emacs时的当前目录(PWD)。修改启动emacs的当前目录，有多种方法：修改emacs快捷方式属性的起始位置为你希望的文件夹，路径有空格的要加双引号。写一个bat/cmd脚本来启动emacs，该脚本内容：先CD到目标路径，然后执行emacs如果当前buffer已经打开了文件，default-directory 会变成文件的所在路径。这个行为是不建议更改的。如果希望任何时候 C-x C-f 都是默认到某个目录，建议自己写一个函数来代替默认C-x C-f 绑定的函数。例如：(defun my-find-file ()  (interactive)  (let ((default-directory "mnt"))    (call-interactively #'find-file)))(global-set-key (kbd "C-x C-f") 'my-find-file)查看当前buffer所在的路径：M-x pwd12.11 LATER 如何重做？State "LATER"      from "INBOX"      [2015-12-03 四 15:39]12.12 LATER 如何成块缩进?State "LATER"      from "INBOX"      [2015-12-03 四 15:40]12.13 LATER 如何创建空文件State "LATER"      from "INBOX"      [2015-12-03 四 15:40]12.14 NEXT 如何跳转至上次编辑内容？12.15 DONE 如何save all？State "DONE"       from "INBOX"      [2015-12-03 四 15:40]输入 C-x s , 根据弹出的提示选择待保存的buffer, !表示保存剩余的全部。12.16 DONE emacs如何加载插件？State "DONE"       from "WAIT/FORWARD" [2016-03-03 四 11:19]State "WAIT/FORWARD" from "INBOX"      [2015-12-03 四 15:41]  填写配置文件，待整理下载插件，插件都是elisp脚本，一般自动加载都是修改配置文件，比如 recent-jump.el 将加载语句写入配置文件：;;plugins(load "recent-jump.el")或者(require 'recent-jump) ;; back/forward或者如果直接在当前会话中加载插件，可以到 *scratch* buffer中或者其他地方将加载语句写下来，然后则直接执行加载语句（在相应的语句结尾输入 C-x C-e ）具体可参考：elisp library12.17 LATER TAB标签显示？State "LATER"      from "INBOX"      [2015-12-03 四 15:41]12.18 LATER 跳至上次编辑的位置？State "LATER"      from "INBOX"      [2015-12-03 四 15:41]12.19 WAIT/FORWARD 插件在哪配置State "WAIT/FORWARD" from "INBOX"      [2015-12-03 四 15:41]  有emacs plugin相关文章，待整理可能需要整理到原理中。~/.emacs是emacs配置文件的入口，一般保存整体配置信息，~/.emacs.d存放插件等具体配置子脚本。12.20 DONE kill buffer?State "DONE"       from "INBOX"      [2015-12-03 四 15:42]输入 C-x k, 默认是当前buffer.12.21 DONE 直接执行lisp函数？State "DONE"       from "NEXT"       [2015-11-02 一 12:18]State "NEXT"       from "INBOX"      [2015-11-02 一 12:17]已有elisp函数： M-x &lt;functionname&gt;自定义函数，在函数体结尾后执行 C-x C-e12.22 LATER 如何实现自动缩进？State "LATER"      from "INBOX"      [2015-12-03 四 15:43]12.23 WAIT/FORWARD 如何插入确定的缩进TAB？State "WAIT/FORWARD" from "NEXT"       [2015-10-19 一 16:41]  如果有确定的答案，就直接给出一个简单的提示操作，或者关闭问题。参考：关于Tab缩进12.24 NEXT 如何输入上次输入的内容或者重做？C-x z12.25 DONE 交换行State "DONE"       from "WAIT/FORWARD" [2016-03-03 四 11:26]参考：编辑输入： C-x C-t12.26 WAIT/FORWARD 动态加载配置立即生效？不重启 Emacs 让 .emacs 配置文件生效有四个函数可以做到：eval-last-sexp,eval-region,eval-buffer 和load-fileM-x eval-last-sexp 使.emacs中光标前的那一条语句立刻生效。M-x eval-region 使.emacs中选中的region中的语句立刻生效。M-x eval-buffer 使当前的buffer中的设置语句立刻生效。M-x load-file ~/.emacs 载入.emacs文件，从而使其中的设置生效。用 emacs 打开 .emacs 文件，C-x C-e 光标前面的运行一条语句。立即生效。注意，有时候，需要重新载入当前buffer才能看见效果，有时候只对当前buffer起效果（可以查看相关配置的帮助说明）。12.27 DONE 如何执行命令时在回显区快速输入和删除？State "DONE"       from "INBOX"      [2015-12-03 四 16:00]回显区和正常buffer一样对待，它就是minibuffer.更多参考：http://www.gnu.org/software/emacs/manual/html_node/emacs/Minibuffer.html#Minibuffer12.28 DONE 如何查看某一配置变量的值？State "DONE"       from "INBOX"      [2015-12-03 四 16:01]查看该变量的帮助信息即可。输入 C-h v ,然后输入变量名称，默认为当前光标所在变量。12.29 MAYBE/FUTURE 如何恢复默认配置？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 16:02]12.30 WAIT/FORWARD 如何文件刷新？用于重新载入配置和文件变化。http://blog.csdn.net/horstlinux/article/details/7857123http://www.emacswiki.org/emacs/RevertBuffer有四个可以revertbuffer的方法：    M-x revert-buffer RET yes RET    C-x C-v RET    (global-set-key [(control c) r] 'revert-buffer)    C-x RET r RET RET除了手动设置revert-buffer，我们还可以自动设置，加入如下配置：(global-auto-revert-mode 1)另外注意，C-x C-v 是打开一个文件，取代当前缓冲区，缓冲区名字也改变了，就算再次重新打开相应的缓冲区文件，其之前对应的Agenda View也不可用了。12.31 DONE 如何显示匹配括号？State "DONE"       from "INBOX"      [2015-12-03 四 16:03]输入如下配置：;;paren(show-paren-mode 1)12.32 NEXT 关于Tab缩进State "NEXT"       from "INBOX"      [2015-10-10 六 16:47]State "INBOX"      from              [2015-10-10 六 16:47]12.32.1 &#x2014;&#x2014;Time:[2015-09-30 三 15:19]------12.32.1.1 文档中的描述文档上关于indent的一些变量和函数，翻译过来大致意思如下：C-h f indent-for-tab-command依赖于 tab-always-indent 的设置，会为当前主模式的行或者区域进行合适的缩进，或者插入 TAB 。在大多数主模式中，如果光标在行缩进区域，它会在缩进后移动到第一个非空的字符上，否则光标会呆在当前文本的同样的位置。如果给定了一个前缀参数，也会严格缩进以当前行首开始的整个balanced expression，来反映当前行缩进的变化。如果 transient-mark-mode 被打开，并且当前region是active的，会将当前的区域缩进（这个时候，任何前缀参数都会被忽略）。实际上被调用来缩进行的函数取决与 indent-line-function 变量的设置。C-h v indent-line-function这个变量是buffer local的变量，表示用来缩进当前行的函数；这个函数被调用的时候没有任何参数，如果函数在一个auto-indentation无法发生的地方被调用了（比如一个字符串的中间），这个函数将只会返回 noindent ；我们可以设置这个函数来们组自己的需求，使得 TAB 能够合适的被缩进，如果并非必须，最好不要重新绑定 TAB 按键。关于这个变量的值，比如我当前打开一个 emacs_tips.org 文件，然后查看这个变量，可以看到如下：Local in buffer emacs_tips.org; global value is indent-relative说明，在文件 emacs_tips.org 中它的值为 org-indent-line （这是orgmode的设置），其它位置默认为 indent-relative 。C-h v tab-always-indent如果为 t ，则键入 TAB 会缩进当前行；如果为 nil ，并且光标在左边的空白区或者行缩进区，则键入 TAB 会缩进当前行；如果为 nil ，并且光标没有在空白或缩进区，则键入 TAB 会直接插入 TAB 字符；如果为 complete=，则键入 =TAB 首先会缩进当前行，如果当前行已经缩进了，就尝试补全光标所在单词。有些编程语言有他们自己的变量控制这个行为，例如 c-tab-always-indent ，这时候不会考虑这个变量。C-h v indent-tabs-mode这个是在C语言代码中定义的变量，设置成任何内容都会编程buffer-local的变量，这个变量做为文件局部变量保存，是安全的。如果 non-nil ，将会插入 TAB .12.32.1.2 参考：关于emacs 缩进有一篇不错的文章参考：http://www.cnblogs.com/bamanzi/archive/2010/04/04/emacs-indent.html主要包括了：默认的Tab行为、需要的行为、以及配置的方式摘抄一些部分不插入tab字符，不插入tab字符每次缩进4个空格(setq default-tab-width 4)缩进完全自行控制，不用syntax indentation来自动 （按语法格式化完全可以使用C-_）?按TAB键时如果选择多行，则缩进(行首插入多个空格)如果未选择多行，当前光标在行首（不管是indentation区还是第一个字符上)，则缩进光标不在行首，插入多个空格(如果要将代码补齐考虑进来，则:如果光标在一个单词的末尾，则TAB键需要激活补全函数,如果单词后有一个空格，再按TAB键则添加空格)按Shift-TAB键时如果选择多行，则反缩进(行首删除多个空格)如果未选择多行，光标在行首，反缩进光标不在行首，发向移动光标或者什么也不做从最后两条来看，原来的indent-for-tab-command不能满足需求，需要将TAB键绑定到别的函数才行。在网上搜了半天，找到这篇文章提供的方法正是我所要的：emacs, indent/unindent region as a block using the tab keyhttp://ignaciopp.wordpress.com/2009/06/17/emacs-indentunindent-region-as-a-block-using-tab-key/上面链接中的实现也考虑了，如果要对接其它的代码补齐，只需要将(hippie-expand nil)换成其它的即可，比如auto-complete的ac-start缩进可能涉及到的配置可查阅参考：http://crushon.blog.163.com/blog/static/21440415520121117105642762/一些变量：(setq indent-tabs-mode nil)(setq default-tab-width 4)(setq tab-width 4)(setq tab-stop-list '(4 8 12 16 20 24 28 32 36 40      44 48 52 56 60 64 68 72 76 80 84 88 92 96))    总结根据上面资料，默认的情况：选择块之后Tab会缩进相应的选择块如果没有选择块tab-always-indent为t时会依据当前语法体系缩进，而不管光标是在行首还是其它；tab-always-indent为nil时根据光标三种情况：行首空白区(即在indentation区内)，则取消所有缩进;行首第一个非空白字符上， 则按第一次则语法缩进，第二次则插入tab字符或者空格(插入TAB还是空格则依赖于indent-tabs-mode设置);不在行首,插入tab字符或者空格另外，实践发现，默认情况下还有如下行为：Tab对应的空格长度，需要设置：tab-width如果Tab缩进长度达到Tab长度，是否自动将达到Tab长度的部分转换为Tab字符，需要设置：indent-tabs-mode多次tab时，光标依次缩进（前进）的长度，需要设置：tab-stop-list每次tab会缩进上行缩进的长度（无论是否为Tab的整数倍）需求：每个人需求各不相同，大致需求如下：orgmode下，采用其默认行为即可，缩进方面可以？12.33 LATER 如何显示空白字符？State "LATER"      from "INBOX"      [2015-12-03 四 16:05]12.34 LATER 如何复制一行？State "LATER"      from "INBOX"      [2015-12-03 四 16:07]12.35 LATER 缩进提示线？State "LATER"      from "INBOX"      [2015-12-03 四 16:07]12.36 DONE 重命名当前文件？State "DONE"       from "WAIT/FORWARD" [2016-03-03 四 11:30]State "WAIT/FORWARD" from "INBOX"      [2015-12-03 四 16:07]  参考dired相关命令输入 M-x rename-file或参考 文件管理12.37 MAYBE/FUTURE 如何表示当前文件名？State "MAYBE/FUTURE" from              [2016-03-03 四 11:29]12.38 WAIT/FORWARD 宏录制开始录制宏，用 C-x ( 结束录制宏，用 C-x )使用宏，用 C-x e 来使用宏。可以利用C-u来重复使用100次这个宏，即命令C-u 100 C-x e。 C-x e e e &#x2026;将宏重复。命名宏输入: M-x name-last-kbd-macro输入之后，提示输入名称，输入名称后即可完成宏命名。使用已命名的宏输入: M-x yourmacroname输入之后，便执行之前保存的"yourmacroname"对应的宏了，输入时候，输入的宏名支持Tab补全。保存宏实现输入： M-x insert-kbd-macro输入之后，提示输入宏名，输入宏名称后（这里支持Tab补全），就会将宏的实现以文本的形式插入到你的当前文本中。例如：(fset 'ins_4spc_nextline   "\C-n\C-a    ")这个宏实现是之前录制的，命名为"ins_4spc_nextline"的宏，如果将这个实现插入到你的emacs配置文件中，那么就可以通过 M-x yourmacroname 的方式来进行调用了。n重命名宏？12.39 WAIT/FORWARD 如何块缩进？State "WAIT/FORWARD" from "NEXT"       [2015-10-19 一 16:42]  如果有确定的答案就简单给出操作提示，或者直接关闭问题。参考：关于Tab缩进12.40 WAIT/FORWARD C-/是UndoState "WAIT/FORWARD" from "INBOX"      [2015-10-16 五 16:58]  wait for move12.41 DONE 如何操作目录State "DONE"       from "INBOX"      [2015-11-30 一 13:57]参考：文件管理12.42 CANCEL 如何管理配置目录State "CANCEL"     from "DONE"       [2015-12-03 四 16:10]  因人而异，可能会在将来整理相关文档。这里暂时不做深入回答。State "DONE"       from "INBOX"      [2015-12-03 四 16:09]12.43 LATER 如何定位光标下路径的文件？State "LATER"      from "INBOX"      [2015-12-03 四 16:11]12.44 LATER 如何按项目组织目录State "LATER"      from "INBOX"      [2015-12-03 四 16:11]12.45 WAIT/FORWARD 如何让Emacs在光标到达当前Buffer最后一行尾部不自动recenter?State "WAIT/FORWARD" from "NEXT"       [2016-03-03 四 11:04]  wait for arranged.State "NEXT"       from "LATER"      [2015-12-03 四 16:11]State "LATER"      from "INBOX"      [2015-12-03 四 16:11]需设置滚动参数，具体参考如下配置以及文档 和 emacs的光标滚动如何让其不在屏幕尾部自动滚屏到中间？;;auto scroll behavior, '0' is center point while outof screen, or don't center.;;(setq scroll-conservatively)(setq scroll-step 1);;(setq scroll-up-aggressively);;(setq scroll-down-aggressively);;wheel scroll step(setq mouse-wheel-scroll-amount '(1 ((shift) . 5) (control)))12.46 LATER 考虑一下用el-get插件管理插件State "LATER"      from "INBOX"      [2015-12-03 四 16:11]12.47 MAYBE/FUTURE eshell如何操作？State "MAYBE/FUTURE" from "LATER"      [2015-12-03 四 16:11]State "LATER"      from "INBOX"      [2015-12-03 四 16:11]Time:&lt;2015-10-02 五 09:53&gt;From:/media/sda6/study/mygitrepo/quietheart/misc/mylinux_home/home.user/_emacs.d/elisp/plugins.el12.48 WAIT/FORWARD 如何配置自动新开“弹出”窗口的分割方向？State "WAIT/FORWARD" from "LATER"      [2015-11-05 四 11:02]  等待整理至合适的位置。State "LATER"      from "INBOX"      [2015-11-05 四 10:49]State "INBOX"      from              [2015-10-09 五 15:10]查看 M-x info 获取到帮助信息。默认查看帮助信息的的时候，窗口会分割成左右两个，如果我们想要分割成上下，那么配置如下：;; perfer split 'pop' window vertically(whole-&gt;up+lower).(setq split-height-threshold 0)(setq split-width-threshold nil)这里我们需要注意的是， split vertically 意思是将窗口分割成上下两个部分； split horizontally 意思是将窗口分割成左右两个部分。具体查看 C-h f split-window-sensibly 。12.49 LATER Emacs如何控制Pop分割窗口的大小？State "LATER"      from "INBOX"      [2015-12-03 四 16:12]State "INBOX"      from              [2015-11-05 四 11:05]12.50 WAIT/FORWARD emacs如何进行会话保存？State "WAIT/FORWARD" from "LATER"      [2015-10-10 六 11:08]  等待整理到合适的位置。State "LATER"      from "INBOX"      [2015-10-10 六 11:05]Time:[2015-10-10 六 10:19]暂时参考：保存和恢复工作环境大致如下：可借助desktop.el来完成buffer等缓存文件、位置等加载的保存和恢复。自动恢复与保存相关的配置：(desktop-save-mode 1)手动保存会话：输入 M-x desktop-save输入之后，选择保存的目录。手动恢复以前的会话：输入 M-x desktop-change-dir输入之后，选择之前会话所在目录，之后即可加载。退回之前的会话：输入 M-x desktop-revert输入之后，可以退回之前加载的会话。如果保存变量之类的信息，需要额外的插件：session.el，插件可能有些问题暂不考虑。12.51 DONE Emacs背景配色设置？State "DONE"       from "INBOX"      [2015-12-03 四 16:14]Time:[2015-10-09 五 16:07]关于对emacs的颜色主题配置，有相关的插件：12.51.1 下载地址：http://ftp.twaren.net/Unix/NonGNU/color-theme/color-theme-6.6.0.tar.gz12.51.2 配置默认主题当把主题下载下来后 解压，然后将文件夹整个复制到到我们的load-path中然后添加如下配置：;;================================ ;;为我的emacs配置主题色彩 (color-theme-色彩名称) ;;================================ (require 'color-theme) (color-theme-initialize) (color-theme-calm-forest)12.52 WAIT/FORWARD emacs的光标滚动如何让其不在屏幕尾部自动滚屏到中间？State "WAIT/FORWARD" from "DONE"       [2016-01-18 一 16:44]  等待整理State "DONE"       from "NEXT"       [2016-01-16 六 17:18]State "NEXT"       from "INBOX"      [2015-12-03 四 16:14]Time:[2015-10-09 五 16:16]依照优先级别，依次可以设置如下三类变量，具体参见变量文档，这里设置 scroll-step, 默认0表示光标到达屏幕顶或者尾之后就立即自动滚动到屏幕中心，其它值表示滚动的行数。;;auto scroll behavior, '0' is center point while outof screen, or don't center.;;(setq scroll-conservatively)(setq scroll-step 1);;(setq scroll-up-aggressively);;(setq scroll-down-aggressively)12.53 WAIT/FORWARD 如何控制鼠标滚轮滚动的行数State "WAIT/FORWARD" from              [2016-01-18 一 16:44]  等待整理可以通过设置 mouse-wheel-scroll-amount 实现，具体可以通过 C-h v mouse-wheel-scroll-amount 查看其文档。大致含义是：该变量是一个列表，列表元素是 ("行数" . “控制按键”) 表示按下特定控制按键时滚轮滚动的行数；如果没有 “控制按键” 那么表示单纯滚轮滚动行数；如果没有指定行数，那么按下控制按键滚轮滚动将近一个屏幕。下面是一个例子：;;wheel scroll step(setq mouse-wheel-scroll-amount '(1 ((shift) . 5) (control)))12.54 LATER emacs如何清除所有buffer?State "LATER"      from "INBOX"      [2015-12-03 四 16:14]Time:[2015-10-10 六 10:21]12.55 LATER 配置调试State "LATER"      from "NEXT"       [2015-10-14 三 13:27]State "NEXT"       from "INBOX"      [2015-10-14 三 13:27]如果某项没有生效的话，可以尝试 =emacs &#x2013;init-debug- 启动，看看哪错了12.56 NEXT 不喜欢emacs新开"提示窗口"是垂直方向State "NEXT"       from "LATER"      [2015-12-03 四 16:14]State "LATER"      from "INBOX"      [2015-12-03 四 16:14]State "INBOX"      from              [2015-10-19 一 09:37]12.57 DONE Emacs如何定制颜色？State "DONE"       from "INBOX"      [2015-11-02 一 12:14]Time:[2015-10-12 一 11:12]可以使用特定插件，例如;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;color themes;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(require 'color-theme)(color-theme-initialize) (color-theme-calm-forest);;we can also select and preview with 'M-x color-theme-select'.12.58 LATER 如何设置撤销的次数？目前貌似撤销只有有限的几次State "LATER"      from "INBOX"      [2015-12-03 四 16:14]Time:[2015-10-14 三 14:53]12.59 LATER 重复最近的命令State "LATER"      from "INBOX"      [2015-12-03 四 16:14]输入 C-x z12.60 WAIT/FORWARD elisp libraryState "WAIT/FORWARD" from "NEXT"       [2015-11-30 一 17:45]  等待移动到合适的位置State "NEXT"       from "INBOX"      [2015-11-02 一 12:13]State "INBOX"      from              [2015-10-21 三 09:23]整理至原理部分。主要介绍：library, package, features的区别，以及 load-file, load, require, autoload 的区别。12.60.1 关于 load-file, load, require, autoloadload-file加载特定文件。加载特定的文件（".el", ".elc"文件扩展名不会自动加载，但是".gz"会被自动加载）。档不想让emacs猜测文件扩展名".el", ".elc" 或者没有扩展名的时候使用这个函数。load加载一个文件。通过搜索变量 load-path 加载一个文件，参数可以是一个文件名称（不用是全路径）， 比如 (load "undo") 。如果有".elc"编译版本的内容，这个命令将会自动加载之， 否则会自动加载".el", 或者".gz"的文件。当不需要知道文件的具体路径的时候不，使用这个函数加载。require如果一个package没有被加载的时候，加载一个package。检测 features变量， 如果没有相应的标号，那么调用 load 进行加载， 文件名是根据feature 名进行猜测的， 也可通过一个选项参数进行。最好在elisp库或者脚本中使用这个函数，这个和其他语言的 "require"或者"import"类似。autoload在函数被调用的时候加载文件。将一个函数名称和一个文件路径相关联，档这个功能被调用的时候，会加载这个文件，并且执行函数。如果你正在写一个major mode，尽可能将你的package安装使用autoload完成，因为这样可以节省启动的时间。12.60.2 关于 Library, Package, Feature12.60.2.1 Emacs lisp没有命名空间所有的东西都是全局的动态的作用域，它只有一些隐藏的机制，所以，不能将library或者module当作像perl、python、java类似的具有命名空间的语言的Package系统。12.60.2.2 Package和Library的区别是什么呢？其实，这些概念在elisp中没有专门的定义，我们只能大致这样来看待它们：Library包含许多组建的elisp文件，比如 comment-dwim 命令定义在 newcomment.el 中，它是一个包含众多函数的库。Package任何对emacs用户有用的elisp库，无论是在major还是在minor模式下。另外在emacs中，不使用 "module"这个概念。12.60.2.3 Package/Library/Feature不会被管理在package/library/feature/autoload的概念和文件名称之间没有绝对的对应关系。默认来说，如果一个elisp文件名称是xyz-mode.el，那么它会提供一个"xyz-mode"的lisp标号做为feature名称，然后用来执行这个mode的命令一般都是 xyz-mode 。 有时候， -mode 部分在任何 {file name, feature symbol name, command name} 中被忽略。这只是一个松散的规则，有许多不按照这个规则的例子，比如：文件 lisp-mode.el 会提供一个 lisp-mode 的标记做为feature，激活的命令可能是 emacs-lisp-mode 。文件 cua-base.el 提供一个 cua-base 的标记，feature名称为 cua, 并且激活的命令是 cua-mode 。文件 text-mode.el 没有提供任何标记做为feaure, 它通过命令 text-mode 被激活。文件 desktop.el 提供一个 desktop 标记做为feature， 并且激活的命令是 desktop-save-mode 。从以上即可看出，你可以有一个文件名称为 Joe-xyz-mode-v2.1.el, 它提供了名为 abc 的feature, 同时用来激活它的命令可能是 opq, 在 mode line中可能会被显示为 OPQ helper 。 这个文件可以被看作是一个package或者libaray。12.60.2.4 其它没有 "name space" "不被管理"的 module系统并不一定非常糟糕，这只是做为一个软件状态存在，许多流行的语言例如 C, C++, PHP 表现的更差，他们没有module系统，并且通过 include 来包含文件。我们需要注意的是，Scheme lisp也没有module系统，在2007年发布的R6RS添加了严格的module系统控制，但是这导致了Scheme社区的分裂。更多内容参考：http://ergoemacs.org/emacs/elisp_library_system.html12.61 WAIT/FORWARD Emacs自定义配置State "WAIT/FORWARD" from "INBOX"      [2015-10-21 三 15:08]  待整理到合适的位置Capture Time:[2015-10-21 三 14:22]在帮助菜单里配置，而非手动修改配置文件时产生的配置信息，会以类似如下的形式写到~/.emacs中：(custom-set-variables  ;; custom-set-variables was added by Custom.  ;; If you edit it by hand, you could mess it up, so be careful.  ;; Your init file should contain only one such instance.  ;; If there is more than one, they won't work right. '(ecb-options-version "2.40") '(ecb-primary-secondary-mouse-buttons (quote mouse-1--mouse-2)))12.62 LATER 默认启动xemacs的窗口大小State "LATER"      from "INBOX"      [2015-10-21 三 15:09]Capture Time:[2015-10-21 三 09:46]12.63 NEXT emacs-desktop的会话存储默认位置State "NEXT"       from "INBOX"      [2015-10-21 三 15:09]Capture Time:[2015-10-21 三 09:39]12.64 NEXT 如何高亮？参考：http://www.xuebuyuan.com/729481.html12.65 NEXT Emacs如何进行特定模式下的按键绑定映射？State "NEXT"       from "INBOX"      [2015-10-21 三 15:09]Capture Time:[2015-10-21 三 08:39]12.66 LATER 如何为当前的Emacs编辑器升级？State "LATER"      from "INBOX"      [2015-10-21 三 15:10]Capture Time:[2015-10-20 二 11:51]12.67 DONE Emacs撤销、重做和重复State "DONE"       from "WAIT/FORWARD" [2015-12-10 四 17:24]State "WAIT/FORWARD" from "NEXT"       [2015-12-10 四 16:45]  等待进一步整理State "NEXT"       from "INBOX"      [2015-12-03 四 16:14]Capture Time:[2015-10-23 五 11:03]撤销是取消上次的操作，重做是对撤销的撤销，重复是对上次命令进行重做。大致如下：撤销（undo）输入 C-x u 或 C-/重做（redo）输入 C-g C-x u  或 C-g C-/ 重复（repeat）输入 C-x z具体参考：Emacs撤销、重做和重复 和 编辑12.68 NEXT Emacs 如何远程访问？State "NEXT"       from "INBOX"      [2015-10-23 五 12:03]Capture Time:[2015-10-22 四 15:02]12.69 LATER 将emacs custom config变成手动的configState "LATER"      from "INBOX"      [2015-12-03 四 16:15]Capture Time:[2015-10-23 五 13:11]12.70 WAIT/FORWARD 恢复文件State "WAIT/FORWARD" from "NEXT"       [2015-10-23 五 15:22]  等待转移至合适的位置。State "NEXT"       from "INBOX"      [2015-10-23 五 15:21]State "INBOX"      from              [2015-10-23 五 15:21]回复上次崩溃之时没有来得及修改的文件。输入 M-x recover-file输入之后，可以补全，输入文件路径即可。如果文件已经保存，则不存在恢复文件，如果文件上次没有保存，就会有一个 .#filename# 之类的文件，通过它来恢复上次没有来得及保存的内容。12.71 LATER 无需远端安装emacs，用本地emacs直接访问远端，可否？State "LATER"      from "INBOX"      [2015-12-03 四 16:15]Capture Time:[2015-10-26 一 11:46]12.72 MAYBE/FUTURE Emacs 任务管理？State "MAYBE/FUTURE" from "INBOX"      [2015-12-03 四 16:15]Capture Time:[2015-10-27 二 10:14]12.73 LATER 崩溃后下次启动自动提示回复文件的方式？State "LATER"      from "INBOX"      [2015-12-03 四 16:15]Capture Time:[2015-10-27 二 14:19]12.74 LATER Emacs如何粘帖复制文本到X剪切板中？State "LATER"      from "INBOX"      [2015-12-03 四 16:15]Capture Time:[2015-10-28 三 11:02]12.75 LATER Emacs中如何在require后卸载插件？State "LATER"      from "INBOX"      [2015-12-03 四 16:15]State "INBOX"      from              [2015-11-04 三 09:36]12.76 LATER 拼音输入法State "LATER"      from "INBOX"      [2015-12-03 四 16:15]Capture Time:[2015-10-30 五 09:35]意外发现的情况： C-\ 会切换Emacs的输入法。12.77 NEXT Emacs为什么有时候缩进无法删除？State "NEXT"       from "INBOX"      [2015-12-03 四 16:17]Capture Time:[2015-11-02 一 09:50]12.78 NEXT Emacs如何搜索光标下的内容State "NEXT"       from "INBOX"      [2015-11-05 四 09:18]Capture Time:[2015-11-05 四 08:56]目前是先 M-b 到单词首，再 C-s C-w 搜索光标后至单词尾的内容。12.79 LATER Emacs如何格式化全部代码？State "LATER"      from "INBOX"      [2015-12-03 四 16:17]Capture Time:[2015-11-05 四 16:01]12.80 NEXT 为什么Emacs有时候无法删除缩进？State "NEXT"       from "INBOX"      [2015-12-03 四 16:17]Capture Time:[2015-11-09 一 11:06]ttbb12.81 DONE Emacs如何反撤销重做？State "DONE"       from "NEXT"       [2016-03-03 四 11:11]State "NEXT"       from "INBOX"      [2015-11-16 一 10:33]Capture Time:[2015-11-13 五 14:13]参考：Emacs撤销、重做和重复12.82 WAIT/FORWARD emacs剪切板和x剪切板共享State "WAIT/FORWARD" from "NEXT"       [2015-12-21 一 15:22]  有待进一步整理State "NEXT"       from "INBOX"      [2015-11-16 一 10:33]Capture Time:[2015-11-10 二 11:35];;clipboard share for gui emacs(setq x-select-enable-clipboard t)参考：http://www.th7.cn/system/lin/201410/72664.shtml12.83 DONE 完善自己的开发环境，代码跳转、扫描、定位等，不用每次都要手动配置State "DONE"       from "INBOX"      [2015-11-30 一 14:10]Capture Time:[2015-11-20 五 15:35]需要借助插件： cedet 和 ecb 。 cedet 主要用于建立索引已经提供跳转等功能, ecb 主要提供方便的窗口布局。当然，最好还是用 understand 或者 sourceinsight 之类的工具，简易点的也可用 geany 。12.84 LATER Emacs 括号跳转State "LATER"      from "INBOX"      [2015-11-30 一 14:10]Capture Time:[2015-11-23 一 14:38]`C-M-n‘Move forward over a parenthetical group (`forward-list‘).`C-M-p‘Move backward over a parenthetical group (`backward-list‘).`C-M-u‘Move up in parenthesis structure (`backward-up-list‘).`C-M-d‘Move down in parenthesis structure (`down-list‘).12.85 DONE 关于NarrowState "DONE"       from "WAIT/FORWARD" [2016-02-09 二 16:02]State "WAIT/FORWARD" from "NEXT"       [2015-11-30 一 14:10]  等待移动到合适的位置。State "NEXT"       from "INBOX"      [2015-11-24 二 17:32]可参考：关于Narrow12.86 LATER emacs如何搜索光标所在字符的内容State "LATER"      from "NEXT"       [2016-02-09 二 16:02]State "NEXT"       from "INBOX"      [2015-11-24 二 11:53]Capture Time:[2015-11-24 二 10:06]http://emacser.com/next-pre-word.htm如果图个简单，可以C-&lt;left&gt; 定位到单词首，然后 C-s C-w 将当前单词搜索，连续 C-w 可以扩展搜索的单词12.87 LATER C-x =State "LATER"      from "INBOX"      [2015-12-03 四 16:17]State "INBOX"      from              [2015-11-30 一 14:09]12.88 MAYBE/FUTURE 定义自己的Emacs环境State "MAYBE/FUTURE" from "NEXT"       [2016-02-09 二 16:02]State "NEXT"       from "INBOX"      [2015-11-30 一 14:15]State "INBOX"      from              [2015-11-30 一 14:15]最好兼容，与将要拥有以及已有的插件快捷键不冲突高亮当前光标单词搜索当前光标单词http://emacser.com/next-pre-word.htm12.89 MAYBE/FUTURE 将emacs插件分层整理一下，最好能尝试一下新版本的emacsState "MAYBE/FUTURE" from "LATER"      [2016-02-09 二 16:03]State "LATER"      from "INBOX"      [2015-12-01 二 17:02]Capture Time:[2015-11-26 四 16:57]12.90 NEXT Emacs如何撤销以及反撤销？State "NEXT"       from "INBOX"      [2015-11-30 一 14:36]Capture Time:[2015-11-30 一 14:35]12.91 WAIT/FORWARD &#x2014;&#x2014; [2015-12-02 三 15:06]  Emacs标签跳转------State "WAIT/FORWARD" from              [2015-12-03 四 14:15]  wait for moveFrom:/home/miracle/mydata/orgmode/gtd/output/emacs_tips.org主要有如下功能设置书签输入 C-x r m跳转到指定书签输入 C-x r b , 输入之后，提示跳转的书签，可以 TAB 补全。列出书签输入 C-x r l另外获取帮助信息输入 C-x r C-h , 其中的m/l/b子项和书签有关。12.92 LATER &#x2014;&#x2014; [2015-12-02 三 16:58]  Emacs mark ring------State "LATER"      from              [2015-12-03 四 14:15]From:/home/miracle/work/androidL/gitlocalcode/device/tpvision/tvsoc/tvsoc_mtk/test/tpapi_pvr_test.cppC-x C-x 在上次Mark和光标之间切换，并且高亮C-u C-x C-x 同上，但是不高亮,效果类似在上次位置和下次位置来回切换C-@ C-@ 将记录mark到mark ring, 实际是activate，再deactivate除了这个命令，许多命令在操作后，会自动保存操作之前的mark位置到mark ring(有当前buffer的、和全局的两种mark ring)， 这样的命令运行之后，在回显区域有 Mark set 提示， 便于回到之前的位置。例如：使用 C-y 粘帖之时,使用 M-&lt; / M-&gt; 跳转buffer首尾之时，退出增量搜索之时， 插入buffer/file之时……C-u C-@ 跳到上一次记录的mark, 范围是当前bufferC-x C-@ 范围是global mark ring.参考：http://www.gnu.org/software/emacs/manual/html_node/emacs/Setting-Mark.html#DOCF5http://www.gnu.org/software/emacs/manual/html_node/emacs/Mark-Ring.html#Mark-Ring12.93 MAYBE/FUTURE 意外发现 ESC-` 在minibuf打开菜单栏State "MAYBE/FUTURE" from "WAIT/FORWARD" [2015-12-03 四 16:19]State "WAIT/FORWARD" from "LATER"      [2015-12-03 四 16:19]State "LATER"      from "NEXT"       [2015-12-03 四 16:19]State "NEXT"       from "INBOX"      [2015-12-03 四 16:19]State "INBOX"      from              [2015-12-03 四 16:19]12.94 NEXT 学习资源State "NEXT"       from "INBOX"      [2015-12-04 五 10:38]State "INBOX"      from              [2015-12-04 五 10:38]如何在官方网址上或者邮件上提问？http://blog.gmane.org/gmane.emacs.orgmode官网http://www.gnu.org/software/emacs/对于每个插件，找到该插件发布的地方（如github），然后以报告bug的形式，或者查看前人报告的问题。12.95 LATER Emacs如何自定义按键映射不冲突State "LATER"      from "NEXT"       [2016-02-09 二 16:03]State "NEXT"       from "INBOX"      [2015-12-04 五 15:36]Capture Time:[2015-12-02 三 14:59]12.96 NEXT Emacs高级搜索State "NEXT"       from              [2015-12-14 一 17:47]在当前文件列出所有匹配行M-x list-maching-lines在多个文件和目录中搜索M-x grep 或 M-x rgrep , 后者交互性更好。在目录中查找文件M-x find-name-dired参考：http://www.cnblogs.com/cobbliu/p/3745474.html12.97 WAIT/FORWARD Emacs如何显示括号匹配？如何显示行号？State "WAIT/FORWARD" from "DONE"       [2015-12-17 四 10:58]  等待整理State "DONE"       from "INBOX"      [2015-12-17 四 10:57]Capture Time:[2015-12-02 三 17:46];;paren(show-paren-mode 1);;line number(global-linum-mode t)启动后,显示行号输入 M-x  global-linum-mode12.98 LATER 设置输入法State "LATER"      from              [2016-02-09 二 16:11]M-x set-input-methodC-x Ret C-\12.99 DONE 使用Emacs阅读代码State "DONE"       from "LATER"      [2016-02-09 二 16:14]State "LATER"      from "INBOX"      [2015-12-18 五 13:37]Capture Time:[2015-12-15 二 16:42]主要涉及到的插件包括：cedet+ecb+globalcedet 是一个代码索引后端ecb 可以操作显示方式global 是代码索引生成和查找的工具，类似ctags参考：http://www.newsmth.net/nForum/#!article/Emacs/84691http://blog.csdn.net/bigmarco/article/details/693450212.100 LATER emacs自动保存间隔State "LATER"      from "INBOX"      [2015-12-18 五 13:38]Capture Time:[2015-12-16 三 10:07]12.101 NEXT emacs如何替换文本?State "NEXT"       from "INBOX"      [2015-12-18 五 13:38]Capture Time:[2015-12-17 四 09:25]12.102 LATER Emacs如何设置多重功能的按键?State "LATER"      from "INBOX"      [2015-12-18 五 13:38]Capture Time:[2015-12-17 四 15:16]例如我想在按下鼠标后,先定位到对应位置,然后再执行特定的函数(这里是 gtags-find-tag-from-here )(local-set-key (kbd "C-M-&lt;mouse-1&gt;") '(lambda ()(interactive);;(mouse-set-point &lt;mouse-1&gt;) ;; how to position at first?(gtags-find-tag-from-here)))12.103 NEXT Emacs如何切换最近buffer,而非只有一个最近buffer?State "NEXT"       from "INBOX"      [2015-12-18 五 13:38]Capture Time:[2015-12-17 四 15:24]12.104 WAIT/FORWARD Emacs如何高亮多个单词?State "WAIT/FORWARD" from "NEXT"       [2016-02-09 二 19:17]  等待进一步整理。State "NEXT"       from "INBOX"      [2015-12-18 五 13:38]Capture Time:[2015-12-17 四 15:42]12.104.1 利用emacs自带的 hi-lock-mode高亮指定单词 M-s h p 输入之后，再输入待高亮的单词，以及高亮的颜色（可补全），即可。高亮特定正则表达式M-s h r 类似前面，输入之后输入正则表达式以及颜色即可。高亮匹配正则表达式的行M-s h l 类似前面。取消高亮M-s h u 输入之后，默认自动取消刚刚设置的高亮，或者输入想要取消高亮的正则表达式来进行取消。12.104.2 利用插件主要有 highlight-symbol 和 idle-highlight可实现光标处自动高亮，以及类似 vim 中的 * 和 # 搜索。参考：http://www.cnblogs.com/bamanzi/archive/2012/12/03/emacs-find-modify-all-occurences.html12.105 DONE 如何在Emacs直接预览markdown效果？State "DONE"       from "LATER"      [2016-02-09 二 16:10]State "LATER"      from "INBOX"      [2015-12-21 一 15:57]Capture Time:[2015-12-18 五 14:54]可以使用 markdown-mode 插件。参考网址：官方网址LinuxToy的文档12.106 MAYBE/FUTURE 如何执行脚本State "MAYBE/FUTURE" from              [2015-12-22 二 16:36]$emacs -batch -l ~/.emacs -eval '(org-batch-agenda "t")' | lpr12.107 NEXT Emacs崩溃后的恢复策略State "NEXT"       from              [2015-12-31 四 14:50]输入 M-x recover-session 之后根据时间，选择需要恢复的会话情况。12.108 NEXT emacs如何跳转到匹配的括号？State "NEXT"       from "INBOX"      [2016-01-05 二 15:36]Capture Time:[2015-12-22 二 17:08]12.109 NEXT 一些基本操作State "NEXT"       from              [2016-02-04 四 13:54]前进后退跳转至光标下的路径关闭所有buffer跳至指定百分比12.110 NEXT emacs如何返回上次编辑的位置State "NEXT"       from "INBOX"      [2016-01-31 日 16:56]Capture Time:[2016-01-31 日 16:56]12.111 NEXT Emacs如何定期自动保存文件?State "NEXT"       from "INBOX"      [2016-01-21 四 10:28]Capture Time:[2016-01-21 四 10:27]12.112 DONE emacs打开文件等，如何实现部分匹配文件或者命令而非精确开头匹配State "DONE"       from "WAIT/FORWARD" [2016-03-03 四 11:34]State "WAIT/FORWARD" from "NEXT"       [2016-02-10 三 11:22]  等待整理至合适位置。State "NEXT"       from "INBOX"      [2016-02-09 二 11:45]Capture Time:[2016-02-09 二 10:52]对打开buffer的 C-x b 以及打开文件的 C-x C-f 实现增加部分匹配可使用 ido 插件。对于运行Emacs命令 M-x xxx 可以使用基于 ido 的 smex 插件实现部分匹配，省去了记忆许多快捷键的麻烦。另外 helm 也是另外一套替换 ido 的补全方案，也可支持命令输入补全。12.112.1 ido具体参考相关文档。12.112.1.1 下载http://repo.or.cz/w/emacs.git/blob_plain/HEAD:/lisp/ido.el12.112.1.2 配置;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ido;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(require 'ido)(ido-mode t)12.112.2 smex12.112.2.1 下载https://github.com/nonsequitur/smex12.112.2.2 配置;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;smex;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(require 'smex)(global-set-key (kbd "M-x") 'smex)(global-set-key (kbd "M-X") 'smex-major-mode-commands);; This is your old M-x.(global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)12.113 LATER 意外发现的 M-* 和 M-. 是做什么的？State "LATER"      from "NEXT"       [2016-02-11 四 14:41]State "NEXT"       from              [2016-02-09 二 19:19]12.114 NEXT Emacs代码折叠State "NEXT"       from              [2016-02-10 三 12:15]http://www.cnblogs.com/bamanzi/archive/2011/10/09/2203866.html      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2015-09-09 三 14:08]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-09-09]<a href="/categories/study/emacs/emacs_tips.html"> Emacs学习笔记 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '租房三要素'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '找房子不一定非要跑很多趟。可以只把握住以下三要素:  价格对策:打电话，问中介。注意:为防止骚扰，可用阿里小号，虚拟号码联系。区域对策:上网，查地图注意:根据自身喜好，可按地铁，公交，价格区域查找。特色对策:实地考察';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-09-05]<a href="/categories/life/three_points_for_rent.html"> 租房三要素 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '测试代码'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '测试文章链接[文章（引用错误）](/_posts/2015-08-14-first_page.md)文章（引用错误）[文章（html引用成功）](/others/2015/08/14/first_page.html)文章（html引用成功）[文章（html引用成功，建议这样）](/others/2015/08/14/first_page.html &quot;2015-08-14-first_page.md&quot;)文章2（html引用成功，建议这样）  测试图片链接![图片（大小不协调）](/data/2015-08-19-test_link.files/image/2015-08-19-test_image.jpg)  测试文件链接[Sing for You(音乐无法播放?可下载)](/data/2015-08-19-test_link.files/audio/sing_for_you.mp3)Sing for You(音乐无法播放?可下载)[普通文件（可下载）](/data/2015-08-19-test_link.files/misc/2015-08-19-lxr-2.0.3.tgz)普通文件（可下载）  测试子分类代码：&lt;ul&gt;    &lt;li onclick=&quot;lev1.style.display=&#39;block&#39;&quot;&gt;        记事        &lt;ul id=&quot;lev1&quot; style=&quot;display:none; margin-left:10px;&quot;&gt;            &lt;li&gt;备忘&lt;/li&gt;            &lt;li&gt;计划&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;    &lt;li onclick=&quot;lev2.style.display=&#39;block&#39;&quot;&gt;        学习        &lt;ul id=&quot;lev2&quot; style=&quot;display:none; margin-left:10px;&quot;&gt;            &lt;li&gt;第2节点--1&lt;/li&gt;            &lt;li&gt;第2节点--2&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;&lt;/ul&gt;效果：      记事          备忘      计划            学习          第2节点--1      第2节点--2      ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-08-19]<a href="/categories/others/test_link.html"> 测试代码 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Jekyll+github建站实践'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '本文通过实践介绍使用Jekyll+github建立个人站点的过程。假设我们已经申请了一个github账户，账户名称为username。  创建一个用来建站的仓库#仓库名：  username/username.github.io  检出仓库：  $git clone https://github.com/username/username.github.io  个人主页的网站内容是在master分支下的。  创建主页：  $cd username.github.io  $echo &quot;Hello World&quot; &gt; index.html  $git add --all  $git commit -m &quot;Initial commit&quot;  $git push -u origin master  注意：第一次push的时候使用`-u origin master`，以后直接用`git push`命令即可。访问主页：  http://username.github.io  至此，个人站点创建完毕，我们可以自己添加html内容来完善自己的站点。完全手写html代码建立站点的过程过于复杂，下面我们将讲述如何使用Jekyll来创建个人站点。搭建Jekyll环境 #使用Jekyll可以帮助我们自动生成静态网站，减少建站的负担，使我们将主要精力集中到文章和内容上。github使用的就是Jekyll来生成站点项目的网页，所以这里我们可以在本地先搭建一个和github一样的环境。发布文章之前可以预览效果，确认可以了就能直接push到github。安装ruby过程大致如下:$wget -c https://cache.ruby-lang.org/pub/ruby/2.2/ruby-2.2.2.tar.gz$tar -xzvf ruby-2.2.2.tar.gz$mkdir -p ~/myinstalled$mv ruby-2.2.2 ~/myinstalled$cd ~/myinstalled/ruby-2.2.2$./configure$make$sudo make install这里要求ruby大于2.0.0，所以直接从官方下载源代码安装。安装bundle  $ sudo gem install bundle[sudo] password for quietheart:Fetching: bundler-1.10.6.gem (100%)Successfully installed bundler-1.10.6Fetching: bundle-0.0.1.gem (100%)Successfully installed bundle-0.0.1Parsing documentation for bundler-1.10.6Installing ri documentation for bundler-1.10.6Parsing documentation for bundle-0.0.1Installing ri documentation for bundle-0.0.1Done installing documentation for bundler, bundle after 4 seconds2 gems installed注：  此处安装可能会有错误，提示类似如下：  $gem install bundleERROR:  While executing gem ... (Gem::Exception)Unable to require openssl, install OpenSSL and rebuild ruby (preferred) or use non-HTTPS sources如果这样，我们可以查看一下源信息：  $ gem sources -l*** CURRENT SOURCES ***https://rubygems.org/然后换一个没有被“墙”的代理，如下尝试：  $ gem sources --remove https://rubygems.org/https://rubygems.org/ removed from sources$ gem sources -a http://ruby.taobao.org/http://ruby.taobao.org/ added to sources$ gem sources -l*** CURRENT SOURCES ***http://ruby.taobao.org/配置Gemfile文件  $&gt;Gemfile$vim Gemfile内容如下：source &#39;http://ruby.taobao.org/&#39;gem &#39;github-pages&#39;安装jekyll环境下面根据实际安装时出现的状况，给出两种方式。  方式一、利用bundle安装与更新(报错, 待解决)  $ bundle install$ bundle update至此，通过bundle方式安装完毕，可以用如下命令启动和转化本地服务:  $ bundle exec jekyll serve（失败）方式二、手动安装：  $sudo gem update --system$sudo gem install jekyll$jekyll --version至此，jekyll安装完毕，通过jekyll --version可以检测安装是否成功。可能遇到的问题：  如果jekyll --version运行失败，安装依赖  $sudo gem install directory_watcher$sudo gem install liquid$sudo gem install open4$sudo gem install maruku$sudo gem install classifier$sudo gem install rdiscount$sudo gem install rouge$sudo gem install therubyracer$sudo gem install execjs$sudo apt-get install nodejs$jekyll --version如果nodejs安装失败，手动源码安装  $ sudo apt-get install python$ sudo apt-get install build-essential$ sudo apt-get install gcc$ sudo apt-get install g++$ wget -c https://nodejs.org/dist/v0.12.7/node-v0.12.7.tar.gz$ tar -xzvf node-v0.12.7.tar.gz$ mkdir -p ~/myinstalled$ mv node-v0.12.7 ~/myinstalled &amp;&amp; cd ~/myinstalled$./configure$make$sudo make install$node -vv0.12.7使用Jekyll建站  建立用户构建站点的文件需要建立的文件不多解释，大致如下：  $ pwd/home/quietheart/github/vaqeteart.github.io$ tree.├── assets├── _config.yml├── _includes├── index.html├── _layouts│   └── default.html├── _plugins├── _posts│   └── 2015-08-14-first_page.md├── readme.md使用Jekyll生成站点根据前面建立的文件，生成站点。运行编译如下：  $ jekyll buildConfiguration file: /media/sda6/study/github/vaqeteart.github.io/_config.ymlSource: /media/sda6/study/github/vaqeteart.github.ioDestination: /media/sda6/study/github/vaqeteart.github.io/_siteGenerating...done.Auto-regeneration: disabled. Use --watch to enable.如果语法错误会有提示。  运行服务器：  $ jekyll serverConfiguration file: /media/sda6/study/github/vaqeteart.github.io/_config.ymlSource: /media/sda6/study/github/vaqeteart.github.ioDestination: /media/sda6/study/github/vaqeteart.github.io/_siteGenerating...done.Auto-regeneration: enabled for &#39;/media/sda6/study/github/vaqeteart.github.io&#39;Configuration file: /media/sda6/study/github/vaqeteart.github.io/_config.ymlServer address: http://127.0.0.1:4000/Server running... press ctrl-c to stop.Regenerating: 1 file(s) changed at 2015-08-14 18:56:40 ...done in 0.018106602 seconds.运行之后，可以在浏览器上通过http://127.0.0.1:4000/预览生成的站点。  注意：如果对于jekyll想知道更多的命令可以运行jelly --help。如果需要每次修改文件jekyll会自动检测到变化并生成对应新页面。可以直接使用jekyll server -w。这样就不用每次修改文件都运行jekyll build&amp;jekyll server了。参考资料下面列出一些不错的参考资料：http://www.cnblogs.com/purediy/archive/2013/03/07/2948892.htmlhttp://blog.csdn.net/on_1y/article/details/19259435https://github.com/minixalpha/minixalpha.github.iohttp://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.htmlhttp://higrid.net/c-art-blog_jekyll.htmhttp://www.tuicool.com/m/articles/INBnMzhttp://higrid.net/c-art-jeklly_template_data.htmhttp://holbrook.github.io/http://jekyllrb.com/docs/datafiles/  其它的还有：http://www.pchou.info/web-build/2014/07/04/build-github-blog-page-08.htmlhttps://pages.github.com/https://help.github.com/articles/using-jekyll-with-pages/http://www.cnblogs.com/netbuddy/p/3501147.htmlhttp://segmentfault.com/q/1010000000476530http://www.cnblogs.com/hwpayg/archive/2012/11/04/2753404.html  ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-08-19]<a href="/categories/study/jekyll_on_github.html"> Jekyll+github建站实践 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'My first page'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '第一篇文章这是我的第一篇文章直接在github上用Markdown书写。';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2015-08-14]<a href="/categories/others/first_page.html"> My first page </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '理解repo'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2014-10-09 四]	  	    		  Update	  	    Table of Contents1. 须知1.1. repo1.2. git项目1.3. repo项目2. repo init3. repo sync4. 关于分支4.1. repo分支4.2. 清单文件指定的分支4.3. git分支5. 其它1 须知1.1 reporepo用于管理多个git项目，同一产品可能包含多个git项目，不同的git项目集合，可能形成不同产品，通过repo可以实现方便的管理。repo主要包含repo配置信息、以及repo所管理的git项目集合。1.2 git项目对于所有git管理的项目，例如 mygitproject ，其中 mygitproject/.git 是git目录（或git库）； mygitproject/ 中除 .git 之外的内容为git工作目录，来自相应git目录中的某个版本。1.3 repo项目对于所有repo管理的项目，例如 myrepoproject ，其中 myrepoproject/.repo 是repo目录（或repo库）； myrepoproject/ 中除 .repo 之外的内容为repo工作目录，来自相应repo目录中的某个版本。2 repo initrepo init 的作用是下载或更新好repo配置和脚本集（相当于对repo配置和repo脚本集进行 git pull ，但是它还额外做了更多的事情），repo配置和脚本本身又是由git管理的，repo配置指定使用哪些git项目，脚本是repo命令本身的实现。在空目录中执行这个目录后，会生成一个 .repo 目录，查看 .repo 目录，会看到有如下内容：$ls .repomanifests/  manifests.git/  manifest.xml  repo/具体解释如下：.repo此为repo目录，可用于提取相应项目工作目录到外面的repo工作目录。.repo/manifests.git此为repo配置信息的git库，不同版本包含不同配置信息，配置信息大致描述内容见后面。.repo/manifests此为repo配置信息的工作目录（将配置信息的工作目录和相应的实际git目录分离管理，并且配置信息中的.git目录实际只是指向实际git库的软连接），其中可能包含一个或多个xml文件描述的配置。每个xml文件是独立的一套配置，配置内容包括当前repo工作目录包含哪些git项目、所有git项目所处的默认公共分支、以及远端地址等。.repo/manifest.xmlrepo工作目录中的内容同一时刻只能采用manifests中的一个xml文件做为其配置，该文件就是其软连接，通过init的-m选项指定采用哪个文件；另外，同一xml文件也可能处于manifests库的不同版本或者不同分支，通过 init 的 -b 选项指定使用manifests中的哪个分支，每次init命令都会从服务器更新最新的配置。这里通过 -m 指定的manifests中的xml文件中，有两个需要注意：default.xml是稳定版，default_head.xml是开发版，开发版始终包含最新的内容。.repo/repo此为repo脚本集的git库，用于repo管理所需的各种脚本，repo的所有子命令就是其中的对应脚本实现。该脚本也通过git管理， .repo/repo/.git 为对应的git目录。这里包含repo命令所需的所有子命令脚本实现，由python完成（我们可以在 .repo/repo/subcmds 中看到类似repo的init等的子命令脚本实现，如repo的 init 子命令即 repo init ，它由 .repo/repo/subcmds/init.py 实现），这个目录本身又由git来管理。不同的repo库或者不同版本的repo库，其repo命令实现会有些不同，所以也对应不同的repo脚本集，建议每次采用对应repo项目的最新的repo库做为其repo命令集实现。第一次使用repo时，采用的repo脚本实际是一个简单的repo的引导脚本，它既符合shell语法，又符合python语法，最终会将所需的具体脚本实现下载至最新的 .repo/repo 中，后面类似 repo init 、 repo sync 等脚本的实现，全都有这里的内容来实现。我们发现 .repo/repo/repo ，这个文件其实就是当前repo库中最新的repo引导脚本，可供其它没有使用过repo的用户做为repo的引导脚本来使用。3 repo syncrepo sync 的作用是下载当前repo配置的所有项目，并生成对应的repo工作目录。执行之后，会看到.repo目录包含如下内容：$ls .repomanifests  manifests.git  manifest.xml  projects  repo还有 .repo 外面也多出了许多目录。也就是说，多出了一个 projects 目录，和 .repo 外面的许多目录，具体内容如下：.repo/projects此为repo所管理的所有git项目集，包含repo当前配置所指定的所有git项目对应的git目录。不同的清单文件（即 manifest.xml ）内容，指定不同的git项目集组合，表征不同的项目版本或者项目，而如上所述，manifest.xml文件的内容又由其指向的manifests中的、具体的分支下的、xml文件来决定。.repo/../*此为repo的工作区。在repo目录（即 .repo ）之外，根据repo配置（即 .repo/manifest.xml 文件），从 .repo/projects/* 中提取出指定分支的各个git项目（即 .repo/projects 中git项目的子集）的工作目录，形成repo工作目录，可供开发使用。其中每个git工作目录中的 .git 只是指向 .repo/projects/* 的软连接，在repo工作目录中的某个git工作目录更新相应的git库，其实最终会更新到 .repo/projects 中对应的git库。刚刚repo sync之后，当前工作目录不处于任何分支，其中的修改只能本地保存无法提交至远端，若想提交工作，需要先创建一个分支保存工作内容。4 关于分支以上描述，有几个分支的概念需要明确。4.1 repo分支这里通过 repo init -b ，中的 -b 所指定的分支，是manifests的分支，不同分支，其中的文件清单内容有所不同。4.2 清单文件指定的分支通过清单文件 manifest.xml 中的default实体的revision属性，指定版本库默认的分支为revision属性值，该属性值做为 repo sync 之后工作目录中所有git项目的公共起点分支，也就是说，该manifest对应所有的git项目都有一个以revision属性值为名的分支， repo sync 之后，在任意一个repo工作目录下的git库中，使用 git branch 或者 repo start 创建的分支，都是基于该git库中revision属性值为名的分支来创建。我们可以将这个分支设置为和repo分支类似的名字。4.3 git分支除了repo管理的用于repo配置的repo分支，和用于设置工作目录起点的清单文件分支，每个工作目录对应的git库，也可设置自己的工作分支，和平时使用git时的含义一样。5 其它以上参考《git权威指南》和网络，如有错误之处，欢迎指正，谢谢。';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2014-10-09]<a href="/categories/study/repo_understand.html"> 理解repo </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '使用git进行版本控制'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '本文将介绍一种强大的版本控制工具，git的基本使用。与之前svn工具类似，首先给出一些常见的使用需求，然后以这些需求为中心，来展开git的学习过程。由于我也是在学习当中所以其中不准确之处可以通过后面的联系方式来交流，谢谢。_^主要内容+ 简介+ 基本概念+ 常用命令+ 具体实践+ 其它  简介本文将介绍一种强大的版本控制工具，git的基本使用。与之前svn工具类似，本文首先给出一些常见的使用需求，然后以这些需求为中心，来展开git的学习过程。带着问题学习：从svn过渡过来的用户初次使用git，会遇到许多的问题，这里以习惯了svn用户的角度，来考虑学习使用git需要解决的一些问题：  如何查看库路径信息？如何合并和创建分支？如何恢复到指定的版本？如何查看指定版本的信息？如何理解分布式存储？什么是索引？什么是工作树？如何查看log详细信息？这些问题也可作为学习之后的练习，我们可以尝试自己来解决一下_。一、基本概念 ###这部分内容，大部分来自git的man手册，更为具体的信息可以参见man gittutorial的命令输出。svn和git都是用于进行代码版本控制的工具。但是两者有许多不同，这里只对两个重要的地方：分布式管理、是否可更改历史，进行说明，随着以后的学习，我们会发现两者之间更多的不同之处。使用过svn的用户可知svn有两个比较重要的特点：  在svn中一个项目已经提交的历史无法被修改。不同的svn代码库之间不能相互同步不同的代码修改。svn服务器通过其中的某个统一的代码库集中管理某个项目代码，其他部分的代码都是这个服务器中库的工作拷贝，提交时都提交到这个统一的服务器代码库中。当然这并不是绝对的，我们可以通过特殊方法修改svn的历史，也可以让svn实现“分布”管理）。而对于git，至少在这两点上与svn不同：  在git中，我们可以任意修改已经提交的内容的历史信息。git中的服务器可以不只一个，服务器中同一项目的的代码库也可以不止是一个。我们可以将一台机器器上面的git代码库拷贝到另外一台机器上，然后提交的时候只往那个库中提交，而这些库之间还可以相互同步它们之间不同的修改部分。下面是学习git时需要了解的一些重要内容，其中有些涉及到的内容，在后面的部分会详细提及。  1、git中的status和diff，以及add和commit ####git中，每次提交修改文件之前要add，然后再commit。git的add命令和许多版本控制系统不一样，不是增加新增的文件，而是以内容为单位，将最新修改的内容，添加到一个临时的索引中，等待commit。实践发现，如果修改一个文件，然后diff查看修改，然后add，然后再修改，然后在commit，那么只把第一次修改提交了。commit的时候，建议遵守这样的格式：开始是简短的一行描述（不超过50字符），然后根着一个空行，最后是详细的描述。这样，就便于有些软件将开始的简短行作为email的题目，后面的详细描述作为email的信息内容，完成自动化转换。另外，如果修改了一个文件然后没有git add，那么可以用git diff查看修改的内容，而git status无法看到修改的内容；当git add这个文件之后，用git diff就看不到这个内容了，用git status就可以看到。例如：  lv-k@quietheart:~/temp/temp/git_t$ echo hello5 &gt;&gt;hellolv-k@quietheart:~/temp/temp/git_t$ git diffdiff --git a/hello b/helloindex 0863c71..bba0e39 100644--- a/hello+++ b/hello@@ -3,3 +3,4 @@ hello1hello2hello3hello4+hello5    &lt;===这里说明在&quot;git add hello&quot;之前，对hello文件进行了修改。lv-k@quietheart:~/temp/temp/git_t$ git status# On branch master# Changes not staged for commit:   &lt;===这里说明修改没有被添加（stage）,并且提示用&quot;git add&quot;。#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)##       modified:   hello    &lt;===这里说明修改了hello文件#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)    &lt;===说明不会提交修改，可用&quot;git add&quot;或者&quot;git commit -a&quot;来提交修改。lv-k@quietheart:~/temp/temp/git_t$ git add hellolv-k@quietheart:~/temp/temp/git_t$ git diff    &lt;===添加之后，没有任何输出。lv-k@quietheart:~/temp/temp/git_t$ git status# On branch master# Changes to be committed: &lt;===提示将会提交修改的内容，并且提示用&quot;git reset&quot;来取消stage。#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##       modified:   hello#lv-k@quietheart:~/temp/temp/git_t$ echo hello6 &gt;&gt;hello    &lt;===提交之前又修改了lv-k@quietheart:~/temp/temp/git_t$ git diffdiff --git a/hello b/helloindex bba0e39..34e8bc5 100644--- a/hello+++ b/hello@@ -4,3 +4,4 @@ hello2hello3hello4hello5+hello6       &lt;===显示最新没有add的修改lv-k@quietheart:~/temp/temp/git_t$ git status# On branch master# Changes to be committed: &lt;===显示提交时会提交一部分修改#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##       modified:   hello## Changes not staged for commit:   &lt;===显示提交时也会有一部分修改不会提交上去。#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)##       modified:   hello#lv-k@quietheart:~/temp/temp/git_t$ git add hellolv-k@quietheart:~/temp/temp/git_t$ git difflv-k@quietheart:~/temp/temp/git_t$ git status# On branch master# Changes to be committed:#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##       modified:   hello#lv-k@quietheart:~/temp/temp/git_t$ git reset hello    &lt;===撤消&quot;git add&quot;的动作Unstaged changes after reset:M       hellolv-k@quietheart:~/temp/temp/git_t$ git diffdiff --git a/hello b/helloindex 0863c71..34e8bc5 100644--- a/hello+++ b/hello@@ -3,3 +3,5 @@ hello1hello2hello3hello4+hello5+hello6lv-k@quietheart:~/temp/temp/git_t$ git status# On branch master# Changes not staged for commit:#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)##       modified:   hello#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)lv-k@quietheart:~/temp/temp/git_t$ git add hello   &lt;===再次&quot;git add&quot;lv-k@quietheart:~/temp/temp/git_t$ git difflv-k@quietheart:~/temp/temp/git_t$ git status# On branch master# Changes to be committed:#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)##       modified:   hello#对于以上内容中出现的命令，我们可以在后续的学习中看到。2、pull、push和fetchgit中的pull子命令做两个工作：从远处库的分支fetch相应的修改，然后将修改合并到当前分支。如果发生冲突，那么也会进行fetch但是会拒绝对冲突的文件进行合并（这时需要解决冲突然后再次pull???）。git-fetch用于从另一个reposoitory下载objects和refs，但是并不提交到本地库。其中表示远端的仓库路径。其中的标准格式应该为:，表示源的分支，如果不为空，则表示本地的分支；如果为空，则使用当前分支。而push和pull相反，是向远端发送本地提交的修改，当然需要让远端设置成可以接受本地提交的修改。具体参见后面的实践。3、常用常量和范围表示有一些常用常量可以表示特定的版本，它们是：  HEAD：表示最近一次的commit。MERGE_HEAD：如果是merge产生的commit，那么它表示除HEAD之外的另一个父母分支。FETCH_HEAD：使用git-fetch获得的object和ref的信息都存储在这里，这些信息是为日后git-merge准备的。HEAD：表示HEAD父母的信息HEAD：表示HEAD父母的父母的信息HEAD~4：表示HEAD上溯四代的信息HEAD1：表示HEAD的第一个父母的信息（和HEAD相同）HEAD2：表示HEAD的第二个父母的信息COMMIT_EDITMSG：最后一次commit时的提交信息。  当我们表示两个特定版本之间的内容的时候，一般有如下表示：使用&quot;..&quot;表示两个提交版本之间的内容例如：  $ git log v2.5..v2.6表示查看v2.5到v2.6之间的log信息；再如：  HEAD..FETCH_HEAD表示显示抓取的开始之后的信息不显示HEAD开始之后的信息(也就是显示的时候不显示自HEAD以来本地库的信息，而是只显示远端的信息)；还有:   $ git log v2.5..表示自v2.5之后提交的内容。  使用&quot;...&quot;表示包含更多的范围：例如HEAD...FETCH_HEAD，可以用来查看两者都修改了什么，是两者分别修改的而不是同时修改的。二、常用命令这里给出常用的基本命令。获取git的子命令的帮助信息的方式：  $man git-log$git help log这里，子命令用git log或git log --graph之类的log子命令进行举例。为git添加自己的名字以及邮箱信息：  $ git config --global user.name &quot;Your Name Comes Here&quot;$ git config --global user.email you@yourdomain.example.com另外，通过当前目录的.git/config，来查看类似svn info输出的url相关的信息等等。将一个目录添加到git控制中过程如下：初始化目录：  $ tar xzf project.tar.gz$ cd project$ git init将当前目录下所有文件的快照(snap)加入git  $ git add .`  这样会告诉git将当前目录下所有的修改的文件，以及以前不在git下面的文件等的当前状态，添加到git的一个临时&quot;stage area&quot;中(但是还没有被保存下来)，git称它为索引(index)。将索引(index)的内容保存到git库中：  `$git commit`  这样会提示你输入日志信息，之后就将当前的目录所有最新内容存放到git中管理了。另外需要注意的是，commit有一个--amend选项，可以给修改版本的信息，例如注释信息，具体参见man手册。修改文件并提交  将新增或者修改等变化的文件添加到git的索引(index)中：  $ git add file1 file2 file3这里，添加之后，后面的commit命令将会把此次添加的内容都提交上去(由此可见git的&quot;add&quot;添加的不仅仅是文件，它是以内容为单位的，添加的是当前的修改)。提交之前，查看修改状态：$git diff --cached或者$git status这里，diff如果没有--cached选项，信息更多（有则只显示没有add的内容），status显示的使概要的简洁信息。  提交修改：$ git commit这样，会提示你输入日志信息，然后更新git库的版本。其实，每次提交修改文件之前都要用add将修改的内容添加进去，然后才能commit，如果合并两步，可以这样：$git commit -a这样会自动将修改的文件（不包含新增的文件）添加到索引，并且提交。  注意提交时候的日志信息，最好用一个简单行开始，然后一个空行，因为许多工具将其日志第一行自动转换作为邮件标题，剩下内容作为邮件内容。查看历史信息  $git log或者  $git log -p或者  $git log --stat --summary这里，-p 查看完整历史消息并且重定向到 less 之类的pager程序查看，--stat --summary也会重定向到pager但是信息比较简要，而只有 git log 则更简要并且不会将输出重定向到pager程序中。另外，使用git log --graph可以用文本图形的方式显示版本之间的关系。分支管理  创建分支：  $ git branch experimental查看分支：  $ git branch这样，会列出所有分支，并且当前分支前面用&#39;*&#39;标识出来。  切换分支：$ git checkout experimental这样，会切换到experimental分支，默认分支是&#39;master&#39;分支，它是被自动创建的。  合并分支：  $ git merge experimental这里，如果正常则合并成功，如果冲突，那么冲突文件中会有冲突标记。合并之后可以提交。使用diff可以查看冲突。  删除分支：  $ git branch -d experimental这里分支要确保被合并到上层才行，如果不考虑合并状态，那么使用-D代替-d。  使用git合作开发假设用户A有一个git库，地址为：/home/alice/project；B和A同为一台机器，其用户主目录为/home/bob。B在A库的基础上面工作：bob$ git clone /home/alice/project myrepo(edit files)bob$ git commit -a(repeat as necessary)这里，首先B从A拷贝一份库到本地，然后在本地进行修改，并且提交，这个时候，提交的内容都是提交到B自己的库中。A合并B的修改：alice$ cd /home/alice/projectalice$ git pull /home/bob/myrepo master这里，当A想要合并B的内容的时候，可以通过pull实现；如果A已经在本地有过一些修改，那么可能会出现并处理一些合并的冲突问题。其实，pull=fetch+merge，就是先获取远端修改的内容，然后合并到本地。只查看B的修改，但是不合并：alice$ git fetch /home/bob/myrepo masteralice$ git log -p HEAD..FETCH_HEAD这里，fetch只是将修改信息抓取下来，并不进行合并，这样就能够在合并之前看到远端（抓取端）进行了哪些修改HEAD是最新的一次commit，FETCH_HEAD使抓取端的信息。HEAD..FETCH_HEAD表示显示抓取的开始之后的信息不显示HEAD开始之后的信息(也就是显示的时候不显示自HEAD以来本地库的信息，而是只显示远端的信息).而用HEAD...FETCH_HEAD可以用来查看两者都修改了什么，是两者分别修改的而不是同时修改的。A设置fetch时使用的B的远端位置的简写：alice$ git remote add bob /home/bob/myrepo如果A经常和B进行交互，那么可以使用remote命令，这样以后A便可以通过这个简写来获取B的修改而不用输入完整名称了。A使用remote设置的B的简写来获取B的修改并合并：alice$ git fetch bobalice$ git merge bob/master这里，也可以用如下命令来完成合并：  alice$ git pull . remotes/bob/masterB获取A最新修改的内容：bob$ git pull这里，B不需要给出A的库的位置，因为B是来自A的一个拷贝，A的位置信息在拷贝的时候被记录到库的配置中了，这个位置信息在B使用没有参数的pull的时候会被自动地应用。使用如下命令可以查看B的配置中的这个url信息：bob$ git config --get remote.origin.url/home/alice/project查看B来自A的原始master拷贝：bob$ git branch -rorigin/master拷贝B的时候，git会自动将一份原始的A的master分支拷贝到&quot;origin/master&quot;中，用这个命令可以看到。与A在不同主机上的B拷贝A的库到本地：  bob$ git clone alice.org:/home/alice/project myrepo这里，可以使用特定的本地协议例如“rsync”或者“http”，可以查看git-pull的信息来获取更多帮助。另外，查看git-push(1)和gitcvs-migration(7)，可以知道git还可以设置成像cvs那样集中控制版本的模式。由上面的过程我们可以知道，git版本控制工具中分布式管理的含义。与svn不同的是，在svn中，只能有一个svn服务器集中存放版本控制库，其他的客户端全部都是这个版本库的工作拷贝，提交的时候全部都提交到这个集中的svn库中或者库的某个分支中。git分步式管理的意思就是可以将一个由git创建的版本控制库拷贝到另外的地方，所有这个git库的拷贝都可以各自作为一个“版本控制中心”，管理自己工作拷贝以及本地分支的提交，同时这些库之间还可以相互合并其修改到另外的库的特定分支中。指定版本操作这里将git中的版本号假设为特定的commit的id。查看所有历史信息：  $git log这样会显示所有的历史信息，包括commit的id，使用git log --graph会以文本图形的方式直观地显示出每个历史版本之间的合并关系等。其实，我们可以将历史看成一系列的commit。查看特定id的历史信息：  $git show c82a22c39cbc32576f64f5c6b3f24b99ea8149c7或$git show c82a22c39c这样，我们可以看到指定commit的id为&quot;c82a22c39cbc32576f64f5c6b3f24b99ea8149c7&quot;的历史信息。这里，只要能够保证前缀唯一，也可指定部分id的前缀作为相应历史的标识。查看当前分支当前的历史状态：  $git show HEAD这里，HEAD表示当前分支最新版本。关于查看时候指定的类似&quot;HEAD&quot;的常量大致如下：HEAD：表示最近一次的commit。MERGE_HEAD：如果是merge产生的commit，那么它表示除HEAD之外的另一个父母分支。FETCH_HEAD：使用git-fetch获得的object和ref的信息都存储在这里，这些信息是为日后git-merge准备的。HEAD：表示HEAD父母的信息HEAD：表示HEAD父母的父母的信息HEAD~4：表示HEAD上溯四代的信息HEAD1：表示HEAD的第一个父母的信息（和HEAD相同）HEAD2：表示HEAD的第二个父母的信息COMMIT_EDITMSG：最后一次commit时的提交信息。自定义commit的id名称：  $ git tag v2.5 1b2e1d63ff这样定义之后，就可以使用v2.5这样比较容易理解的方式来引用&quot;1b2e1d63ff&quot;这种看起来没有意义的字符串，如果想要和别人共享这个定义的名称，需要创建一个tag对象，并且给它&quot;sign&quot;，具体参见git help tag。比较两个不同的版本：  $git diff HEAD bc32576f64f5c6b3f24b99ea8149c7这里，比较&quot;HEAD&quot;和&quot;bc32576f64f5c6b3f24b99ea8149c7&quot;之间的区别，也可以使用自己定义的名称。回退到指定版本，清除该版本之后所有的信息：  $ git reset --hard HEAD这样将会把当前工作分支的内容回退到HEAD^版本。注意，这个命令不仅会把当前的修改给移除，而且还会把自HEAD^以后的所有commit给删除（HEAD^版本本身保留为当前的HEAD），如果当前的分支是唯一的分支的话，那么运行这个命令之后，之前HEAD^以后的修改将会完全丢失（当然可以通过pull再将之前的HEAD拉取回来，但是自己没有提交的本地修改是无法找回来的了）；另外如果在一个公共的分支上面执行这个命令将会导致其他开发者pull的时候都进行一遍这个清除的工作，如果不加--hard选项，那么可能当前HEAD基础上有修改的情况导致这个命令不会成功。回退到指定版本，并作为新版本提交上去（保留该版本之后所有的信息）：  $ git revert HEAD^这样只会把内容回退为HEAD^之前的版本（即HEAD^^），再将这样的内容做为新的HEAD提交上去，原来的HEAD变成HEAD^（即在库中保留HEAD^之后的版本的提交，而不像reset那样完全清除）。这里，运行之后，会打开一个编辑窗口让你编辑提交的log信息，退出就直接提交了，或者revert命令也有不编辑提交log信息的选项。使用checkout的“回退”：  $ git checkout v2.5这样，会将当前v2.5版本重新检出，效果是使用v2.5做为当前的HEAD了，但是，原来的HEAD对应的commit id还存在于库中，可以使用那个id用checkout重新检回。另外，如果检出v2.5之后做了修改并且提交到库中，那么会以v2.5为基础重新生成一个版本，并且提交上去，这时候可以再用原来那个HEAD检查出，但是就“隐藏”了这个v2.5之后提交的新HEAD相关的一系列修改版本，这时候一般git会提醒你为此次提交创建一个新分支，并且会给出提示命令。实践发现，如果修改了没有提交，那么checkout会有问题，就是修改的内容并到了checkout的版本中，具体需要实践。从指定版本搜索某个字符串：  $ git grep &quot;hello&quot; v2.5这样将会从&quot;v2.5&quot;这个自定义的commit名字的版本中的所有文件搜索&quot;hello&quot;字符串。如果没有指定&quot;v2.5&quot;类似的commit的号码的话，将会从当前路径搜索这个&quot;hello&quot;字符串。介于v2.5和v2.6之间的commit信息：  $ git log v2.5..v2.6介于v2.5之后的commit信息：  $ git log v2.5..两周以前的commit信息：  $ git log --since=&quot;2 weeks ago&quot; # commits from the last 2 weeks自Makefile修改之后的commit信息：  $ git log v2.5.. Makefile       # commits since v2.5 which modify两个没有前后关系的commit之间的信息：  $git log v2.5 s2.5这里，v2.5和s2.5是两个没有直系关系的版本，这样会只显示关于s2.5的提交信息。指定某个版本的文件并进行操作：  $ git diff v2.5:Makefile HEAD:Makefile.in或  $ git show v2.5:Makefile这里，我们运行操作文件的命令的时候，可以给文件名称添加一个commit的ID，以标识对那个版本的文件进行操作。三、具体实践下面用一个具体的实践展示使用git的简单过程。若有更多内容，再做更新。  简单命令查看帮助：  $ git具体如下：lv-k@quietheart:~/temp/git_test$ gitusage: git [--version] [--exec-path[=&lt;path&gt;]] [--html-path]           [-p|--paginate|--no-pager] [--no-replace-objects]           [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;]           [-c name=value] [--help]           &lt;command&gt; [&lt;args&gt;]The most commonly used git commands are:   add        Add file contents to the index   bisect     Find by binary search the change that introduced a bug   branch     List, create, or delete branches   checkout   Checkout a branch or paths to the working tree   clone      Clone a repository into a new directory   commit     Record changes to the repository   diff       Show changes between commits, commit and working tree, etc   fetch      Download objects and refs from another repository   grep       Print lines matching a pattern   init       Create an empty git repository or reinitialize an existing one   log        Show commit logs   merge      Join two or more development histories together   mv         Move or rename a file, a directory, or a symlink   pull       Fetch from and merge with another repository or a local branch   push       Update remote refs along with associated objects   rebase     Forward-port local commits to the updated upstream head   reset      Reset current HEAD to the specified state   rm         Remove files from the working tree and from the index   show       Show various types of objects   status     Show the working tree status   tag        Create, list, delete or verify a tag object signed with GPGSee &#39;git help &lt;command&gt;&#39; for more information on a specific command.这里，通过这个命令我们可以看见git最常用的一些命令。关于分支  查看当前分支：  $ git branch具体如下：lv-k@quietheart:~/temp/git_test$ git branch*master这里，可知当前处于主分支&quot;master&quot;，当前分支用&#39;*&#39;和高亮标记出来。创建分支：  $ git branch quietheart具体如下：  lv-k@quietheart:~/temp/git_test$ git branch quietheartlv-k@quietheart:~/temp/git_test$ git branch*masterquietheart这里，创建了一个&#39;quietheart&#39;分支，但是创建之后并没有切换过去。切换分支：  $ git checkout quietheart具体如下：lv-k@quietheart:~/temp/git_test$ git checkout quietheartSwitched to branch &#39;quietheart&#39;lv-k@quietheart:~/temp/git_test$ git branchmaster*quietheart这里，使用&#39;checkout&#39;命令切换到了指定的分支。分别在分支中进行修改：lv-k@quietheart:~/temp/git_test$ git checkout masterlv-k@quietheart:~/temp/git_test$ echo &#39;change in master&#39; &gt;&gt;hellolv-k@quietheart:~/temp/git_test$ git commit -m &#39;change in master&#39; -alv-k@quietheart:~/temp/git_test$ git checkout quietheartlv-k@quietheart:~/temp/git_test$ echo &#39;changed in quietheart&#39; &gt;&gt;example lv-k@quietheart:~/temp/git_test$ git commit -m &#39;change in quietheart&#39; -a具体如下：lv-k@quietheart:~/temp/git_test$ git checkout masterSwitched to branch &#39;master&#39;lv-k@quietheart:~/temp/git_test$ git branch*masterquietheartlv-k@quietheart:~/temp/git_test$ lsexample  hello  mydirlv-k@quietheart:~/temp/git_test$ echo &#39;change in master&#39; &gt;&gt;hellolv-k@quietheart:~/temp/git_test$ git diffdiff --git a/hello b/helloindex 1b11f8b..60cacc0 100644--- a/hello+++ b/hello@@ -1,3 +1,4 @@hello worldhello worldhello world+change in masterlv-k@quietheart:~/temp/git_test$ git commit -m &#39;change in master&#39; -ifatal: No paths with --include/--only does not make sense.lv-k@quietheart:~/temp/git_test$ git commit -m &#39;change in master&#39; -a[master d8f32e0] change in masterCommitter: lv-k &lt;lv-k@quietheart.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:  git config --global user.name &quot;Your Name&quot;  git config --global user.email you@example.comAfter doing this, you may fix the identity used for this commit with:  git commit --amend --reset-author1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test$ git difflv-k@quietheart:~/temp/git_test$ git logcommit d8f32e0e0b16e6dc499d5295a8a13ec3938664f8Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:54:10 2012 +0800  change in mastercommit fa4abf6455aa01cf7d74810b96e2279983287fc8Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:41:51 2012 +0800  add modify2commit 07ee8b68e90a470aec9a5194079e54332093fc70Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:29:00 2012 +0800  add modifycommit 098e14c671f8cef3507a8b43fba7b386892ed5bcAuthor: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 16:59:04 2012 +0800  initial commit contents这里，在执行本例子之前提交过一次，而那次提交没有在本文档记录所以所以多了一条记录&#39;add modify2&#39;。lv-k@quietheart:~/temp/git_test$ git checkout quietheartSwitched to branch &#39;quietheart&#39;lv-k@quietheart:~/temp/git_test$ git logcommit fa4abf6455aa01cf7d74810b96e2279983287fc8Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:41:51 2012 +0800  add modify2commit 07ee8b68e90a470aec9a5194079e54332093fc70Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:29:00 2012 +0800  add modifycommit 098e14c671f8cef3507a8b43fba7b386892ed5bcAuthor: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 16:59:04 2012 +0800  initial commit contentslv-k@quietheart:~/temp/git_test$ echo &#39;changed in quietheart&#39; &gt;&gt;example lv-k@quietheart:~/temp/git_test$ git diffdiff --git a/example b/exampleindex 6e93434..0706323 100644--- a/example+++ b/example@@ -1 +1,2 @@my example+changed in quietheartlv-k@quietheart:~/temp/git_test$ git commit -m &#39;change in quietheart&#39; -a[quietheart 8a95074] change in quietheartCommitter: lv-k &lt;lv-k@quietheart.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:  git config --global user.name &quot;Your Name&quot;  git config --global user.email you@example.comAfter doing this, you may fix the identity used for this commit with:  git commit --amend --reset-author1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test$ git logcommit 8a95074a30e32a4df3cdf50648fce2d6a0a73a97Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 18:00:10 2012 +0800  change in quietheartcommit fa4abf6455aa01cf7d74810b96e2279983287fc8Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:41:51 2012 +0800  add modify2commit 07ee8b68e90a470aec9a5194079e54332093fc70Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:29:00 2012 +0800  add modifycommit 098e14c671f8cef3507a8b43fba7b386892ed5bcAuthor: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 16:59:04 2012 +0800  initial commit contents合并某分支到当前分支最新：$ git checkout master$ git merge quietheart具体过程如下：lv-k@quietheart:~/temp/git_test$ git branchmaster*quietheartlv-k@quietheart:~/temp/git_test$ git checkout masterSwitched to branch &#39;master&#39;lv-k@quietheart:~/temp/git_test$ git branch*masterquietheartlv-k@quietheart:~/temp/git_test$ git merge quietheartMerge made by recursive.example |    1 +1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test$ git difflv-k@quietheart:~/temp/git_test$ git logcommit 83548b1a87668a5dbd606c6bcefdc984970ffb40Merge: d8f32e0 8a95074Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 18:09:51 2012 +0800  Merge branch &#39;quietheart&#39;commit 8a95074a30e32a4df3cdf50648fce2d6a0a73a97Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 18:00:10 2012 +0800  change in quietheartcommit d8f32e0e0b16e6dc499d5295a8a13ec3938664f8Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:54:10 2012 +0800  change in mastercommit fa4abf6455aa01cf7d74810b96e2279983287fc8Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:41:51 2012 +0800  add modify2commit 07ee8b68e90a470aec9a5194079e54332093fc70Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 17:29:00 2012 +0800  add modifycommit 098e14c671f8cef3507a8b43fba7b386892ed5bcAuthor: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 16:59:04 2012 +0800  initial commit contents这样，就将刚才在quietheart分支上面的从master继承过来之后的所有修改合并到了master主分支上面来了，同时提交分支quietheart时候的日志信息也合并进来了。使用clone、pull、push实践多人合作拷贝两份远端库到本地：  $ git clone /home/lv-k/temp/git_test git_test_clone具体如下：lv-k@quietheart:~/temp$ git clone /home/lv-k/temp/git_test git_test_cloneCloning into git_test_clone...done.lv-k@quietheart:~/temp$ git clone /home/lv-k/temp/git_test_clone/ /home/lv-k/temp/git_test_clone1Cloning into /home/lv-k/temp/git_test_clone1...done.这里，其实拷贝的是当前库所在的分支，通过git branch查看可知，得到的git_test_clone其实只有master分支，因为拷贝的时候，git_test库所在的当前分支是master。在一个拷贝上面修改并提交：$ cd git_test_clone1/$ echo &quot;hello after clone&quot; &gt;&gt;hello$ git commit -a -m &#39;commin in clone&#39;具体如下：lv-k@quietheart:~/temp$ cd git_test_clone1/lv-k@quietheart:~/temp/git_test_clone1$ echo &quot;hello after clone&quot; &gt;&gt;hellolv-k@quietheart:~/temp/git_test_clone1$ git commit -a -m &#39;commin in clone&#39;[master bf44b20] commin in clone Committer: lv-k &lt;lv-k@quietheart.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:    git config --global user.name &quot;Your Name&quot;    git config --global user.email you@example.comAfter doing this, you may fix the identity used for this commit with:    git commit --amend --reset-author 1 files changed, 1 insertions(+), 0 deletions(-)这里，修改之后，本地库便和远端的原始库发生了变化。将远端拷贝修改的内容拉取过来：$ cd git_test_clone/$ git pull /home/lv-k/temp/git_test_clone1/具体如下：lv-k@quietheart:~/temp$ cd git_test_clone/lv-k@quietheart:~/temp/git_test_clone$ git pull /home/lv-k/temp/git_test_clone1/remote: Counting objects: 5, done.remote: Compressing objects: 100% (3/3), done.remote: Total 3 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.From /home/lv-k/temp/git_test_clone1 *branch            HEAD       -&gt; FETCH_HEADUpdating 83548b1..bf44b20Fast-forward hello |    1 + 1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test_clone$ cat hellohello worldhello worldhello worldchange in masterhello after clonelv-k@quietheart:~/temp/git_test_clone$ git log |head -n 10commit bf44b2085fe716b1fdb4c04b0dabbca60c451f39Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Wed Jun 13 16:28:32 2012 +0800    commin in clonecommit 83548b1a87668a5dbd606c6bcefdc984970ffb40Merge: d8f32e0 8a95074Author: lv-k &lt;lv-k@quietheart.(none)&gt;Date:   Thu Feb 9 18:09:51 2012 +0800从这里我们可以看到，拉取过来的内容被自动地提交上去了，其实拉取内容的时候应该指明是哪个分支。实际如果没有参数则从clone时候的来源来pull，这里可以通过.git/config中查看来源。将本地库拷贝的修改推送到远程库中：$ cd git_test_clone1/$ echo &quot;test push&quot; &gt;&gt;hello$ cd ../git_test_clone1/$ vim .git/config###编辑内容，添加如下###[receive]    denyCurrentBranch = ignore###编辑内容，添加如上###$ cd ../git_test_clone1$ git push /home/lv-k/temp/git_test_clone具体如下：lv-k@quietheart:~/temp$ cd git_test_clone1/lv-k@quietheart:~/temp/git_test_clone1$ echo &quot;test push&quot; &gt;&gt;hellolv-k@quietheart:~/temp/git_test_clone1$ git push /home/lv-k/temp/git_test_cloneEverything up-to-datelv-k@quietheart:~/temp/git_test_clone1$ cat /home/lv-k/temp/git_test_clonecat: /home/lv-k/temp/git_test_clone: Is a directorylv-k@quietheart:~/temp/git_test_clone1$ cat /home/lv-k/temp/git_test_clone/hellohello worldhello worldhello worldchange in masterhello after clonelv-k@quietheart:~/temp/git_test_clone1$ git commit -a -m &#39;to be pushed&#39;[master c478225] to be pushed Committer: lv-k &lt;lv-k@quietheart.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:    git config --global user.name &quot;Your Name&quot;    git config --global user.email you@example.comAfter doing this, you may fix the identity used for this commit with:    git commit --amend --reset-author 1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test_clone1$ git status# On branch master# Your branch is ahead of &#39;origin/master&#39; by 2 commits.#nothing to commit (working directory clean)lv-k@quietheart:~/temp/git_test_clone1$ git pullFrom /home/lv-k/temp/git_test_clone   83548b1..bf44b20  master     -&gt; origin/masterAlready up-to-date.lv-k@quietheart:~/temp/git_test_clone1$ git status# On branch master# Your branch is ahead of &#39;origin/master&#39; by 1 commit.#nothing to commit (working directory clean)lv-k@quietheart:~/temp/git_test_clone1$ git pushCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 339 bytes, done.Total 3 (delta 1), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.remote: error: refusing to update checked out branch: refs/heads/masterremote: error: By default, updating the current branch in a non-bare repositoryremote: error: is denied, because it will make the index and work tree inconsistentremote: error: with what you pushed, and will require &#39;git reset --hard&#39; to matchremote: error: the work tree to HEAD.remote: error: remote: error: You can set &#39;receive.denyCurrentBranch&#39; configuration variable toremote: error: &#39;ignore&#39; or &#39;warn&#39; in the remote repository to allow pushing intoremote: error: its current branch; however, this is not recommended unless youremote: error: arranged to update its work tree to match what you pushed in someremote: error: other way.remote: error: remote: error: To squelch this message and still keep the default behaviour, setremote: error: &#39;receive.denyCurrentBranch&#39; configuration variable to &#39;refuse&#39;.To /home/lv-k/temp/git_test_clone/ ! [remote rejected] master -&gt; master (branch is currently checked out)error: failed to push some refs to &#39;/home/lv-k/temp/git_test_clone/&#39;lv-k@quietheart:~/temp$ cd ../git_test_clone/lv-k@quietheart:~/temp/git_test_clone$ git config --bool core.bare truelv-k@quietheart:~/temp$ cd ../git_test_clone1/lv-k@quietheart:~/temp/git_test_clone1$ git pushCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 339 bytes, done.Total 3 (delta 1), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.To /home/lv-k/temp/git_test_clone/   bf44b20..c478225  master -&gt; masterlv-k@quietheart:~/temp/git_test_clone1$ cat ../git_test_clone/hellohello worldhello worldhello worldchange in masterhello after clonelv-k@quietheart:~/temp$ cd git_test_clone/lv-k@quietheart:~/temp/git_test_clone$ git reset --hardfatal: This operation must be run in a work treelv-k@quietheart:~/temp/git_test_clone$ git  config --bool core.bare falselv-k@quietheart:~/temp/git_test_clone$ git reset --hardHEAD is now at c478225 to be pushedlv-k@quietheart:~/temp/git_test_clone$ cat hello hello worldhello worldhello worldchange in masterhello after clonetest pushlv-k@quietheart:~/temp/git_test_clone$ vim .git/config添加如下：[receive]    denyCurrentBranch = ignorelv-k@quietheart:~/temp$ cd git_test_clone1lv-k@quietheart:~/temp/git_test_clone1$ echo &quot;push2&quot; &gt;&gt;hellolv-k@quietheart:~/temp/git_test_clone1$ git commit -a -m &#39;push2&#39;[master 8b45c2f] push2 Committer: lv-k &lt;lv-k@quietheart.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:    git config --global user.name &quot;Your Name&quot;    git config --global user.email you@example.comAfter doing this, you may fix the identity used for this commit with:    git commit --amend --reset-author   1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test_clone1$ git pushCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 332 bytes, done.Total 3 (delta 1), reused 0 (delta 0)  Unpacking objects: 100% (3/3), done.   To /home/lv-k/temp/git_test_clone/   c478225..8b45c2f  master -&gt; master  lv-k@quietheart:~/temp$ cd git_test_clonelv-k@quietheart:~/temp/git_test_clone$ lsexample  hello  mydirlv-k@quietheart:~/temp/git_test_clone$ cat hello hello worldhello worldhello worldchange in masterhello after clonetest pushlv-k@quietheart:~/temp/git_test_clone$ git reset --hardHEAD is now at 8b45c2f push2lv-k@quietheart:~/temp/git_test_clone$ cat hello hello worldhello worldhello worldchange in masterhello after clonetest pushpush2这里我们可见，本地修改之后，直接使用git push无法提交，还需要远端用git config --bool core.bare true配置好之后，才能push，push之后，如果远端也在同样分支上面，并不能立即反应，需要将core.bare设置为&quot;false&quot;然后再git reset --hard。根据网上查询的资料，push无法进行有如下解决方法：方法1：    git config --bool core.bare true方法2：修改.git/config添加如下代码：[receive]    denyCurrentBranch = ignore我们使用第1个方法，比较麻烦，使用第二个方法，就不用再从服务端重新设置&quot;core.bare&quot;了。另外，参考资料还提到，最好用git -bare init初始化库，而不是git init，本例子因为使用git init初始化，所以这样。待整理版本回退的实践：这里分别对reset,revert,checkout三种方式进行一下实践具体过程如下：lv-k@quietheart:~/temp$ git clone git_test git_test_clone2Cloning into git_test_clone2...done.lv-k@quietheart:~/temp$ cd git_test_clone2/lv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit 8a95074a30e32a4df3cdf50648fce2d6a0a73a97| Author: lv-k &lt;lv-k@quietheart.(none)&gt; | Date:   Thu Feb 9 18:00:10 2012 +0800 | |     change in quietheart|  *commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|  *commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:29:00 2012 +0800| |     add modify|  *commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;  Date:   Thu Feb 9 16:59:04 2012 +0800   initial commit contentslv-k@quietheart:~/temp/git_test_clone2$ git reset --hard fa4abf6455aa01cf7d74810b96e2279983287fc8HEAD is now at fa4abf6 add modify2lv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|*commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt; | Date:   Thu Feb 9 17:29:00 2012 +0800 ||     add modify|*commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;   Date:   Thu Feb 9 16:59:04 2012 +0800      initial commit contentslv-k@quietheart:~/temp/git_test_clone2$ git pullUpdating fa4abf6..8a95074Fast-forward example |    1 + 1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit 8a95074a30e32a4df3cdf50648fce2d6a0a73a97| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 18:00:10 2012 +0800| |     change in quietheart|  *commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|  *commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:29:00 2012 +0800| |     add modify|  *commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;  Date:   Thu Feb 9 16:59:04 2012 +0800     initial commit contentslv-k@quietheart:~/temp/git_test_clone2$ git revert fa4abf6455aa01cf7d74810b96e2279983287fc8...自动打开编辑器，编辑log，退出编辑器（不用保存）...[quietheart d707529] Revert &quot;add modify2&quot; Committer: lv-k &lt;lv-k@quietheart.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:    git config --global user.name &quot;Your Name&quot;    git config --global user.email you@example.comAfter doing this, you may fix the identity used for this commit with:   git commit --amend --reset-author 1 files changed, 0 insertions(+), 1 deletions(-)lv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit d707529ef6ed1b2bca493d22d367e56751ae3f3d| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Jun 14 16:24:51 2012 +0800| |     Revert &quot;add modify2&quot;|     |     This reverts commit fa4abf6455aa01cf7d74810b96e2279983287fc8.|  *commit 8a95074a30e32a4df3cdf50648fce2d6a0a73a97| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 18:00:10 2012 +0800| |     change in quietheart|  *commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|  *commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:29:00 2012 +0800| |     add modify|  *commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;  Date:   Thu Feb 9 16:59:04 2012 +0800   initial commit contentslv-k@quietheart:~/temp/git_test_clone2$ git diff d707529ef6ed1b2bca493d22d367e56751ae3f3d:hello 07ee8b68e90a470aec9a5194079e54332093fc70:hellolv-k@quietheart:~/temp/git_test_clone2$ git reset --hard fa4abf6455aa01cf7d74810b96e2279983287fc8HEAD is now at fa4abf6 add modify2lv-k@quietheart:~/temp/git_test_clone2$ git pullUpdating fa4abf6..8a95074Fast-forward example |    1 + 1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit 8a95074a30e32a4df3cdf50648fce2d6a0a73a97| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 18:00:10 2012 +0800| |     change in quietheart|  *commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|  *commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:29:00 2012 +0800| |     add modify|  *commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;  Date:   Thu Feb 9 16:59:04 2012 +0800   initial commit contentslv-k@quietheart:~/temp/git_test_clone2$ git checkout fa4abf6455aa01cf7d74810b96e2279983287fc8Note: checking out &#39;fa4abf6455aa01cf7d74810b96e2279983287fc8&#39;.You are in &#39;detached HEAD&#39; state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example:  git checkout -b new_branch_nameHEAD is now at fa4abf6... add modify2lv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|  *commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:29:00 2012 +0800| |     add modify|  *commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;  Date:   Thu Feb 9 16:59:04 2012 +0800   initial commit contentslv-k@quietheart:~/temp/git_test_clone2$ git commit -a -m &#39;add&#39;[detached HEAD 9bd6059] add Committer: lv-k &lt;lv-k@quietheart.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:   git config --global user.name &quot;Your Name&quot;   git config --global user.email you@example.comAfter doing this, you may fix the identity used for this commit with:   git commit --amend --reset-author 1 files changed, 1 insertions(+), 0 deletions(-)lv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit 9bd605958283f6b33264af3ec6c9a0faa07feb55| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Jun 14 16:28:51 2012 +0800| |     add|  *commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|  *commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:29:00 2012 +0800| |     add modify|  *commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;  Date:   Thu Feb 9 16:59:04 2012 +0800      initial commit contentslv-k@quietheart:~/temp/git_test_clone2$ git checkout 8a95074a30e32a4df3cdf50648fce2d6a0a73a97Warning: you are leaving 1 commit behind, not connected toany of your branches:  9bd6059 addIf you want to keep it by creating a new branch, this may be a good timeto do so with: git branch new_branch_name 9bd605958283f6b33264af3ec6c9a0faa07feb55HEAD is now at 8a95074... change in quietheartlv-k@quietheart:~/temp/git_test_clone2$ git log --graph*commit 8a95074a30e32a4df3cdf50648fce2d6a0a73a97| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 18:00:10 2012 +0800| |     change in quietheart|  *commit fa4abf6455aa01cf7d74810b96e2279983287fc8| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:41:51 2012 +0800| |     add modify2|  *commit 07ee8b68e90a470aec9a5194079e54332093fc70| Author: lv-k &lt;lv-k@quietheart.(none)&gt;| Date:   Thu Feb 9 17:29:00 2012 +0800| |     add modify|  *commit 098e14c671f8cef3507a8b43fba7b386892ed5bc  Author: lv-k &lt;lv-k@quietheart.(none)&gt;  Date:   Thu Feb 9 16:59:04 2012 +0800   initial commit contents这里，根据前面的运行可知，reset可以将包括注释以及以前的提交全部清除，实现根本的回退；revert只是将指定版本的内容做为新的HEAD重新提交（类似打反向补丁），并且不会清除已有原来的提交；checkout是检出一个版本，已有的版本信息仍然保存在库中，但是在检出的旧版本上提交会导致新的分支。没有解决的问题：使用git checkout &lt;commit id&gt;可以提取以前的版本，并且也可以回到以前之后的版本，但是如何回到以前的版本之后，知道以后有什么版本？参考资料本文实践的库http://www.cnblogs.com/abeen/archive/2010/06/17/1759496.htmlhttp://stackoverflow.com/questions/2816369/git-push-error-remote-rejected-master-master-branch-is-currently-checked-ouman gittutorial  作者：QuietHeartEmail：quiet_heart000@126.com日期：2012年6月14日  ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2012-06-14]<a href="/categories/study/git/git_basic.html"> 使用git进行版本控制 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Linux文件系统与目录结构'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. Linux 和 Windows 文件系统1.1. Windows 上面的文件系统1.1.1. 优点1.1.2. 缺点1.2. Linux 上面的文件系统1.2.1. 缺点1.2.2. 优点1.3. Linux 文件系统在操作系统中的位置2. Linux 上面的虚拟文件系统目录组织2.1. 常用的重要目录2.2. 对文件系统目录的分类标准Linux 和 Windows 的文件系统有些不同，在学习使用 Linux 之前，若能够了解这些不同，会有助于后续学习。本文先对 Windows 和 Linux 上面文件系统的一些概念进行区分，然后介绍一些 Linux 文件系统相关的原理，最后较为详细地介绍了 Linux 系统的目录结构。1 Linux 和 Windows 文件系统下面分别简单介绍一下启动 Windows 和 Linux 之后，它们是怎样看待自己世界的， 着重介绍 Linux 。1.1 Windows 上面的文件系统Windows 系统中一切东西都是存放在硬盘上的。启动系统后，先确定硬盘，再硬盘上的分区和每个分区所对应的文件系统，最后是存放在某个分区特定的文件系统中的文件。 也就是说， Windows 是通过 “某个硬盘-硬盘上的某个分区-分区上的特定文件系统-特定文件系统中的文件” 这样的顺序来访问到一个文件的。具体点说，假设我们的机器上面有一个硬盘，硬盘分为几个区，那么我们启动系统之后就会看到 C, D, E, 等几个分区(也就是我们启动系统后看到的 C 盘， D 盘等)，每个分区可以被格式化为各自不同的文件系统（例如 NTFS 格式， FAT32 格式等，文件系统的基本功能就是为了存放文件的，不同文件系统区别一般在于管理其中存放的文件的功能的强弱)，分区被格式化成指定格式的文件系统之后，就可以存放任何文件和目录了。这里，我们可以把文件大体分为两种： 系统文件和用户文件 。一般来说系统文件（例如 Windows 操作系统本身，一些系统程序，程序运行所需的库文件，以及一些系统配置文件等）存放的默认位置在 C 盘，当然也可以在安装时候指定在其他盘；其它用户文件，包含用户后来安装的程序以及一些数据文件等，用户可以把它们随意存放在任意的分区。这样组织有优点，更有缺点。1.1.1 优点优点主要是用户存放东西的位置比较自由，系统结构简单便于新用户上手。1.1.2 缺点缺点有很多这里只列出几种：目录组织缺乏标准由于对“系统文件”和“用户文件”存放位置缺乏细致的规定，数据组织的方式显得比较凌乱，并且两种文件之间很容易相互干扰（例如数据文件可能存放在系统区域给系统带来垃圾文件等）。用户的使用经验对系统的使用效率影响很大一般来说，我们使用 Windows 时候合理使用分区会提升的系统效率。例如根据需要设置合理的系统分区（假设为 C 分区），尽量少往 C 盘存放数据文件，根据具体情况可以将一些 “重要并且常用的” 程序安装在 C 分区，随时保持系统目录的清洁和大小助于提升系统的运行速度，用户安装的一般软件尽量不要安装在 C 盘，安装软件时候指定的位置最好采用默认标准目录名称（例如 X:\Program Files 目录，这里 X 表示盘符而不要自己定义一些奇怪名字的目录，这样便于软件的维护等等。共享不便Windows 上有经验的用户们会将自己的目录结构组织好，但是每个用户组织自己内容的方式是不一样的，所以他的机器上哪里存放了什么内容，别人很难知道，为共享带来了麻烦。但是这些在 Linux 系统中，情况就所不同了。1.2 Linux 上面的文件系统在 Linux 系统中正好相反，一切东西都是存放在一个唯一的 虚拟文件系统 中的，这个 虚拟文件系统 是树状的结构以一个根目录开始。启动系统后，先有这个 虚拟文件系统 ，再硬盘， 再把某个硬盘的某个分区做为这个 虚拟文件系统 的一部分（用某个子目录表示这个分区），再通过这个 虚拟文件系统 中对应硬盘分区的那个子目录确定硬盘分区中的特定文件系统，最后的文件就存放在这个特定的文件系统中。 也就是说， Linux 系统是通过 “虚拟文件系统-硬盘-硬盘上的分区-分区上的特定文件系统-特定文件系统中的文件” 这样的顺序来访问一个文件的。可能对习惯了使用 Windows 的用户来说，这样的组织点不太适应，这里的 虚拟文件系统 ，实质就是一颗目录树，最开始的目录叫做根目录，根目录中又有每一级子目录，或者文件，子目录又有子子目录和文件，其中每个子目录都特定的功能这个功能是约定俗成了的后面会详细说明……和 Windows 中把硬盘分成的 C, D, E 分区的概念不同了， Linux 中最开始根本就没有硬盘的概念，就只有一个纯粹的 虚拟文件系统 。如果想要使用哪个硬盘的某个分区，就把那个分区 “挂载” 到某个子目录之下，这样硬盘中的分区，文件系统，目录等内容就呈现到了那个子目录里面。也就是说，在 Linux 中，我们使用硬盘中的数据，实际是先把硬盘 “挂载” 到某个子目录下，然后通过那个子目录来访问硬盘的。硬盘中原的数据组织结构都反映到了子目录上，成为了整个 虚拟文件系统 根目录下的一颗子树。也许人会问，没这个 虚拟文件系统 就无法使用硬盘，但是最开始没有硬盘，那么这个 虚拟文件系统 以及相应的组织结构是怎么存放起来的呢？这个问题，就像先有鸡还是先有蛋这个问题一样看似简单实则……但是，在 Linux 中，很轻易地跳出了这个思维循环，问题的答案并没在 虚拟文件系 和 硬盘 这两者之间徘徊，而是第三者—— 内存 ，Linux系统启动起来之后，整个 虚拟文件系统 的组织结构，都是随着每次内核系统的启动自动在内存中建立好了的，根本就不需要硬盘。Linux 这样组织它的目录结构，有缺点当然更多的是优点。1.2.1 缺点最开始 虚拟文件系统 中的每个子目录的功能是事先规定好了的，我们需要事先知道那些目录存放哪些文件，然后在相应的位置中创建自己的内容，这也是为什么 Linux 系统入门门槛高的一个原因。（当然最开始的新手，也可以像 Windows 那样随意地创建目录和文件）。实际上最开始的目录也不多，主要就那么几个，花不了多长时间就会明白它们的作用的，而明白这些作用之后带来的好处，远不止付出那么多。 本文后面着重对这些目录进行介绍。1.2.2 优点这里只说几个优点：目录结构反映系统运行机理当我们了解了这些目录的功能之后，我们对整个 Linux 操作系统的运行机理也会有一个大致的了解。结构清晰避免逻辑混乱这样的目录结构，有助于我们以一种高效的方式组织自己的数据，分类清晰并且不会对系统运行有任何影响，规定了最开始每个目录的功能，并没有限制我们的自由，因为我们知道我们可以在哪里创建自己的子目录并且在子目录中任意创建自己的文件。组织规范便于共享由于目录具有统一的组织结构，所以 Linux 上面的用户在共享数据的时候，能够很容易地猜测出他所需要的数据大致存放在什么位置，同时也不会影响到私有数据的保密性（怎么存放自己的私有数据，那是用户自己决定的）。1.3 Linux 文件系统在操作系统中的位置在 Linux 系统中，主要两个东西： 虚拟文件系统 中的文件和 Linux操作系统内核 本身。逻辑上可以认为前者属于上层，后者在下层，前者基于后者，后者依赖前者而存在。Linux 把除了它本身（ Linux操作系统内核 ）以外的一切事物都看作是在 虚拟文件系统 中的文件了。无论是键盘，鼠标，数据，程序，CPU，内存，网卡……无论是硬件、软件、数据还是内存中的东西，我们都可以在 虚拟文件系统 中的相应子目录对他们进行访问和操作，操作统一。而实现这些管理的幕后就是 Linux操作系统内核 本身：启动 Linux 系统的时候，首先电脑把 Linux操作系统内核 加载到内存中，内核本身提供了文件管理，设备管理，内存管理，CPU进程调度管理，网络管理等功能，等内核运行起来之后，就在内存中建立起相应的 虚拟文件系统 ，最后就是内核利用它提供的那些功能，来管理 虚拟文件系统 中的硬件软件等各种资源了。Linux 把提供操作系统本身功能（管理计算机软硬件资源）的那些部分划给了 Linux操作系统内核 ，使得 Linux操作系统内核 成为一个独立的部分，有它自己的开源代码；其上其它的一切（软件，硬件，数据）都根据其特性有自己的开源代码、或者自由地组织并且存放在那个 虚拟文件系统 中由 Linux操作系统内核 来管理。这样，将系统本身和系统所管理的资源分开，并开放源代码，有助于对系统或者系统所管理的资源进行灵活的定制和扩展，还能按需快速建立起只适合自己使用的操作系统，也利于操作系统本身的发展。实际 Ubuntu ， Fedora ， RedHat 等各种不同的 Linux 操作系统发行版，简单来说就是对其文件系统和内核进行了不同的配置而产生的 “大众化” 的操作系统，相比之下， Windows 就显得非常地零乱复杂，将系统、软件、硬件都混在了一起，其不同版本只能由 Mircro 一家公司发行。另外，我们还要注意个问题，就是在我们的角度上，是使用路径来访问一个文件的。表示文件的路径由 “文件所在的目录+各级目录的分隔符+文件” 三个部分组成，这无论在 Windows 还是 Linux 上面，都是一样的，所不同的是， Windows 下面目录分隔符是 \ ， Linux 下面是 / ，也许这也是两者之间为了表示其各自立场不同的一个原因吧？^_^例如：Window系统上的文件：D:\Program Files\PPStream\PPStream.exeLinux系统上的文件：/usr/bin/screen2 Linux 上面的虚拟文件系统目录组织实质上，我们启动系统所看到的 “根目录” ，逻辑上是 Linux 虚拟文件系统的根目录中的一个子目录，我们看不到除了这个 “根目录” 以外的其他的目录，那些目录和操作系统的具体实现相关是被操作系统内核隐藏起来了的，所以这里就介绍我们所能看到的文件系统中的 “根目录” 的各个子目录中的作用吧。在 Linux 文件系统中的每一个子目录都有特定的目的和用途。一般都是根据 FHS 标准定义一个正式的文件系统结构的，这个标准规定了哪些目录应该哪些作用。这里我们先介绍一些日常经常用到的目录，然后给出 FHS 相关的内容。2.1 常用的重要目录这里，根据本人的使用经验，给出比较常见重要的一些目录，最开始我们对它们有所了解就可以了。随着对 Linux 使用的经验的加深，我们会了解越来越多的目录。对目录的功能知道得越多，我们对 Linux 系统的工p作原理就理解的越深刻，理解操作系统的工作原理，更助于我们更为规范地使用和理解系统中每个目录存在的意义，直至最后几乎知道系统中的每个文件……/ 根目录包含了几乎所的文件目录。相当于中央系统。进入的最简单方法是：cd /。/boot 引导程序，内核等存放的目录这个目录，包括了在引导过程中所必需的文件，引导程序的相关文件（例如 grub ， lilo 以及相应的配置文件）以及 Linux 操作系统内核相关文件（例如 vmlinuz 等）一般都存放在这里。在最开始的启动阶段，通过引导程序将内核加载到内存，完成内核的启动（这个时候， 虚拟文件系统 还不存在，加载的内核虽然是从硬盘读取的，但是没经过 Linux 的 虚拟文件系统 ，这是比较底层的东西来实现的）。然后内核自己创建好 虚拟文件系统 ，并且从 虚拟文件系统 的其他子目录中（例如 /sbin 和 /etc ）加载需要在开机启动的其他程序或者服务或者特定的动作（部分可以由用户自己在相应的目录中修改相应的文件来配制）。如果我们的机器中包含多个操作系统，那么可以通过修改这个目录中的某个配置文件（例如 grub.conf ）来调整启动的默认操作系统，系统启动的择菜单，以及启动延迟等参数。/sbin 超级用户可以使用的命令的存放目录存放大多涉及系统管理的命令（例如引导系统的 init 程序），是超级权限用户 root 的可执行命令存放地，普通用户无权限执行这个目录下的命令（但是有时普通用户也可能会用到）。这个目录和 /usr/sbin , /usr/X11R6/sbin或/usr/local/sbin 等目录是相似的，我们要记住，凡是目录 sbin 中包含的都是 root 权限才能执行的，这样就行了。后面会具体区分。/bin 普通用户可以使用的命令的存放目录系统所需要的那些命令位于此目录，比如 ls 、 cp 、 mkdir 等命令；类似的目录还 /usr/bin ， /usr/local/bin 等等。这个目录中的文件都是可执行的、普通用户都可以使用的命令。作为基础系统所需要的最基础的命令就是放在这里。/lib 根目录下的所程序的共享库目录此目录下包含系统引导和在根用户执行命令时候所必需用到的共享库。做个不太好但是比较形象的比喻，点类似于 Windows 上面的 system32 目录。按理说，这里存放的文件应该是 /bin 目录下程序所需要的库文件的存放地，也不排除一些例外的情况。类似的目录还 /usr/lib ， /usr/local/lib 等等。/dev 设备文件目录在 Linux 中设备都是以文件形式出现，这里的设备可以是硬盘，键盘，鼠标，网卡，终端，等设备，通过访问这些文件可以访问到相应的设备。设备文件可以使用 mknod 命令来创建，具体参见相应的命令；而为了将对这些设备文件的访问转化为对设备的访问，需要向相应的设备提供设备驱动模块（一般将设备驱动编译之后，生成的结果是一个 *.ko 类型的二进制文件），在内核启动之后，再通过 insmod 等命令加载相应的设备驱动之后，我们就可以通过设备文件来访问设备了。一般来说，想要 Linux 系统支持某个设备，只需要三个东西：相应的硬件设备，支持硬件的驱动模块，以及相应的设备文件。/home 普通用户的家目录（或 $HOME 目录、主目录）在 Linux 机器上，用户主目录通常直接或间接地置在此目录下。其结构通常由本地机的管理员来决定。通常而言，系统的每个用户都有自己的家目录，目录以用户名作为名字存放在 /home 下面（例如 quietheart 用户，其家目录的名字为 /home/quietheart ）。该目录中保存了绝大多数的用户文件(用户自己的配置文件，定制文件，文档，数据等)， root 用户除外（参见后面的 /root 目录）。由于这个目录包含了用户实际的数据，通常系统管理员为这个目录单独挂载一个独立的磁盘分区，这样这个目录的文件系统格式就可能和其他目录不一样了（尽管表面上看，这个目录还是属于根目录的一棵子树上），将系统文件和数据文件分开存放，有利于维护。/root 用户root的 $HOME 目录系统管理员(就是 root 用户或超级用户)的主目录比较特殊，不存放在 /home 中，而是直接放在 /root 目录下了。/etc 全局的配置文件存放目录系统和程序一般都可以通过修改相应的配置文件，来进行配置。例如，要配置系统开机的时候启动那些程序，配置某个程序启动的时候显示什么样的风格等等。通常这些配置文件都集中存放在 /etc 目录中，所以想要配置什么东西的话，可以在 /etc 下面寻找我们可能需要修改的文件。一些大型套件，如 X11 ，在 /etc 下它们自己的子目录。系统配置文件可以放在这里或在 /usr/etc 。 不过所有程序总是在 /etc 目录下查找所需的配置文件，你也可以将这些文件链接到目录 /usr/etc 。另外，还一个需要注意的常见现象就是，当某个程序在某个用户下运行的时候，可能会在该用户的家目录中生成一个配置文件（一般这个文件最开始就是 /etc 下相应配置文件的拷贝，存放相应于“当前用户”的配置），这样当前用户可以通过配置这个家目录的配置文件，来改变程序的行为，并且这个行为只是该用户特有的。原因就是：一般来说一个程序启动，如果需要读取一些配置文件的话，它会首先读取当前用户家目录的配置文件，如果存在就使用；如果不存在它就到 /etc 下读取全局的配置文件进而启动程序。就是这个配置文件不自动生成，我们手动在自己的家目录中创建一个文件的话，也有许多程序会首先读取到这个家目录的文件并且以它的配置作为启动的选项（例如我们可以在家目录中创建 vim 程序的配置文件 .vimrc ，来配置自己的 vim 程序）。/usr 这个目录中包含了命令库文件和在通常操作中不会修改的文件这个目录对于系统来说也是一个非常重要的目录，其地位类似Windows上面的 Program Files 目录（请原谅我可能这样做比较不太恰当^_^）。安装程序的时候，默认就是安装在此文件内部某个子文件夹内。输入命令后系统默认执行 /usr/bin 下的程序（当然，前提是这个目录的路径已经被添加到了系统的环境变量中）。此目录通常也会挂载一个独立的磁盘分区，它应保存共享只读类文件，这样它可以被运行 Linux 的不同主机挂载。/usr/lib 目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件的存放位置这个目录功能类似 /lib 目录，理说，这里存放的文件应该是 /bin 目录下程序所需要的库文件的存放地，也不排除一些例外的情况。/usr/bin 一般使用者使用并且不是系统自检等所必需可执行文件的目录此目录相当于根文件系统下的对应目录（ /bin ），非启动系统，非修复系统以及非本地安装的程序一般都放在此目录下。/usr/sbin 管理员使用的非系统必须的可执行文件存放目录此目录相当于根文件系统下的对应目录（ /sbin ），保存系统管理程序的二进制文件，并且这些文件不是系统启动或文件系统挂载 /usr 目录或修复系统所必需的。/usr/share 存放共享文件的目录在此目录下不同的子目录中保存了同一个操作系统在不同构架下工作时特定应用程序的共享数据(例如程序文档信息)。使用者可以找到通常放在 /usr/doc 或 /usr/lib 或 /usr/man 目录下的这些类似数据。/usr/include C程序语言编译使用的头文件Linux 下开发和编译应用程序所需要的头文件一般都存放在这里，通过头文件来使用某些库函数。默认来说这个路径被添加到了环境变量中，这样编译开发程序的时候编译器会自动搜索这个路径，从中找到你的程序中可能包含的头文件。/usr/local 安装本地程序的一般默认路径当我们下载一个程序源代码，编译并且安装的时候，如果不特别指定安装的程序路径，那么默认会将程序相关的文件安装到这个目录的对应目录下。例如，安装的程序可执行文件被安装（安装实质就是复制）到了 /usr/local/bin 下面，此程序（可执行文件）所需要依赖的库文件被安装到了 /usr/local/lib 目录下，被安装的软件如果是某个开发库（例如 Qt ， Gtk 等）那么相应的头文件可能就被安装到了 /usr/local/include 中等等。也就是说，这个目录存放的内容，一般都是我们后来自己安装的软件的默认路径，如果择了这个默认路径作为软件的安装路径，被安装的软件的所文件都限制在这个目录中，其中的子目录就相应于根目录的子目录。/proc 特殊文件目录这个目录采用一种特殊的文件系统格式（ proc 格式），内核支持这种格式。其中包含了全部虚拟文件。它们并不保存在磁盘中，也不占据磁盘空间(尽管命令 ls -c 会显示它们的大小)。当您查看它们时，您实际上看到的是内存里的信息，这些文件助于我们了解系统内部信息。例如： ├1/ 关于进程1的信息目录。每个进程在/proc 下一个名为其进程号的目录。 ├cpuinfo 处理器信息，如类型、制造商、型号和性能。 ├devices 当前运行的核心配置的设备驱动的列表。 ├dma 显示当前使用的DMA通道。 ├filesystems 核心配置的文件系统。 ├interrupts 显示使用的中断，and how many of each there have been. ├ioports 当前使用的I/O端口。 ├kcore 系统物理内存映象。与物理内存大小一样，但实际不占这么多内存； ├kmsg 核心输出的消息。也被送到syslog 。 ├ksyms 核心符号表。 ├loadavg 系统”平均负载”；3个没意义的指示器指出系统当前的工作量。 ├meminfo 存储器使用信息，包括物理内存和swap。 ├modules 当前加载了哪些核心模块。 ├net 网络协议状态信息。 ├self 到查看/proc 的程序的进程目录的符号连接。 ├stat 系统的不同状态 ├uptime 系统启动的时间长度。 └version 核心版本。/opt 可择的文件目录这个目录表示的是可择的意思，些自定义软件包或者第方工具，就可以安装在这里。比如在 Fedora Core 5.0 中， OpenOffice 就是安装在这里。些我们自己编译的软件包，就可以安装在这个目录中；通过源码包安装的软件，可以把它们的安装路径设置成 /opt 这样来安装。这个目录的作用一点类似 /usr/local 。/mnt 临时挂载目录这个目录一般是用于存放挂载储存设备的挂载目录的，比如磁盘，光驱，网络文件系统等，当我们需要挂载某个磁盘设备的时候，可以把磁盘设备挂载到这个目录上去，这样我们可以直接通过访问这个目录来访问那个磁盘了。一般来说，我们最好在 /mnt 目录下面多建立几个子目录，挂载的时候挂载到这些子目录上面，因为通常我们可能不仅仅是挂载一个设备吧?/media 挂载的媒体设备目录挂载的媒体设备目录，一般外部设备挂载到这里，例如 cdrom 等。比如我们插入一个U盘，我们一般会发现， Linux 自动在这个目录下建立一个 disk 目录，然后把U盘挂载到这个 disk 目录上，通过访问这个 disk 来访问U盘。/var 内容经常变化的目录此目录下文件的大小可能会改变，如缓冲文件，日志文件，缓存文件，等一般都存放在这里。/tmp 临时文件目录该目录存放系统中的一些临时文件，文件可能会被系统自动清空。的系统直接把 tmpfs 类型的文件系统挂载到这个目录上， tmpfs 文件系统由 Linux 内核支持，在这个文件系统中的数据，实际上是内存中的，由于内存的数据断电易失，当系统重新启动的时候我们就会发现这个目录被清空了。/lost+found 恢复文件存放的位置当系统崩溃的时候，在系统修复过程中需要恢复的文件，可能就会在这里被找到了，这个目录一般为空。以上目录，是最常见的重要目录。其中，有些目录初学者容易混淆，这里简单区分一下：/bin , /sbin 与 /usr/bin , /usr/sbin/bin 一般存放对于用户和系统来说“必须”的程序（二进制文件）。/sbin 一般存放用于系统管理的“必需”的程序（二进制文件），一般普通用户不会使用，根用户使用。/usr/bin 一般存放的只是对用户和系统来说“不是必需的”程序（二进制文件）。/usr/sbin 一般存放用于系统管理的系统管理的不是必需的程序（二进制文件）。/lib 与 /usr/lib/lib 和 /usr/lib 的区别类似 /bin, /sbin 与 /usr/bin, /usr/sbin 。/lib 一般存放对于用户和系统来说“必须”的库（二进制文件）。/usr/lib 一般存放的只是对用户和系统来说“不是必需的”库（二进制文件）。其他还一些目录例如： /home/user/bin, /home/user/opt, /home/user/etc, /usr/local/etc 等等，其作用都是类似于 /etc, /bin 等目录的，可能只是层次概念不同了，使用 Linux 时间长了，会逐渐体会到其中的含义。当然，我们可以无视这些目录，像使用 Windows 那样自由的，不管啥文件，想往哪存就往哪存，还是那句话，使用 Linux 时间长了，会逐渐体会到其中的含义，到时候也许我们想要乱来都不行了呢。^_^2.2 对文件系统目录的分类标准在大多数 Linux 系统上面，我们可以使用一个命令： man hier ，通过这个命令的输出，就知道“根目录”中所子目录的作用了。这个命令含义我不多说了，总之这里的 hier 就是对 Linux 文件系统中各级目录的标准功能，是一个大家都约定俗成了的东西。想要了解每个目录更详细的信息，需要仔细参考 man hier 的输出。下面就是一个比较简短的中文描述的对文件系统目录分类的 FHS 标准，也就是对 man hier 的简单翻译。NAME 名称hier - 文件系统描述 DESCRIPTION 描述一个典型的Linux系统具以下几个目录结构：/ 根目录，是所目录树开始的地方。/bin 此目录下包括了单用户方式及系统启动或修复所用到的所执行程序。/boot 包括了引导程序的静态文件。此目录下包括了在引导过程中所必需的文件。系统装载程序及配制文件在 /sbin 和 /etc 目录中找到。/dev 对应物理设备的指定文件或驱动程序。参见mknod(1)。/dos 如果MS-DOS和Linux共存于一台计算机时，这里通常用于存放DOS 文件系统。/etc 用于存放本地机的配置文件。一些大型套件，如X11，在 /etc 下它们自己的子目录。系统配置文件可以放在这里或在 /usr/etc。 不过所程序总是在 /etc 目录下查找所需的配置文件，你也可以将这些文件链接到目录 /usr/etc./etc/skel 当建立一个新用户账号时，此目录下的文件通常被复制到用户的主目录下。/etc/X11X11 window system所需的配置文件。/home 在Linux机器上，用户主目录通常直接或间接地置在此目录下。其结构通常由本地机的管理员来决定。/lib 此目录下包含系统引导和在根用户执行命令所必需用到的共享库。/mnt 挂载临时文件系统的挂载点。/proc 这是提供运行过程和核心文件系统 proc 挂载点。这一”伪”文件系统在以下章节中详细叙述 proc(5)。/sbin 类似于 /bin 此目录保存了系统引导所需的命令，但这些命令一般使用者不能执行。/tmp 此目录用于保存临时文件，临时文件在日常维护或在系统启动时无需通知便可删除/usr 此目录通常用于从一个独立的分区上挂载文件。它应保存共享只读类文件，这样它可以被运行Linux的不同主机挂载。/usr/X11R6 X-Window系统 Version 11 release 6./usr/X11R6/bin X-Windows系统使用的二进制文件；通常是在对更传统的 /usr/bin/X11 中文件的符号连接。/usr/X11R6/lib 保存与X-Windows系统关数据文件。/usr/X11R6/lib/X11 此目录保存与运行X-Windows系统关其他文件。通常是对来自 /usr/lib/X11 中文件的符号连接。/usr/X11R6/include/X11 此目录保存包括使用X11窗口系统进行编译程序所需的文件。通常是对来自 /usr/lib/X11 中文件的符号连接。/usr/bin 这是执行程序的主要目录，其中的绝大多数为一般使用者使用，除了那些启动系统或修复系统或不是本地安装的程序一般都放在此目录下。/usr/bin/X11X11执行文件放置的地方；在Linux系统中，它通常是对 /usr/X11R6/bin. 符号连接表/usr/dict此目录保存拼写检查器所使用的词汇表文件。/usr/doc此目录下应可以找到那些已安装的软件文件。/usr/etc此目录可用来那些存放整个网共享的配置文件。然而那可执行命令指向总是使用参照使用 /etc 目录下的文件。 /etc 目录下连接文件应指向 /usr/etc. 目录下适当的文件。/usr/includeC程序语言编译使用的Include”包括”文件。/usr/include/X11C程序语言编译和X-Windows系统使用的 Include”包括”文件。它通常中指向 /usr/X11R6/include/X11. 符号连接表。/usr/include/asm申明汇编函数的Include”包括”文件，它通常是指向 /usr/src/linux/include/asm 目录的符号连接/usr/include/linux包含系统变更的信息通常是指向 /usr/src/linux/include/linux 目录的符号连接表，来获得操作系统特定信息。(注：使用者应在此自行包含那些保证自己开发的程序正常运行所需的libc 函数库。不管怎样，Linux核心系统不是设计用来执行直接运行用户程序的，它并不知道用户程序需要使用哪个版本的libc库 。如果你随意将 /usr/include/asm 和 /usr/include/linux 指向一个系统核心，系统很可能崩溃。Debian系统不这么做。它使用 libc*-dev运行包中提供的核心系统标识，以保证启动所正确的文件。) /usr/include/g++GNU C++编译程序所使用的Include”包括”文件。/usr/lib目标库文件，包括动态连接库加上一些通常不是直接调用的可执行文件案。一些复杂的程序可能在此占用整个子目录。/usr/lib/X11存放X系统数据文件及系统配置文件的地方。 Linux中通常是指向 /usr/X11R6/lib/X11 目录的符号连接表。/usr/lib/gcc-libGNU C 编译程序所使用的可执行文件案和”包括”文件。 gcc(1)./usr/lib/groffGNU groff 文件格式系统所使用的文件。/usr/lib/uucpuucp(1) 所使用的文件。/usr/lib/zoneinfo关时区信息文件文件。/usr/local安装在本地执行程序的地方。/usr/local/bin在此地放置本地执行程序的二进制文件。/usr/local/doc放置本地文件。/usr/local/etc安装在本地程序的配置文件。/usr/local/lib安装在本地程序的库文件。/usr/local/info安装在本地程序关信息文件。/usr/local/man安装在本地程序使用手册。/usr/local/sbin安装在本地的系统管理程序。/usr/local/src安装在本地程序的原始码。/usr/man手册页通常放在此目录，或相关子目录下。/usr/man//man[1-9]此目录在指定的地方以原始码形式存放手册页。系统在所的手册页中使用自己独特的语言及代码集，可能会省略 substring 子字符串。/usr/sbin此目录保存系统管理程序的二进制码，这些文件不是系统启动或文件系统挂载 /usr 目录或修复系统所必需的。/usr/share在此目录下不同的子目录中保存了同一个操作系统在不同构架下工作时特定应用程序的共享数据。使用者可以找到通常放在 /usr/doc 或 /usr/lib 或 /usr/man 目录下的这些数据。/usr/src系统不同组成部份的源文件包括参考数据报。不要将你自己与项目关的文件放这里，因为在安装软件外，/usr下的文件属性除通常设为只读。/usr/src/linux系统核心资源通常拆包安装于此。这是系统中重要的一环，因为 /usr/include/linux 符号连接表指向此目录。你应当使用其他目录来来编译建立新核心。/usr/tmp此目录不再使用了。它应指向目录 /var/tmp。 这个链接只是出于系统兼容的目的，一般不再使用。/var此目录下文件的大小可能会改变，如缓冲文件可日志文件。/var/adm此目录为 /var/log 甩替代，通常是指向 /var/log 的符号连接表。/var/backups此目录用来存放重要系统文件的后备文件/var/catman/cat[1-9] or /var/cache/man/cat[1-9]此目录存储根据手册分类预先格式化的参考手册页。(这些参考手册页是相互独立的)/var/lock此目录存储锁定文件。依据命名习惯，设备锁定文件是 LCKxxxxx xxxxx与在文件系统中该设备名相同，使用的格式是HDU UUCP锁定文件，例如包含进程标识PID的锁定文件是一个10字节的ASCII格式的数字，后面跟一个换行符。/var/log各种日志文件。/var/preserve这是 vi(1) 存放正在编辑中的文件，以便以后可以恢复。/var/run运行时的变量文件，如存放进程标识和登入使用者信息的文件。 (utmp) 此目录下文件在系统启动时被自动清除。/var/spool各种程序产生的缓冲或排除等待的文件/var/spool/atat(1) 的作业存缓区/var/spool/croncron(1) 的作业存缓区/var/spool/lpd打印缓存文件。/var/spool/mail使用者邮箱。/var/spool/smail存放 smail(1) 邮件发送程序的缓冲文件。/var/spool/news新闻子系统的缓冲目录/var/spool/uucpuucp(1) 的缓冲文件/var/tmp类似 /tmp, 此目录保存未指定持续时间的临时文件。      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2011-06-24 五 20:25]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2011-06-24]<a href="/categories/study/linux/Linux_fs_dir.html"> Linux文件系统与目录结构 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '努力'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '我正在努力着让自己成为一个真正努力的人……From:努力 in cublog';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2011-04-04]<a href="/categories/others/rambles/213516cublog.html"> 努力 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = '清明'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '清明时节雨纷纷，路上行人欲断魂，借问酒家何处有，牧童遥指杏花村。From:清明 in cublog';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2011-04-02]<a href="/categories/others/rambles/211013cublog.html"> 清明 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-09其他'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '查看vim的简易教程：输入:!vimtutor.这里实际vimtutor是shell终端下的一个命令，这里实际是执行的shell命令，可以在终端直接输入vimtutor。  保存与恢复上次的编辑状态：  保存会话与状态，步骤如下：输入:cd src。这将切换到./src目录输入:mksession vim70.vim这将在./src目录创建一个会话文件，该会话文件保存了当前的窗口状态（例如打开几个窗口）输入:wviminfo vim70.viminfo这将在./src目录创建一个viminfo文件，该会话文件保存了当前的命令历史，缓冲等等状态。输入:qa这样，退出vim。根据上次保存的文件恢复会话与状态，步骤如下：1）输入:source ~/src/vim70/src/vim70.vim    这样，载入vim70.vim会话文件(mksession建立的不一定非要.vim后缀)，当前立即会出现上次保存vim70.vim时候的窗口布局状态。2）输入rviminfo vim70.viminfo    这样，读入viminfo文件（wviminfo建立的），当前的历史、缓冲等状态会被恢复（如set nu等）。更新并重新载入.vimrc：输入:source ~/.vimrc。这里，当我们修改完了.vimrc文件之后，执行这句话，不用重启vim就能载入.vimrc中的新设置。  查找当前光标位置单词的man手册：输入[Shift]k.这个命令经常用来查某个库函数，等同于:!man &lt;当前光标单词&gt;。  显示所有命令：输入:[Ctrl]d.按[Tab]可以依次选择每一个。  显示所有以e开始的命令：输入:e[Ctrl]d.这里先在命令模式下面输入一个字母e（其他字母类似），然后按[Ctrl]D就会显示所有以e开始的命令。按[TAB]选择一个命令。  在vi中暂时进入shell:输入:shell.这样,临时从vi进入shell,当前路径就是刚才vi的路径。从shell返回vi,则敲入exit。  一个基于vi的比较工具，vimdiffvimdiff可以同时打开两个或者多个文件,进行比较。它会将两个文件的相同指出尽量列在同一位置上面，便于查对比较。其实vimdiff就是vim，只是一个符号链接而已，你可以用file /etc/alternatives/*|grep bin/vim看看, 其命令基本和vim是一致的。  命令格式:vimdiff [options] file1 file2 [file3]  启动后，vimdiff使用vim加载两个或者多个文件，每个文件有其自己的窗口。每个文件中不同的地方会用高亮显示出来。它在进行改变的检查以及将改动从一个版本的文件移动到另一个版本的情况下非常方便。首先你得保证安装了vim才能是用vimdiff.用这个命令安装：#apt-get install vim-full其他类似的工具还tkdiff,meld 和 xfdiff4等。   同时打开main.cpp和main2.cpp，垂直方向分屏:输入$vimdiff main.cpp main2.cpp或$vim -d main.cpp main2.cpp这样会同时打开两个文件垂直在两栏显示，可以打开不止两个文件。同时打开main.cpp和main2.cpp，水平方向分屏：$vimdiff -o main.cpp main2.cpp这样会同时打开两个文件在上下两栏显示.打开文件之后可以看见不同的地方会高亮显示，相同的地方默认会被折叠起来。如下常用操作：  跳到下一个不同的地方:输入]c.跳到上一个不同的地方：输入[c.用另外一个窗口的不同处替换当前：输入do.这里，前提是用]c或者[c跳到相应的不同处,执行完毕之后，当前窗口当前位置内容被替换为另外一个窗口的当前位置内容。注意这里是两个文件的情况,当前窗口有多于两个文件时无法进行。先指定范围1-100行，再用另外一个窗口的不同处替换当前：输入1,100 diffg.或输入1,100 diffget.这里，等同于do不过指定了范围，如果有缓冲还可在diffg后面指定缓冲名字。先指定范围1-100行，再用指定3号缓冲(假设是文件file3)的不同处替换当前：输入1,100 diffg 3.或输入1,100 diffget 3.这里，在diffg后面指定缓冲名字。用当前替换另外一个窗口的不同处：输入dp.这里，前提是用]c或者[c跳到相应的不同处,执行完毕之后，另外一个窗口的当前位置内容被替换成当前窗口当前的位置内容。注意这里是两个文件的情况,当前窗口有多于两个文件时无法进行。先指定范围1-100行，再用另外一个窗口的不同处替换当前：输入1,100 diffpu.或输入1,100 diffput.这里，等同于dp不过指定了范围，如果有缓冲还可在diffpu后面指定缓冲名字。先指定范围1-100行，再用指定3号缓冲(假设是文件file3)的不同处替换当前：输入1,100 diffpu 3.或输入1,100 diffput 3.这里，在diffpu后面指定缓冲名字。新开一个水平窗口载入file文件进行对比：输入:diffsplit file.这里新开的窗口是水平排列的,在不同窗口间移动的命令同vim。新开一个垂直窗口载入file文件进行对比：输入vert diffsplit file.这里,vert实际是vertical前缀的简写。新开的窗口是垂直排列的,在不同窗口间移动的命令同vim。强制更新文件的不同状态：输入:diffupdate.这里，当我们修改某一个文件的时候，vim会试图使它和另外一个文件的不同之处保持更新，例如插入和删除行。但是，更复杂的修改或者在一个行内的修改可能会导致不同处(vimdiff)没有及时更新，这时候可以运行这个命令diffupdate进行强制更新。修改缺省的上下文行为3行:输入:set diffopt=context:3.这里vimdiff 缺省是会把不同之处上下各 6 行的文本都显示出来以供参考。其他的相同的文本行被自动折叠。如果希望修改缺省的上下文行数，可以这样设置.打开折叠的文本：输入zo.折叠折叠的文本：输入zc.修改完毕之后保存所有文件：输入wqa.杂项  关于vim的配置文件：如果让vim启动自动执行某些命令可以在主目录（~/）下建立一个.vimrc文件，填入相关命令即可。Vim启动时会自动读取这个文件，当然可以在编辑文件的状态下输入:source ~/.vimrc实时读取该文件，这样修改了这个文件的时候就不用重新启动vim了。例如：设置vi启动后，不备份当前修改文件，输入：echo &#39;set nobackup&#39; &gt;&gt;~/.vimrc ，这样相当于把set nobackup加到.vimrc中去了。  举例：一个简单的程序员的vi编辑器, 创建或修改~/.vimrc文件,内容如下:  set tabstop=4  set softtabstop=4  set shiftwidth=4  set autoindent  set cindent  set number  set showmatch  set mouse=a  更多的选项，具体有待研究，如：  打开语法高亮：输入:syntax enable。或输入:syntax on。这里前者设置完了还可以用hilight设置自己喜欢的颜色，后者只用默认的颜色（??help这样说??）；都只在当前编辑中起作用。换行时自动缩进：输入:set si。或输入:set smartindent。红色的不确定据说X/Windows 的剪贴板的内容是存在寄存器+中，粘贴命令为：输入&quot;+P.将简单的 y 和 p命令与系统剪贴板联系起来:输入:set clipboard+=unnamed &quot; set clipboard.注释代码块的步骤：先移到第一行，输入 I// (就是ESC键).这样，将第一行注释。移到第二行，按 V 进行 line visual mode，再按j 或其它方向移动键选好要注释的所有代码行。最后按..实际这只是在visual mode 里使用 redo 的功能而已。这样应该就将许多代码块一并注释了。（可以看看先用V选择，再i插入//）用一個 &#39;適當&#39; 的 space數量取代 tab：输入:set expandtab.这里，需要和shiftwidth一块使用，在多人一起开发项目时，为了使代码风格尽量保持一致，一般不允许在代码使用TAB符，而以4个空格代之。我们可以编辑一个文件，包含下面的内容：  set shiftwidth=4  set expandtab  遇到make不做expandtab：输入:au FileType make set noexpandtab.这里，make和python中[Tab]有特殊的含义，所以不做[Tab]向[Space]的转换。  遇到python不做expandtab：输入:au FileType python set noexpandtab.这里，make和python中[Tab]有特殊的含义，所以不做[Tab]向[Space]的转换。据说可以把下面的命令加入到.vimrc中：autocmd FileType c,cpp set shiftwidth=4 | set expandtab就可以只在编辑c和cpp文件时实行相应的设置了  快速输入匹配的小技巧这里介绍一个小技巧，可以快速输入{},()等匹配对里面的内容。  经常在编程的时候输入{},()等等需要成对输入的元素，如果不一下输入一对，很容易就会忘记了匹配，这是一个好习惯，但是这样，我们在往匹配对里面输入字符的时候还要按方向键进入匹配对里面，输入之后还要再按方向键从匹配对里面出来，这样很麻烦，手的动作很大，所以我用如下方法解决这个问题。  原理：利用vim里面编辑状态的[Ctrl]o临时切换程命令行状态执行命令，然后自动回到编辑状态。  举例：如果我输入{good}a，则：  输入{}。这里意思是先输入匹配对输入[Ctrl]o.临时切换到命令行状态输入i.命令行状态下}一般都会在行尾，所以按i就回到了{}里面；注意如果按左方向键，就到了{}的左面了，当然若你的{}不在行尾的话可以用左方向键进入{}。 输入good.这里，自动回到了编辑状态，所以输入的good是在{}里面的。 输入[Ctrl]o.这里输入完了{}的内容，想要从{}出来，所以又临时切换成命令模式。 输入o.或输入a.如果输入o则在新行继续输入你要输入的内容，如果输入a则在{}的后面继续输入你要输入的内容。 继续输入你想要输入的内容。过程说着很麻烦，但是，如果实践一下很简单的，任何知识都是说着麻烦做着简单的。试试看，你一定会有所收获，如果养成了习惯，一定会提高效率的。根据原理，你还可以扩展其它的类似技巧。_^配置cscope配置好cscope之后，可以在代码中完成函数跳转、搜索代码标号、以及查看被调用函数、搜索文件等等。cscope与ctags的不同之处在于，cscope产生的索引是静态的，文件内容改变之后，定位信息就不准确了。可以在vim的配置中加入相关的配置，如cscope.vim的内容如下：  &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; CSCOPE settings for vim           &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; This file contains some boilerplate settings for vim&#39;s cscope interface,&quot; plus some keyboard mappings that I&#39;ve found useful.&quot;&quot; USAGE: &quot; -- vim 6:     Stick this file in your ~/.vim/plugin directory (or in a&quot;               &#39;plugin&#39; directory in some other directory that is in your&quot;               &#39;runtimepath&#39;.&quot;&quot; -- vim 5:     Stick this file somewhere and &#39;source cscope.vim&#39; it from&quot;               your ~/.vimrc file (or cut and paste it into your .vimrc).&quot;&quot; NOTE: &quot; These key maps use multiple keystrokes (2 or 3 keys).  If you find that vim&quot; keeps timing you out before you can complete them, try changing your timeout&quot; settings, as explained below.&quot;&quot; Happy cscoping,&quot;&quot; Jason Duell       jduell@alumni.princeton.edu     2002/3/7&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; This tests to see if vim was configured with the &#39;--enable-cscope&#39; option&quot; when it was compiled.  If it wasn&#39;t, time to recompile vim... if has(&quot;cscope&quot;)    &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; Standard cscope/vim boilerplate    &quot; use both cscope and ctag for &#39;ctrl-]&#39;, &#39;:ta&#39;, and &#39;vim -t&#39;    set cscopetag    &quot; check cscope for definition of a symbol before checking ctags: set to 1    &quot; if you want the reverse search order.    set csto=0    &quot; add any cscope database in current directory    if filereadable(&quot;cscope.out&quot;)        cs add cscope.out      &quot; else add the database pointed to by environment variable     elseif $CSCOPE_DB != &quot;&quot;        cs add $CSCOPE_DB    endif    &quot; show msg when any other cscope db added    set cscopeverbose      &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; My cscope/vim key mappings    &quot;    &quot; The following maps all invoke one of the following cscope search types:    &quot;    &quot;   &#39;s&#39;   symbol: find all references to the token under cursor    &quot;   &#39;g&#39;   global: find global definition(s) of the token under cursor    &quot;   &#39;c&#39;   calls:  find all calls to the function name under cursor    &quot;   &#39;t&#39;   text:   find all instances of the text under cursor    &quot;   &#39;e&#39;   egrep:  egrep search for the word under cursor    &quot;   &#39;f&#39;   file:   open the filename under cursor    &quot;   &#39;i&#39;   includes: find files that include the filename under cursor    &quot;   &#39;d&#39;   called: find functions that function under cursor calls    &quot;    &quot; Below are three sets of the maps: one set that just jumps to your    &quot; search result, one that splits the existing vim window horizontally and    &quot; diplays your search result in the new window, and one that does the same    &quot; thing, but does a vertical split instead (vim 6 only).    &quot;    &quot; I&#39;ve used CTRL-\ and CTRL-@ as the starting keys for these maps, as it&#39;s    &quot; unlikely that you need their default mappings (CTRL-\&#39;s default use is    &quot; as part of CTRL-\ CTRL-N typemap, which basically just does the same    &quot; thing as hitting &#39;escape&#39;: CTRL-@ doesn&#39;t seem to have any default use).    &quot; If you don&#39;t like using &#39;CTRL-@&#39; or CTRL-\, , you can change some or all    &quot; of these maps to use other keys.  One likely candidate is &#39;CTRL-_&#39;    &quot; (which also maps to CTRL-/, which is easier to type).  By default it is    &quot; used to switch between Hebrew and English keyboard mode.    &quot;    &quot; All of the maps involving the macro use &#39;^$&#39;: this is so    &quot; that searches over &#39;#include &quot; return only references to    &quot; &#39;time.h&#39;, and not &#39;sys/time.h&#39;, etc. (by default cscope will return all    &quot; files that contain &#39;time.h&#39; as part of their name).    &quot; To do the first type of search, hit &#39;CTRL-\&#39;, followed by one of the    &quot; cscope search types above (s,g,c,t,e,f,i,d).  The result of your cscope    &quot; search will be displayed in the current window.  You can use CTRL-T to    &quot; go back to where you were before the search.      &quot;    nmap s :cs find s =expand(&quot;&quot;)    nmap g :cs find g =expand(&quot;&quot;)    nmap c :cs find c =expand(&quot;&quot;)    nmap t :cs find t =expand(&quot;&quot;)    nmap e :cs find e =expand(&quot;&quot;)    nmap f :cs find f =expand(&quot;&quot;)    nmap i :cs find i ^=expand(&quot;&quot;)$    nmap d :cs find d =expand(&quot;&quot;)    &quot; Using &#39;CTRL-spacebar&#39; (intepreted as CTRL-@ by vim) then a search type    &quot; makes the vim window split horizontally, with search result displayed in    &quot; the new window.    &quot;    &quot; (Note: earlier versions of vim may not have the :scs command, but it    &quot; can be simulated roughly via:    &quot;    nmap s :cs find s =expand(&quot;&quot;)    nmap s :scs find s =expand(&quot;&quot;)    nmap g :scs find g =expand(&quot;&quot;)    nmap c :scs find c =expand(&quot;&quot;)    nmap t :scs find t =expand(&quot;&quot;)    nmap e :scs find e =expand(&quot;&quot;)    nmap f :scs find f =expand(&quot;&quot;)    nmap i :scs find i ^=expand(&quot;&quot;)$    nmap d :scs find d =expand(&quot;&quot;)    &quot; Hitting CTRL-space *twice* before the search type does a vertical     &quot; split instead of a horizontal one (vim 6 and up only)    &quot;    &quot; (Note: you may wish to put a &#39;set splitright&#39; in your .vimrc    &quot; if you prefer the new window on the right instead of the left    nmap s :vert scs find s =expand(&quot;&quot;)    nmap g :vert scs find g =expand(&quot;&quot;)    nmap c :vert scs find c =expand(&quot;&quot;)    nmap t :vert scs find t =expand(&quot;&quot;)    nmap e :vert scs find e =expand(&quot;&quot;)    nmap f :vert scs find f =expand(&quot;&quot;)    nmap i :vert scs find i ^=expand(&quot;&quot;)$    nmap d :vert scs find d =expand(&quot;&quot;)    &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; key map timeouts    &quot;    &quot; By default Vim will only wait 1 second for each keystroke in a mapping.    &quot; You may find that too short with the above typemaps.  If so, you should    &quot; either turn off mapping timeouts via &#39;notimeout&#39;.    &quot;    &quot;set notimeout     &quot;    &quot; Or, you can keep timeouts, by uncommenting the timeoutlen line below,    &quot; with your own personal favorite value (in milliseconds):    &quot;    &quot;set timeoutlen=4000    &quot;    &quot; Either way, since mapping timeout settings by default also set the    &quot; timeouts for multicharacter &#39;keys codes&#39; (like ), you should also    &quot; set ttimeout and ttimeoutlen: otherwise, you will experience strange    &quot; delays as vim waits for a keystroke after you hit ESC (it will be    &quot; waiting to see if the ESC is actually part of a key code like ).    &quot;    &quot;set ttimeout     &quot;    &quot; personally, I find a tenth of a second to work well for key code    &quot; timeouts. If you experience problems and have a slow terminal or network    &quot; connection, set it higher.  If you don&#39;t set ttimeoutlen, the value for    &quot; timeoutlent (default: 1000 = 1 second, which is sluggish) is used.    &quot;    &quot;set ttimeoutlen=100endif';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_09Others.html"> Vim实践与学习-09其他 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-08配置相关'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '查看vim的版本及功能：输入:version.这样会显示当前vim的版本，编译选项，vim配置路径等信息。  查看所有set选项:输入:set all.或输入:se all.这样可以查看所有可以设置的选项。  显示当前set设置：输入:set.或输入:se这样，可以显示当前set设置。  显示制定选项的设置:输入:set {option}?.或输入:se {option}?这里，可以查看选项{option}的值，例如:set nu?可以查看是nu或是nonu（是否显示行号）。  显示所有行行号：输入:set nu。  设置搜索时显示高亮：输入:set hls。或输入set hlsearch。  取消搜索时高亮显示：输入:set nohls。或输入:set nohlsearch。或输入:nohl.这里，查找一个字符，程序会用高亮显示出来，这样设置就不高亮了，当然查找一个不存在的字符也可取消当前高亮状态。通过:nohlsearch只是暂时关闭高亮显示，下次搜索时将自动恢复高亮(当然是在一次启动vim的期间，如果关闭vim再重新启动，那么状态是.vimrc规定的)。高亮就不能用:hls需要用:set hls.实践发现，:set nohls之后，关闭vi,再打开之后上次搜索的还是高亮状态，但是用:nohls之后再打开那么上次的搜索就不是高亮了.  搜索时忽略大小写：输入set ic.这样输入/进行搜索的时候，就不考虑大小写了。  取消搜索时忽略大小写：输入set noic.也即搜索不忽略大小写，这也是默认的情况。  对netrw插件（文件浏览）窗口方向的配置：输入:let g:netrw_preview=0.或输入:let g:netrw_preview=1.设置内部变量g:netrw_preview.假设光标在目录的某一个文件上面，如果为0（默认）则按p的时候水平开窗口预览文件，为1则垂直。  高亮当前行：输入:set cursorline.或输入:set cul.这样光标当前行会有一个下划线。  取消高亮当前行：输入:set no cursorline.或输入:set no cul.这样取消了当前行的下划线。  在’complete‘选项中去掉i标记:输入:set complete -=i如果CTRL-N和CTRL-P补全时查找所包含的头文件，耗时会比较久。此时，可以在 ’complete‘ 选项中去掉i标记:set complete-=i 。  让vi自动缩进对齐代码:输入:set ai.或输入:set autoindent.这样在你敲入一个新行的时候,会自动将上一行的缩进拷贝过来,这样上下两行的缩进就会一样了,并且即使输入{之后,再新起一行也会这样,而不是多缩进一个,为了保持代码的语法缩进输入{之后新行要手动再输入一个缩进.如果该行没有任何内容就进入下一行,那么这个缩进会自动被删除.  让vi智能缩进对齐代码:输入:set si.或输入:set smartindent.亦或:set cindent.这里，si是smartindent的简写，它比ai智能，而ai只管复制上一行缩进。如果有si那么ai就会自动也有了，并且在输入{或者一些cinwords关键字的时候会自动插入一个缩进(不止是复制，还多插入一个缩进，这导致输入这样字符之后新起一行看起来像是自动又缩进了)，而且输入}的时候如果它是一行的第一个字符会自动让它和与它匹配的那个{取相同的缩进。smartindent和cindent有点不一样，前者在多数语言中比较通用，而后者比较严格像c.cindent如果打开那么smartindent就会关闭。  设置在敲},]或)显示出对应匹配的{,[或(:输入:set sm.这样,在敲入右半括号的时候会自动把前面的左半括号高亮一下.  设置简写：输入:ab.这里，会将做为的简写，例如：输入:ab usa United States of America之后，当你在文见里插入 usa 之后，按下回车或空格等，这时 United States of America 就蹦出来了。  设置显示的颜色主题为ron：输入:color ron.或输入:colorscheme ron.这里，ron主题是我个人感觉比较好看的一种主题，可以先输入:colorscheme再[Ctrl]d可以查看所有的可选主题。  打开语法高亮：输入:syntax on.或输入:syn on.这里，syntax还有enable等值，具体察看:help syntax,之后搜索syntax on.  关于缩进的宽度：  一個tab用4个space寬度顯示：输入:set tabstop=4.这里，定义tab所等同的空格长度，一般来说最好设置成8，因为如果是其它值的话，可能引起文件在打印之类的场合中看起来很别扭。除非你设置了 expandtab模式，也就是把tabs转换成空格，这样的话就不会一起混淆，不过毕竟制表符为8是最常用最普遍的设置，所以一般还是不要改。一個縮排 (indent) 跳的 space 數为4：输入:set shiftwidth=4.或输入:set sw=4.这个是用于程序中自动缩进（(auto)indent）所使用的空白长度指示的。一般来说为了保持程序的美观，和tabstop参数最好一致。同时它也是符号移位长度的制定者。一個 tab 含幾個 space (under editing operation)：输入:set softtabstop=4.这里，若我们希望改变程序中的缩进，shiftwidth和tabstop不一样的话，你会发现程序比较难看的。这时需要设置这个softtabstop。从vim说明可知，一旦设置了softtabstop的值，你按下tab键，插入的是空格和tab制表符的混合，具体如何混合取决于你设定的softtabstop。例如，如果设定softtabstop=8,那么按下tab键，插入的就是正常的一个制表符;如果设定 softtabstop=16,那么插入的就是两个制表符；如果softtabstop=12,那么插入的就是一个制表符加上4个空格；如果 softtabstop=4呢？那么一开始，插入的就是4个空格，此时一旦你再按下一次tab，这次的四个空格就会和上次的四个空格组合起来变成一个制表符。换句话说，softtabstop是逢8空格进1制表符,前提是你tabstop=8。设置举例1(建议使用)：  set shiftwidth=4  set tabstop=4  这样，缩进的宽度和制表宽度都是4个空格的宽度，也没有前面的在Makefile等需要制表符的语法里需要敲两次[Tab]才产生一个制表符号的缺点了。  设置举例2：  set shiftwidth=4  set tabstop=8  set softtabstop=4  这样，代码自动缩进(shiftwidth)的宽度是4个空格，一个制表符的宽度(tabstop)是8个空格,按下一次[Tab]会产生4个空格，产生8个空格的时候会自动转换成一个制表符号（很智能地，删除的时候可以判断是删[Tab]产生的4个空格）。缺点是这样的设置在Makefile等需要制表符的语法里需要敲两次[Tab]才产生一个制表符号。  设置当前目录自动跟随当前文件:输入:set autochdir.或输入:set acd.这样之后，当切换到另一个文件的时候，vim的当前工作目录就会自动地切换到那个文件所在的目录。这里即使有tab标签打开多个文件，当前显示的文件，所在的目录就是vim的工作目录。取消这个选项的命令是set noacd.  不要备份编辑的文件:输入:set nobackup.这里，当vi打开一个文件开始编辑的时候，会创建一个原始文件的备份文件（一般以原名加~结尾），如果不想创建这个备份，那么就设置这个选项。一般这个选项可以和writebackup一块使用，两者的值的组合决定了不同的备份策略。当backup和writebackup同时为no的时候就会什么备份也不创建了。使用具体参见帮助help backup。一般默认的设置就是:set nobackup和:set writebackup,就是备份当前文件，过后（成功写入之后）再删除？。  备份编辑的文件：输入:set backup.这样设置之后，会在你编辑并且保存写好的文件的时候，备份文件。  ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_08Config.html"> Vim实践与学习-08配置相关 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-07显示相关'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'vi 有时候可以用特殊的方式来显示你编辑的文件，例如多个窗口等。这里就将这类相关的命令集中了。  让vi显示多个窗口（多缓冲区）:  水平分割当前窗口：输入:split。或输入:sp。这样窗口会分为上下两部份，可以继续分割；之后在某一个窗口下，可以用:n filename或者:e filename在这个窗口内载入新文件。垂直分割当前窗口：输入:vsplit。这样窗口会分为左右两部份，可以继续分割；之后在某一个窗口下，可以用:n filename或者:e filename在这个窗口内载入新文件。一次打开多个窗口：输入vi -on file1 file2。这里只用两个文件举例，同时打开file1和file2，打开的窗口按水平方向分为上下两部份。在多窗口内操作：  在上次和本次窗口间切换：输入[Ctrl]w w。跳到左边的窗口：输入[Ctrl]w h。或输入[Ctrl]w [Left]。最后一个键表示移动方向，和移动光标类似。跳到右边的窗口：输入[Ctrl]w l。或输入[Ctrl]w [right]。最后一个键表示移动方向，和移动光标类似。跳到上边的窗口：输入[Ctrl]w k。或输入[Ctrl]w [up]。最后一个键表示移动方向，和移动光标类似。跳到下边的窗口：输入[Ctrl]w j。或输入[Ctrl]w [down]。最后一个键表示移动方向，和移动光标类似。扩大当前水平窗口：输入[Ctrl]w +。这里‘＋’前面可以加输入一个数字，表示迭代次数。缩小当前水平窗口：输入[Ctrl]w -。这里‘-’前面可以加输入一个数字，表示迭代次数。扩大当前垂直窗口：输入[Ctrl]w &gt;。这里‘&gt;’前面可以加输入一个数字，表示迭代次数。缩小当前垂直窗口：输入[Ctrl]w &lt;。这里‘&lt;’前面可以加输入一个数字，表示迭代次数。最大化当前水平窗口:输入[Ctrl]w _。最大化当前垂直窗口:输入[Ctrl]w |。平分窗口:输入[Ctrl]w =。水平分割窗口：输入[Ctrl]w s.垂直分割窗口:输入[Ctrl]w v.退出当前窗口：输入:q.退出并保存当前窗口：输入：wq.退出全部窗口：输入:qa.退出并保存全部窗口：输入wqa.移动窗口上下左右移动窗口位置的命令，是CTRL-W J/K/H/L (:help CTRL-W_H, …)。前提是开了多个窗口(:split或:vsplit)。注意，这里的H, J, K, L是大写的,小写的则表示移动到相应的窗口里面了.  将窗口移动到左面：输入[Ctrl]w H.将窗口移动到右面：输入[Ctrl]w L.将窗口移动到上面：输入[Ctrl]w K.将窗口移动到下面：输入[Ctrl]w J.颜色相关：  改变颜色主题（为evening）：输入color evening。或输入colorscheme evening。改变主题颜色为默认：输入color default。或输入colorscheme default。pages tab标签打开多文件：自从Vim发布7.0之后, 就开始支持标签或者叫标签页. 不像其它程序中的普通标签, Vim的标签页就像是将你打开的文件分组的一种方法. 每个标签能够保存几个打开的缓冲, 并且也能同时处理几个窗口. 实际上一个标签中用yy在另一个page中也可以p上去的。这里给出常用命令，更多帮助可以查看:help tabpage。  启动的时候为每一个文件打开新的page：输入vi -p file1 file2注意：这里file1，file2是文件。打新page：输入tabnew。在当前tab page的后面打开一个新的空窗口的tab page.打新page并且编辑file：输入tabnew file打开新page并执行命令：输入[count] tab {cmd}.这里，新的tabpage在后面第[count]个page上面出现，:0tab {cmd}将会在第一个位置得到一个新的标签.:tab split 使用一个新的标签页打开当前的缓存,即把split的分割窗口放到两个pages里面了。:tab help gt 打开一个tab page 同时执行了:help gt命令.打开新page，并编辑在cursor下的文件:输入CTRL-W gf。关闭tab page当关闭最后一个窗口的时候也会关闭这个标签页命令如下。  关闭当前page:输入:tabclose!。这里加&#39;!&#39;是强制关闭不管保存了，tabclose可以简化为tabc，实践发现:q也行。关闭编号为{count}的page:输入:tabclose count。或输入:tabclose! count。这里加&#39;!&#39;是强制关闭不管保存了，tabclose可以简化为tabc。关闭除了自身的其他pages：输入tabonly。或输入tabonly!。这里加&#39;!&#39;是强制关闭不管保存了，tabonly可以简化为tabo。切换到另外page:  切换到下一个page：输入gt。或输入:tabnext。或输入[Ctrl]PageDown。这里，tabnext可以简化为tabn，都是循环切换的最后一个之后就是第1个(第3个方法好像不管用?)。切换到第{count}号page：输入{count}gt。或输入:tabnext {count}。或输入{count}[Ctrl]PageDown。这里，tabnext可以简化为tabn，第一个page是1，都是循环切换的(第3个方法好像不管用?)。切换到上一个page：输入gT。或输入:tabprevious。或输入:tabN[ext]。或输入[Ctrl]PageUp。这里，tabprevious可简化为tabp，tabNext可简化为tabN,没有tabP，切换循环,第1个之后就是最后一个(第4个方法好像不管用?).切换到前{count}个page:输入{count}gT。或输入:tabprevious{count}。或输入:tabNext{count}。或输入{count}[Ctrl]PageUp。也就是后退{count} page，也是循环的，tabprevious可简化为tabp，tabNext可简化为tabN(第4个方法好像不管用?)。去第一个page:输入:tabfirst。这里tabfirst可简化为tabfir。去最后一个page:输入:tablast。这里tablast可简化为tabl。列出所有pages它们包含的windows:输入:tabs。这里结果中&gt;是当前的window，+是被修改的缓存。移动当前page到第N个后面：输入tabmove[N]。这里，tabmove可以简化为tabm使用0表示移动当前page成为第1个，不使用N表示当前page成为最后一个。在每一个page 中执行命令{cmd}输入:tabd[o] {cmd}。注意的是：它只执行每个page的当前窗口，如果有一个窗口出现了错误，那么就中断后面的访问。这里，tabdo可以简化为tabd。文件浏览：在vim 7.0以前，文件浏览功能由explorer.vim插件提供，在vim 7.0中，这个插件被netrw.vim插件所代替。这里说得是netrw.vim插件。使用vim尝试打开目录时，vim会自动调用netrw.vim插件打开该目录。  打开当前文件的目录:输入:E。水平分割窗口，并打开当前文件目录:输入:He。或输入:Se。垂直分割窗口，并打开当前文件目录:输入:Ve。在前一个窗口打开文件:输入:P。这里，假设光标在目录的某一个文件上面，则在上次打开的窗口打开该文件（适合多文件窗口）.新开一个垂直窗口，打开该文件：输入:v。假设光标在目录的某一个文件上面，则新开一个垂直窗口，打开该文件。新开一个水平窗口预览文件：输入:p。假设光标在目录的某一个文件上面，新开一个水平窗口预览文件，光标仍在该目录中，如果换其他文件再按p则仍在上面的预览窗口中显示新文件新开一个标签打开文件输入:t。假设光标在目录的某一个文件上面，新开一个标签打开文件。以不同模式显示目录中文件：输入i。这里，直接输入i就以不同的模式循环切换显示目录中的文件，如树型，列表等等。更多的命令查看帮助：输入：[F1]下面,列出一些简短的常用操作：  &gt; 显示帮助  &gt; 如果回车，光标下为目录，则进入该目录；光标下是文件，则打开该文件  &gt; -           返回上级目录  &gt; c           切换vim的当前工作目录为正在浏览的目录  &gt; d           创建目录  &gt; D           删除文件或目录  &gt; i           切换显示方式  &gt; R           改名文件或目录  &gt; s           选择排序方式  &gt; x           定制浏览方式，使用你指定的程序打开该文件  关于历史窗口：  打开命令历史：输入q:.这样，就可以打开命令历史窗口，查看以前输入过的命令行命令（就是在:提示符号后面输入的命令）。选择其中的任何一个回车，相应的命令都会被执行。在最后一个空行上面回车就退出相应窗口。打开查找历史：输入q/.这样，就可以打开查找历史窗口，查看以前查找过的字符串。选择其中的任何一个回车，相应的查找都会被执行。在最后一个空行上面回车就退出相应窗口。';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_07View.html"> Vim实践与学习-07显示相关 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-06编程'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '这里的内容是针对编程序或者阅读源代码时候使用的，本来它的有些内容可以属于其它类的，但是这里单独用&quot;编程相关&quot;将这类命令集中起来了。编译并自动定位第一个错误：输入:make filename。注意：在vi中编译test.c,直接用:make test就可以了,注意是不带后缀的哟。如果有makefile的话可以再vi直接敲:make，然后就能够定位到第一个错误上面了。关于ctags跳转：通常我们需要使用名为ctags的程序来生成这样的tag文件。vim能直接使用ctags程序所生成的tag文件。  安装ctags：  $sudo apt-get install ctags注意这里是在ubuntu下。为当前目录文件生成tags文件：  $ctags -R ./或  $ctags -R这里，如果ctags -R ../将会也生成父目录文件的tags，ctags利用tags进行跳转。载入当前标签：输入:set tags=tags.这将载入（当前目录的）所需标签文件，如果不载入则没有ctags所需要的tags文件，为了实现自动载入启动可以在~/.vimrc加入如下内容：  if has(&quot;ctags&quot;)    if filereadable(&quot;tags&quot;)        set tags=tags    endifendif直接打开文件并跳转到函数:    $vim -t func这样，将打开vim并且直接跳转到func函数的位置。跳转到当前光标函数实现内部：输入[Ctrl]].实现这个功能需要有tags标签。回到[Ctrl][之前的位置：输入[Ctrl]T.这里，应该是[Ctrl]]之前的位置，有待修改。分割一个窗口并跳转到当前光标函数实现内部：输入[Ctrl]w ].  跳转到指定函数实现处：输入:tag func.或输入:tselect func这样将跳到func函数的实现地方,tag func如果有多个将自动跳到第1个,tselect func如果多个则显示一个所有匹配列表，让你选择哪个。这里标签名可以用[Tab]进行命令补全.新开一个窗口，查看tag的函数：输入:stag tagname.这里，tagname是一个tag标签（例如函数名）效果相当于首先用:split，再用tag tagname.窗口是水平的。如果有多个tag匹配则：  切换到下一个匹配标签处：输入:tnext切换到上一个匹配标签处：输入:tprev切换到第一个匹配标签处：输入:tfirst切换到最后一个匹配标签处：输入:tlast显示所有匹配标签:输入:tags显示所有匹配标签并让你选择指定的：输入:tselect。关于代码折叠  设置可以折叠输入:set fdm=syntax.或输入:set fdm=indent.这里，fdm实际上是foldmethod的简写,第1个syntax方式是按照语法进行折叠（我倾向用这个所以后面都是对这个方式折叠下的命令），第2个是对大括号内的进行折叠。对当前代码块进行折叠：输入zc.这里，需要把当前光标放置到需要折叠的代码块的内部，因为一般程序结构都是嵌套的，这个命令折叠的是最内层的代码块。对当前代码块所在范围代码块全部折叠：输入zC.这里，折叠的不仅仅是最内层的代码块了，而是连带着递归地折叠了包含该代码块的这个代码块。展开当前代码最外层折叠：输入zo.这里，是对光标下的折叠代码块最外层折叠进行打开，内层的折叠仍旧折叠着，除非你移动到那里再次用这个命令打开折叠，有时候你按一下左右方向键也会打开折叠。展开当前代码包含的所有折叠：输入zO.这里，展开的不仅仅是最外层的代码块了，而是连带着递归地展开了该代码块包含的所有内层代码块。折叠当前文件所有可能折叠的代码：输入zM.这样，将把当前文件的所有可以折叠的代码进行折叠。展开当前文件所有折叠的代码：输入zR.或输入:set foldlevel=999.这样，将把当前文件的所有折叠的代码展开。全部展开或折叠当前文件所有可以折叠的代码：输入zi.这里，相当于zR和zM命令的“综合”，这个命令在全部折叠和全部展开两个命令之间进行“开关”切换。到当前打开的折叠的开始处:输入[z.到当前打开的折叠的末尾处:输入]z.跳到下一个折叠的开始处:输入zj.这里，关闭的折叠也被计入。跳到上一个折叠的末尾处:输入zk.这里，关闭的折叠也被计入。cscope的使用  cscioe功能：可以解决类似如下的问题：符号在哪里实用的？在哪里定义的？变量从哪里得到它的值的？全局变量的定义？这个函数在源代码中的什么文件中？什么函数调用了这个函数？这个函数调用了什么函数？消息“out of space”来自哪里？这个源文件在目录中的结构？哪些文件包含了这个头文件？软件下载：http://sourceforge.net/project/showfiles.php?group_id=4664软件安装:./configure --with-flex (注：如果平台是Linux,最好带上 --with-flex选项)make (注：我没有遇到错误)make install (注： 直接安装好了)cscope配置修改vim配置文件vimrc.你可以修改/etc/vimrc使用所有用户都使用本配置文件，当然你还可以修改~/.vimrc下载cscope配置文件：cscope_map.vim  （http://cscope.sourceforge.net/cscope_maps.vim）把cscope_map.vim里从 if has(&quot;cscope&quot;)? 到 endif里边的内容复制到/etc/vimrc里边去里边的命令意思自己琢磨cscope相关命令生成索引文件,在源代码目录中输入：$cscope -Rb另外，有的时候：$cscope -Rbkq&lt;回车&gt;这里，R 表示把所有子目录里的文件也建立索引b 表示cscope不启动自带的用户界面，而仅仅建立符号数据库q生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度k在生成索引文件时，不搜索/usr/include目录更多查看man.vim下的相关命令：  简单的帮助命令列表：输入:cs help或输入:cscs是cscope的简写命令，后面也是如此。添加一个新的cscope数据库链接:输入:cs add cscope.out这样，把当前目录下面的cscope.out这个cscope数据文件添加了，就可以利用其中的内容了，如果没有链接数据库，那么就用不了相应的功能了。可以把这个命令加入到.vimrc中，省得人工输入。查看当前已经链接的cscope数据库链接:输入:cs show查找相关命令：查找C语言符号，即查找函数名、宏、枚举值等出现的地方输入:cs find s &lt;符号名&gt;.或输入cs f s &lt;符号名&gt;.这里,等价于:cs find 0.    2. 查找函数、宏、枚举等定义的位置，类似ctags所提供的功能:          输入`:cs find g &lt;符号名&gt;`.          或输入`cs f g &lt;符号名&gt;`.      这里,等价于`:cs find 1`.    3. 查找本函数调用的函数:          输入`:cs find d &lt;符号名&gt;`.          或输入`:cs f d &lt;符号名&gt;`.          这里,等价于`:cs find 2`.    4. 查找调用本函数的函数:          输入`:cs find c &lt;符号名&gt;`.          或输入`:cs f c &lt;符号名&gt;`.          这里,等价于`:cs find 3`.    5. 查找指定的字符串:          输入`:cs find t &lt;符号名&gt;`.          或输入`:cs f t &lt;符号名&gt;`.          这里等价于`:cs find 4`    6. 查找egrep模式，相当于egrep功能，但查找速度快多了:          输入`:cs find e &lt;字符串&gt;`.          或输入`:cs f e &lt;字符串&gt;`.          这里,等价于`:cs find 6`，注意没有5.    7. 查找并打开文件，类似vim的find功能:          输入`:cs find f &lt;文件&gt;`.          或输入`:cs f f &lt;文件&gt;`.          这里,等价于`:cs find 7`.    8. 查找包含本文件的文件:          输入`:cs find i &lt;文件&gt;`          这里等价于`:cs find 8`.          以上的`cs find`均可简写为`cs f`.  - 将cscope的数据库内容作为tags:      输入`:set cst`.      或输入`:set cscopetag`.      这样就 会把cscope的数据库当成tag文件了，在只有cscopt.out的情况下可以用[Ctrl]]进入相应的函数了。这样只用cscope不用ctags了。关闭这个功能是`:set nocst`.但是cscope无法在tag的时候自动不全标号，另外，cscope虽然搜索全局字符串似乎挺好，但是在用cscope的方式tag函数的时候，如果源文件修改了例如增加几个空行之类的，那么回出现定位错位，而ctags就不会。  - 察看光标下的函数:      输入`[Ctrl]\g`.      这里，是加入cscope.vim的相关语句到.vimrc中之后有的快捷键。cscope.vim内容在“其他相关“里面最后有列出了。  - 察看调用光标下函数的函数：      输入`[Ctrl]\c`.      还有其他等等，察看脚本内容就知道了，实际是`[Ctrl]\`等价于输入`:cs f`，之后输入相应的字符f,g,c等，就可以查找当前光标下标号的东西了。  到当前局部变量的定义处:输入gd.这里，当前的意思是光标停留其上的单词。  到当前全局变量的定义处:输入gD.  跳转到当前代码块的开头:输入[{.这里代码块一般是用{}扩起来的。  查找在头文件中的某个相关定义：输入[Ctrl]w[Ctrl]i.这样，vim可以直接根据头文件进行查看，察看当前光标下的符号在头文件的相关定义。  注释第1行到第20行:输入:1,20s/^/\/\//g.这里，^表示在行首插入,因为Vim/Vi替换命令格式中默认/为分隔符，这样就需要使用转义符\，表示/就要写成\/才可以，所以命令如上所示。强烈建议各位看官使用，省时省力省键盘还，如果shell的注释符号&#39;#&#39;就不用转义了。  简单重排功能  当前行向右移一个shiftwidth:输入&gt;&gt;.这里， 整行会向右移一个 shiftwidth（预设是 8 个字元，可重设）。当前行向左移一个shiftwidth:输入&lt;&lt;.这里， 整行会向左移一个 shiftwidth（预设是 8 个字元，可重设）。将{},()或[]等符号括起来的文本都右移:输入&gt;%.这里,您必须把光标放在这些符号({},()或[])上面.将{},()或[]等符号括起来的文本都左移:输入&lt;%.这里,您必须把光标放在这些符号({},()或[]`)上面.自动缩进选中代码的格式：输入v，移动光标，选择待调整的代码块，输入=。这里，关键是先进入选择模式选择相应的代码，然后按‘＝’键，如果只按=就格式化当前行（需移动一下光标才看得出来）。打开一个预览窗口来显示函数 write_char：输入:ptag write_char.这样之后，光标会自动移动回原来的位置。窗口是水平的。  关闭预览窗口：输入:pclose.这里，尽管当前光标不在预览窗口，也会关闭预览窗口。  在预览窗口中编辑一个指定的文件:输入 :pedit。这在编辑头文件时很有用，这里的是要编辑的文件名,还可以同时定位到函数比如：:pedit +/funcs defs.h。这样可以在原有光标不变的情况下在预览窗口中修改。  查找当前文件和任何包含文件中的单词并在预览窗口中显示匹配:输入psearch &lt;函数名&gt;。这在使用没有标签文件的库函数时十分有用。虽然它不是很智能，但是它能够到库头文件中搜索。  quickfix定位代码错误的使用Quickfix模式的主要思想是保存一个位置列表，然后提供一系列命令，实现在这个位置列表中跳转。加快你的开发速度。假设:你编写了一个程序，在vi中输入:make调用makefile来编译的时候程序中有错误，回车就会返回编辑界面（实际会自动定位到第一个错误）。运行如下命令可以定位错误：  显示并定位到第n个错误：输入:cc n.这样就会自动定位到第n个错误的位置，并显示相应的错误信息，如果没有n参数，就重现当前错误信息。定位到当前错误的下一个错误处：输入:cn.这样如果当前在第n个错误的状态，这样会切换到第n+1个错误并定位到相应的位置。定位到当前错误的上一个错误处：输入:cp.这样如果当前在第n个错误的状态，这样会切换到第n-1个错误并定位到相应的位置。列出当前所有错误列表：输入:cl.这样列出一个错误列表，只是显示出了所有错误回车就又回到先前界面了。在当前窗口底部打开一个quickfix窗口列出所有错误信息：输入:cw.这样会在当前窗口底部新开一个窗口，方便的看到所有错误信息，还可以把光标移动到相应的错误之处然后回车，就会回到代码窗口并定位到相应的错误位置。回到上一个错误列表：输入:colder.或输入:col.这样回到上一次的quickfix错误列表，例如再次编译还有错误，这个命令返回的是上次而不是这次的错误列表，运用cw等都是上次的错误信息。进入较新的错误列表：输入:cnewer.或输入:cnew.这个命令的作用和前面colder相反，进入更新的错误列表。关于自动补全：  显示自动补全列表：输入[Ctrl]p这里，是在插入模式下进行的，例如当前输入了aa字符，然后输入[Ctrl]p这样会列出所有以aa为开头的单词列表。它们会在当前缓冲区、其它缓冲区，以及当前文件所包含的头文件中查找以光标前关键字开始的单词。选择自动补全列表中匹配的下一项：输入[Ctrl]n.这样如果有多个匹配的单词项那么会高亮下一项进行选择。如果不够则循环显示。选择自动补全列表中匹配的上一项：输入[Ctrl]p.这样如果有多个匹配的单词项那么会高亮上一项进行选择。如果不够则循环显示。自动匹配整个行：输入[Ctrl]x[Ctrl]l.这里，注意要在编辑状态下面运行的，会弹出文件中所有的整个行，之后用[Ctrl]p等就可以自动匹配了。如果CTRL-N和CTRL-P补全时查找所包含的头文件，耗时会比较久。此时，可以在’complete‘选项中去掉&#39;i&#39;标记:set complete-=i 。';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_06Programing.html"> Vim实践与学习-06编程 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-05定位'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '定位到指定行n:输入:nG.或输入:ngg.或输入::n这里,n就是指定的行的行号.注意，有时候G=gg.跳到屏幕顶部：输入:H.这里，停在第一个非空字符上。加一个数字N，是指距窗口顶部的行数（如NH正数第N行）跳到屏幕底部：输入:L.这里，停在第一个非空字符上。加一个数字，是指距窗口底部的行数（如NL倒数第N行）跳到屏幕中间：输入:M.这里，停在第一个非空字符上。跳到文件首：输入:gg.  跳到文件尾：输入:G.  光标移至句尾:输入:).  光标移至句首:输入:(.   光标移至段落开头:输入:}.   光标移至段落结尾:输入:{.   跳到行末尾：输入:$.  跳到行首:输入:^.或输入:0.这里输入^是移动到首的第一个非空白字符。  向后跳到整文件最近距离的单词末尾：输入:e.  向前跳到整文件最近距离的单词首部：输入:b.  跳到整文件下个单词首部:输入:w.  行内移动以下均可可以加上数字N前缀表示移动N次（如3fc表示执行fc3次。）  移动到光标右面第一个字符c的后面:输入:fc.移动到光标右面第一个字符c的前面:输入:tc.移动到光标左面第一个字符c的前面:输入:Fc.移动到光标左面第一个字符c的后面:输入:Tc.重复前一次输入的f, t, F, T命令:输入:;.例如刚才是fc，输入;相当于还是fc。会反方向重复前一次输入的f, t, F, T命令:输入:,.例如刚才是fc，输入,相当Fc。在较长行内的移动：这里做一个小小的约定：较长的一行如果占据了屏幕的多行，那么这一行我们把它叫“长行”，屏幕上的一行叫做“屏幕行”。所以对于一个&#39;长行&#39;需要有多个&#39;屏幕行&#39;来显示。  在“长行”中移动到下一个“屏幕行”：输入:gj.在“长行”中移动到上一个“屏幕行”：输入:gk.在&quot;长行&quot;中移动到当前&quot;屏幕行&quot;首：输入:g^.在&quot;长行&quot;中移动到当前&quot;屏幕行&quot;尾：输入:g$.这里，如果一行超过了屏幕宽度，会显示在屏幕的多行，显示的虽然是多行，但是实际上还是一行，在输入上下移动的时候虽然是进入了上一行或者下一行，但是往往会呈现出在屏幕中一下跳过n行的样子。g$,g^, gj ,gk 在行超过长度时好用。 j,k下上移动的是文本中的一行，当文本一行的长度超过屏幕的一行的时候，j,k移动的时候在屏幕上可能是移动多行。这时候可以用gj,gk来移动屏幕的一行而不是文本的一行。 同理g^和g$是屏幕的行首行尾，而不是文本的行首行尾。按百分比来跳转,跳转到文件50%处：输入:50%.这里利用%实现按百分比来跳转，如果想跳到75%处，输入75%。  翻页可以跟数字前缀N表示执行的倍数，翻页可以用[PageUP]/[PageDown].  向下翻页：输入:C-f.向上翻页：输入:C-b.向下翻半页：输入:C-d.向上翻半页：输入:C-u.相对于光标的翻页效果是行向相应的方向滚动了，光标仍然在原来的行，好像是将这个文本拖动了一样.  光标所在行移动窗口的顶端:输入:zt.光标所在行移动窗口的中间:输入:zz.光标所在行移动窗口的底端:输入:zb.将第n行滚至屏幕顶部：输入:nzt。将第n行滚至屏幕底部：输入:nzb。将第n行滚至屏幕中部：输入:nzz。设置书签：输入:ma.这样，会在当前光标的位置标记一个书签，名字为 a。书签名只能是小写字母。你看不见书签的存在，但它确实已经在那里了。只能记录当前文件里的书签,退出vim后再次进入将不会保留这些书签, 书签只是当前文件中的一个位置，但是我实践一下发现，设置完了书签之后，保存文件，这样也把书签保存了。  到书签a处：输入:`a.注意,这个不是单引号，它一般位于大部分键盘的 1 的左边。  到书签a所在的行：输入:&#39;a.这里用的是单引号，将跳到书签所在的行。  到上次编辑文件的地方：输入:`..这个命令很有用，而且你不用自己去标记它，注意这里输入的是反引号`,精确到点。  到上次编辑文件所在行：输入:&#39;.注意这里是精确到行，输入的是引号&#39;。  回到最后一次插入状态返回的位置：输入:&#39;^.或输入:`^.这里&#39;.精确到行，`.精确到点（行+列）。  查看当前所有书签的列表：输入::marks.  搜索相关：  搜索一个字符串：输入:/string。这里string就是将要被搜索的字符串，会自动跳到光标后面第一个string处。在上次搜索的基础上向前搜索：输入:N。在上次搜索的基础上向后搜索：输入:n.逆向搜索一个字符串：输入:?string。这里string就是将要被搜索的字符串，会自动跳到光标前面第一个string处。之后使用的:n和:N命令方向也会相反了。列出查找的历史记录：输入:q/.或输入:q?.这会在vim窗口最下面打开一个新的窗口，列出你的查找历史记录可以选择。向下完全匹配当前光标下单词：输入:*。之后也可以按n继续向下查找。向上完全匹配当前光标下单词：输入:#。之后也可以按N继续向上查找。向下匹配包含当前光标单词的字符串：输入:g*。向上匹配包含当前光标单词的字符串：输入:g#。跳到匹配的另一半括号：输入:%。这样可以查找配对的括号，即： )、]、}。  打开当前光标单词下的文件：输入:gf。这里，假设当前的光标在相应的文件名上面，例如main.c等等。  切换到上次打开文件：输入:C-^。这里，例如我们输入了gf进入某个文件，可以输入C-^来回到刚才的文件，这个命令只能在当前和上一个文件之间切换，不能后退多步。  后退到某个曾经浏览过的位置:输入:C-o.流行的文本编辑器通常都有前进和后退的功能，可以在文件中曾经浏览过的位置之间来回移动。在vim中多次输入C-o可以执行后退。  前进到某个曾经浏览过的位置:输入:C-i.或输入:[Tab].这样，如果执行过后退，在vim中多次输入C-o可以执行前进。  ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_05Jump.html"> Vim实践与学习-05定位 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-04编辑'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '输入模式进入输入模式:输入i.或输入a.这里，输入i是在字符前开始插入，输入a是在字符后开始插入。直到输入ESC退回到命令模式。删除当前光标字符并进入插入模式（替换字符）：输入s.这里注意 是小写的s,这个命令和 R 不同，R 是覆盖式的取代并不切换模式，s 则是插入式的取代，相当于输入x删除一个字符，再输入i进入插入状态。清空当前行并进入插入状态（替换当前行）：输入cc.或输入S.这里，第二个是大写 S。这个命令的效果相当于dd删除一行并且在原来行的位置上面插入一个空行，光标放在空行上面再进入插入状态。 这里和c相关的操作与和d相关的操作类似，不过最后c操作会进入插入模式。清空一个字（替换一个字）并进入插入状态：输入cw.这里， cw 替换一个英文字(word)，中文不适用。(change)相当于用dw删除一个词，然后进入插入状态。取代至行尾并进入插入状态：输入C。或输入c$。这里，注意第一个是大写C，第二个是小写c.这个命令会把当前光标(包含光标下字符)至行尾内容删除在进入插入状态。即相当于D之后进入插入状态。取代至行首并进入插入状态：输入c0.或输入c^.这里，将会把当前光标(不含光标下字符)至行首内容删除。经过实践，发现两者区别是c0 取代至行最开始无论原来行以什么字符开始，而 c^则当原来行以空白开始的时候，不会删除开头的那几个空白。删除之后，两者都自动进入插入状态。总结一下：我们可以结合后面这样理解：s操作类似x，不过最后也进入插入模式，一般是单字符的命令；c相关的操作类似d，不过最后进入插入模式，一般是多字符的命令（即cc,dd,cw,dw等）；删除删除一个字符：输入x。注意：结果是光标所处的字符的消失，后面的文字左移动，假如没有任何文字了，喇叭就叫，同时将删除的内容保存到剪切板中。如果x前面有数字N那么就是重复N次。删除当前行:输入dd。注意： 可以跟数字，（如：5dd 将删除 5 行），同时将删除的内容保存到剪切板中。删除从光标到行尾:输入D。或输入d$.这样，将当前光标（包含当前光标所在的内容）一直到以后的内容全部删除。删除到当前词尾输入dw.删除整个单词输入daw.删除当前字符输入dl.上面许多例子实际是d{motion}，即d--删除对象的命令,d命令的右边要有一定的文字对象,文字对象就是控制光标移动的那些字符;例如 w 表示到下一个单词首，那么 dw 将删除光标至当前单词尾;同理，5w 表示前进 5 个单词，那么 d5w 将删除他们(daw比较特殊， delete a word)。用&quot;数学语言&quot;描述，上面的删除范围是：[光标起始，光标终点)。也可用d /text 删除从文本中出现&quot; text&quot;中所指定字样的位置，具体需要实践。c也有相应的c{motion}不过删除之后紧接着会进入插入模式的。删除当前光标至&quot;text&quot;之间的文本：输入d/text.这样， 删除从文本中出现&quot;text&quot;中所指定字样的位置，一直向前直到下一个该字样所出现的位置（但不包括该字样）之间的内容。复制复制当前行:输入yy。或输入Y。注意： 可以跟数字，（如：5yy 将复制当前和后面的共5 行）到剪切板中。复制当前光标到词尾：输入yw.复制这个单词：输入yaw.复制书签a和当前光标之间内容：输入y`a.这样，可以利用标签进行成块数据复制，需要注意的是，这里`a是反引号的，复制的内容包含设置书签时所在光标的字符，但不包含当前光标所在字符。复制当前光标行和书签a所在行之间内容：输入y&#39;a.这样包括当前光标行以及书签行在内的两行之间的内容全被复制，这里&#39;a用的是单引号。这里的例子同d--删除对象一样的道理，不多说了。粘贴:  粘帖上次删除或复制的内容输入p.注意：按p会将最近删除或复制的粘贴(vim中的删除一般就是我们平时所说的“剪切”）。交换两个字符位置：输入xp.这里，实际是先x删除字符，再p粘贴先前删除的字符。上下两行调换:输入ddp.这里，原理同xp.指定范围的编辑：把n,m之间的内容拷贝到k行的下面(空格可省略):输入:n,m co k。或输入:n,m copy k.只复制不粘贴第n,m行之间的内容(空格可省略):输入n,m y。剪切n,m行之间的内容到剪切板中(空格可省略):输入:n,m d。或输入:n,m delete k。把n,m之间的内容拷贝到k行的下面(空格可省略):输入:n,m m k.或输入n,m mo k.或输入:n,m move k.粘帖到k行下：输入:k pu.或输入:k put.后面可以接寄存器名字。可视模式下：进入可视模式：输入v。或输入V。这里，进入可视模式后，如果进行移动操作（例如h、j、k、l等），将会高亮显示进入可视模式时的光标所在字符（行）和你移动之后的字符（行）之间的部分表示你选择了这块文本。输入v是按字符单位进行选择，输入V是按行单位进行选择。选择之后，可以对选中文本进行操作。选择一块数据：输入C-v.按方向键选择相应的数据。这里，按下方向键之后，选择的数据会以列为单位选择，不想v是以行为单位了。实践一下就知道我说的是什么意思了。剪贴可视模式选择的内容到剪贴板：输入d。拷贝可视模式选择的内容到剪贴板：输入y。剪贴可视模式选择的内容到剪贴板并且进入插入模式：输入c。如果你很清楚的知道你想拷贝或者剪切什么，那你根本就不需要进入可视选择模式。这样也会节省时间。所选内容向右移动n个Tab：输入[n]Shift &gt;.这里Tab次数用[]括起来,也可以没有这个[n]代表只有一个Tab.所选内容向左移动n个Tab：输入[n]Shift &lt;.这里Tab次数用[]括起来,表示也可以没有这个[n]，即只有一个Tab.替换相关替换当前光标一个字符步骤：  定位到待替换字符A.输入r.输入要替换成的字符B。这样，字符A就变成了字符B。替换多个字符步骤：输入R。定位到将要被替换的字符A.输入要替换成的字符B.如果继续替换，则再次回到2执行否则输入[ESC]完成替换。这样就完成了多个字符的替换。在当前行替换全部：输入:s/old/new/g。这里，可以把当前行的所有字符串“old”替换为“new”。在当前行替换第一个：输入:s/old/new。这里，将只替换当前行第一个匹配的字符串old为new。指定范围的替换：输入:#,#s/old/new/g。这里，#,#表示表示范围的两个行号，命令会把两个行号之间的所有字符串“old”替换为“new”。整个文件的替换：输入:%s/old/new/g.这里将把整个文件中的所有字符串“old”替换为“new”。忽略大小写的替换：输入:%s/old/new/gi.这里加上i，替换时忽略大小写即大小写是一样的。带有确认的替换：输入:s/old/new/gc.这里，加c仅以当前行范围内替换确认进行举例了，其他范围类似。结果是，在替换字符串“old”为“new”之前，将会询问(replace with to (y/n/a/q/l/E/Y) )。 输入y表示替换当前这个，n表示这个不要替换，a表示全部替换，q表示退出，不替换了,l表示把当前这个替换后就退出，^E([Ctrl]e,好像大小写都可以)表示向下滚动一行， ^Y([Ctrl]y,好像大小写都可以)表示向上滚动一行。令游标所在处之大小写互换:输入~.这里，只适用于英文，当然不要忘记输入的时候按SHIFT.为光标下或者光标后面的数字增1：输入CTRL-a.这样，当前光标或者光标后面有数字的话，光标就会跳到那个数字的地方，并给那个数字增1。例如有一个326那么就会变成327.上下两行合并输入J.这里实际就是把当前行的换行符号变成了空格，这样下一行就合并到这行中了。撤销刚才的操作:输入u。恢复:输入CTRL-r。和u相反。重复上次编辑:输入.。寄存器关于寄存器相关的命令帮助输入:help redo-register或寄存器的其它引用方式:h i_CTRL-R数字寄存器vim中最常用到的寄存器，当不指定寄存器时，复制操作的内容被保存到&quot;1，删除操作的内容被压到&quot;2，同时原先&quot;2的内容转到&quot;3，依此类推，原先&quot;8转到&quot;9，原先&quot;9的内容丢失。如果指定操作的寄存器，如&quot;ayy和&quot;bdd，则上述的数字寄存器无影响（有些例外情况，详见Vim手册,这里我发现用&quot;add等删除的时候，&quot;d,&quot;1,&quot;&quot;三个寄存器内容就都一样是最近的操作了）。寄存器&quot;&quot;未命名寄存器&quot;&quot;保存最近一次复制或删除操作内容，无论是否指定寄存器。寄存器&quot;.保存上一次插入的文字,也就是你上次切换到插入状态下(包括临时切换的CTRL-o)，输入的文字。寄存器&quot;%保存当前文件名,&quot;#保存替换文件名(即上次操作的文件)文件是相对vi当前路径的路径名。寄存器&quot;_这是一个特殊的“黑洞”寄存器&quot;_，当指定其进行删除时，包括&quot;&quot;在内的任何寄存器都不受影响，当然，你也没法把掉进黑洞的物质p出来。寄存器&quot;/vim将最近一次的搜索文字保存在&quot;/中，对应的变量@/决定了n/N命令和查找高亮的对象。@/被所有buffer共享，也就是说在一个buffer里进行新的查找，其它buffer的匹配高亮和n/N命令也随着更新。寄存器&quot;=这个寄存器与众不同，它不存储文本，而是在可以使用寄存器的场合中提供了用表达式求值并取得其结果的途径。简单的说，就是在指定&quot;=时，Vim会提示输入一个表达式，然后将求值结果返回，至于这串文本如何使用，就看在什么地方使用了。寄存器&quot;:这个寄存器记录最近一次运行的命令行命令，因此@:是重复上次的命令行操作(也就是:提示的命令而不是dd和yy等)。值得注意的是，@x宏运行的是normal命令，而@:运行的是Ex命令。如果某个寄存器&quot;x保存的是Ex命令，你可以用:@x来执行。比如在测试vimrc中的某条命令时，先yy，然后:@&quot;执行。总之不管什么是normal命令和Ex命令？了，&quot;:寄存器里面存的就是命令行:提示下输入的命令，其他寄存器（假设为x）内容如果是:set nu那么可以直接由@x来运行，如果是set nu,那么需要用:@x来运行。&quot;和&quot;+寄存器两个特殊的“全局性”寄存器：帮助入口:help clipboard.在vi中用:reg看一下,有没有&quot;+一项.如果没的话,就不支持对&quot;+的访问，需要安装一下vim-gtk（或者vim-full）.$apt-get install vim-gtk&quot;+寄存器，是一个“全局性”的寄存器，对应于X11的剪切板，当使用vi和其他gui程序进行互相复制粘贴的时候，实际使用的就是&quot;+寄存器（xterm不行，xterm的双击自动复制是用&quot;寄存器）。&quot;*寄存器，也是一个“全局性“的寄存器，可以在vi和其他vi程序之间互相访问或者vi和xterm等一些特殊的程序之间互相访问（个别时候没有&quot;+的时候也充当X11剪切板）。察看当前各个寄存器中的内容用：输入:display.或输入:di.或输入:reg.察看寄存器1的内容：输入:display 1.或输入:di 1.总之，diaplay后面接寄存器的名就可以显示寄存器的内容了。将当前行放入寄存器a中：输入 &quot;aY.或输入&quot;ayy.这里，vim 有多个所谓寄存器来寄存剪切的内容,寄存器引用要使用&quot;r(r是寄存器名字).粘贴寄存器a的内容:输入&quot;aP.粘贴寄存器中的内容：输入：&lt;C-r&gt;。或输入：&lt;寄存器名&gt;这里，寄存器名可以是26个字母或者数字等等，具体应该参见编辑相关里面的寄存器相关操作。例如我在输入模式下想要把寄存器a中的内容粘上去，就输入&lt;C-r&gt;再输入a.粘贴1号寄存器中的内容(并重复循环粘贴)：输入&quot;1p.这里，若p命令时指定数字寄存器，则后续的.命令会自动将数字寄存器的编号加一，也就是说执行&quot;1p之后，第一个.执行的是&quot;2p，依次类推,到最后一个之后就会粘贴空的内容了。粘贴之后光标停留在粘贴出的文字之后：输入gp.或输入gP.这里结果相当于先p后dw.问题是要重新定位需要删除的部分。与p/P功能一样，不过光标停留在粘贴出的文字之后，便于随后的删除。(p与P区别是：P粘贴之后，光标位置不变，而p粘贴之后，光标始终随着刚在被在前面粘贴的字符向前走)在插入模式或命令行中或搜索时候的/等之后插入寄存器&quot;x的内容：输入x.这样寄存器&quot;x的内容将插入到相应的位置，x是寄存器名称。在命令行中直接引用寄存器x内容：输入:@x.这样，相当于把寄存器x中的内容输入进去了,x同样是寄存器名称，这里使用@把寄存器当作变量来使用可以用于脚本。使用&quot;=寄存器十六进制转十进制：  插入模式下输入CTRL-r输入=输入0x1234这样，回车之后就会自动插入十进制的4660了。+ 在不同vi程序之间互相复制粘贴：    1. 在vi中输入v之后，选择一段文字（或者定位到某一行）。    2. 在vi中输入&quot;*y(或者行复制用&quot;*yy).    这样就把内容复制到寄存器&quot;中了。    3. 在另一个vi输入`&quot;p`。  这样就把刚才vi中复制到&quot;*中的内容粘贴出来了。+ 使用vi和其他图形程序（例如gedit）之间剪切板互访：    1. 在gedit中用鼠标选中文本，并且右键-&gt;复制。    2. 在vi中输入&quot;+p。    这样就将之前在gedit中复制的文本粘贴到vi中了,注意这里是三个字符&#39;&quot;&#39;,&#39;+&#39;,&#39;p&#39;.    3. 在vi中输入v之后，选择一段文字（或者定位到某一行）。    4. 在vi中输入&quot;+y(或者行复制用&quot;+yy).    这样就把相应的内容复制到寄存器&quot;+中了。    5. 在gedit中右键-&gt;粘贴。  这样就把vi的寄存器&quot;+中的内容粘贴上去了。+ 设置&quot;寄存器共享且默认：    输入:set clipboard=unnamed.    设置之后，使用vi中的复制命令的时候，会自动把内容也放在&quot;寄存器中。粘贴的时候，也自动使用&quot;寄存器了,而不是默认的数字寄存器。这样多个vi程序之间可以方便地互相复制粘贴了，而不用在加&quot;前缀指定寄存器了。    当然如果另外一个vi程序没有设置这个选项那么它还是要用&quot;前缀的。去掉这个设置好像是:set clipboard=.  宏寄存器与宏是紧密相连的宏的相关帮助命令入口如下：:h q:h @:h :@宏是Vim中非常重要的功能，用来重复执行多个连续操作。当包含移动、查找、插入、修改等不同类型的命令时，宏显得尤其方便，很多时候用:s和:g难以实现的功能，宏都可以轻松搞定。  用q录制宏实际上是将键盘输入记录到寄存器的过程，而用@运行宏则是将指定寄存器内容作为normal命令执行的过程。q命令提供了“所做即所得”，但有时候直接修改寄存器更为方便。比如当你录制完一个非常复杂的宏，但发现有一个小毛病（例如应该是de而不是dw），不必重新录制一遍，只需要将寄存器的内容p出来修改好再y回去。宏有一些运用的技巧：容许错误：录制过程中如果有错不必放弃重来，可以undo或，只要保证这些操作和处理文本无关，寄存器里有些乱七八糟的东西又何妨。分而治之：当录制一个很复杂的宏时可以考虑分成几段，比如qa第一步，qb第二步，然后在qc中调用a和b，各个击破简单易行。重复运行：@@命令可以重复上次的宏调用。另作它用：q命令是向寄存器里录入命令，你也可以什么都不录！用处例如清除&quot;a最快的方法：qaq。假设进行的操作为&lt;某操作&gt;，使用宏你可以重复多个不同的操作. 使用宏的步骤如下：输入qa.这里，开始把一段宏记录入寄存器变量a中，共有26个可用的寄存器供你记录宏。输入&lt;某操作&gt;.这里，象平常一样键入要进行的操作, 只是这些操作都会被Vim记录进前面名为a的宏中。输入q.这里再次再下q键, 就结束了宏a的录制.输入@a.这里，重复执行你刚才记录的那些操作时只要使用@a命令，引用那个宏。可以前面加数字前缀表示执行次数。重定向：信息重定向会把你输入的命令的输出重定向到指定的寄存器或者文件中。帮助入口是:help redir.把命令的输出重定向到寄存器中：输入:redir @a.这里，指定输出会定向到寄存器a中，当前显示中会看到相应的输出。输入&lt;你要输入的一个或者多个命令&gt;.这里，命令可以是命令状态下的命令如搜索命令/等,用:引出的命令等,甚至进入插入提示的--INSERT--。输入:redir END.这里，小写的也行。执行以上三步之后，那些命令的输出了被显示的同时也存在了寄存器&quot;a中。把命令的输出重定向到文件中：输入:redir &gt;&gt;file.这里，指定输出会定向到file中，当前显示中会看到相应的输出。使用&gt;&gt;表示追加，使用&gt;表示清空并加入。输入&lt;你要输入的一个或者多个命令&gt;.这里，命令可以是命令状态下的命令如搜索命令/等,用:引出的命令等,甚至进入插入提示的--INSERT--。输入:redir END.这里，小写的也行。执行以上三步之后，那些命令的输出了被显示的同时也存在了文件file中。';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_04Edit.html"> Vim实践与学习-04编辑 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-03文件'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '这里包含在shell下执行vim,以及vim中关于文件操作的内容。打开一个文件file进行编辑等操作：$vi file打开文件，并将光标置于第n行首：$vi +n filename这里输入得都是shell下进行得，是shell命令，打开之后光标在屏幕中间，而屏幕中间的行就是第n行。打开文件，并将光标置于第一个与pattern匹配的串处：$vi +/pattern filename这里输入得都是shell下进行得，是shell命令。在上次正用vi编辑时发生系统崩溃，恢复filename:$vi -r filename 以只读方式打开文件:$vi -R file或$view file这里输入得都是shell下进行得，是shell命令。其中view是unix得命令，有的linux有。vi下临时切换到shell执行shell命令:输入:!command。注意：这里command是命令名字(例如ls).查看当前编辑的文件和行号:输入&lt;C-g&gt;。或输入:args,查看当前编辑缓冲文件状态(文件名).显示当前光标所在行的行号：输入:nu.这里只是在底部“状态栏”的位置显示一下当前光标所在的行号以及行。保存:输入:w。若输入:w file(效果和另存为文件file一样).载入（创建）一个新文件（&quot;file&quot;）:输入:e file。或输入:n file。或输入:hide e filename。这里，类似于新建文件或者新打开一个文件，当前文件的窗口将会被待编辑的文件所占用，如果当前文件没有保存会提示的。实质上是隐藏当前文件到buffer缓存,打开另一个文件进行编辑，具体见缓存部分。在新窗口载入（创建）一个文件(file)输入:vnew file。或输入:vsplit file或输入:split file这将新开一个垂直的分割窗口，并在新开的窗口中载入相应的文件（:split file是水平窗口）。将当前文件以及改动保存到另外文件中输入:w FILENAME.这里，FILENAME是另外的文件名，执行之后仍然停留在当前文件中,只是目录中多了一个FILENAME文件（即另存为）.只保存文章的某个部分到另外文件：输入:#,# w TEST。这里的 #,# 就是要求您记住的行号范围(最小行号,最大行号)，而 TEST就是选定的文件名。向当前光标中插入另外的文件的内容：输入:r FILENAME.这里，FILENAME是要插入的文件名,r前面可以指定一个行号，表示把内容插在这个行号后面。在buffer缓冲内操作文件相关  列出当前打开的文件，以及编号:输入:buffers.或输入:ls.假设我们打开一个文件，之后用n来切换到另外一个文件中，或者用tabnew打开新文件，那么原来的文件以及现在的文件都会在buffers中，并且yy等命令复制的原来的文件的内容还能用。列表前面的前缀%表示当前文件，#表示可以用[Ctrl]^等切换的可用buffer,其他的可以查看:help ls或者:help buffers.切换成第N个缓冲:输入N ctrl^.或输入:buffer N.这里，注意第一种方法不用输入:，两个buffer文件之间也可用yy,pp.新开一个窗口，载入第N个缓冲区的文件：输入:sbuffer N.窗口默认是水平的。切换到下一个文件:输入:bn.切换到上一个文件:输入:bp.关闭当前文件:输入:bw.这样会关闭当前文件进入下一个buffer的文件，并且当前文件也会从buffer列表中删除。跳至下一个文件:输入:n.当然这里打开文件的方法应该是$vi file1 file2 file3才行。如果用vi file1之后用:n file2这样不行。回到刚才编辑的文件:输入:e#.或输入[Ctrl]^例如运行了vi a b c,当前编辑文件为a，:n跳至b,再:n跳至c,:e#回到b,想回到a的话用:ea。退出:输入:q。保存退出:输入:wq.或者输入:x.或输入ZZ.强制退出:输入:q!(可能未保存)。退出所有：输入:qa.这里如果打开多个窗口或者文件的时候，使用这个命令可以实现一次性退出。查看当前编辑缓冲文件状态(文件名)：输入:args。';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_03File.html"> Vim实践与学习-03文件 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-02输入模式'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Vim基本模式Vim中有6个基本模式和6个基本模式的变种的辅助模式，后面的讲述中会涉及到这些模式。这里将这些模式做一个简单介绍，更多文档请参考vim手册中 *vim-modes-intro* *vim-modes* 部分的内容（可通过:help vim-modes浏览）。Normal Mode也被称作Command Mode。是Vim启动后默认进入的模式（除非设置设置了insertmode选项），该模式下不能编辑文件内容，但是可以接收大多数编辑指令（例如拷贝、删除、修改保存等）。Visual mode类似Normal Mode Mode，在Normal mode中通过V或v可进入该模式下，该模式中任何移动光标的动作都会将光标所经过的区域高亮，非光标移动的指令作用于高亮区域；设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- VISUAL --。具体可参见 :help Visual-mode。Select mode类似Visual mode，但是命令有很大不同。在Visual mode中输入&lt;C-g&gt;、或者在Normal中输入gh、gH、g &lt;C-h&gt;等可以进入该模式。它有点像MS Windows中的选择模式，键入一个可打印的字符后，会删除选择区域并进入插入模式。设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- SELECT --。Insert mode在该模式下你键入类似打开普通编辑器（如记事本）的状态，在Normal mode中键入i、a、o、s等都可以进入该模式。在该模式下可以键入你想插入的字符，字符会被插入到当前文件缓存中。设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- INSERT --。具体可参见:help Insert-mode。Command-line mode/Cmdline mode该模式下你可以在窗口底部键入一行文本，完成复杂的操作指令。从Normal mode进入该模式的方式，比如用于 Ex命令键入:，用于搜索键入/和?，用于过滤内容键入!、=……具体参见:help Cmdline-mode。Ex mode类似Command-line mode，在Normal mode中通过键入Q、gQ可以进入该模式。该模式下输入的命令和Command-line mode中的差不多，但是输入完一条命令之后，你会保持在Ex mode中继续输入其他命令，期间当前屏幕不会刷新，键入vi会退出该模式。具体参见:help Ex-mode。Vim的辅助模式除了基本模式之外，Vim还有六个辅助模式，如下。Operator-pending mode该模式类似Normal Mode，但是在一个操作命令开始之后，Vim会等待一个{motion}（移动），来指定操作对应的文本。Replace mode该模式是一种特殊的Insert mode，你可以进行和Insert mode一样的操作，但是不同的是每次你键入一个被插入的字符之时，插入之处原来所在的字符就会被替换成你键入的字符。设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- REPLACE --。Virtual Replace mode该模式类似Replace mode，不同的是它会替换屏幕当前的内容状态，在Normal mode中键入gR会进入该模式。设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- VREPLACE --。Insert Normal mode该模式类似Normal mode，在Insert mode下键入&lt;C-o&gt;可以进入该模式，该模式下执行一条Normal mode命令后，又会回到之前的Insert mode。设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- (insert) --。Insert Visual mode这个模式类似Visual mode，是在Insert mode中进入 Insert Normal mode后再键入v、V、&lt;C-v&gt;，该状态结束后，会回到Insert mode。设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- (insert) VISUAL --。Insert Select mode这个模式类似Select mode，是在Insert mode中进入 Insert Normal mode后再键入从Normal进入Select mode的命令，会进入该模式，该状态结束后，会回到Insert mode。设置showmode选项为on后，可以在窗口底部看到进入该模式的提示-- (insert) SELECT --。最常见的模式及相关操作前面介绍了Vim的多种模式，内容较多，为便于理解和继续，这里给出其中最常见的模式和相关操作。深入理解可在学习完本系列文章后再回顾。内容是在输入模式下的功能。输入模式主要有如下的操作：回到指令模式(Command mode)：输入：&lt;Esc&gt;.输入内容：输入：...[你要输入的字符串]...在这里，直接输入相应的字符即可。临时切换到指令模式，执行完命令之后自动回到输入模式(Insert mode)：切换指令模式时输入：&lt;C-o&gt;.回到输入模式时输入：&lt;Esc&gt;本文剩余部分介绍的大部分都是指令模式的相关操作。';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_02Input.html"> Vim实践与学习-02输入模式 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Vim实践与学习-01简介'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = '什么是Vim没有明确的定义，这里给出一些经验性的概括Vim是上世纪这个世界上诞生的两款最著名的编辑神器之一，另外一个是EmacsVim和Emacs若只提两者之一而不提另外一个，这个世界便显得不平衡这两款编辑器均诞生在Linux/Unix平台上，后来也被移植到其他操作系统中二者是软件世界中的神话，历经半个世纪的洗礼、淘汰筛选、甚至它们本身相互之间的圣战至今，仍然长盛不衰，其强大之处让其它同类工具望尘莫及虽说是传闻但是在各个不同版本和来源上的传闻都意指：真正强悍的程序员开发使用的不是IDE，而是Vim和Emacs本人喜欢寻找各类功能强大、灵活、方便的开发以及文档撰写编辑等工具，随着经验、技术和实践、成长的积累，最终也渐渐将目标集中在这两款编辑器中有人甚至总结出世界上有三种程序员：使用Vim的程序员、使用Emacs的程序员、和其它程序员本文主要介绍Vim编辑器，Emacs的介绍放在其它之处目前我们实际使用的都是Vim，它其实是vi的改进版本之一，是最流行的改进版本，所以现在所说的Vi基本上就是Vim了Vim能做什么Vim能够处理的事情很多，前面说了那么多空话，为避免有广告之嫌，这里列出其中一些常用的功能应用：  编辑和浏览文本文件浏览和管理文件目录阅读程序源代码提供编程、调试环境利用自带的脚本语言扩展自身自动化智能、批量地处理文本等等……与其他编辑器的比较这里的比较主要是针对与它的“对手”Emacs而言，前面众多说法中，有一种可以这样解释：在Linux/Unix界，有三种编辑器：一种是Emacs，一种是Vim，还有一种是除此之外的编辑器，由此可见Vim在编辑器领域的地位。操作理念不同Vim与Emacs，两者各有千秋，下面只列出其中少许Vim侧重简洁、快速、高效；Emacs侧重大而全、具有超强的扩展与配置能力Vim更专注于编辑功能本身，将编辑功能发挥到极致，将每一次的操作任务一气呵成Emacs注重全面，集成了编辑中你能想到的方方面面，将因频繁切换被打断的思路减至最少等等……其实，Vim更算是一款编辑器，而Emacs则像是隐藏在编辑器下的操作系统。工作方式不同有人做过这样的比喻，Vim是编辑器之神，Emacs是神之编辑器。使用Vim时其编辑之高效，将所思想如行云流水般实现随着对Vim的熟练，甚至不注意时操作会超越思维，还没有想完下一步的操作，手指就已经被Vim控制着完成了任务使用Vim容易让人有种走火入魔，成为“编辑器神之奴”的感觉使用Emacs时总会不满当前操作效率，对当前的编辑操作提出更高要求；不满过后，总能在后续的完善配置扩展中找到能够达到、甚至超过预期需求的特性达到需求后，又再次陷入不满、配置、扩展、满足的循环当中在这种不断进步并且提高效率过程中，让人不断地因找到更好方式而满足，因不断发现缺陷而失落，使得Emacs逐渐成为让我们踏足“神域”的桥梁两者除各自擅长之处外，又各自在对方擅长的领域表现优异，令其它类编辑器“无可乘之机”，也另对方不敢有丝毫“松懈”。建议历史上两者的阵营之间爆发过多次“圣战”，涉及的方面太多，这里不一一列举，在实用的原则上，这里给出一点建议：* 对两者的选择，应当建立在对它们的了解之上* 使用Vim之时要给自己的思维一点空闲时间，防止进入“走火入魔”的境地* 而对Emacs的使用，其配置和扩展能够达到一定实用价值即可，避免为了不断提升Emacs而使用Emacs（虽然不断的提升是值得的）Vim的特征本文并无意加入Vim和Emacs的圣战中来；因讲述的是Vim的使用，所以针对其特点进行叙述；相应地Emacs也有它的特点，在讲述Emacs之时也会相应提到。一般使用过两者的人，可能会有如下的感觉：相比Emacs而言，Vim更为“通用”，这里的通用是指，并不是所有机器上都配有Emacs、但是大多数机器上都配有vi编辑器使用Vim不会像Emacs那样过度依赖本地配置与扩展，有些配置可以在使用Vim时按需即时开启（比如语法高亮与代码折叠）Vim启动迅速（启动Vim时，一般不需加载过多增强插件），按键简短（Vim的按键命令一般不会过长，组合键的情况很少）Vim只将编辑相关操作发挥极致，不做多余之事（与其它工具配合度高，编辑外的事情在Linux中自然有专门软件替它实现，如搜索文本通过grep完成）还有许多，这里也不过多叙述，为避免卷入圣战，还是需要做一点补充：当然，若不频繁切换自己的环境，或者能找到一种方式稳定在同一环境下工作的话，Emacs迟早也同样能做到甚至超越这些方面（记得有一款Emacs插件叫&quot;evil&quot;，作用是将vim的功能包含到Emacs中来，可见这款插件的意图是多么的邪恶_）。总之，使用工具的方式，决定工具的价值。与Emacs的共通之处Vim与Emacs其实也有许多共通之处，这里只给出我们最容易遇见和理解的两条：相比其他编辑器，Vim的入门门槛高一些，这里给出一个编辑器的学习曲线图：虽然两者入门难度较大，但是两者又都有一个非常好的学习捷径：避免只看理论，尽早让实践成为习惯，在实践中学习。开始学习本文约定特殊按键表示：Space: &lt;SPC&gt;  Ctrl: &lt;CTRL&gt;或&lt;C&gt;  Alt: &lt;ALT&gt;或&lt;M&gt;  Esc: &lt;ESC&gt;（注意，Emacs也将Esc键归为&lt;M&gt;）  Shift: &lt;SHIFT&gt;或&lt;S&gt;  Tab: &lt;Tab&gt;  Enter: &lt;Enter&gt;（有些时候为&lt;RET&gt;或&lt;CR&gt;）  BackSpace:&lt;&lt;BS&gt;（注意，Emacs上表示为&lt;DEL&gt;，Emacs上&lt;DEL&gt;不是Delete按键）  Delete:&lt;Del&gt;  组合键的表示：&lt;Esc&gt;: Escape key&lt;C-G&gt;: CTRL-G&lt;Up&gt;: cursor up key&lt;C-LeftMouse&gt;: Control- left mouse click&lt;S-F11&gt;: Shifted function key 11&lt;M-a&gt;: Meta- a  (&#39;a&#39; with bit 8 set)&lt;M-A&gt;: Meta- A  (&#39;A&#39; with bit 8 set)&lt;t_kd&gt;: &quot;kd&quot; termcap entry (cursor down key)更多内容可以打开Vim并输入:help keycode，参考其帮助手册给出的Key表示。在没有歧义的情况下，可以使用任何方式表示。模式的概念　　Vim具有多种模式，后面会详述，初学时，我们最好能理解其中两种最常见的模式：输入模式又可称为或插入模式、编辑模式。输入模式下输入字符，字符会插入至文本中，并显示在屏幕上。  指令模式又可称为命令模式，是Vim启动后默认的模式。指令模式下输入字符，并不会将相应的字符插入文本，而是将字符解释为一个输入命令并执行，理解指令模式最简单方式就是想象平时剪切、复制以及粘贴数据时所发生的情况。  行命令模式是在指令模式下一种特殊的情况，可以输入复杂的命令用户 。进入行命令模式后，vim底部会有一行空间，供用户输入。用户输入的字符会在这里显示，键入回车后执行相应的命令。总结起来，在本文中，“插入模式”＝“输入模式”＝“编辑模式”、“指令模式”＝“命令模式”、“行命令模式”是特殊的指令模式。基本操作这里提供了使用vi得最基本的操作，能够实现基本的编辑目的。如果你肯花几分钟把这里的内容都实践一下，那么至少能够独立地在Vim中朝你想要得方向“前进”。如果你不想学习，也可以把它当作一个“便签”，现查现用。打开一个文件：输入vi filename。这里，filename就是你要打开的文件的名字，默认打开文件后vi处于指令模式。进入编辑模式编辑打开的文件：输入i.或输入a.进入编辑模式后，你可以直接敲入想要输入的字符到文件，两者的区别是i在当前字符前面开始插入，a在当前字符后面开始插入。退出编辑模式：输入&lt;ESC&gt;.这样，将返回指令模式，准备接收你要传达给vi的指令并执行，如果之前已经在指令模式下，那么系统将响铃提醒一下。以下命令都是在命令模式下进行：撤销修改输入u.这里，相比以前的vi来说，vim支持多步撤销。恢复修改输入&lt;C-r&gt;.这里，和撤销命令相反，是撤销的撤销，也可多步。复制行到剪切板：输入yy.复制选定内容到剪切板：  输入v。按方向键将高亮选择的内容。输入y。这里，开始输入v使vi临时进入了一个&quot;选择模式&quot;，输入方向键可以选择，输入y将选择的内容复制剪切板。  删除行：输入dd.注意，vi的删除等价于剪切，删除的内容会保存到剪切板中。删除选定内容：  输入v。按方向键将高亮选择的内容。输入d。这里，开始输入v使vi临时进入了一个“选择模式”，输入方向键可以选择，输入d将选择的内容删除。粘贴：输入p.这样会将剪切板的内容粘贴到光标位置或者光标下一行。查找字符并定位到第一个匹配处：输入/character.这里character是待查找的字符，只要先输入/，再输入待查字符，最后回车即可定位到第一个匹配的字符处。定位到匹配查找的下一个字符处：输入n.定位到匹配查找的上一个字符处：输入N.保存文件：输入:w.注意w前面的:，输入:之后，vim会将:之后的输入解释为待执行的指令。退出：输入:q.这里，如果文件没有保存，将提示无法退出，除非你强制退出，不保存文件，或者保存退出。强制退出：输入:q!.保存退出：输入:wq.或输入:x.或输入ZZ.  察看帮助输入:help.';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2010-04-02]<a href="/categories/study/vim/vim_use_tutor_01Introduction.html"> Vim实践与学习-01简介 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Linux命令学习手册-wc'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 功能2. 描述2.1. 参数有2.2. 这个命令返回以下输出值3. 举例3.1. 对 hello3.c 行数、字数和字节数统计3.2. 仅对 hello3.c 字节数和字数统计3.3. 对所有以 hello 开头的文件，仅对字节数和字数统计3.4. 对 hello3.c 文件的字符数统计3.5. 对标准输入进行统计4. 其它4.1. 还有一个选项4.2. 用如下的命令可以统计当前目录下的文件数，挺常用wc [-c|-m] [-l] [-w] [File...]1 功能统计一个文件中的行数、字数、字节数或字符数.2 描述缺省情况下， wc 命令对 File 参数指定的文件中的行数、字数和字节数进行计数。这个命令将换行符数、字数和字节数写到标准输出并为所有指定的文件保留一个总数。当使用 File 参数时， wc 命令显示文件名以及请求的计数。如果没有给 File 参数指定一个文件名， wc 命令使用标准输入。wc 命令受 LANG, LC_ALL, LC_CTYPE 和 LC_MESSAGES 环境变量影响。wc 命令把一个字看作是被一个空格（如空白和跳格）分隔的非零长度字符串。 2.1 参数有-c 统计字节数-l 统计行数。-m 统计字符数。这个标志不能与 -c 标志一起使用。-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。-L 打印最长行的长度。2.2 这个命令返回以下输出值0 命令成功运行。&gt;0 发生一个错误。3 举例假设：$nl hello3.c1  #include2  //using std::cin;3  using std::endl;4  using std::cout;5  i6  int main(int argc, char *argv[])7  {8          cout&lt;&lt;"hello,this is a simple program writing in cpp"&lt;9          return 0;10  }3.1 对 hello3.c 行数、字数和字节数统计$wc hello3.c输入之后，输出如下：10  25 183 hello3.c3.2 仅对 hello3.c 字节数和字数统计$wc -cw hello3.c输入之后，输出如下：25 183 hello3.c3.3 对所有以 hello 开头的文件，仅对字节数和字数统计$ wc -cw hello*输入之后，输出如下：7  266 hello224  182 hello2.c7  266 hello2h7  266 hello2s25  183 hello3.c70 1163 total3.4 对 hello3.c 文件的字符数统计$wc -m hello3.c输入之后，输出如下：183 hello3.c3.5 对标准输入进行统计$wc输入之后，需要继续输入：dddddd按 [Ctrl]D ，输出如下：3       3       9这里，没有指定文件名则以默认的标准输入做为输入， [Ctrl]D 表示输入结束。4 其它4.1 还有一个选项-k 统计字符数。指定 -k 标志等同于指定 -klwc 标志。如果把 -k 标志同其它标志一起使用，那么必须包含 -c 标志。否则，将会忽略 -k 标志。请参阅示例 4 和5 以获取更多信息。注：这个标志在将来的发行版中将会撤销。4.2 用如下的命令可以统计当前目录下的文件数，挺常用$ls -l|wc -l输入之后，例如输出：15表示15个。      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2009-11-23 一 21:20]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2009-11-23]<a href="/categories/study/linux/command/linux_command_wc.html"> Linux命令学习手册-wc </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Linux命令学习手册-install'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 功能2. 描述3. 举例4. 其它install [OPTION]... SOURCE... DIRECTORYinstall [OPTION]... -t DIRECTORY SOURCE...install [OPTION]... -d DIRECTORY...1 功能拷贝文件并设置属性， install 可以安装或升级软件或备份数据，它的使用权限是所有用户。 2 描述在前两种格式中，会将 &lt;来源&gt; 复制至 &lt;目的地&gt; 或将多个 &lt;来源&gt; 文件复制至已存在的 &lt;目录&gt; ，同时设定权限模式及所有者/所属组。在第三种格式中，会创建所有指定的目录及它们的主目录。长选项必须用的参数在使用短选项时也是必须的。 主要参数 ：&#x2013;backup[=CONTROL]：为每个已存在的目的地文件进行备份。 -b：类似 &#x2013;backup，但不接受任何参数。 -c：(此选项不作处理)。 -d，&#x2013;directory：所有参数都作为目录处理，而且会创建指定目录的所有主目录。 -D：创建&lt;目的地&gt;前的所有主目录，然后将 &lt;来源&gt; 制至 &lt;目的地&gt; 在第一种使用格式中有用。 -g，&#x2013;group=组：自行设定所属组，而不是进程目前的所属组。 -m，&#x2013;mode=模式：自行设定权限模式 (像 chmod )，而不是 rwxr-xr-x 。 -o，&#x2013;owner=所有者：自行设定所有者 (只适用于超级用户)。 -p，&#x2013;preserve-timestamps：以 &lt;来源&gt; 文件的访问/修改时间作为相应的目的地文件的时间属性。 -s，&#x2013;strip：用 strip 命令删除 symbol table ，只适用于第一及第二种使用格式。 -S，&#x2013;suffix=后缀：自行指定备份文件的 &lt;后缀&gt; 。 -v，&#x2013;verbose：处理每个文件/目录时印出名称。 &#x2013;version：显示版本信息并离开。 &#x2013;help：显示此帮助信息并离开。 3 举例把test拷贝到目录 dir1$install test dir1这里将 test 文件复制到 dir1 目录中，如果 dir1 中有 test 将被替换；不会自动建立目录， dir1 必须已存在，否则把 test 拷贝成 dir1 文件了。创建 dir2/dir21/ 目录$install -d dir2/dir21这里将创建一个 dir2/dir21 目录,如果存在，不会被覆盖，不存在那么就创建这样的多层目录。把 test1 test2 两个文件拷贝到 dir1 目录里面$install -t dir1 test1 test2这里，把 test1 和 test2 文件拷贝到 dir1 目录中，如果没有目录不会自动创建。4 其它这个命令好像不常用， man 手册内容也不多，可以现用现查，一般我在软件 makefile 里面常常看见这个命令的使用。参考资料：http://blog.chinaunix.net/u2/75269/showart_1206016.html      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2009-11-23 一 14:20]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2009-11-23]<a href="/categories/study/linux/command/linux_command_install.html"> Linux命令学习手册-install </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Linux命令学习手册-fsck'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 功能2. 举例3. 描述3.1. 参数3.2. 详细参数3.3. 一些原理4. 其它4.1. 运行 fsck 命令后产生的文件有什么用？4.2. 关于 fsck 得结果输出：4.3. 文件fsck [-aANPrRsTV][-t &lt;文件系统类型&gt;][文件系统...]1 功能检查文件系统并尝试修复错误。补充说明：当文件系统发生错误四化，可用 fsck 指令尝试加以修复。2 举例检查 msdos 档案系统的 /dev/hda5 是否正常，如果有异常便自动修复:$fsck -t msdos -a /dev/hda5此指令可与 /etc/fstab 相互参考操作来加以了解。检查所有的缺省文件系统:$fsck这个命令检查在 /etc/filesystems 文件中所有标记 check=true 的文件系统。 fsck 命令这种形式在对文件系统做出任何更改之前会向您请求许可。利用缺省的文件系统自动修复较次要的问题:$fsck -p检查一个特定的文件系统:$fsck /dev/hd1这个命令检查位于 /dev/hd1 设备上的未安装的文件系统。3 描述3.1 参数-a 自动修复文件系统，不询问任何问题。-A 依照 /etc/fstab 配置文件的内容，检查文件内所列的全部文件系统。-N 不执行指令，仅列出实际执行会进行的动作。-P 当搭配 -A 参数使用时，则会同时检查所有的文件系统。-r 采用互动模式，在执行修复时询问问题，让用户得以确认并决定处理方式。-R 当搭配 -A 参数使用时，则会略过 / 目录的文件系统不予检查。-s 依序执行检查作业，而非同时执行。-t &lt;文件系统类型&gt; 指定要检查的文件系统类型。-T 执行 fsck 指令时，不显示标题信息。-V 显示指令执行过程。 -o f 对系统进行强制检查，不论系统是否在 clean 等状态-o p 非交互式检查并修复文件系统，对有的问题则立即退出-o b=xx 用来修复超级块的错误，就是将备份的超级块内容拷入超级块中。solaris对超级块很重视，它的备份有很多，一般的 b=32 就可以了，如果不行可以使用命令 newfs -N /dev/rdsk/cxtxdxsx 来查看超级块的位置，其中任何一个备份块都可使用.3.2 详细参数-d BlockNumber 搜索指定磁盘块的参考。无论 fsck 命令遇到包含特定块的文件，它将会显示索引节点号和所有指向它的路径名称。对于 JFS2 文件系统，引用指定模块的索引节点号将会被显示，但是不是它们的路径名称。 -f 进行快速检查。在正常情况下，通过非正确方式关闭系统来停机仅有的文件系统很可能被影响，这个文件系统就是当系统停止时在安装的那些。 -f 标志会提示 fsck 命令不要检查没有成功安装的文件系统。=fsck= 命令通过检查文件系统超级块中的 s_fmod 标志来决定这件事。 当文件系统没有成功安装的时候，无论何时文件系统被安装和被清除，这个标志都将被设定。如果文件系统被成功的卸载，这不大可能会存在什么问题。因为多数文件系统没有成功安装，不检查这些文件系统能减少检查时间。-i i-NodeNumber 搜索指定索引节点的参考。无论何时 fsck 命令遇到一个指向指定索引节点的目录，它都会显示这个参考的完整路径名称。 -n 对 fsck 命令所提出的所有问题给出一个 no 的回应；不打开指定的文件系统来写。 -o 选项 向 fsck 命令传递逗号分隔的选项。这些选项被认为是文件系统的实现细节，除了下面目前为了所有文件系统而当前被支持的选项： mountable如果有问题的文件系统可安装（清除），促使 fsck 命令成功的退出，返回一个 0 值。如果文件系统不可安装, fsck 命令退出并返回一个值 8 。 mytype如果存在问题的文件系统与在 /etc/filesystems 文件中或者在命令行中通过 -V 标志指定的具有相同的类型，那么促使 fsck 命令退出并给出一个成功的 0 值。否则，返回一个值 8 。例如，如果 / （引导文件系统）是一个分类文件系统，那么 fsck 命令 -o mytype -V jfs / 会退出给出一个 0 值。  -p 不显示次要问题的消息但是自动修复问题。这个标志并不是象 -y 标志那样授予大规模许可，当系统正常启动的时候对自动进行检查工作有用。无论系统在何时自动运行，您应该将这个标志作为系统启动过程的一部分来使用。也允许并行分组检查。如果主要的超级块损坏了，次要的超级块就被验证，并且复制到主要的高级块中。 -t文件 如果 fsck 命令得不到足够的内存来保存它的表的话，在文件系统中作为一个临时文件而不是被检查的文件来指定File参数。如果没有指定 -t 标志，那么 fsck 命令需要一个临时文件，它会提示您给这个临时文件起名字。但是，如果指定了 -p 标志， fsck 命令是不成功的。如果临时文件不是一个特定的文件，当 fsck 命令结束的时候，它就会被删除。 -V VfsName 使用为文件系统由VFSName变量指定的虚拟文件系统的描述，而不是用 /etc/filesystems 文件决定描述。如果 -V VfsName 标志没有在命令行中指定，就会检查 /etc/filesystems 文件并且 vfs= 匹配节的特性被认为是正确的文件系统类型。 -y 对所有 fsck 命令提出的所有问题假定一个 yes 的响应。这个标志使 fsck 命令采取它认为必要的行动。仅在损坏严重的文件系统中使用这个标志。 3.3 一些原理大多数系统设置为启动时自动运行 fsck ，因此任何错误将在系统使用前被检测到(并根据希望修正)。自动检查只对启动时自动 mount 的文件系统发生作用，使用 fsck 手工检查其他文件系统，比如软盘。使用有错误的文件系统可能使问题变得更坏。如果系统正常关闭，几乎从不发生错误，因此有一些方法可以不进行检查。如果文件 /etc/fastboot 存在，就不检查。另外，如果 ext2 文件系统在超级块中有一个特定的标记告知该文件系统在上次 mount 后没有正常 unmount . 如果标记指出 unmount 正常完成(假设正常 unmount 指出没问题)， e2fsck ( fsck 的 ext2 文件系统版) 就不检查系统。 /etc/fastboot 是否影响系统依赖于你的启动手稿，但 ext2 标记则在你使用 e2fsck 时发生作用&#x2013;基于一个 e2fsck 选项(参阅 e2fsck 手册页) 　　运行 fsck 后，该命令会分6个阶段对文件系统进行检查，这六个阶段分别是： 阶段1： 检查块和块的大小阶段2： 检查路径名阶段3： 检查连接性阶段4： 检查参考记数阶段5： 检查自由块列表阶段6： 补救自由块列表对每个阶段进行检查,常见的一些错误:移去一个没有相关文件的目录入口　这时用户可以回答 Yes 或 Y 来删除该目录入口。 　　　　重连接一个已分配但不能访问的文件fsck 找到了一个已分配的I节点，但却不可访问(该节点没与任何目录连接)，这时一般对 fsck 的"RECONNECT？"回答 Yes ，即把该I节点连接到 lost+found 目录下，文件名即是I节点号，之后管理员应检查该文件类型，判明该文件用途，再将该文件拷贝到相应目录下。连接数调整ADJUST在交互方式下， fsck 若发现连接数(与原记录)不一致，将询问用户采取何种行动，本例发现一目录的I节点连接数与该目录的真实连接数不一致。这时用户应该回答 Yes 或 Y 来改正连接数。 　　　　自由块表不一致fsck 查出未分配块数与超级块中所给出的自由块表不一致。这时用户应该回答 Yes 或 Y 来修正超级块。 从上面的出错信息和处理方法可以发现，对于 fsck 询问的问题大多数情况下都可以用 Yes 来回答，所以在实际应用时，可以用 -y 选项来执行该命令对硬盘进行检查和修复。 这里：RECONNECT表示目录丢失，可将其存入 lost+found 中再作转移。回答 yesSUPERBLK坏（注意是坏，不是wrong）修复见上面（如果是wrong就随便了，修不修都可以）CLEAR删i节点，可能会错REMOVE删文件，一般给出文件名。 file=&#x2026;.ADJUST调整连接数。实际数与原记录不符。回答 yes使用一般都是 yes 过去的，不能在正在 mount 的文件系统上操作，否则有可能导致文件系统损坏。但也没有碰到过用 fsck 导致发生错误的情况，不过还是建议操作的时候规范一些。对于一个已经安装好了的文件系统， fsck 命令不会做出矫正。 fsck 命令出于某些原因可以在一个已经安装好了的文件系统中运行，但不是进行修复。但是当文件系统安装完毕之后，也许会返回不准确的错误消息。 fsck 命令检查并以交互方式修复不连贯的文件系统。在安装文件系统之前，应该运行这个命令。您必须能够读设备文件，在这个设备上驻留着文件系统（例如 /dev/sda1 )安装一个不连贯的文件系统也许会导致系统的崩溃。4 其它（有待实践）4.1 运行 fsck 命令后产生的文件有什么用？当执行 fsck 命令时， fsck 命令如果发现存在孤立的文件或目录，这些孤立的文件或目录对于系统管理员或用户来说，无法访问到它，因为它与它的上级目录失去了关联，如果用户允许 fsck 重新把它们找回来的话， fsck 命令就会把这些孤立的文件或目录放在文件系统的 /lost+found 目录下，并用各自的 i-node 号来命名，以便用户查找自己需要的文件。 Lost+found 目录通过它的英文含义我们都可以知道，它是一个失物认领处。因此当某个用户发现自己丢失了某个文件，可以在执行 fsck 之后到 /lost+found 目录下去查找，这时通过文件名已无法辨认出文件的作用，只能用 file 之类的命令来确定文件的类型，如果是数据文件，可以用 more 或 vi 命令来查看，如果是二进制文件，可以用 dbx 命令来调试或者试着执行它(注意它可能是一个具有破坏性的程序)，知道文件或目录的作用之后，可以对其进行改名。如果用户不允许 fsck 把这些孤立的文件或目录找回来，那么 fsck 命令就会破坏这些文件或目录，彻底丢失这些文件或目录，用户或系统管理员永远也无法找回它们。 4.2 关于 fsck 得结果输出：当系统启动的时候会使用 fsck 对文件系统进行扫描，并相应的报出扫描结果。例如： dev/rdsk/c0t0d0s7 stable 等。后面是Fs的状态。其中，clean 表示文件系统 umount 后无人用，stable 表示文件系统用过，但却是完整的，好的。而出一大堆的话，还有什么 fragment % 什么的的那都表示文件系统上有乱的地方，那么就应该进入系统后使用 fsck 来整理。　　当系统的状态是 clean ， stable 和 logging 的状态的时候 fsck 不运行。在非法关机后（各种原因），再次启动的时候会有很多的情况，上面说的是一种情况，再厉害一些是系统只能进入但用户状态，最厉害的是连单用户的状态都无法进入（肯定是 / 和 /usr 区有问题。这是因为 fsck 对 / 区的扫描无法通过的话，系统当然无法启动，而 fsck 调用的一些函数库又在 /usr 上。。。。）此外，在一个已经安装好了的文件系统上运行的 fsck 命令产生不可靠的结果。4.3 文件/usr/sbin/fsck 包含 fsck 命令。 /etc/filesystems 列出已知的文件系统并且定义它们的特征。 /var/spool/mail/* 包含虚拟文件系统类型的描述。 /usr/bin/from 包含当系统启动的时候运行的命令（包括 fsck 命令）。       		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2009-11-23 一 20:25]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2009-11-23]<a href="/categories/study/linux/command/linux_command_fsck.html"> Linux命令学习手册-fsck </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Linux命令学习手册-find'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 功能2. 描述2.1. find 命令的参数2.2. find 命令选项2.3. 使用 exec 或 ok 来执行shell命令3. 举例3.1. 按名称3.1.1. 在当前目录中查找任何扩展名为 .c 的文件：3.1.2. 到 ./test 、 ./viStudy 目录查找所有 .c 文件：3.1.3. 不区分大小写的 find 查找：3.1.4. 列出当前目录和所有子目录中的所有文件（包括隐藏文件）的完整清单：3.2. 按类型3.2.1. 查找某（当前）目录中的所有子目录：3.2.2. 查找某（当前）目录中的所有符号链接：3.2.3. 从当前目录开始查找位于本文件系统中文件名以XC结尾的文件：3.2.4. 告知 find 在指定文件系统(例如 vfat )中查找:3.3. 按时间3.3.1. 查找在最近 1 *24小时内修改的所有文件：3.3.2. 查找恰好在 1 *24小时以前修改的所有文件：3.3.3. 查找 1 *24个多小时以前修改的所有文件：3.3.4. 查找在不到 1 分钟以前读取的所有文件：3.3.5. 查找在当前目录中 hello2.c 文件之后被编辑过的所有文件：3.3.6. 查找更改时间比文件httpd1.conf新但比文件temp旧的文件：3.4. 按大小3.4.1. 查找所有大于 5MB 的用户文件:3.4.2. 在当前目录下查找长度超过10块的文件（一块等于512字节）：3.4.3. 搜索所有零字节文件并将它们移至 /tmp/zerobyte 文件夹:3.4.4. 查找test目录下的空文件：3.5. 按权限、所属3.5.1. 在当前目录下查找文件权限位为 755 的文件:3.5.2. 查找属于 user1name 或着属于 user2name 的文件:3.5.3. 查找既属于 user1name 又属于 user2name 用户的文件:3.5.4. 查找在系统中属于非用户（ ? ）的文件:3.5.5. 查找在系统中属于 username 的文件：3.5.6. 查找在系统中属于 groupname 的文件:3.6. 按指定目录3.6.1. 希望在 /apps 目录下查找文件，但不希望在 /apps/bin 目录下查找：3.6.2. 在 /usr/sam 目录下查找不在 dir1 子目录之内的所有文件：3.6.3. 避开多个文件夹：3.6.4. 确保先在一个目录中进行查找，然后才在其子目录中进行查找:3.6.5. 让 find 在至少下至目录树三个级别的目录中查找：3.6.6. 在目录树的前三个级别中查找日志文件:3.7. 查找并执行命令：3.7.1. 用 =ls -l=命令列出所匹配到的文件:3.7.2. 在 /logs 目录中查找更改时间在5日以前的文件并删除它们：3.7.3. 当前目录中查找所有文件名以 .LOG 结尾、更改时间在5日以上的文件并删除,删除之前先给提示:3.7.4. 匹配所有文件名为 passwd* 的文件，然后执行 grep 命令看这些文件中是否存在 sam 用户:3.7.5. 当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件:3.7.6. 查找 /var/logs 目录中更改时间在7日以前的普通文件，并在删除之前询问它们:3.7.7. 查找系统中所有属于 root 组的文件:3.7.8. 查找并删除访问时间在7日以来、含有数字后缀的 admin.log 文件:3.8. 高效的查找执行：3.8.1. 查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件:3.8.2. 当前目录下查找 file 开头的文件然后把结果保存到 /tmp/core.log 文件中：3.8.3. 在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限：3.8.4. 用 grep 命令在当前目录下的所有的普通文件中搜索 hostname 这个词：4. 其它find pathname -options [-print -exec -ok ...]1 功能find 用于查找符合某些特性的文件。由于 find 具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统( NFS)， find 命令在该文件系统中同样有效，只要你具有相应的权限。2 描述2.1 find 命令的参数find 的所有参数均为可选pathname : find 命令所查找的目录路径。例如用.来表示当前目录，用 / 来表示系统根目录。-print ： find 命令将匹配的文件输出到标准输出。-exec ： find 命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为 command {  } \; ，注意 {   } 和 \； 之间的空格。-ok ： 和 -exec 的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。2.2 find 命令选项-name 按照文件名查找文件。-perm 按照文件权限来查找文件。-prune 使用这一选项可以使 find 命令不在当前指定的目录中查找，如果同时使用 -depth 选项，那么 -prune 将被 find 命令忽略。-user 按照文件属主来查找文件。-group 按照文件所属的组来查找文件。-mtime -n +n 按文件更改时间来查找文件， -n 表示文件更改时间距现在 n 天以内， +n 表示文件更改时间距现在 n 天以前。 find 命令还有 -atime 和 -ctime 选项，但它们都和 -m time 选项。-nogroup 查找无有效所属组的文件，即该文件所属的组在 /etc/groups 中不存在。-nouser 查找无有效属主的文件，即该文件的属主在 /etc/passwd 中不存在。-newer file1 ! file2 查找更改时间比文件 file1 新但比文件 file2 旧的文件。-type查找某一类型的文件，诸如：b 块设备文件。d 目录。c 字符设备文件。p 管道文件。l 符号链接文件。f 普通文件。-size n [cwbkMG] ： 查找文件长度为 n 块的文件，带有 c 等时表示文件长度(如 c 表示字节计）。-depth ：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。-fstype ：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件 /etc/fstab 中找到，该配置文件中包含了本系统中有关文件系统的信息。-mount ：在查找文件时不跨越文件系统 mount 点。-follow ：如果 find 命令遇到符号链接文件，就跟踪至链接所指向的文件。-cpio ：对匹配的文件使用 cpio 命令，将这些文件备份到磁带设备中。另外,下面三个的区别:-amin n 查找系统中最后N分钟访问的文件-atime n 查找系统中最后n*24小时访问的文件-cmin n 查找系统中最后N分钟被改变文件状态的文件-ctime n 查找系统中最后 n*24 小时被改变文件状态的文件-mmin n 查找系统中最后N分钟被改变文件数据的文件-mtime n 查找系统中最后 n*24 小时被改变文件数据的文件2.3 使用 exec 或 ok 来执行shell命令使用 find 时，只要把想要的操作写在一个文件里，就可以用 exec 来配合 find 查找，很方便的。在有些操作系统中只允许 -exec 选项执行诸如 ls 或 ls -l 这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行 rm 命令删除文件之前，最好先用 ls 命令看一下，确认它们是所要删除的文件。exec 选项后面跟随着所要执行的命令或脚本，然后是一对儿 { } ，一个空格和一个 \ ，最后是一个分号。为了使用 exec 选项，必须要同时使用 print 选项。如果验证一下 find 命令，会发现该命令只输出从当前路径起的相对路径及文件名。3 举例3.1 按名称3.1.1 在当前目录中查找任何扩展名为 .c 的文件：$find ./ -name '*.c'或$find ./ -name \*.c或$find -name '*.c'输入之后，输出如下：./hello.c./1/main.c./1/hello.c./hello2.c这里，当前目录只用 . 也行，如果不用转义， *.c 必须括在引号(单/双)当中，如果不指定路径，将在当前目录找; 默认把子目录下的也都找出来了。3.1.2 到 ./test 、 ./viStudy 目录查找所有 .c 文件：$find test viStudy/ -name '*.c'输入之后，输出如下：test/test_out_direct.cviStudy/hello.cviStudy/1/main.cviStudy/1/hello.cviStudy/hello2.c这里，如果您没有相应的权限，您在开始浏览许多目录时将生成错误消息例如如下的提示：find:  /tmp/orbit-root: Permission denied可以不让错误输出，防止混乱：$find /usr /home  /tmp -name "*.jar" 2&gt;/dev/null3.1.3 不区分大小写的 find 查找：$find downloads -iname '*.gif'输入之后，输出如下：downloads/.xvpics/Calendar05_enlarged.gifdownloads/lcmgcfexsmall.GIF这里,默认情况下， find 是区分大小写的。对于不区分大小写的 find ，将 -iname 测试替换为 -name 。3.1.4 列出当前目录和所有子目录中的所有文件（包括隐藏文件）的完整清单：$find或$find .或$find . -print输入之后，输出如下：../any./tags./hello.c./1./1/main.c...省略...3.2 按类型3.2.1 查找某（当前）目录中的所有子目录：$find . -type d或$find -type d输入之后，输出如下：../13.2.2 查找某（当前）目录中的所有符号链接：$find . -type l输入之后输出如下：./hello2s这里， ./hello2s 是一个软链接，这个命令显示的也是软链接。其他 find 可以找到的文件类型包括：b — 块（缓存）特殊c — 字符（未缓存）特殊p — 命名管道 (FIFO)s — 套接字用 ls 列出软链接需要用 -ls ，用管道不行。如下：$find . type l -ls输出：56231215    0 lrwxrwxrwx   1 quietheart member          6 May 16 16:14 ./hello2s -&gt; hello23.2.3 从当前目录开始查找位于本文件系统中文件名以XC结尾的文件：$ find . -name "*.XC" -mount -print这里，在当前的文件系统中查找文件（不进入其他文件系统），使用了 find 命令的 mount 选项。3.2.4 告知 find 在指定文件系统(例如 vfat )中查找:$find / -name  "*.txt" -fstype vfat还有$find / -name  "*.txt" -mount 2等等，不常用就不多说了。3.3 按时间3.3.1 查找在最近 1 *24小时内修改的所有文件：$find . -mtime -1输入之后输出如下：./plsql/FORALLSample./plsql/RegExpDNASample/plsql/RegExpSample3.3.2 查找恰好在 1 *24小时以前修改的所有文件：$find . -mtime 13.3.3 查找 1 *24个多小时以前修改的所有文件：$find . -mtime +1这里， find 根据系统的时间戳搜索文件的选项。这些时间戳包括：mtime — 文件内容上次修改时间atime — 文件被读取或访问的时间ctime — 文件状态变化时间这里， ctime 则需要更多的解释。由于 inode 维护着每个文件上的元数据，因此，如果与文件有关的元数据发生变化，则 inode 数据也将变化。这可能是由一系列操作引起的，包括创建到文件的符号链接、更改文件权限或移动了文件等。由于在这些情况下，文件内容不会被读取或修改，因此 mtime 和 atime 不会改变，但 ctime 将发生变化。这些时间选项都需要与一个值 n 结合使用，指定为 -n 、 n 或 +n:-n 返回项小于 n+n 返回项大于 nn 返回项正好与 n 相等3.3.4 查找在不到 1 分钟以前读取的所有文件：$find . -amin -1输入之后，输出如下：./.bashrc/.bash_history./.xauthj5FCx1这里是刚刚登陆系统就运行了这个命令，所以输出这样。默认情况下， -mtime 、 -atime 和 -ctime 指的是最近 24 小时。但是，如果它们前面加上了开始时间选项，则 24 小时的周期将从当日的开始时间算起。您还可以使用 mmin 、 amin 和 cmin 查找在不到 1 小时的时间内变化了的时间戳。 另外，应该注意的是，使用 find 命令查找文件本身将更改该文件的访问时间作为其元数据的一部分。3.3.5 查找在当前目录中 hello2.c 文件之后被编辑过的所有文件：$find . -newer hello2.c输入之后输出如下：../hello2s./hello2h./hello2这里,需要注意硬链接的特殊性（我不说，只有你明白了才知道我说的意思）。使用 -newer 、 -anewer 和 -cnewer 选项与特定的文件比较查找已修改或访问过的文件。这类似于 -mtime 、 -atime 和 -ctime 。 -newer 指内容最近被修改的文件-anewer 指最近被读取过的文件-cnewer 指状态最近发生变化的文件3.3.6 查找更改时间比文件httpd1.conf新但比文件temp旧的文件：$find -newer httpd1.conf  ! -newer temp -ls其中， ！ 是逻辑非符号。3.4 按大小3.4.1 查找所有大于 5MB 的用户文件:$find / -size  +5000000c 2&gt; /dev/null输入之后，输出如下：/var/log/lastlog/var/log/cups/access_log.4/var/spool/mail/bluher这里，把错误的信息定位到 /dev/null 了。结尾的 c 以字节为单位报告我们的结果。默认情况下， find 以 512 字节块的数量报告大小。如果我们将 c 替换为 k ，我们还会看到以千字节的数量报告的结果，如果使用 w ，则会看到以两字节字的数量报告的结果。3.4.2 在当前目录下查找长度超过10块的文件（一块等于512字节）：$ find . -size +10 -print3.4.3 搜索所有零字节文件并将它们移至 /tmp/zerobyte 文件夹:$find test -type f  -size 0 -exec mv {} /tmp/zerobyte \;这里， -exec 操作允许 find 在它遇到的文件上执行任何 shell 命令。在本文的后面部分，您将看到其用法的更多示例。大括号允许移动每个空文件。3.4.4 查找test目录下的空文件：$find test -empty输入之后输出如下：test/footest/test查找空文件用的是 -empty 选项。3.5 按权限、所属3.5.1 在当前目录下查找文件权限位为 755 的文件:$find . -perm 755 -print还有一种表达方法：在八进制数字前面要加一个横杠 - ，表示都匹配，如 -007 就相当于 777 ， -006 相当于 666 .3.5.2 查找属于 user1name 或着属于 user2name 的文件:$find / -user user1name -or -user user2name3.5.3 查找既属于 user1name 又属于 user2name 用户的文件:$find / -user user1name -and -user2name3.5.4 查找在系统中属于非用户（ ? ）的文件:$find /－nouser3.5.5 查找在系统中属于 username 的文件：$find / -user username3.5.6 查找在系统中属于 groupname 的文件:$find / -group groupname3.6 按指定目录3.6.1 希望在 /apps 目录下查找文件，但不希望在 /apps/bin 目录下查找：$find /apps -path "/apps/bin" -prune -o -print在使用 -prune 选项时要当心，因为如果你同时使用了 -depth 选项，那么 -prune 选项就会被 find 命令忽略。3.6.2 在 /usr/sam 目录下查找不在 dir1 子目录之内的所有文件：$find /usr/sam -path "/usr/sam/dir1" -prune -o -print这里， find [-path ..] [expression] 在路径列表的后面的是表达式。-path "/usr/sam" -prune -o -print 是 -path "/usr/sam" -a -prune -o -print 的简写表达式按顺序求值， -a 和 -o 都是短路求值，与 shell 的 &amp;&amp; 和 || 类似。如果 -path "/usr/sam"= 为真，则求值 =-prune , -prune 返回真，与逻辑表达式为真；否则不求值 -prune ，与逻辑表达式为假。如果 -path "/usr/sam" -a -prune 为假，则求值 -print ， -print 返回真，或逻辑表达式为真；否则不求值 -print ，或逻辑表达式为真。这个表达式组合特例可以用伪码写为if -path "/usr/sam"  then          -pruneelse          -print3.6.3 避开多个文件夹：$find /usr/sam \( -path /usr/sam/dir1 -o -path /usr/sam/file1 \) -prune -o -print这里，圆括号表示表达式的结合。 \ 表示引用，即指示 shell 不对后面的字符作特殊解释，而留给 find 命令去解释其意义。3.6.4 确保先在一个目录中进行查找，然后才在其子目录中进行查找:$find -name "*test*" -depth输入之后，输出：./test/test./test./localbin/test./localbin/test_shell_var./localbin/test.txt./test2/test/test./test2/test./test23.6.5 让 find 在至少下至目录树三个级别的目录中查找：$find / -mindepth 3  -name "*log"3.6.6 在目录树的前三个级别中查找日志文件:$find / -maxdepth 3  -name "*log"3.7 查找并执行命令：3.7.1 用 =ls -l=命令列出所匹配到的文件:$find . -type f -exec ls -l {  } \;输入之后，输出：-rw-r--r--    1 root     root        34928 2003-02-25  ./conf/httpd.conf-rw-r--r--    1 root     root        12959 2003-02-25  ./conf/magic-rw-r--r--    1 root     root          180 2003-02-25  ./conf.d/README这里， exec 选项后面跟随着所要执行的命令或脚本，然后是一对儿 {} ，一个空格和一个 \ ，最后是一个分号，注意 {} 内可以没有空格，但是 {} 后面、 \ 前面要有一个空格。3.7.2 在 /logs 目录中查找更改时间在5日以前的文件并删除它们：$find logs -type f -mtime +5 -exec rm {  } \;在shell中用任何方式删除文件之前，应当先查看相应的文件，一定要小心！当使用诸如 mv 或 rm 命令时，可以使用 -exec 选项的安全模式。3.7.3 当前目录中查找所有文件名以 .LOG 结尾、更改时间在5日以上的文件并删除,删除之前先给提示:$find . -name "*.conf"  -mtime +5 -ok rm {  } \;输入之后，输出如下提示：&lt; rm ... ./conf/httpd.conf &gt; ? n这里，按 y 键删除文件，按 n 键不删除。3.7.4 匹配所有文件名为 passwd* 的文件，然后执行 grep 命令看这些文件中是否存在 sam 用户:$find /etc -name "passwd*" -exec grep "sam" {  } \;输入之后，输出：sam:x:501:501::/usr/sam:/bin/bash3.7.5 当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件:$find . -type f -perm 644 -exec ls -l {  } \;3.7.6 查找 /var/logs 目录中更改时间在7日以前的普通文件，并在删除之前询问它们:$find /var/logs -type f -mtime +7 -ok rm {  } \;3.7.7 查找系统中所有属于 root 组的文件:$find . -group root -exec ls -l {  } \;输入之后，输出：-rw-r--r--    1 root     root          595 10月 31 01:09 ./fie1这里实际不用 -exec 也行，即: $find . -group root 。不过为了更详细列出相关的信息，使用 exec 选项对每个文件执行了 ls 。3.7.8 查找并删除访问时间在7日以来、含有数字后缀的 admin.log 文件:$find . -name "admin.log[0-9][0-9][0-9]" -atime -7  -ok rm {  } \;输入之后，输出：&lt; rm ... ./admin.log001 &gt; ? n&lt; rm ... ./admin.log002 &gt; ? n&lt; rm ... ./admin.log042 &gt; ? n&lt; rm ... ./admin.log942 &gt; ? n这里，只寻找了3位数的数字。3.8 高效的查找执行：使用 find 命令的 -exec 选项处理匹配到的文件时，  find 命令将所有匹配到的文件一起传递给 exec 执行。但有些系统对能够传递给 exec 的命令长度有限制，这样在 find 命令运行几分钟之后，就会出现溢出错误;还可能导致有些系统进程过多，系统性能下降的问题，因而效率不高.使用 xargs 命令则只有一个进程。另外，在使用 xargs 命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。 下面是 xargs 命令同 find 命令一起使用的一些例子:3.8.1 查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件:$find . -type f -print | xargs file输入之后，输出：./.kde/Autostart/Autorun.desktop: UTF-8 Unicode English text./.kde/Autostart/.directory:      ISO-8859 text\...省略...3.8.2 当前目录下查找 file 开头的文件然后把结果保存到 /tmp/core.log 文件中：$find . -name "file*" -print | xargs echo "" &gt; /temp/core.log3.8.3 在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限：$find . -perm -7 -print | xargs chmod o-w3.8.4 用 grep 命令在当前目录下的所有的普通文件中搜索 hostname 这个词：$find . -type f -print | xargs grep "hostname"或$find . -name \* -type f -print | xargs grep "hostname"输入之后，输出：./httpd1.conf:#     different IP addresses or hostnames and have them handled by the./httpd1.conf:# VirtualHost: If you want to maintain multiple domains/hostnames on your注意，这里， \ 用来取消 find 命令中的 * 在shell中的特殊含义。4 其它      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2009-11-23 一 20:25]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2009-11-23]<a href="/categories/study/linux/command/linux_command_find.html"> Linux命令学习手册-find </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Linux命令学习手册-diff'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 功能2. 举例3. 描述4. 其它4.1. diff 和 patch 的使用:4.2. 内核补丁4.3. 参考资料diff [选项] file1 file21 功能该命令的功能为逐行比较两个文本文件，列出其不同之处。它比 comm 命令完成更复杂的检查。它对给出的文件进行系统的检查，并显示出两个文件中所有不同的行，不要求事先对文件进行排序。2 举例假设有这样两个文件：程序清单1 ：hello.c#include &lt;stdio.h&gt;int main(void){    char msg[] = "Hello world!";    puts(msg);    printf("Welcome to use diff commond.\n");    return 0;    }程序清单2：hello_diff.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void){    char msg[] = "Hello world,fome hello_diff.c";    puts(msg);    printf("hello_diff.c says,'Here you are,using diff.'\n");    return 0;    }可有如下命令：查看这两个文件的不同之处,普通格式输出:$diff hello.c hello_diff.c 1a2&gt; #include &lt;stdlib.h&gt;5c6&lt;       char msg[] = "Hello world!";---&gt;       char msg[] = "Hello world,fome hello_diff.c";8c9&lt;       printf("Welcome to use diff commond.\n");---&gt;       printf("hello_diff.c says,'Here you are,using diff.'\n");这里， 1a2 表示后面的一个文件 hello_diff.c 比前面的一个文件 hello.c 多了一行 5c6 表示第一个文件的第5行与第二个文件的第6行有区别。查看这两个文件的不同之处,并排输出格式:$diff hello.c hello_diff.c -y -W 130#include &lt;stdio.h&gt;                                                  #include &lt;stdio.h&gt;                                                                  &gt; #include &lt;stdlib.h&gt;int main(void)                                                      int main(void){                                                                   {      char msg[] = "Hello world!";                              |         char msg[] = "Hello world,fome hello_diff.c";      puts(msg);                                                          puts(msg);      printf("Welcome to use diff commond.\n");                 |         printf("hello_diff.c says,'Here you are,using diff.'\n");      return 0;                                                           return 0;}                                                                   }这里，并排格式的对比一目了然，可以快速找到不同的地方。 -W 选择可以指定输出列的宽度，这里指定输出列宽为130。查看这两个文件的不同之处，上下文格式输出：$diff hello.c hello_diff.c -c*** hello.c     2007-09-25 17:54:51.000000000 +0800--- hello_diff.c        2007-09-25 17:56:00.000000000 +0800****************** 1,11 ****#include &lt;stdio.h&gt;int main(void){!       char msg[] = "Hello world!";        puts(msg);!       printf("Welcome to use diff commond.\n");        return 0;}--- 1,12 ----  #include &lt;stdio.h&gt;+ #include &lt;stdlib.h&gt;int main(void){!       char msg[] = "Hello world,fome hello_diff.c";        puts(msg);!       printf("hello_diff.c says,'Here you are,using diff.'\n");        return 0;}这里，在开头两行作了比较文件的说明，这里有三中特殊字符：+        比较的文件的后者比前着多一行-        比较的文件的后者比前着少一行！        比较的文件两者有差别的行查看这两个文件的不同之处，统一输出格式：$diff hello.c hello_diff.c -u--- hello.c     2007-09-25 17:54:51.000000000 +0800+++ hello_diff.c        2007-09-25 17:56:00.000000000 +0800@@ -1,11 +1,12 @@ #include &lt;stdio.h&gt;+#include &lt;stdlib.h&gt;int main(void){-       char msg[] = "Hello world!";+       char msg[] = "Hello world,fome hello_diff.c";        puts(msg);-       printf("Welcome to use diff commond.\n");+       printf("hello_diff.c says,'Here you are,using diff.'\n");        return 0;}这里，统一格式的输出更加紧凑，所以更易于理解，更易于修改。查看两个文件是否不同又不想显示差异之处$diff hello.c hello_diff.c -qFiles hello.c and hello_diff.c differ这里，如果两个文件相同，那么不会输出任何信息。查看这两个文件的不同之处，忽略带有“ include”字样的行:$diff hello.c hello_diff.c -c -I include*** hello.c     2007-09-25 17:54:51.000000000 +0800--- hello_diff.c        2007-09-25 17:56:00.000000000 +0800****************** 2,11 ****int main(void){!       char msg[] = "Hello world!";        puts(msg);!       printf("Welcome to use diff commond.\n");        return 0;}--- 3,12 ----int main(void){!       char msg[] = "Hello world,fome hello_diff.c";        puts(msg);!       printf("hello_diff.c says,'Here you are,using diff.'\n");        return 0;}这里，另外你还可以提供一些匹配规则来忽略某中差别，可以用 -I regexp(正则表达式).3 描述说明：该命令告诉用户，为了使两个文件 file1 和 file2 一致，需要修改它们的哪些行。如果用 - 表示 file1 或 fiie2 ，则表示标准输入。如果 file1 或 file2 是目录，那么 diff 将使用该目录中的同名文件进行比较。参数-b 忽略行尾的空格，而字符串中的一个或多个空格符都视为相等。-c 采用上下文输出格式（提供三行上下文）。-C n 采用上下文输出格式（提供n行上下文）。-e 产生一个合法的ed脚本作为输出。-r 当file1和file2是目录时，递归作用到各文件和目录上。结果例如： diff /usr/xu mine 把目录 /usr/xu 中名为 mine 的文件与当前目录中的 mine 文件进行比较。通常输出由下述形式的行组成：n1 a n3，n4n1，n2 d n3 n1，n2 c n3，n4这些行类似 ed 命令把 filel 转换成 file2 。字母（ a 、 d 和 c ）之前的行号（ n1 ， n2 ）是针对 file1 的，其后面的行号（ n3 ， n4 ）是针对 file2 的。字母 a 、 d 和=c= 分别表示附加、删除和修改操作。在上述形式的每一行的后面跟随受到影响的若干行，以 &lt; 打头的行属于第一个文件，以 &gt; 打头的行属于第二个文件。另外，=diff= 能区别块和字符设备文件以及FIFO（管道文件），不会把它们与普通文件进行比较。 4 其它4.1 diff 和 patch 的使用:diff/patch 这对工具在数学上来说， diff 是对2个集合求差， patch 是求和生成 A 和 B 的diff文件 C:$diff A B &gt; C这里 C 相当于 A 到 B 的一个“补丁”文件，记录两者之间的差异。给 A 打上diff文件得到 B:$patch A C这里，如果用 patch B C 则会提示警告告诉你用反了。B 还原为 A:$patch -R B C这里，如果用 patch -R A C 则会提示警告告诉你用反了。4.2 内核补丁生成$diff -uNr linux-2.6.xxx linux-2.6.xxx.1 &gt; diff.patch升级$cp diff.patch linux-2.6.xxx/.$cd linux-2.6.xxx$patch -p1 &lt; diff.patch4.3 参考资料http://baike.baidu.com/view/1374858.htmhttp://blog.csdn.net/zhanglei6645/archive/2007/10/16/1827728.aspxhttp://www.linuxdiyf.com/viewarticle.php?id=42597      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2009-11-23 一 15:20]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2009-11-23]<a href="/categories/study/linux/command/linux_command_diff.html"> Linux命令学习手册-diff </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Linux命令学习手册-df'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 功能2. 描述3. 举例4. 其它df -[选项] [文件...]1 功能检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 df 命令可显示所有文件系统对i节点和磁盘块的使用情况。2 描述该命令各个选项的含义如下：  -a 显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如 /proc 文件系统。-k 以k字节为单位显示。  -m 使用 MBytes 显示结果-h 增加显示方式可读性，例如上G了则以G为单位显示-i 显示i节点信息，而不是磁盘块。  -t 显示各指定类型的文件系统的磁盘空间使用情况。  -x 列出不是某一指定类型文件系统的磁盘空间使用情况（与t选项相反）。  -T 显示文件系统类型。  如果给定了文件或者路径名，那么显示的只是和该文件相关的文件系统的相关信息。3 举例列出各文件系统的磁盘空间使用情况输入输出如下:$ dfFilesystem           1K-blocks      Used Available Use% Mounted on/dev/sda1            150837820   8446552 134729068   6% /varrun                 4097572        92   4097480   1% /var/runvarlock                4097572         0   4097572   0% /var/lockudev                   4097572        32   4097540   1% /devdevshm                 4097572         0   4097572   0% /dev/shmlrm                    4097572     44976   4052596   2% /lib/modules/2.6.24-22-generic/volatile192.168.2.5:/store/home                     2399169216 323220096 1954078368  15% /home这里，输出清单的第1列是代表文件系统对应的设备文件的路径名（一般是硬盘上的分区）；第2列给出分区包含的数据块（1024字节）的数目；第3，4列分别表示已用的和可用的数据块数目。用户也许会感到奇怪的是，第3，4列块数之和不等于第2列中的块数。这是因为缺省的每个分区都留了少量空间供系统管理员使用。即使遇到普通用户空间已满的情况，管理员仍能登录和留有解决问题所需的工作空间。清单中Use% 列表示普通用户空间使用的百分比，即使这一数字达到100％，分区仍然留有系统管理员使用的空间。最后，Mounted on列表示文件系统的安装点。另外,实践之后发现：如果未 mount 也会显示信息，但是显示几乎未使用，信息含义不明，但肯定不是使用的剩余空间； mount 之后如果没有进入 mount 点也和未 mount 的结果是一样的；当 mount 之后也进入过 mount 点了，那么用 df /dev/sda* 则显示正确地信息了。列出所有文件系统的磁盘空间使用情况输入输出如下:$df -aFilesystem           1K-blocks      Used Available Use% Mounted on/dev/sda1            150837820   8446596 134729024   6% /proc                         0         0         0   -  /proc/sys                         0         0         0   -  /sysvarrun                 4097572        92   4097480   1% /var/runvarlock                4097572         0   4097572   0% /var/lockudev                   4097572        32   4097540   1% /devdevshm                 4097572         0   4097572   0% /dev/shmdevpts                       0         0         0   -  /dev/ptslrm                    4097572     44976   4052596   2% /lib/modules/2.6.24-22-generic/volatile192.168.2.5:/store/home                     2399169216 323220192 1954078304  15% /homesecurityfs                   0         0         0   -  /sys/kernel/security这里，输出的结果包括0块（block）的文件系统，如 /proc 文件系统.更友好地列出所有文件系统的磁盘空间使用情况输入输出如下:$df -ahFilesystem            Size  Used Avail Use% Mounted on/dev/sda1             144G  8.1G  129G   6% /proc                     0     0     0   -  /proc/sys                     0     0     0   -  /sysvarrun                4.0G   92K  4.0G   1% /var/runvarlock               4.0G     0  4.0G   0% /var/lockudev                  4.0G   32K  4.0G   1% /devdevshm                4.0G     0  4.0G   0% /dev/shmdevpts                   0     0     0   -  /dev/ptslrm                   4.0G   44M  3.9G   2% /lib/modules/2.6.24-22-generic/volatile192.168.2.5:/store/home                      2.3T  309G  1.9T  15% /homesecurityfs               0     0     0   -  /sys/kernel/security这里，可以看出，输出的方式更为友好，具有合适的单位之后，可读性更强。列出各文件系统的i节点使用情况输入输出如下:$ df -iaFilesystem            Inodes   IUsed   IFree IUse% Mounted on/dev/sda1            19169280  279092 18890188    2% /proc                       0       0       0    -  /proc/sys                       0       0       0    -  /sysvarrun               1024393      57 1024336    1% /var/runvarlock              1024393       1 1024392    1% /var/lockudev                 1024393    2760 1021633    1% /devdevshm               1024393       1 1024392    1% /dev/shmdevpts                     0       0       0    -  /dev/ptslrm                  1024393      14 1024379    1% /lib/modules/2.6.24-22-generic/volatile192.168.2.5:/store/home                     304676864 9339216 295337648    4% /homesecurityfs                 0       0       0    -  /sys/kernel/security这里，如果用 df -i 则应该不会输出 /proc 等0 Inodes的行了。列出文件系统的类型输入输出如下:$ df -TFilesystem    Type   1K-blocks      Used Available Use% Mounted on/dev/sda1     ext3   150837820   8446628 134728992   6% /varrun       tmpfs     4097572        92   4097480   1% /var/runvarlock      tmpfs     4097572         0   4097572   0% /var/lockudev         tmpfs     4097572        32   4097540   1% /devdevshm       tmpfs     4097572         0   4097572   0% /dev/shmlrm          tmpfs     4097572     44976   4052596   2% /lib/modules/2.6.24-22-generic/volatile192.168.2.5:/store/home               nfs   2399169216 323220352 1954078112  15% /home这里，可以发现增加了 Type 这列。列出ext3这种类型文件系统的使用情况输入输出如下:$ df -t ext3Filesystem           1K-blocks      Used Available Use% Mounted on/dev/sda1            150837820   8446636 134728984   6% /这里，只列出了ext3类型文件系统的使用情况。列出除ext3类之外的文件系统使用情况输入输出如下:$df -x ext3Filesystem           1K-blocks      Used Available Use% Mounted onvarrun                 4097572        92   4097480   1% /var/runvarlock                4097572         0   4097572   0% /var/lockudev                   4097572        32   4097540   1% /devdevshm                 4097572         0   4097572   0% /dev/shmlrm                    4097572     44976   4052596   2% /lib/modules/2.6.24-22-generic/volatile192.168.2.5:/store/home                     2399169216 323220480 1954078016  15% /home这里，没有列出ext3类型文件系统的使用情况。4 其它主要参考资料:http://fanqiang.chinaunix.net/a1/b1/20010508/133026.html      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2009-11-23 一 15:20]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2009-11-23]<a href="/categories/study/linux/command/linux_command_df.html"> Linux命令学习手册-df </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Linux命令学习手册-awk'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 功能2. 描述2.1. awk 的处理流程2.2. 常用变量（变量名称 代表意义）2.3. 逻辑运算符号3. 举例3.1. 假设输入输出如下：3.2. 假设如下表(pay.txt)4. 其它awk '条件类型1{动作1} 条件类型2{动作2} ...' filename1 功能相较于 sed 常常作用于一整个行的处理， awk 则比较倾向于一行当中分成数个『字段』来处理。2 描述2.1 awk 的处理流程读入第一行，并将第一行的资料填入 $0, $1, $2&#x2026;. 等变数当中；依据 "条件类型" 的限制，判断是否需要进行后面的 "动作"；做完所有的动作与条件类型；若还有后续的『行』的数据，则重复上面 1~3 的步骤，直到所有的数据都读完为止。经过这样的步骤，您会晓得， awk 是『以行为一次处理的单位』， 而『以字段为最小的处理单位』。2.2 常用变量（变量名称 代表意义）NF 每一行 ( $0 ) 拥有的字段总数 NR 目前 awk 所处理的是『第几行』数据 FS 目前的分隔字符，预设是空格键 每一行的每个字段的变量名称就是 $1, $2 &#x2026; 等。还有个例外,那就是 $0 代表一整行的意思。注意， awk 后续的所有动作以 ' 括住， 所以，内容如果想要以 print 打印时，记得，非变量的文字部分， printf 提到的格式中，都需要使用双引号.2.3 逻辑运算符号&gt; 大于 &lt; 小于 &gt;=  大于或等于 &lt;= 小于或等于 ==  等于 !=  不等于 3 举例3.1 假设输入输出如下：$lastdmtsai   pts/0        192.168.1.12     Mon Aug 22 09:40   still logged inroot     tty1                          Mon Aug 15 11:38 - 11:39  (00:01)reboot   system boot  2.6.11           Sun Aug 14 18:18         (7+15:41)dmtsai   pts/0        192.168.1.12     Fri Aug 12 12:07 - 12:08  (00:01)打印每行的第1列和第三列，并且用[TAB]隔开输入输出如下$last | awk '{print $1 "\t" $3}'dmtsai  192.168.1.12root    Monreboot  bootdmtsai  192.168.1.12这里，我们没有设定条件，也就是无论哪一行都做同样处理，所以第2，3行显示的有点"不正常"。由此可知awk是“迭代”处理每一行的。列出每一行的账号，目前处理的行数， 以及该行有多少字段输入输出如下$last | awk '{print $1 "\t lines: " NR "\t columes: " NF}'dmtsai   lines: 1        columes: 10root     lines: 2        columes: 9reboot   lines: 3        columes: 9dmtsai   lines: 4        columes: 10查阅 /etc/passwd ，第3栏小于 10 以下的数据，并且仅列出账号与第3栏输入输出如下：$cat /etc/passwd | awk '{FS=":"} $3 &lt; 10 {print $1 "\t " $3}'root:x:0:0:root:/root:/bin/bashbin      1daemon   2......(以下省略)......这里，在 /etc/passwd 当中是以冒号 ":" 来作为字段的分隔，所以需要设置一下。但是我们读入第一行的时候， 那些变数 $1, $2&#x2026; 预设还以空格键为分隔，所以虽然我们定义了 FS=":" 了， 但是却仅能在第二行后才开始生效（可能因为一般第一行仅仅是列名不需处理，而这里却是特例，见例4改进）。对上面过滤的操作改进输入输出如下：$ cat /etc/passwd | awk 'BEGIN {FS=":"} $3 &lt; 10 {print $1 "\t " $3}'root     0bin      1daemon   2......(以下省略)......利用 BEGIN 这个关键词，可以从第一行就生效了。实际除了BEGIN，还有END。3.2 假设如下表(pay.txt)Name    1st     2nd     3thVBird   23000   24000   25000DMTsai  21000   20000   23000Bird2   43000   42000   41000计算每一行总额，添加追加到最后一列输入输出如下：$awk 'NR==1{printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total" }NR&gt;=2{total = $2 + $3 + $4printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'Name        1st        2nd        3th      TotalVBird      23000      24000      25000   72000.00DMTsai      21000      20000      23000   64000.00Bird2      43000      42000      41000  126000.00注意：所有的动作在 {} 内，如需多个指令辅助，可利用分号 ; 间隔或直接以 [Enter] 按键来隔开每个指令，例如上面的 NR&gt;=2 后面接的动作， 利用 total = &#x2026; 那个指令来指定加总，而后续则以 printf 来格式化输；格式化输出时，在 printf 的格式设定当中，务必加上 \n ，才能进行分行；与 bash shell 的变量不同，在 awk 当中，变量可以直接使用，不需加上 $ 符号（如total）。4 其它参考资料： 《鸟哥的私房菜》      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2009-11-23 一 14:10]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2009-11-23]<a href="/categories/study/linux/command/linux_command_awk.html"> Linux命令学习手册-awk </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Linux命令学习手册-ar'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 功能2. 描述2.1. 选项2.2. 退出状态3. 举例3.1. 查看 ar 的版本号3.2. 要创建一个库3.3. 创建一个库的另一个方法3.4. 查看库中的所有模块3.5. 删除库中的指定模块3.6. 将库中指定的模块提取出来3.7. 打印成员的内容3.8. 解压缩并重命名一个成员3.9. 要指定在模块的前面插入新成员3.10. 要指定在模块的后面插入新成员3.11. 要替换或添加新成员到库中3.12. 要更新一个已经更改过的成员3.13. 更改库成员的顺序4. 其它4.1. 利用库文件进行编译举例1(后面有简化)4.1.1. 编辑 hello1.c/h hello2.c/h hello3.c/h hello4.c/h hello5.c/h hello6.c/h4.1.2. 编译生成目标文件（模块）4.1.3. 打成 libhello.a 库包4.1.4. 编辑 main.c4.1.5. 建立一个子文件夹 program/,把 hello*.h 和 main.c 移动到 program 里面并且利用刚才的库编译 main.c:4.1.6. 运行测试4.2. 利用库进行编译链接举例2（对例1的简化）4.2.1. 过程同上例1，不同的唯一之处是：4.2.2. 编译运行4.3. 利用库进行编译链接举例3（对例3的进一步简化，这样看不到接口头文件了）：4.3.1. 过程同上例2，不同的唯一之处是：4.3.2. 编译运行4.4. 参考资料：ar [-c] [-l] [-g|-o] [-s] [-v] [-C] [-T] [-z] {-h|-p|-t|-x} [-X {32|64|32_64}] ArchiveFile [File ...]ar [-c] [-l] [-g|-o] [-s] [-v] [-C] [-T] [-z] {-m|-r [-u]} [{-a|-b|-i} PositionName] [-X {32|64|32_64}] ArchiveFile File ...ar [-c] [-l] [-g|-o] [-s] [-v] [-C] [-T] [-z] {-d|-q} [-X {32|64|32_64}] ArchiveFile File ...ar [-c] [-l] [-v] [-C] [-T] [-z] {-g|-o|-s|-w} [-X {32|64|32_64}] ArchiveFile1 功能ar 命令可以用来创建、修改库，也可以从库中提出单个模块。库是一单独的文件，里面包含了按照特定的结构组织起来的其它的一些文件（称做此库文件的 member ）。原始文件的内容、模式、时间戳、属主、组等属性都保留在库文件中。2 描述当我们的程序中有经常使用的模块，而且这种模块在其他程序中也会用到，这时按照软件重用的思想，我们应该将它们生成库，使得以后编程可以减少开发代码量。2.1 选项选项前可以有 - 字符，也可以没有。-a PositionName 在 PositionName 参数标识的现有文件后安置指定的文件。 -b PositionName 在 PositionName 参数标识的现有文件前安置指定的文件。 -c 禁止在创建库时产生的正常消息。 -C 阻止解压缩的文件替换文件系统中同名的文件。 -d 从库中删除指定的文件。 -g 对压缩文档成员进行排序以确保用最小数量的未用空间获得最大的加载效率。在几乎所有情况下， -g 标志以压缩文档成员的逻辑链接顺序物理地安置它们。最终生成的压缩文档通常写成小格式，这样该标志可用来将大格式压缩文档转换成小格式压缩文档。包含 64 位 XCOFF 对象的压缩文档不能创建成或转换至小格式。 -h 将指定的文件的成员报头中的修改时间设置为当前日期和时间。如果不指定任何文件名称，则 ar 命令设置所有成员报头的时间戳记。此标志不能和 -z 标志一起使用。 -i PositionName 在 PositionName 参数标识的现有文件前安置指定的文件（和 -b 相同）。 -l 将临时文件置于当前（本地）目录中，而非 TMPDIR 目录中（缺省为 /tmp ）。 -m 将指定的文件移动到库中的某个其它位置。缺省情况下，它将指定的文件移动到库的末尾。使用位置标志（ abi ）来指定某个其它位置。 -o 对压缩文档成员进行排序以确保用最小数量的未用空间获得最大的加载效率。在几乎所有情况下， -o 标志以压缩文档成员的逻辑链接顺序物理地安置它们。最终生成的压缩文档通常写成大格式，这样该标志可用来将小格式压缩文档转换成大格式压缩文档。 -p 将 Files 参数中指定的文件的内容或在 ArchiveFile 参数中指定的所有文件（如果您不指定任何文件）都写至标准输出。 -q 将指定的文件添加到库的末尾。另外，如果指定同一个文件两次，它可能被放入库中两次。 -r 如果指定的文件已经存在于库中，则替换它。因为指定的文件在库中占据它们替换的文件的同一个位置，位置标志没有任何附加的影响。当和 -u 标志（更新）一起使用时， -r 标志仅替换自从最后一次添加到库中以后修改的文件。 如果指定的文件不存在于库中，则 ar 命令添加它。在这种情况下，位置标志影响放置。如果不指定位置，则将新文件置于库的末尾。如果指定同一个文件两次，它可能被放入库中两次。-s 无论 ar 命令是否修改了库内容都强制重新生成库符号表。请在库上使用 strip 命令之后，使用此标志来恢复库符号表。 -t 将库的目录写至标准输出。如果指定文件名称，则仅显示指定的那些文件。如果不指定任何文件， -t 标志列出库中的所有文件。 -T 如果压缩文档成员名称比文件系统支持的长，则允许文件名称截短。此选项无效，因为文件系统支持的名称长度等于 255 个字符的最大压缩文档成员名称。 -u 仅复制自它们最后一次复制起更改的文件（请参阅先前讨论过的 -r 标志）。 -v 将建立新库的详细的逐个文件的描述写至标准输出。当和 -t 标志一起使用时，它给出类似于 ls -l 命令给出的长列表。当和 -x 标志一起使用时，它在每个文件前加一个名称。当和 -h 标志一起使用，它列出成员名称和更新的修改时间。 -w 显示压缩文档符号表。每个符号和其中定义此符号的文件的名称一起列出。 -x 通过将指定的文件复制到当前目录来解压缩它们。这些副本和原始文件（保留在库中）具有相同的名称。如果不指定任何文件，=-x= 标志复制库中的所有文件。此过程不会更改库。 -X mode 指定 ar 应检查的目标文件的类型。 mode 必须是以下项之一： 32 仅处理 32 位目标文件64 仅处理 64 位目标文件32_64 处理 32 位 和 64 位目标文件缺省值是处理 32 位目标文件（忽略 64 位对象）。 mode 还可以用 OBJECT_MODE 环境变量来设置。例如， OBJECT_MODE=64 使 ar 处理任何 64 位对象并忽略 32 位对象。=-X= 标志覆盖 OBJECT_MODE 变量。 -z 创建压缩文档的临时副本并对副本执行所有要求的修改。当所有操作成功完成时，压缩文档的工作副本覆盖原始副本。此标志不能和 -h 标志一起使用。 ArchiveFile 指定压缩文档文件名称；必需。 MemberName ... 各压缩文档成员的名称。 2.2 退出状态该命令返回以下出口值：0 成功完成。 &gt;0 发生错误。3 举例3.1 查看 ar 的版本号$ar -V3.2 要创建一个库$ar -rv libhello.a hello1.o hello2.o hello3.o hello4.o hello5.o hello6.o输入之后，输出如下：ar: creating libhello.aa - hello1.oa - hello2.oa - hello3.oa - hello4.oa - hello5.oa - hello6.o这里，从多个用 ld 命令创建的共享模块( hello*.o 目标文件)中创建一个压缩文档库,编译并链接如何使用这个库文件本文有举例。注意这里的添加顺序。 -v 标志设置详细方式，在此方式中 ar 命令在其进行时显示进程报告，如果没有这个 v 将只显示：ar: creating libhello.a。3.3 创建一个库的另一个方法$ar -qv libhello.a hello1.o hello2.o hello3.o hello4.o hello5.o hello6.o这里，如果 libhello.a 库不存在，则此命令创建它，并将文件 hello1.o-hello6.o 的副本输入其中。如果 libhello.a 库存在，则此命令在不检查相同成员的情况下，将新的成员添加到末尾。3.4 查看库中的所有模块$ar -t libhello.a输入之后，输出如下：hello1.ohello2.ohello3.ohello4.ohello5.ohello6.o这样会依次列出库中所有的模块成员。显示的次序不是根据名字的，而是添加模块时候决定的。加 -v 则类似 ls -l 的长格式。3.5 删除库中的指定模块$ar -dv libhello.a hello3.o输入之后输出如下：d - hello3.o这样会在库中删除指定的模块成员 hello3.o ，加 -v 是为了显示删除什么文件。下面用详细方式显示删除后的库文件如下：$ar -tv libhello.a输入之后输出如下：rw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello1.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello2.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello4.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello5.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello6.o3.6 将库中指定的模块提取出来$ar -xv libhello.a hello1.o输入之后，输出如下：x - hello1.o这样,会将库中的模块 hello1.o 释放到当前的文件夹，不会在库中删除该模块。这里实际是加 -v 选项是为了显示输出删除了那个模块。3.7 打印成员的内容$ar -pv libhello.a hello1.o输入之后，输出如下：^?ELF^B^A^A^@^@^@^@^@^@^@^@^@^A^@&gt;^@^A^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@(^A^@^@^@^@^@^@^@^@^@^@@^@^@^@^@^@@^@^M^@.....由于篇幅关系，后面省略了......这里，打印的是 hello1.o 的内容，估计我们也看不懂,如果不加 -v 选项，就不会打印第一行的了。3.8 解压缩并重命名一个成员$ar -p libhello.a hello1.o &gt;hello1copy.o此命令将成员 hello.o 复制到一个名为 hello1copy.o 的文件,实际就是一个重定向的操作。3.9 要指定在模块的前面插入新成员$ar -rb hello1.o libhello.a hello3.o或$ar -ri hello1.o libhello.a hello3.o这样,没用 -v 所以没有输出，但会把 hello3.o 插入 libtest.a 中，并且在 hello1.o 模块前.用 -t 可以看到次序如下：$ar -tv libhello.a输入之后，输出如下：rw-r--r-- 14506/1001   1488 Jul  4 14:24 2009 hello3.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello1.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello2.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello4.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello5.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello6.o如果要插入的成员已经存在于库中，结果相当于将原来的同名模块删除，之后再插入,如下：quietheart@ubuntu:~/libTest/hellolib/ver2obj/bak$ar -rb hello4.o libhello.a hello3.oquietheart@ubuntu:~/libTest/hellolib/ver2obj/bak$ar -tv libhello.a输入之后，输出如下：rw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello1.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello2.orw-r--r-- 14506/1001   1488 Jul  4 14:25 2009 hello3.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello4.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello5.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello6.o在这里，我们用 -v 选项会显示详细的插入信息，这里我修改了 hello3.o 的内容，如果不修改，那么始终时间是 14:23 怎么加都是。3.10 要指定在模块的后面插入新成员$ar -ra hello2.o libhello.a hello3.o这里的操作和 rb 或者 ri 选项指定的在前面插入原理一样，不过插入的方向变成了在后面追加插入了。用 -v 会显示详细的插入信息。3.11 要替换或添加新成员到库中$ar -r libhello.a hello6.o这样，如果 libhello.a 库中没有 hello6.o 那么就会把模块 hello6.o 添加到库的末尾，如果有的话就会替换之（ 位置还是原来的位置）。3.12 要更新一个已经更改过的成员$ar -ru libhello.a hello3.o这时候，仅当 hello3.o 比库中的 hello3.o 更新时或者没有在库中时才替代库中的 hello3.o 或者加入 hello3.o .3.13 更改库成员的顺序$ar -mav hello4.o libhello.a hello1.o hello3.o输入之后，输出如下：m - hello1.om - hello3.o此命令将成员 hello1.o 和 hello3.o 移动到 hello4.o 后面。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用 a, b,或 i 任选项移动到指定的位置。检查结果如下：$ar -tv libhello.a输入之后，输出如下：rw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello2.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello4.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello3.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello1.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello5.orw-r--r-- 14506/1001   1488 Jul  4 14:23 2009 hello6.o这里，注意，发现参考资料中别人的解释和实践之后的结果不一样，那个参考资料这样说的：$ar -v -m -a strcmp.o lib.a strcat.o strcpy.o此命令将成员 strcat.o 和 strcpy.o 移动到紧跟在 strcmp.o 成员之后的位置。保留 strcat.o 和 strcpy.o 成员的相对顺序。换句话说，如果在移动之前 strcpy.o 成员在 strcat.o 成员之前，那么（移动后）它依旧如此。可是我运行了这个命令发现相对次序也变化了？？4 其它4.1 利用库文件进行编译举例1(后面有简化)4.1.1 编辑 hello1.c/h hello2.c/h hello3.c/h hello4.c/h hello5.c/h hello6.c/h内容如下：//hello1.h  1 int hello1();//hello2.h-hello6.h的内容类似，不过把hello1替换成相应的hello2-hello6了.//hello1.c  1 #include  2 #include "hello1.h"  3 int hello1()  4 {  5     printf("hello1\n");  6 }//hello2.c-hello6.c的内容类似，不过把hello1替换成相应的hello2-hello6了.4.1.2 编译生成目标文件（模块）$gcc -c hello*.c这样会在当前目录下面生成 hello1.o hello2.o hello3.o hello4.o hello5.o hello6.o4.1.3 打成 libhello.a 库包$ar -rv libhello.a hello*.o这样会把所有的 .o 文件做为模块打包进 libhello.a 库中。4.1.4 编辑 main.c//main.c  1 #include  2 #include"hello1.h"  3 #include"hello3.h"  4  5 int main(int argc, char *argv[])  6 {  7     hello1();  8     hello3();  9     return 0; 10 }4.1.5 建立一个子文件夹 program/,把 hello*.h 和 main.c 移动到 program 里面并且利用刚才的库编译 main.c:$mkdir program;mv hello*.h program;mv main.c hello*.h;cd program$gcc -o main main.c -L ../ -lhello这样，在 program 中生成了 main ，编译命令的 -L 选项指定库的路径， -l 指定 ld 链接的库的名字，即 libhello.a 中的 hello 。4.1.6 运行测试$./main输入之后，输出如下：hello1hello34.2 利用库进行编译链接举例2（对例1的简化）4.2.1 过程同上例1，不同的唯一之处是：hello*.c 中不需要包含 hello*.h 头文件，其内容如下：//hello1.c  1 #include  2 //#include "hello1.h"  3 int hello1()  4 {  5     printf("hello1\n");  6 }//hello2.c-hello6.c的内容类似，不过把hello1替换成相应的hello2-hello6了.4.2.2 编译运行$gcc -o main main.c -L ../ -lhello这样编译之后，照样能运行。4.3 利用库进行编译链接举例3（对例3的进一步简化，这样看不到接口头文件了）：4.3.1 过程同上例2，不同的唯一之处是：main.c 中不需要包含 hello*.h 头文件了（即所有文件任何地方都不需要头文件了），其内容如下：//main.c  1 #include  2 //#include"hello1.h"  3 //#include"hello3.h"  4  5 int main(int argc, char *argv[])  6 {  7     hello1();  8     hello3();  9     return 0; 10 }4.3.2 编译运行$gcc -o main main.c -L ../ -lhello这样编译之后，照样能运行。4.4 参考资料：http://www.kuqin.com/aixcmds/aixcmds1/ar.htm#a0949a5bhttp://www.cppblog.com/prayer/archive/2009/05/27/85877.html      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2009-11-23 一 20:40]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2009-11-23]<a href="/categories/study/linux/command/linux_command_ar.html"> Linux命令学习手册-ar </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
	   var article = 'Linux命令学习手册-0前言'; //by title
	   var reg = new RegExp(search, "i");
	   //var article = 'Table of Contents1. 读者须知2. 本文内容3. 本文约定3.1. 对于每一个命令，大致分为如下三个部分3.2. 对于每个命令的使用例子，如下说明4. 基本知识4.1. 命令组成4.2. 关于项4.3. 关于项的参数4.4. 基本命令4.4.1. 文件管理相关4.4.2. 权限管理相关4.4.3. 磁盘管理相关4.4.4. 其他操作4.4.5. GNome桌面下面的操作4.4.6. 任务的前台和后台控制4.4.7. 最基本的文件编辑操作1 读者须知这篇文章纯粹是我个人在学习Linux过程中实践的积累，其中语言文字上面也许会有些错误，希望读者发现之后能够帮我纠正，在此先谢了。这里的每个命令都经过我亲身的实践，linux多数命令使用起来并不难，关键是读懂命令的输出信息，以及如何使用命令帮助。我的愿望是大家能够花费尽可能短的时间，熟悉Linux操作系统。如果你仅仅是为了临时做一些事情，那么本文也适合你，你只需要看本前言中的 基本命令 一节即可。如果有人转载，希望您能注明出处和作者；如果将本文用于商业行为，希望您能先通知我；希望大家能够互相体谅，尊重对方的劳动成果。2 本文内容本文档最开始介绍Linux命令相关的基本知识，然后给出一些基本的Linux命令。后面每个章节将分别对每个重要的Linux命令进行详细的讲解，并给出详细的举例。这是一个没有终点的学习，这个手册的内容会随着学习的命令的更多而增加。侧重应用，重在举例，所以想要了解每个命令的具体细节还需要察看man或者info手册。如机会，每个命令可能会在今后完善更新。3 本文约定3.1 对于每一个命令，大致分为如下三个部分功能简单介绍该命令功能。举例给出该命令最常使用的例子。描述详细描述该命令。其他该命令其他杂乱或者补充性的内容。3.2 对于每个命令的使用例子，如下说明以orgmode格式做为文档格式, orgmode格式一方面可读性强,另一方面便于将来导出为各种格式.对于单个命令操作+ 开始的列表项第一行给出要操作的目的，然后是具体的命令，最后给出该命令的详细解释。例如：+ 列出当前目录的内容  =$ls=  这里，将会列出当前目录所文件。如果命令过长，则使用 #+BEGIN_SRC/#+END_SRC 对。对于某个系列的命令具体的命令使用列表给出,而命令所述的系列使用子标题(orgmode中,列表的排版比较容易出错,所以使用子标题,尽量避免嵌套列表)。例如：** 使用vi编辑：   + 编辑之前首先打开文件&lt;filename&gt;:     =$vi filename=   打开文件之后，操作如下：   + 插入     输入 =a=   + 退出     输入 =:q=4 基本知识这里简单介绍linux命令行的一般语法格式。这对初学者很重要，尤其是查找某个命令的帮助手册( man 手册)的时候，不会什么也看不懂。4.1 命令组成一般linux的命令语法格式如下： 命令名称 项 项参数(值) 命令参数(值)例如： od [OPTION]... [FILE]... 这里，命令名称是 =od= ,项是OPTION。这里项用'[]'括起来表示这个部分在 =od= 命令里面可可无。命令的参数是FILE也是可可无；'...'表示其前面的东西（这里是OPTION和FILE可以不只一个.一般来说(不是绝对的)，在 =man= 手册里面，命令中像OPTION和FILE这样的变量形式的参数（即其值取决于用户的键入部分会用特殊颜色显示出来；而 =od= 这样本身是固定的部分（即不是用户能改变的用另外一种颜色显示（例如加粗）。也有的描述中把可变的部分用'&lt;&gt;'括起来。再如： cp [OPTION]... SOURCE... DIRECTORY 从这里可以看出，=cp= 命令参数SOURCE和DIRECTORY,其中SOURCE参数可以是多个，DIRECTORY只能一个。OPTION部分可可无，但是SOURCE和DIRECTORY部分必须要。 具体的例子： =$cp -r file1 file2 dir=4.2 关于项项简单书写形式也复杂书写形式。简单形式的项一般用 - 引出，复杂形式一般用 -- 引出等等。例如: $cp -v file1 file2 等价于 $cp --verbose file1 file2这里，=-v= 和 --verbose 是一样的, -v 是简写形式， --verbose 是复杂形式。 又例如: cp -r src des其中， -r 就是其中的[OPTION]部分，也可以是 --recursive 。另外，有些命令的项不用 - 来引出，例如： $unrar e test.rar使用 e 项指定 unrar 命令解压 test.rar 文件。 有些命令项用 - 做为前缀，然后可以接多个选项,例如： $tar -czvf dir.tgz dir这个命令使用 tar 命令的 -c -z -v -f 四个项，给 dir 目录打包并且压缩，生成结果文件为 dir.tgz.在项用'[]'包含起来表示可的同时，如果几个值其中只能出现一个的话那么用'|'来分开。例如： command [-a|-b]这里， command 是假设的一个命令，这表示这个命令 command 中， -a 和 -b 项，两者要么都没，要么只一个。 4.3 关于项的参数不光是命令，命令的项也可以参数。 这里举一个复杂点的命令gdb [-help] [-nx] [-q] [-batch] [-cd=dir] [-f] [-b bps] [-tty=dev] [-s symfile] [-e prog] [-se prog] [-c core] [-x cmds] [-d dir] [prog[core|procID]]这是 gdb 命令的语法格式，关键的几个部分如下： [-d dir] 就是指,运行gdb命令，可以添加一个可的项 -d ，这个项的参数是 dir.在本文的描述中，不太容易一下子看出 [-d dir] 里面哪部分是固定的字符串，哪部分是随用户输入而变的字符串,但是 man 手册里面都把它们标记为不同的颜色了，实际通过分析也很容易知道哪个部分是可变的。 有些命令项和项的参数之间可以没空格,的项和项参数之间用 = 连接,例如这里的 ~[-cd=dir]'再举一个例子minicom [-somMlwz8] [-c on|off] [-S script] [-d entry] [-a on|off] [-t term] [-p pty] [-C capturefile] [configuration]这是minicom的命令语法，其中[-c on|off]表示-c项是可的（即在命令中可可无，它一个选项参数，参数值可以是on或者off. 4.4 基本命令这里是经常使用的linux命令,用于平时查阅之用.一般而言，超级用户(root)的命令提示符号是 #,一般用户的命令提示符号是 $. 4.4.1 文件管理相关创建名字为1的目录$mkdir 1创建名字为1的文件$touch 1删除名字为1的文件$rm 1查看文件1的内容 $cat 1强制删除一个目录$rm -rf dirname这里， rm -r dirname 是递归删除的意思，如果加上 -i 项，表示删除之前提示是否删除。 重命名/移动文件$mv ./origin ./newname这里，Linux中没专门的重命名命令，这里实际是使用了移动命令来进行的。原来的文件名 origin,新文件名 newname.把文件file1拷贝一份到file2 $cp file1 file2这里，操作都是在当前目录下面进行的,如果拷贝到别的目录，可以指定路径，例如 cp file1 /anotherdir/file2.把目录dir1考到另一个地方为dir2$cp -r dir1 dir2这里， -r 表示递归拷贝所子目录。 进入到一个目录中$cd dirname查看目录dirname中所包含的文件$ls dirname查看目录dirname中所包含的文件的详细信息$ls -l这样，会显示相应文件的详细信息，包括属主，大小，权限等信息。 查看当前的目录$pwd这样，会输出当前所在目录的路径。 创建文件file的硬链接$ln file lnfile这里，使用链接的目录格式类似 cp 。建立硬链接之后，如果删除源，还可以通过这个硬链接访问到这个文件的内容，除非所的硬链接都被删除了，否则文件内容就一直存在的。硬链接不能够跨越文件系统，不能够建立目录的硬链接。 创建文件 file 的软链接$ln -s file lnfile这里，创建软链接，文件名里面 $ 就用了转义 \$ 表示 $,尽量用绝对路径防止出错。软链接可以跨越文件系统，可以为目录创建软链接，但是软链接的文件，如果删除源，链接会失效，类似windows中的快捷方式。 4.4.2 权限管理相关修改文件的权限为所人可读可写可执行$chmod 777 filename这里，文件属主必须是当前用户，否则就只能进入超级用户才能执行这个命令了。 修改文件filename的权限,为other用户添加写权限： $chmod o+w filename修改目录以及所子目录的权限为777$chmod 777 -R dir查看在线登陆用户 $who将一个用户添加到用户组中#usermod -a -G groupA user这里，不要忘记 -a 项。如果用： usermod -G groupA,这做会使 user 用户离开其他用户组，仅仅做为这个用户组 groupA 的成员。 更改用户user的组为groupA#usermod -G groupA user查看所的用户$cat /etc/passwd这里，用户都保存在了 passwd 文件中，所以查看这个文件的内容就可以看到所的用户了。 成功创建一个新用户以后，在 /etc/passwd 文件中就会增加一行该用户的信息，其格式如下： 〔用户名〕：〔密码〕：〔UID〕：〔GID〕：〔身份描述〕：〔主目录〕：〔登陆Shell〕其中每个字段被冒号 : 分成7各部分。 由于小于500的 UID 和 GID 一般都是系统自己保留，不用做普通用户和组的标志，所以新增加的用户和组一般都是 UID 和 GID 大于500的。 查看所的组$cat etc/group查看所的组$cat etc/group这里，用户都保存在了 group 文件中，所以查看这个文件的内容就可以看到所的用户了。 添加一个用户testusr#useradd testusr这里，注意在超级用户模式才能用,刚建立没密码，没自己的home,其他项可以参见man 添加一个用户testusr,并自动建立其用户主目录#useradd -m testusr运行完毕，自动生成用户的家目录，目录里面 .bashrc 等文件。 删除一个用户 testusr#userdel testusr这里，命令不会把主目录删除. 删除一个用户testusr,连同主目录和邮箱缓存等#userdel -r testusr切换到用户testusr$su testusr如果用户需要密码，那么需要输入密码才能登录这个用户。 切换到超级用户$su这样，会提示输入超级用户的密码，输入之后，就会切换成超级用户了。 以超级用户身份运行一个程序$sudo app这样，会以超级用户身份运行app程序，如果当前权限不够的时候，这条命令是很用的。当然，运行之前需要输入自己的密码。还有如 sudo su 也是类似的。 设置更改一个用户testusr的密码#passwd testusr这里，需要在超级用户下，输入之后，按照提示输入旧密码和新密码就行了。如果运行的 passwd 没参数，那么会修改当前用户的密码。更改自己的密码只需输入 passwd 不用切换到超级用户下。 修改用户testusr的主目录和登录的shell#usermod -d/home/quietheart -s/bin/bash testusr这里，用户名 testusr 的主目录路径设置在 /home/testusr,登陆的Shell设置为 /usr/bin/gcc ( -d 更新使用者新的登陆目录, -s 指定新用户Shell),空格无均可. 修改用户testusr名称为test#usermod -l test testusr把用户名 testusr 改成 test ( -l 变更用户登陆时的名称，手册说同时使用者目录名也会跟着更动成新的名称(实践了没变目录呀)) usermod 不允许改变正在线上的使用者帐号名称. 查看当前用户属于的组$groups查看testusr用户属于的组$groups testusr4.4.3 磁盘管理相关查看当前目录大小$du -sh查看文件的大小$du -sh filename这里， filename 是将要查看的文件名称。 查看分区信息fdisk -l这里，会显示你的电脑上面的所磁盘的信息，例如分区，文件系统等。当前必须是 root 用户，否则没权限。 4.4.3.1 挂载磁盘相关你的linux系统必须将其他硬盘的其他分区(例如windows分区)挂载到根目录树中，才能访问相应的分区。 挂载分区 /dev/sda7 到 /mnt/win#mount -t vfat /dev/sda7 /mnt/win这样的挂载可能会出现显示中文的时候乱码,因为可能没指定解码的字符集。必须是超级用户才能执行。 指定gb2312字符集的挂载#mount -t vfat -o iocharset=gb2312 /dev/sda7 /mnt/win这样的挂载的时候，指定使用gb2312字符集，这样就可能没乱码了。其他常用的字符包括cp936,utf8等等(ntfs的一般用utf8挂载)。必须是超级用户才能执行。 查看已经挂载的分区#mount卸载已经挂载的分区#umount /mnt/win或 #umount /dev/sda7这里，是把 /dev/sda7 分区挂载到了 /mnt/win 上面。重新挂载#mount -o rw,remount /mnt/data这里，时候文件系统变为只读了，试试这个命令. 设置系统启动自动挂载某个分区方法之一是在 /etc/fstab 中加入如下内容：/dev/sda8 /mnt/winG vfat defaults,rw,exec,iocharset=utf8,umask=0000 0 0必须 umask=0000, 否则只 root 可以写，并且 root 也不能更改 chmod 777 -R ... 这是自己尝试出来的。4.4.4 其他操作清屏$clear这样，当前用户的屏幕会被“清理”,并被重新刷新，原来输入的命令和命令的输出都被清理掉了，也可以使用 [Ctrl]l 来达到相同的效果。 查看系统的编码$locale输入之后，例如我的机器输出如下： LANG=zh_CN.UTF-8 LC_CTYPE="zh_CN.UTF-8" LC_NUMERIC="zh_CN.UTF-8" LC_TIME="zh_CN.UTF-8" LC_COLLATE="zh_CN.UTF-8" LC_MONETARY="zh_CN.UTF-8" LC_MESSAGES="zh_CN.UTF-8" LC_PAPER="zh_CN.UTF-8" LC_NAME="zh_CN.UTF-8" LC_ADDRESS="zh_CN.UTF-8" LC_TELEPHONE="zh_CN.UTF-8" LC_MEASUREMENT="zh_CN.UTF-8" LC_IDENTIFICATION="zh_CN.UTF-8" LC_ALL=启动xwindow图形界面$startx这个命令是在纯粹的命令行下面运行的命令。 切换到第一个纯命令行终端输入： [Ctrl][Alt][F1]这样，如果在图形界面中运行这个命令，会切换到第一个命令终端上面。可以是 [F1]~[F7] 等。 切换到图形界面输入： [Ctrl][Alt][F7]这样，如果在命令行终端，那么会切换到图形终端上面的是 [F7] 、 [F8] 等等，都不一定,一般是 [F7] 。 退出图形界面两种方法, 方法1， 注销(不会 umount )方法2， 输入: [Ctrl][Alt][Backspace]退出图形界面之后，不会 umount 之前 mount 过的分区。 查看内核版本号$uname -r这里，如果输入 uname -a 会显示所的内核信息。 查看发行的Linux版本号$cat /etc/issue搜索最近匹配的历史命令使用如下步骤进行： 输入 [Ctrl]r输入以前输入的命令的子字符串根据 2 的输入会自动匹配最近的命令。 如果匹配了一个，但是我们需要的命令是更早的，那么再输入一下 [Ctrl]r 。输入回车，运行匹配的命令。在当前目录中寻找指定的文件$find -name filename这样，会在当前目录下递归地寻找名称为 filename 的文件，并且返回它的位置,这里支持通配符号。 在指定的目录中寻找指定的文件$find dirname -name filename这样，会在 dirname 中递归地寻找名称为 filename 的文件。 在文件中查找字符串$grep 'string' filename这样会在文件 filename 中查找指定的字符串'string'并且返回那个字符串的位置。 在当前目录中所文件中查找指定的字符串$grep -r 'string' *这里,使用了通配符号。 查看当前时间$date4.4.5 GNome桌面下面的操作切换桌面工作区域输入 [Ctrl][Alt]&lt;左右方向键&gt;锁屏幕输入 [Ctrl][Alt]l切换不同任务窗口的快捷键输入 [Alt][Tab]在桌面和上次的程序之间进行切换输入 [Ctrl][Alt]d4.4.6 任务的前台和后台控制假设我们运行了多个vi编辑器，以及其他程序(无论前台还是后台，实际上只一个前台的程序)。将当前的程序放到后台停止输入 [Ctrl]z查看所在后台运行的程序$jobs输入之后,输出如下： [1]-  Stopped                 vi [2]+  Stopped                 vi lex这里，使用前面的数字来标记每一个后台运行的程序。 将后台停止的指定程序变成后台运行$bg %1这样会把第一个后台的作业调到后台运行,实际上，用 bg 1 就行了。 这样做之后，效果相当于运行了 app &amp; ，其中app是运行的程序，&amp;表示放在后台。 将指定的后台运行的作业号放到前台运行$fg %1这样会把第一个后台的作业调到前台运行,实际上，用 fg 1 就行了。 将最近的被停止的程序放到前台运行$fg杀掉指定的后台运行的程序$kill %1这样，会在后台运行的作业 %1 给杀掉。注意：这里的作业号用%来进行标记，而不像进程直接用数字了。 4.4.7 最基本的文件编辑操作这里提供了使用 vi 编辑文件的最基本的操作，能够实现大多数的编辑目的。用 vi 打开一个文件输入 vi filename这里， filename 就是你要打开的文件的名字，默认打开文件后 vi 处于指令模式。 进入编辑模式编辑打开的文件输入 i. 或输入 a. 进入编辑模式后，你可以直接敲入想要输入的字符到文件，两者的区别是 i 在当前字符前面开始插入， a 在当前字符后面开始插入。 退出编辑模式输入 [Esc]这样，将返回指令模式，准备接收你要传达给 vi 的指令并执行，如果之前已经在指令模式下，那么系统将响铃提醒一下。 4.4.7.1 以下命令都是vi在命令模式下进行撤销修改输入 u这里，相比以前的vi来说，vim支持多步撤销。 恢复修改输入 [Ctrl]r这里，和撤销命令相反，是撤销的撤销，也可多步。 复制行到剪切板输入 yy复制定内容到剪切板输入 v 。方向键将高亮择的内容。输入 y 。 这里，开始输入 v 使vi临时进入了一个"选择模式"，输入方向键可以择，输入 y 将择的内容复制剪切板。 删除行输入 dd注意，vi的删除等价于剪切，删除的内容会保存到剪切板中。 删除定内容输入 v 。方向键将高亮择的内容。输入 d 。 这里，开始输入 v 使vi临时进入了一个“选择模式”，输入方向键可以择，输入 d 将择的内容删除。 粘贴输入 p 这样会将剪切板的内容粘贴到光标位置或者光标下一行。 查找字符并定位到第一个匹配处输入 /character这里 character 是待查找的字符，只要先输入 / ，再输入待查字符，最后回车即可定位到第一个匹配的字符处。 定位到匹配查找的下一个字符处输入 n 定位到匹配查找的上一个字符处输入 N 保存文件输入 :w 注意 w 前面的 : ，输入 : 之后，vim会将 : 之后的输入解释为待执行的指令。 退出输入 :q这里，如果文件没保存，将提示无法退出，除非你强制退出，不保存文件，或者保存退出。 强制退出输入 :q!保存退出输入 :wq或输入 ZZ. 察看帮助 输入 :help      		  Author	  QuietHeart	  			  Email	  	    quiet_heart000@126.com	  	  	    		  Date	  [2009-11-23 一 14:05]	  	    		  Update	  	    ';
	   //if (article.indexOf(search) != -1)
	   if (article.match(reg) != null)
	   {
		document.write('[2009-11-23]<a href="/categories/study/linux/command/linux_command_00Introduce.html"> Linux命令学习手册-0前言 </a> <br>');
		document.write("<hr class='article_line'>");
	   }
      	
    </script>
  </div>
</article>

	
		</td>

              </tr>
              <tr id="tr_page_comment">
		<td colspan="6" valign="bottom">
		  <!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="" data-title="搜索结果" data-url="http://vaqeteart.github.io//search.html"></div>
<!-- 多说评论框 end -->
<script src="/assets/js/comment.js"></script>
		</td>
	      </tr>
              <tr>
                <td id="td_page_footer" colspan="6">
<footer>
  &copy 2015
</footer>
<a id="bottom"></a>
</td>


              </tr>
            </tbody>
        </table>
  </body>
</html>
